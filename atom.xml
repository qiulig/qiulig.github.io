<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0972e01a5f38f38e77d0154479c21150</icon>
  <subtitle>菜鸟要更加努力才能追上别人的步伐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blogs.qiulig.website/"/>
  <updated>2019-06-16T03:02:53.275Z</updated>
  <id>http://blogs.qiulig.website/</id>
  
  <author>
    <name>qiulig</name>
    <email>qiuling_long@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-组合模式</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式-组合模式/</id>
    <published>2019-06-16T02:41:40.000Z</published>
    <updated>2019-06-16T03:02:53.275Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><pre><code>有时又叫作部分-整体模式，将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</code></pre><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>1. 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>1.设计较复杂，客户端需要花更多时间理清类之间的层次关系；2.不容易限制容器中的构件；3.不容易用继承的方法来增加构件的新功能；</code></pre><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'抽象构件'</span>（Component）角色：它的主要作用是为树叶构件和树枝构件<span class="string">'声明公共接口，并实现它们的默认行为'</span>。在透明式的组合模式中抽象</span><br><span class="line">    构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'树叶构件'</span>（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于<span class="string">'实现抽象构件角色中声明的公共接口'</span>。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'树枝构件'</span>（Composite）角色：是组合中的分支节点对象，它有子节点。它<span class="string">'实现了抽象构件角色中声明的接口'</span>，它的主要作用是存储和管理</span><br><span class="line">    子部件，通常包含 Add()、Remove()、GetChild() 等方法。</span><br></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1-透明式"><a href="#1-透明式" class="headerlink" title="(1) 透明式"></a>(1) 透明式</h4><pre><code>抽象构件声明了所有子类中的全部方法，包括add,remove等，使树叶和树枝具备完全一致的行为接口。所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。缺点：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。</code></pre><h4 id="2-安全式"><a href="#2-安全式" class="headerlink" title="(2) 安全式"></a>(2) 安全式</h4><pre><code>抽象构件不去声明add、remove方法，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题。缺点：由于不够透明，树叶和树枝不具备相同的接口，客户端的调用需要做相应的判断带来不便。</code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1.在需要表示一个对象整体与部分的层次结构的场合。2.要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。Java  AWT/Swing中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component c0=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component c1=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">"1"</span>); </span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">"2"</span>); </span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">"3"</span>);          </span><br><span class="line">        c0.add(leaf1); </span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2); </span><br><span class="line">        c1.add(leaf3);          </span><br><span class="line">        c0.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123; &#125;           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123; &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"树叶"</span>+name+<span class="string">"：被访问！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children=<span class="keyword">new</span> ArrayList&lt;Component&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;#组合模式&quot; class=&quot;headerlink&quot; title=&quot;组合模式&quot;&gt;&lt;/a&gt;组合模式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;有时又叫作部分-整体模式，将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="http://blogs.qiulig.website/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-外观模式</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式-外观模式/</id>
    <published>2019-06-16T02:28:57.000Z</published>
    <updated>2019-06-16T02:37:00.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><pre><code>为多个子系统提供一个统一的接口，而使这些子系统更加容易被访问的模式。降低系统的耦合度。迪米特法则的典型应用，但是增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</code></pre><a id="more"></a><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'外观'</span>（Facade）角色：为多个子系统对外提供一个共同的接口。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'子系统'</span>（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'客户'</span>（Client）角色：通过一个外观角色访问各个子系统的功能。</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>(1) 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。(2) 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。(3) 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Facade f=<span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1=<span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2=<span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3=<span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统01的method1()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统02的method2()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统03的method3()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;外观模式&quot;&gt;&lt;a href=&quot;#外观模式&quot; class=&quot;headerlink&quot; title=&quot;外观模式&quot;&gt;&lt;/a&gt;外观模式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;为多个子系统提供一个统一的接口，而使这些子系统更加容易被访问的模式。降低系统的耦合度。

迪米特法则的典型应用，但是增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="http://blogs.qiulig.website/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-装饰模式</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式-装饰模式/</id>
    <published>2019-06-16T01:40:34.000Z</published>
    <updated>2019-06-16T02:25:44.515Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><pre><code>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。就增加功能来说，装饰模式比生成子类更为灵活。</code></pre><a id="more"></a><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><pre><code>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。</code></pre><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-   <span class="string">'抽象构件'</span>（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</span><br><span class="line">-   <span class="string">'具体构件'</span>（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</span><br><span class="line">-   <span class="string">'抽象装饰'</span>（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</span><br><span class="line">-   <span class="string">'具体装饰'</span>（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   当需要给一个<span class="string">'现有类添加附加职责'</span>，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</span><br><span class="line">-   当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用<span class="string">'继承关系很难实现'</span>，而采用装饰模式却很好实现。</span><br><span class="line">-   当对象的<span class="string">'功能要求可以动态地添加，也可以再动态地撤销时'</span>。</span><br></pre></td></tr></table></figure><ul><li></li><li></li></ul><h3 id="实际中的应用"><a href="#实际中的应用" class="headerlink" title="实际中的应用"></a>实际中的应用</h3><pre><code> Java I/O 标准库的设计。例如，      (1) InputStream 的子类 FilterInputStream，      (2) OutputStream 的子类 FilterOutputStream，      (3) Reader 的子类BufferedReader 以及 FilterReader，      (4) Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component p=<span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        Component d=<span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建具体构件角色"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用具体构件角色的方法operation()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component=component;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为具体构件角色增加额外的功能addedFunction()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;装饰模式&quot;&gt;&lt;a href=&quot;#装饰模式&quot; class=&quot;headerlink&quot; title=&quot;装饰模式&quot;&gt;&lt;/a&gt;装饰模式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

就增加功能来说，装饰模式比生成子类更为灵活。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="http://blogs.qiulig.website/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-桥接模式</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式-桥接模式/</id>
    <published>2019-06-15T12:34:34.000Z</published>
    <updated>2019-06-16T01:38:41.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><pre><code>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</code></pre><a id="more"></a><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="string">'实现化'</span>（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</span><br><span class="line">- <span class="string">'具体实现化'</span>（Concrete Implementor）角色：给出实现化角色接口的具体实现。</span><br><span class="line">- <span class="string">'抽象化'</span>（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</span><br><span class="line">- <span class="string">'扩展抽象化'</span>（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>(1) 由于抽象与实现分离，所以扩展能力强；(2) 可动态的切换实现     由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。(3) 实现细节对客户端透明，可以对用户隐藏实现细节。</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>(1) 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 (2) 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。</code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>(1)当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。(2)当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。(3)当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Implementor imple=<span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs=<span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体实现化(Concrete Implementor)角色被访问"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Implementor imple;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.imple=imple;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(imple);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"扩展抽象化(Refined Abstraction)角色被访问"</span> );</span><br><span class="line">       imple.OperationImpl();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; class=&quot;headerlink&quot; title=&quot;桥接模式&quot;&gt;&lt;/a&gt;桥接模式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="http://blogs.qiulig.website/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式-适配器模式/</id>
    <published>2019-06-15T09:05:39.000Z</published>
    <updated>2019-06-15T11:56:16.626Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。<a id="more"></a>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>对类适配器来说，更换适配器的实现过程比较复杂。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ol><h3 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h3><p>适配器模式（Adapter）通常适用于以下场景。</p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p><a href="https://blog.csdn.net/wwwdc1012/article/details/82780560" target="_blank" rel="noopener">https://blog.csdn.net/wwwdc1012/article/details/82780560</a></p><h4 id="1-spring-AOP中的适配器模式"><a href="#1-spring-AOP中的适配器模式" class="headerlink" title="(1)spring AOP中的适配器模式"></a>(1)spring AOP中的适配器模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在Spring的Aop中，使用的 Advice（通知） 来增强被代理类的功能。</span><br><span class="line"></span><br><span class="line">Advice的类型有：MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice</span><br><span class="line"></span><br><span class="line">在每个类型 Advice 都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptorSpring</span><br><span class="line">需要将每个 Advice 都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对 Advice 进行转换</span><br></pre></td></tr></table></figure><h4 id="2-spring-JPA中的适配器模式"><a href="#2-spring-JPA中的适配器模式" class="headerlink" title="(2)spring JPA中的适配器模式"></a>(2)spring JPA中的适配器模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在Spring的ORM包中，对于JPA的支持也是采用了适配器模式，首先定义了一个接口的 JpaVendorAdapter，然后不同的持久层框架都实现此接口。</span><br><span class="line"></span><br><span class="line">jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，</span><br><span class="line">因此最好在这里设置；目前Spring提供 HibernateJpaVendorAdapter、OpenJpaVendorAdapter、EclipseLinkJpaVendorAdapter、</span><br><span class="line">TopLinkJpaVendorAdapter 四个实现。其中最重要的属性是 database，用来指定使用的数据库类型，从而能根据数据库类型来决定比如如何将数</span><br><span class="line">据库特定异常转换为Spring的一致性异常，目前支持如下数据库（DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、</span><br><span class="line">SQL_SERVER、SYBASE）</span><br></pre></td></tr></table></figure><h4 id="3-spring-MVC中的适配器模式"><a href="#3-spring-MVC中的适配器模式" class="headerlink" title="(3)spring MVC中的适配器模式"></a>(3)spring MVC中的适配器模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring MVC中的适配器模式主要用于执行目标 Controller 中的请求处理方法。在Spring MVC中，DispatcherServlet 作为用户，</span><br><span class="line">HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h2&gt;&lt;p&gt;将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="http://blogs.qiulig.website/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式-代理模式/</id>
    <published>2019-06-15T07:37:14.000Z</published>
    <updated>2019-06-15T08:53:14.487Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><pre><code>为其他对象提供一种代理以控制对这个对象的访问。</code></pre><a id="more"></a><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>（1）抽象角色(Subject)：通过接口或抽象类声明真实角色实现的业务方法。</p><p>（2）代理角色（Proxy）：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p><p>（3）真实角色(RealSubject)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p><h3 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h3><pre><code>（1）远程代理。为一个位于不同的地址空间的对象提供一个本地的代理对象。这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远    程代理又叫做大使(Ambassador)。这样可以隐藏一个对象存在于不同地址空间的事实，使得客户端可以访问在远程机器上的对象。（2）虚拟代理。根据需要创建开销很大的对象。如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时    才会被真正创建。（3）安全代理。用来控制真实对象访问时的权限。（4）智能指引。当调用真实对象时，代理处理另外的一些事。</code></pre><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><pre><code>Spring 的AOP</code></pre><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>职责清晰：  真实角色就是实现实际的业务逻辑，不用关心其他非本职的事物高扩展性：  真实角色可以随时更换或扩展，只需要实现接口就行，而代理不需要有任何变化</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>(1)由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。  (2)实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</code></pre><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><pre><code>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Proxy proxy=<span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之前的预处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之后的后续处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><pre><code>在实现阶段不需要关心代理谁，在运行阶段会动态生成一个代理类去代理指定的对象</code></pre><p><strong>默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用CGlib来生成代理</strong></p><h3 id="1-jdk动态代理：接口-InvocationHandler-目标对象"><a href="#1-jdk动态代理：接口-InvocationHandler-目标对象" class="headerlink" title="(1)jdk动态代理：接口+InvocationHandler+目标对象"></a>(1)jdk动态代理：<strong>接口+InvocationHandler+目标对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主要用到java.lang.reflect中的两个类：<span class="string">'Proxy和InvocationHandler'</span></span><br><span class="line">InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类代码，动态的将横切逻辑与业务逻辑编织在一起</span><br><span class="line">     <span class="number">1</span>.定义业务逻辑接口</span><br><span class="line">     <span class="number">2</span>.实现业务逻辑接口创建业务实现类</span><br><span class="line">     <span class="number">3</span>.实现（implements）InvacationHandler代理接口，创建代理类</span><br><span class="line">     <span class="number">4</span>.创建业务类和代理类对象，通过代理类对象.bind(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。</span><br><span class="line">缺点：要求目标类必须实现对应方法非接口，它只能为接口创建代理</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvocationHandler + invoke()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被代理类的实例</span></span><br><span class="line">    Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将被代理者的实例传进动态代理类的构造函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖InvocationHandler接口中的invoke()方法</span></span><br><span class="line"><span class="comment">     * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构</span></span><br><span class="line"><span class="comment">     * 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到</span></span><br><span class="line"><span class="comment">     * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊</span></span><br><span class="line"><span class="comment">     * 代码切入的扩展点了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * before ：doSomething();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object result = method.invoke(<span class="keyword">this</span>.obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * after : doSomething();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-cglib动态代理：接口或类-MethodInterceptor-目标对象"><a href="#2-cglib动态代理：接口或类-MethodInterceptor-目标对象" class="headerlink" title="(2)cglib动态代理：接口或类+MethodInterceptor+目标对象"></a>(2)cglib动态代理：<strong>接口或类+MethodInterceptor+目标对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主要用到java.lang.reflect中的两个类:<span class="string">'MethodInterceptor和CglibProcy'</span></span><br><span class="line">    <span class="number">1</span>.定义业务类，无需实现接口（也可以实现）</span><br><span class="line">    <span class="number">2</span>.实现MethodInterceptor方法代理接口，创建代理类</span><br><span class="line">    <span class="number">3</span>.创建业务类和代理类对象，通过代理类对象.getInstance(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。</span><br><span class="line">特点：能代理类和接口，但是不能代理<span class="keyword">final</span>类</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MethodIntercepter + intercept()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Proxy instance = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getInstance</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        sayBefore();</span><br><span class="line">        Object result = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">        sayAfter();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"before..."</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayAfter</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"after..."</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;为其他对象提供一种代理以控制对这个对象的访问。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型模式" scheme="http://blogs.qiulig.website/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式-建造者模式/</id>
    <published>2019-06-14T08:50:36.000Z</published>
    <updated>2019-06-15T07:34:09.036Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><pre><code>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示</code></pre><a id="more"></a><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol><li><strong>产品角色</strong>（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。</li><li><strong>抽象建造者</strong>（Builder）：它是一个包含创建产品各个子部件的抽象方法的<strong>接口</strong>，通常还包含一个返回复杂产品的方法 getResult()。</li><li><strong>具体建造者</strong>(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li><strong>指挥者</strong>（Director）：构建一个使用builder接口的对象。它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>主要用于创建一些复杂的对象，这些对象内部间的建造顺序是稳定的，但对象内部的构建通常面临着复杂的变化。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>（1）使得建造代码与表示代码分离，由于建造者隐藏了产品如何组装，所以若需要改变一个产品内部表示，只需要在定义一个具体的建造者就可以了。</p><p>（2） 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</p><p>（3）<strong>增加新的具体建造者无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统扩展方便，符合 <strong>“开闭原则”</strong></p><p>（4）<strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="http://blogs.qiulig.website/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://blogs.qiulig.website/2019/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://blogs.qiulig.website/2019/06/排序算法/</id>
    <published>2019-06-13T03:27:51.000Z</published>
    <updated>2019-06-13T07:31:10.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="排序算法一览表"><a href="#排序算法一览表" class="headerlink" title="排序算法一览表"></a>排序算法一览表</h3><p><img src="https://github.com/qiulig/IMG/raw/master/排序算法.jpg" alt="排序算法一览表"></p><a id="more"></a><h2 id="1-冒泡排序-稳定"><a href="#1-冒泡排序-稳定" class="headerlink" title="1.冒泡排序[稳定]"></a>1.冒泡排序[稳定]</h2><blockquote><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] Bubblesort(<span class="keyword">int</span> []arr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;<span class="comment">//外层控制排序的趟数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;<span class="comment">//内层循环控制每趟排序多少次</span></span><br><span class="line">            <span class="comment">//前一个数比后一个数大，交换位置</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-选择排序-不稳定"><a href="#2-选择排序-不稳定" class="headerlink" title="2.选择排序[不稳定]"></a>2.选择排序[不稳定]</h2><blockquote><p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span> []arr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> minIndex =i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[j]&lt; arr[minIndex])&#123;</span><br><span class="line">              minIndex = j;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">int</span> temp =arr[i];</span><br><span class="line">    arr[i] =arr[minIndex];</span><br><span class="line">    arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-插入排序-稳定"><a href="#3-插入排序-稳定" class="headerlink" title="3.插入排序[稳定]"></a>3.插入排序[稳定]</h2><blockquote><p>每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span> []arr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">           <span class="comment">//后一个数小于前一个数则交换</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-归并排序-稳定"><a href="#4-归并排序-稳定" class="headerlink" title="4.归并排序[稳定]"></a>4.归并排序[稳定]</h2><blockquote><p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>如　设有数列{6，202，100，301，38，8，1}</p><p>初始状态：6 , 202 , 100 , 301 , 38 , 8 , 1</p><p>第一次归并后：{6,202} , {100,301}, {8,38}, {1} ，比较次数：3；</p><p>第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；</p><p>第三次归并后：{1,6,8,38,100,202,301},比较次数：4；</p><p>总的比较次数为：3+4+4=11；</p><p>逆序数为14；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid  = (low+high)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(arr,low,mid);</span><br><span class="line">        mergeSort(arr,mid+<span class="number">1</span>,high);</span><br><span class="line">        <span class="comment">//两路归并</span></span><br><span class="line">        merge(arr,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];<span class="comment">//汇总两个有序区的临时区域</span></span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">//左边序列起始索引</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右边序列起始索引</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">//临时区域的索引</span></span><br><span class="line">    <span class="comment">//把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;= high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;arr[j])&#123;</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若左边序列还有剩余，则将其全部拷贝进tmp[]中</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        tmp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若右边序列还有剩余，则将其全部拷贝进tmp[]中</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)&#123;</span><br><span class="line">        tmp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将排序后的元素，全部都整合到数组中。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>;t &lt; tmp.length ;t++)</span><br><span class="line">        arr[t+low] = tmp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-计数排序-稳定-–升级为桶排序"><a href="#5-计数排序-稳定-–升级为桶排序" class="headerlink" title="5.计数排序[稳定]–升级为桶排序"></a>5.计数排序[稳定]–升级为桶排序</h2><blockquote><p>工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//桶数</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = max + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;bucketNum;i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        bucketArr.get(arr[i]).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;bucketArr.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bucketArr.get(i).isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(Integer a:bucketArr.get(i))</span><br><span class="line">                System.out.print(a+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-基数排序-稳定"><a href="#6-基数排序-稳定" class="headerlink" title="6.基数排序[稳定]"></a>6.基数排序[稳定]</h2><blockquote><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p>准备10个桶，按照个位将数放入桶中，在倒出来，再按照十位数放入桶中再倒出来…..</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Redixsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span><span class="comment">//d表示最大的数有多少位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;  <span class="comment">//表示位数对应的数</span></span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> [][]bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][len];<span class="comment">//排序桶，用于保存每次排序后的结果，这样位排序结果相同的数字放在同一个桶里</span></span><br><span class="line">    <span class="keyword">int</span> []order = <span class="keyword">new</span> <span class="keyword">int</span>[len]; <span class="comment">// 用于保存每个桶里面有多少个数字</span></span><br><span class="line">    <span class="keyword">while</span>(n&lt; Math.pow(<span class="number">10</span>,d))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;<span class="comment">//将数组array里的每个数字放在相应的桶里</span></span><br><span class="line">            <span class="keyword">int</span> digit = (arr[i]/n)%<span class="number">10</span>;  <span class="comment">//求位上的数</span></span><br><span class="line">            bucket[digit][order[digit]] = arr[i];</span><br><span class="line">            order[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个循环生成的桶里的数据覆盖到原数组中，用于保存这一位的排序结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//桶里有数据</span></span><br><span class="line">            <span class="keyword">if</span>(order[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;order[i];j++)&#123;</span><br><span class="line">                    arr[k] = bucket[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//桶里计数器计0，用于下一次排序</span></span><br><span class="line">            order[i] =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n =n*<span class="number">10</span>;</span><br><span class="line">        k = <span class="number">0</span>; <span class="comment">//将k置0，用于下一轮保存位排序结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-快速排序-不稳定"><a href="#7-快速排序-不稳定" class="headerlink" title="7.快速排序[不稳定]"></a>7.快速排序[不稳定]</h2><blockquote><p>选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</p><p>简单记忆为：</p><p>“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(low &lt; high)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">int</span> position = partition(arr, low, high);</span><br><span class="line"> quicksort(arr, low, position - <span class="number">1</span>);</span><br><span class="line"> quicksort(arr, position + <span class="number">1</span>, high);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置基准值</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="comment">//从右到左，直到找到一个小于key的值</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= key) --high;</span><br><span class="line">        <span class="comment">//将该值填入前的坑</span></span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="comment">//从左到右，直到找到一个大于key的值</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= key) ++low;</span><br><span class="line">        <span class="comment">//将该值填入前一个坑</span></span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准值填入最后一个坑</span></span><br><span class="line">    arr[low] = key;</span><br><span class="line">    <span class="comment">//最后一个坑划分了左边小于该值，右边大于该值</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-希尔排序-不稳定-–插入排序的优化"><a href="#8-希尔排序-不稳定-–插入排序的优化" class="headerlink" title="8.希尔排序[不稳定]–插入排序的优化"></a>8.希尔排序[不稳定]–插入排序的优化</h2><blockquote><p>现在有一个array,希尔排序就是设定一个增量incrementNum (0&lt;incrementNum&lt;array.length)</p><p>(1)先从array[0]开始，以incrementNum为增量的进行直接插入排序，直到数组末尾，然后从array[1]开始重复：以incrementNum为增量的进行直接插入排序; 然后从array[1]开始重复……一直到array[n]。</p><p>然后取一个小于上一步增量的新的增量（比如设置为incrementNum/2）,对前一个步骤的结果array进行遍历，直接插入排序….</p><p>再取小于上一步增量的新的增量，重复进行：遍历，直接插入排序，直到新的增量小于1之后再退出循环</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> incrementNums = arr.length/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(incrementNums&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="comment">//进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =i+incrementNums;j&lt;arr.length;j+=incrementNums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[j-incrementNums])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] =arr[j-incrementNums];</span><br><span class="line">                    arr[j-incrementNums] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置新的增量</span></span><br><span class="line">        incrementNums =incrementNums/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-堆排序-不稳定"><a href="#9-堆排序-不稳定" class="headerlink" title="9.堆排序[不稳定]"></a>9.堆排序[不稳定]</h2><p><img src="https://github.com/qiulig/IMG/raw/master/堆排序.png" alt="堆知识"></p><blockquote><ol><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol><li><p>创建一个堆 H[0……n-1]；</p></li><li><p>把堆首（最大值）和堆尾互换；</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p></li><li><p>重复步骤 2，直到堆的尺寸为 1。</p></li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="comment">//叶子节点为（n/2+1~n,每个叶子本身就是一个大根堆）,故需要遍历的非叶子结点数位len/2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span> ; i&gt;=<span class="number">0</span>;i-- )&#123;</span><br><span class="line">        <span class="comment">//从第一个非叶子结点从下往上，从右至左调整，构造大根堆</span></span><br><span class="line">        <span class="comment">// i为最后一个根节点，n为数组最后一个元素的下标</span></span><br><span class="line">        HeapAdjust(arr,i,len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//最后一个元素跟第一个元素交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = tmp;</span><br><span class="line">        HeapAdjust(arr,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大根堆的构建</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得左孩子</span></span><br><span class="line">    <span class="keyword">int</span> leftchild = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightchild = <span class="number">2</span>* parent + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(leftchild&lt;length &amp;&amp; arr[leftchild]&gt;arr[largest])&#123;</span><br><span class="line">        largest= leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rightchild&lt;length &amp;&amp; arr[rightchild]&gt;arr[largest])&#123;</span><br><span class="line">        largest = rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(parent != largest)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[parent];</span><br><span class="line">        arr[parent] = arr[largest];</span><br><span class="line">        arr[largest]= temp;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        HeapAdjust(arr,largest,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序算法一览表&quot;&gt;&lt;a href=&quot;#排序算法一览表&quot; class=&quot;headerlink&quot; title=&quot;排序算法一览表&quot;&gt;&lt;/a&gt;排序算法一览表&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/qiulig/IMG/raw/master/排序算法.jpg&quot; alt=&quot;排序算法一览表&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="排序算法" scheme="http://blogs.qiulig.website/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://blogs.qiulig.website/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【237】删除链表的节点</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-237-删除链表的节点/</id>
    <published>2019-06-11T06:11:24.000Z</published>
    <updated>2019-06-11T07:06:34.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。<a id="more"></a></p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p>示例 1:</p><p>输入: head = [4,5,1,9], node = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], node = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>这题的输入只给出了要删除的点所在的位置node,即如果链表node为 2–&gt;3–&gt;4–&gt;1,则只删除2节点，即</p><pre><code>将node后面的向前移动覆盖即可</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">         node.val = node.next.val;</span><br><span class="line">         node.next = node.next.next;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/237.png" alt="删除链表结点"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【24】两两交换链表中的节点</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-24-两两交换链表中的节点/</id>
    <published>2019-06-11T01:41:30.000Z</published>
    <updated>2019-06-11T08:46:04.404Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：将链表中的数放到stack里面，每当stack里面有两个值，就pop弹出，将弹出的值放到新的链表后面。</p><p>方法2：递归</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">     ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">     ListNode ans = res;</span><br><span class="line">     <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         stack.push(head.val);</span><br><span class="line">         head = head.next;</span><br><span class="line">         <span class="keyword">if</span>(stack.size()==<span class="number">2</span>)&#123;</span><br><span class="line">             <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                 res.next = <span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">                 res = res.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">         res.next = <span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">         res = res.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans.next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">swapPairs2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode next = head.next;</span><br><span class="line">       head.next = swapPairs(next.next);</span><br><span class="line">       next.next = head;</span><br><span class="line">       <span class="keyword">return</span> next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/24_1.png" alt="两两交换链表中的节点方法1"></p><p><img src="https://github.com/qiulig/IMG/raw/master/24_2.png" alt="两两交换链表中的节点方法2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 你应该返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>链表反转</title>
    <link href="http://blogs.qiulig.website/2019/06/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    <id>http://blogs.qiulig.website/2019/06/链表反转/</id>
    <published>2019-06-10T13:04:46.000Z</published>
    <updated>2019-06-11T00:53:46.642Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>以链表 1-&gt;2-&gt;3-&gt;4  为例子：</p><ul><li>程序到达Node newHead = reverse(head.next);时进入递归</li><li>我们假设此时递归到了3结点，此时head=3结点，temp=3结点.next(实际上是4结点)<a id="more"></a></li><li>执行Node newHead = reverse(head.next);传入的head.next是4结点，返回的newHead是4结点。</li><li>接下来就是弹栈过程了<ul><li>程序继续执行 temp.next = head就相当于4-&gt;3</li><li>head.next = null 即把 3结点指向4结点的指针断掉。</li><li>返回新链表的头结点newHead</li></ul></li></ul><blockquote><p>注意：当retuen后，系统会恢复2结点压栈时的现场，此时的head=2结点；temp=2结点.next(3结点)，再进行上述的操作。最后完成整个链表的翻转。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode temp = head.next;</span><br><span class="line">    ListNode newHead = reverse(head.next);</span><br><span class="line">    temp.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h3><p>依旧是1-&gt;2-&gt;3-&gt;4</p><ul><li>准备两个空结点 pre用来保存先前结点、next用来做临时变量</li><li>在头结点node遍历的时候此时为1结点<ul><li>next = 1结点.next(2结点)</li><li>1结点.next=pre(null)</li><li>pre = 1结点</li><li>node = 2结点</li></ul></li><li>进行下一次循环node=2结点<ul><li>next = 2结点.next(3结点)</li><li>2结点.next=pre(1结点)=&gt;即完成2-&gt;1</li><li>pre = 2结点</li><li>node = 3结点</li></ul></li><li>进行循环…</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   ListNode next;</span><br><span class="line">   ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">       ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">       ListNode cur = node;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode next = cur.next;  <span class="comment">//将下一个节点记录</span></span><br><span class="line">           cur.next = pre;  <span class="comment">//当前节点指向上一个节点</span></span><br><span class="line">           pre = cur;   <span class="comment">//记录当前节点</span></span><br><span class="line">           cur = next; <span class="comment">//将下一个节点变成当前节点</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-递归&quot;&gt;&lt;a href=&quot;#1-递归&quot; class=&quot;headerlink&quot; title=&quot;1.递归&quot;&gt;&lt;/a&gt;1.递归&lt;/h3&gt;&lt;p&gt;以链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4  为例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序到达Node newHead = reverse(head.next);时进入递归&lt;/li&gt;
&lt;li&gt;我们假设此时递归到了3结点，此时head=3结点，temp=3结点.next(实际上是4结点)&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【203】移除链表元素</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-203移除链表元素/</id>
    <published>2019-06-10T12:35:37.000Z</published>
    <updated>2019-06-11T05:30:24.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>删除链表中等于给定值 <strong><em>val</em></strong> 的所有节点。<a id="more"></a></p><p><strong>示例:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, <strong><em>val</em></strong> = 6<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：</p><pre><code>如果当前链表值head.val不等于val,则新建一个节点放到ans后面如果相等，则跳到链表下一个。</code></pre><p>方法2：</p><pre><code>遇到相等则跳指针 要考虑好头节点跟val相等的情况。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：新建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">          ListNode ans = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">          ListNode res = ans;</span><br><span class="line">          <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(head.val==val)&#123;</span><br><span class="line">                  head = head.next;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  ans.next =<span class="keyword">new</span> ListNode(head.val) ;</span><br><span class="line">                  ans = ans.next;</span><br><span class="line">                  head = head.next;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>方法2：跳指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//如果头节点与val相同</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.val == val)</span><br><span class="line">            head = head.next;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;删除链表中等于给定值 &lt;strong&gt;&lt;em&gt;val&lt;/em&gt;&lt;/strong&gt; 的所有节点。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【120】三角形最小路径和</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-120-三角形最小路径和/</id>
    <published>2019-06-09T09:08:41.000Z</published>
    <updated>2019-06-10T07:33:23.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><a id="more"></a><p>例如，给定三角形：</p><p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划：</p><p> 每一层的值加上上一层的值中最小值，最后取最后一层的最小值就好了</p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">2</span>]                             [<span class="number">2</span>]</span><br><span class="line">&gt;    [<span class="number">3</span>,<span class="number">4</span>]         变成               [<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&gt;   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>]                        [<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>]</span><br><span class="line">&gt;  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]                      [<span class="number">15</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">16</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> len = triangle.get(triangle.size()-<span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="comment">//初始化第一层跟第二层</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>]+triangle.get(<span class="number">1</span>).get(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">0</span>] + triangle.get(<span class="number">1</span>).get(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//第一列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;= i ;j++)&#123;</span><br><span class="line">                <span class="comment">//最后一个数的dp,因为上一层比下一层少一个，所以只能最后一个数只能加上上一层的最后一个dp</span></span><br><span class="line">                <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j) + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j)+ Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三角形最后一层中的最小值就是最小路径</span></span><br><span class="line">        <span class="keyword">int</span> res = dp[len-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[len-<span class="number">1</span>][i] &lt; res)&#123;</span><br><span class="line">                res = dp[len-<span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/120.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【95】不同的二叉搜索树2</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-95-不同的二叉搜索树2/</id>
    <published>2019-06-09T07:16:05.000Z</published>
    <updated>2019-06-10T07:31:33.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出:<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释:<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>        <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span>        <span class="number">1</span></span><br><span class="line">&gt;  \      /      /      / \        \</span><br><span class="line">&gt;  <span class="number">3</span>     <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>        <span class="number">2</span></span><br><span class="line">&gt;  /    /        \                   \</span><br><span class="line">&gt;  <span class="number">2</span>   <span class="number">1</span>          <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1)当n = 1时，此时只有一个以1为根节点的二叉搜索树</p><p>(2) 当n &gt; 1时，当以 i 为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，依次递归遍历，分别放到left和right列表中，然后再先序遍历放入res结果中。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//n = 1 的情况，只有一个，就是根节点为1的二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                TreeNode node = <span class="keyword">new</span> TreeNode(start);</span><br><span class="line">                list.add(node);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以 i 为根节点，左子树为start~(i-1),右子树为(i+1)~n</span></span><br><span class="line">            List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                List&lt;TreeNode&gt; left = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                List&lt;TreeNode&gt; right = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (i != start) &#123;</span><br><span class="line">                    <span class="comment">//说明有左子树</span></span><br><span class="line">                    left = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != end) &#123;</span><br><span class="line">                    <span class="comment">//说明有右子树</span></span><br><span class="line">                    right = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//先序遍历存入res里面</span></span><br><span class="line">                <span class="keyword">if</span> (!left.isEmpty() &amp;&amp; !right.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode l : left) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (TreeNode r : right) &#123;</span><br><span class="line">                            TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                            root.left = l;</span><br><span class="line">                            root.right = r;</span><br><span class="line">                            res.add(root);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!left.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode l : left) &#123;</span><br><span class="line">                        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        root.left = l;</span><br><span class="line">                        res.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!right.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode r : right) &#123;</span><br><span class="line">                        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        root.right = r;</span><br><span class="line">                        res.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees=generate(start,i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归遍历右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees=generate(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//先序遍历存入以i为根节点的二叉搜索树</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left:leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right:rightTrees)&#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left=left;</span><br><span class="line">                    root.right=right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/95.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【96】不同二叉搜索树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-96-%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-96-不同二叉搜索树/</id>
    <published>2019-06-08T15:53:51.000Z</published>
    <updated>2019-06-10T07:31:59.584Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>      <span class="number">3</span>     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">&gt;  \     /    /     / \     \</span><br><span class="line">&gt;  <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>     <span class="number">1</span>   <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">&gt;  /   /      \               \</span><br><span class="line">&gt;  <span class="number">2</span>  <span class="number">1</span>        <span class="number">2</span>               <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划：</p><p>(1)初始化</p><pre><code>n  = 1时，只含有1，1作为根节点，此时二叉搜索数个数为1；</code></pre><p>(2) 算法</p><pre><code>    （1）假设n个节点存在二叉排序树的个数是dp[i]，令f[i]为以i为根的二叉搜索树的个数，则                dp[n] = f[1] + f[2] + f[3] + f[4] + ... + f[n]     （2）当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则                f [i]  = dp[i-1] * dp[n-i]综合两个公式可以得到卡特兰数公式</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  dp[n] = dp[<span class="number">0</span>] * dp[n-<span class="number">1</span>] + dp[<span class="number">1</span>] * dp[n-<span class="number">2</span>]+...+dp[n-<span class="number">1</span>] * dp[<span class="number">0</span>]</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * C(<span class="number">2</span>n,n)</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * (<span class="number">4</span>*n-<span class="number">2</span>)/(n-<span class="number">1</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n个节点存在二叉树的个数</span></span><br><span class="line">        <span class="keyword">long</span> []dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//以i为根节点的二叉树个数</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]*(<span class="number">4</span>*i-<span class="number">2</span>)/(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/96.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【70】爬楼梯</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-70-爬楼梯/</id>
    <published>2019-06-08T14:47:57.000Z</published>
    <updated>2019-06-10T07:28:59.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><a id="more"></a><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li><p>2 阶</p><p>示例 2：</p></li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><p>初始化：</p><pre><code>可知dp[0]  = 0;dp[1] = 1;dp[2] = 2;即跳0级有一种方法，一级有1种方法，2级有2种方法</code></pre><p>算法核心：</p><pre><code>dp[i] = dp[i-1] +dp[i-2] ,即爬i阶台阶的方法等于爬i-2阶台阶的方法加上爬i-1阶台阶的方法</code></pre><p>方法2：</p><pre><code>剑指offer第8题</code></pre><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n ;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;=n ;i++)&#123;</span><br><span class="line">            res = one + two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/70.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【64】最小路径和</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-64-最小路径和/</id>
    <published>2019-06-08T14:06:23.000Z</published>
    <updated>2019-06-10T07:28:29.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><a id="more"></a><p>示例:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果数组只有一个数，则路径最小即为该值，dp[0][0] = 0;</p><p> (1)动态规划初始化</p><pre><code>1)只有一行，则路径总和最小为 dp[0][i] = dp[0][i-1] + grid[0][i];2)只有一列，则路径总和最小为 dp[i][0] = dp[i-1][0] + grid[i][0];</code></pre><p>(2) 动态规划核心算法</p><p>  每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：</p><pre><code>dp[i][j] = grid[i][j] + min( dp[i-1][j] , dp[i][j-1]);</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划核心</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                dp[i][j] = grid[i][j]+(dp[i-<span class="number">1</span>][j]&lt;dp[i][j-<span class="number">1</span>]?dp[i-<span class="number">1</span>][j]:dp[i][j-<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/64.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;说明：每次只能向下或者向右移动一步。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【63】不同路径2</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-63-不同路径2/</id>
    <published>2019-06-08T13:38:57.000Z</published>
    <updated>2019-06-10T07:27:35.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><a id="more"></a><p>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果第一个格点 obstacleGrid[0][0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。</p><p>如果 obstacleGrid[0][0] 是 0，我们初始化这个值为 1 然后继续算法。<br>(1)动态规划初始化</p><pre><code>1)obstacleGrid[0][0] == 0,表示没障碍，路径只有一条；dp[0][0] = 1;2)遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[0][j] = dp[0][j-1]。             3)遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[i][0] = obstacleGrid[i-1][0]。</code></pre><p>(2) 动态规划核心算法</p><pre><code>从 obstacleGrid[1][1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 dp[i][j] = dp[i-1][j] + dp[i][j-1]。如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> col = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span> ? <span class="number">0</span> : dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>? <span class="number">0</span>:dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                    dp[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/63.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。&lt;/p&gt;
&lt;p&gt;说明：m 和 n 的值均不超过 100。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【62】不同的路径</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-62-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-62-不同的路径/</id>
    <published>2019-06-08T03:35:18.000Z</published>
    <updated>2019-06-10T07:25:47.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划</p><p>（1）初始化</p><pre><code>1) 从[0,0]走到[0,0]的路径，即没走，设dp[0][0] = 0;2) 如果m*n的n为1，即机器人在m*1走，只能有一条路径，即arr[i][0] = 1;3) 如果m*n的m为1，即机器人在1*n走，只能有一条路径，即arr[0][1] = 1;</code></pre><p>(2) 动态规划核心算法</p><pre><code>机器人每次只能向下或者向右移动一步。即机器人arr[i][j]的路径由arr[i-1][j]和arr[i][j-1]决定，即arr[i][j] = arr[i-1][j]+arr[i][j-1];</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j]+arr[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/62.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【53】最大子序和</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-53-最大子序和/</id>
    <published>2019-06-08T02:52:18.000Z</published>
    <updated>2019-06-10T07:17:31.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><blockquote><ol><li>定义一个函数f(n)，以第n个数为结束点的子数列的最大和，存在一个递推关系f(n) = max(f(n-1) + A[n], A[n]);</li><li>将这些最大和保存下来后，取最大的那个就是，最大子数组和。因为最大连续子数组 等价于 最大的以n个数为结束点的子数列</li></ol></blockquote><p>方法2：</p><blockquote><p>用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。</p><pre><code>(1)当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令    cur = 0.表示从下一个数开始累加。(2)当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最    大值即可。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        ans[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = ans[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//依次求出以第n个数为结束点的子序列最大和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            ans[i] = Math.max(ans[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="comment">//求出最大和</span></span><br><span class="line">            res = Math.max(res,ans[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            cur = cur + nums[i];</span><br><span class="line">            ans = Math.max(cur,ans);</span><br><span class="line">            cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/53_1.jpg" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/53_2.jpg" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
