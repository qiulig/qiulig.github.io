<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0972e01a5f38f38e77d0154479c21150</icon>
  <subtitle>菜鸟要更加努力才能追上别人的步伐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blogs.qiulig.website/"/>
  <updated>2019-05-31T08:09:55.600Z</updated>
  <id>http://blogs.qiulig.website/</id>
  
  <author>
    <name>qiulig</name>
    <email>qiuling_long@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-原型模式</title>
    <link href="http://blogs.qiulig.website/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/05/设计模式-原型模式/</id>
    <published>2019-05-31T07:53:34.000Z</published>
    <updated>2019-05-31T08:09:55.600Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节。<a id="more"></a></p><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1.浅拷贝"></a>1.浅拷贝</h3><pre><code>对类实现Cloneable接口（implements Cloneable），并且重写clone对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型创建成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2.深拷贝"></a>2.深拷贝</h3><pre><code>对其中的引用类型的成员变量进行实现Cloneable接口，重写clone，就变成深拷贝了对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">     String name;</span><br><span class="line"></span><br><span class="line">     String <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1.如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程。</p><p>2.使用原型模式创建对象比直接 new 一个对象在性能上要好的多，因为 Object 类的 clone 方法是一个本地方法，它直接操作内存中的二进制流，特别  是复制大对象时，性能的差别非常明显。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p><strong>在需要重复地创建相似对象时可以考虑使用原型模式</strong>。</p><p>比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数  很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h2&gt;&lt;p&gt;创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式—享元模式</title>
    <link href="http://blogs.qiulig.website/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/05/设计模式—-享元模式/</id>
    <published>2019-05-31T07:30:02.000Z</published>
    <updated>2019-05-31T07:50:56.817Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>运用<strong>共享技术</strong>有效地支持<strong>大量细粒度对象的复用</strong>。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。<a id="more"></a></p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="https://github.com/qiulig/IMG/raw/master/设计模式之享元模式.png" alt="享元模式结构图"></p><p>在享元模式中引入了享元工厂类FlyweightFactory，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><p>享元工厂类：FlyweightFactory</p><p>享元类：ConcreteFlyweight</p><p>享元对象：Flyweight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个HashMap用于存储享元对象，实现享元池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap flyweights = newHashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果对象存在，则直接从享元池获取</span></span><br><span class="line">        <span class="keyword">if</span>(flyweights.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>(Flyweight)flyweights.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Flyweight fw = newConcreteFlyweight();</span><br><span class="line">            flyweights.put(key,fw);</span><br><span class="line">            <span class="keyword">return</span> fw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><blockquote><p>当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。</p><p><strong>String中的享元模式</strong></p><p> Java中将String类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。</p></blockquote><blockquote><p><strong>Integer中的享元模式</strong></p><p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code>之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象</p></blockquote><blockquote><p><strong>Long中的享元模式</strong></p><p>与Integer原理类似</p></blockquote><blockquote><p><strong>Apache Commons Pool2中的享元模式（对象池）</strong></p><p>将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用，从而在一定程度上减少频繁创建对象所造成的开销。用于充当保存对象的“容器”的对象，被称为“对象池”</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;运用&lt;strong&gt;共享技术&lt;/strong&gt;有效地支持&lt;strong&gt;大量细粒度对象的复用&lt;/strong&gt;。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://blogs.qiulig.website/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/05/设计模式式-单例模式/</id>
    <published>2019-05-31T06:57:26.000Z</published>
    <updated>2019-05-31T07:24:05.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><pre><code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式包括（1）私有的构造方法（2）含有一个该类的静态私有对象private static（3）提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</code></pre><a id="more"></a><h3 id="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"><a href="#懒汉模式：全局的单例在第一次使用时构建（延迟初始化）" class="headerlink" title="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"></a>懒汉模式：全局的单例在第一次使用时构建（延迟初始化）</h3><p>优点：<br>    避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法。<br>缺点：<br>    懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉模式：全局的单例实例在类装载时构建"><a href="#饿汉模式：全局的单例实例在类装载时构建" class="headerlink" title="饿汉模式：全局的单例实例在类装载时构建"></a>饿汉模式：全局的单例实例在类装载时构建</h3><p>1.线程安全<br>2.在类加载的同时已经创建好一个静态对象，调用时反应速度快  </p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><pre><code>资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h3><p>数据库连接池，多线程连接池。Windows应用管理器</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例<br>2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。<br>3.提供了对唯一实例的受控访问。<br>4.由于在系统内存中只存在一个对象，因此可以<strong>节约系统资源</strong>，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。<br>5.允许可变数目的实例。<br>6.避免对共享资源的多重占用。</p></blockquote><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>单例模式可能导致内存泄漏（OOM）</p><p>1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。<br>2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。<br>3.单例类的职责过重，在一定程度上违背了“单一职责原则”。<br>4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。

 单例模式包括

（1）私有的构造方法

（2）含有一个该类的静态私有对象private static

（3）提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA_集合中的快速失败与安全失败</title>
    <link href="http://blogs.qiulig.website/2019/05/JAVAVA-java%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5/"/>
    <id>http://blogs.qiulig.website/2019/05/JAVAVA-java中的快速失败与安全失败/</id>
    <published>2019-05-31T06:28:04.000Z</published>
    <updated>2019-05-31T06:48:49.369Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="快速失败-fail—fast-机制"><a href="#快速失败-fail—fast-机制" class="headerlink" title="快速失败(fail—fast)机制"></a>快速失败(fail—fast)机制</h2><blockquote><p>java集合框架中的一种错误检测机制。多线程下用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除），则会抛出Concurrent Modification Exception。<a id="more"></a></p><p>fail-fast机制并不保证在不同步的修改下一定会抛出异常，这种机制一般仅用于检测bug。</p><p>【在循环迭代中修改会报异常，在迭代中修改不会报异常】</p><p><strong>java.util包下的集合类都是采用快速失败机制的，不能在多线程下发生并发修改（只能在迭代过程中被修改）。</strong></p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>这里异常的抛出条件是检测到 <strong>modCount!=expectedmodCount</strong>这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">6</span>)&#123;</span><br><span class="line">            list.remove(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line">----&gt;<span class="keyword">for</span>语句修改结果报错&lt;-------------------</span><br><span class="line">----&gt;Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException&lt;------------</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.next() == <span class="number">6</span>) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line">-------&gt;结果不报错&lt;------------------</span><br></pre></td></tr></table></figure><ul><li>迭代器是作为当前集合的内部类实现的，当迭代器创建的时候保持了当前集合的引用；</li><li>集合内部维护一个int变量modCount，用来记录集合被修改的次数，比如add，remove等都会使该字段递增；</li><li>modCount这个参数记录了某个List改变大小的次数，如果modCount改变的不符合预期，那么就会抛出异常。</li><li>迭代器内部也维护着当前集合的修改次数的字段，迭代器创建时该字段初始化为集合的modCount值</li><li>当每一次迭代时，迭代器会比较迭代器维护的字段和modCount的值是否相等，如果不相等就抛ConcurrentModifiedException异常；</li><li>当然，如果用迭代器调用remove方法，那么集合和迭代器维护的修改次数都会递增，以保持两个状态的一致。</li></ul><h2 id="安全失败-fail-safe"><a href="#安全失败-fail-safe" class="headerlink" title="安全失败(fail-safe)"></a>安全失败(fail-safe)</h2><blockquote><p>在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常</p><p><strong>concurrent包下的都是安全失败的，可以在多线程下并发使用，并发修改。</strong></p></blockquote><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><blockquote><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><blockquote><p>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速失败-fail—fast-机制&quot;&gt;&lt;a href=&quot;#快速失败-fail—fast-机制&quot; class=&quot;headerlink&quot; title=&quot;快速失败(fail—fast)机制&quot;&gt;&lt;/a&gt;快速失败(fail—fast)机制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;java集合框架中的一种错误检测机制。多线程下用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除），则会抛出Concurrent Modification Exception。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="http://blogs.qiulig.website/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合类" scheme="http://blogs.qiulig.website/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hashmap底层</title>
    <link href="http://blogs.qiulig.website/2019/05/Hashmap%E5%BA%95%E5%B1%82/"/>
    <id>http://blogs.qiulig.website/2019/05/Hashmap底层/</id>
    <published>2019-05-30T14:05:27.000Z</published>
    <updated>2019-05-31T02:38:53.426Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HashMap简介</p><h4 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h4><p><img src="https://github.com/qiulig/IMG/raw/master/hashmap_1.jpg" alt="hashmap底层"><a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/hashmap_2.jpg" alt="hashmap底层"></p><blockquote><p><strong>底层是链表+数组，当链表长度大于8自动转化成红黑树。</strong></p><p><strong>首先有一个每个元素都是链表的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。</strong></p></blockquote><h4 id="2-hashMap的java构建"><a href="#2-hashMap的java构建" class="headerlink" title="2.hashMap的java构建"></a>2.hashMap的java构建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-HashMap的put实现"><a href="#3-HashMap的put实现" class="headerlink" title="3.HashMap的put实现"></a>3.HashMap的put实现</h4><blockquote><p>（1）程序先计算该key的hashCode()值</p><p>（2）对该哈希码进行再哈希，然后把哈希值和(数组长度-1)进行按位与操作，得到数组的下标</p><p>（3）该位置没有链表节点就把&lt;key,value&gt;放入该位置。有节点就对链表进行遍历，看是否有key一样的节点，有则value进行覆盖更新，没有就创建节点，把节点放链表表头（头插法）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//HashMap 允许存放null键和null值</span></span><br><span class="line">    <span class="comment">//当key为null时，调用putForNullKey,将value放置在数组第一个位置</span></span><br><span class="line">    <span class="keyword">if</span>(key==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key的keycode重新计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hascode());</span><br><span class="line">    <span class="comment">//搜索指定hash值在对应table的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash,table.length);</span><br><span class="line">    <span class="comment">//如果i索引处的entry不为null,通过循环不断遍历e元素的下一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[i];e!=<span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || ley.equals(k)))&#123;</span><br><span class="line">            V.oldValue = e.value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果i索引处的entry为null,表明此处还没有entry</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//将key、value添加到i索引处</span></span><br><span class="line">    addEntry(hash,key,value,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash,K key,V value,<span class="keyword">int</span> bucketIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取指定bucketIndex索引处的Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  <span class="comment">//将新创建的Entry放入bucletIndex索引处，并让新的Enrty指向原来的Entry</span></span><br><span class="line">   table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt; (hash,key,value,e);</span><br><span class="line">   <span class="comment">//如果Map中的key-value对数量超过了极限</span></span><br><span class="line">   <span class="keyword">if</span>(size++&gt;=threshold)</span><br><span class="line">       <span class="comment">//把table对象的长度扩充为2倍</span></span><br><span class="line">       resize(<span class="number">2</span>*table.length); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HashMap长度扩充</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line">    Entry[] oldTable  = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span>(oldCapacity == MAXIMUM_CAPACITY)&#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>) (newCapacity*loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span></span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;src.length;j++)&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span>(e!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash,newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(e!=<span class="keyword">null</span>)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行hash计算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-HashMap的get方法"><a href="#4-HashMap的get方法" class="headerlink" title="4.HashMap的get方法"></a>4.HashMap的get方法</h4><blockquote><p>（1）通过key的两次hash的值与数组的长度-1进行按位与操作，定位到数组的某个位置</p><p>（2）对该列的链表进行遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();  </span><br><span class="line">     <span class="keyword">int</span> hash = hash(key.hasCode());</span><br><span class="line">     <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[indexFor(hash,table.length)]);e!=<span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span>(e.hash == hash &amp;&amp; (k = e.key) == key || key.equals(k))&#123;</span><br><span class="line">             <span class="keyword">return</span> e.value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-HashMap总结"><a href="#5-HashMap总结" class="headerlink" title="5.HashMap总结"></a>5.HashMap总结</h4><p>（1）hashmap可以存储null值，线性不安全</p><p>（2）hashmap扩容：当 HashMap 中的结点个数超过数组大小<em>loadFactor（加载因子） 时， 就会进行数组扩容，loadFactor 的默认值为 0.75。也就是说，默认情况下，数组大小为 16，那么当 HashMap中结点个数超过 16</em>0.75=12 的时候， 就把数组的大小扩展为 2*16=32， 即扩大一倍，然后重新计算每个元素在数组中的位置，并放进去， 而这是一个非常消耗性能的操作。</p><p>（3）多线程 put 操作后， get 操作导致死循环,导致 cpu100%的现象。 主要是多线程同时put 时， 如果同时触发了 rehash 操作，会导致扩容后的 HashMap 中的链表中出现循环节点， 进而使得后面 get 的时候，会死循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap简介&lt;/p&gt;
&lt;h4 id=&quot;1-实现原理&quot;&gt;&lt;a href=&quot;#1-实现原理&quot; class=&quot;headerlink&quot; title=&quot;1.实现原理&quot;&gt;&lt;/a&gt;1.实现原理&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/qiulig/IMG/raw/master/hashmap_1.jpg&quot; alt=&quot;hashmap底层&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://blogs.qiulig.website/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="底层" scheme="http://blogs.qiulig.website/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>JVM_内存泄漏和内存溢出</title>
    <link href="http://blogs.qiulig.website/2019/05/JVMVM-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>http://blogs.qiulig.website/2019/05/JVMVM-内存泄漏和内存溢出/</id>
    <published>2019-05-30T11:54:41.000Z</published>
    <updated>2019-05-30T12:42:33.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><blockquote><p>一个不再被程序使用的对象或者变量还在内存中占有存储空间。</p><p>（1）堆中申请的空间没有被释放</p><p>（2）对象不在使用但还在内存中保留</p><a id="more"></a></blockquote><h6 id="内存泄漏的原因："><a href="#内存泄漏的原因：" class="headerlink" title="内存泄漏的原因："></a>内存泄漏的原因：</h6><blockquote><p>（1）静态集合类，如hashmap和vector，如果容器为静态，她们的生命周期与程序一致。</p><p>（2）各种连接，如数据库连接，IO连接</p><p>（3）监听器：通常一个应用中会用到多个监听器，但是在释放对象的同时往往没有相应的删除监听器</p><p>（4）变量不合理的作用域。一方面一个变量的定义作用范围大于其使用范围，很可能造成内存泄漏。另一方面如果没有及时把对象设置为null,很可能导致内存泄漏。</p><p>（5）单例模式：一直存在着一个对对象的引用，并且以一个静态变量的方式存储，因此它在JVM整个生命周期都存在。</p></blockquote><h6 id="内存泄漏解决方案："><a href="#内存泄漏解决方案：" class="headerlink" title="内存泄漏解决方案："></a>内存泄漏解决方案：</h6><blockquote><p>（1）避免在循环中创建对象</p><p>（2） 尽早释放无用的对象引用</p><p>（3）尽量少用静态变量</p><p>（4）使用字符串处理，避免使用String,应大量使用StringBuffer,因为每个String对象都得独立占用内存一块区域</p></blockquote><h2 id="内存溢出OOM"><a href="#内存溢出OOM" class="headerlink" title="内存溢出OOM"></a>内存溢出OOM</h2><h6 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h6><blockquote><p>程序运行过程中无法申请到足够的内存而导致的一种错误，除了程序计数器外，其他几个运行区都有OOM的可能。</p></blockquote><h6 id="内存溢出情况："><a href="#内存溢出情况：" class="headerlink" title="内存溢出情况："></a>内存溢出情况：</h6><blockquote><p>（1）虚拟机栈和本地方法栈溢出</p><pre><code>如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackOverflowError 异常。  如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError 异常。  </code></pre><p> （2）<strong>堆溢出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 一般的异常信息： java.lang.OutOfMemoryError:Java heap spaces</span><br><span class="line">&gt;  出现这种异常，一般手段是先通过内存映像分析工具(如 Eclipse Memory Analyzer)对 dump 出来的堆转存快照进行分析,</span><br><span class="line">&gt;  重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏还是内存溢出。</span><br><span class="line">&gt;     1.如果是内存泄漏， 可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。</span><br><span class="line">&gt;     2.如果不存在泄漏， 那就应该检查虚拟机的参数(-Xmx 与-Xms)的设置是否适当。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（3）<strong>方法区溢出</strong></p><pre><code>异常信息： java.lang.OutOfMemoryError:PermGen space。</code></pre><p>（4）<strong>运行时常量池溢出</strong></p><pre><code>异常信息： java.lang.OutOfMemoryError:PermGen space。  </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果要向运行时常量池中添加内容，最简单的做法就是使用 String.intern()这个Native 方法。</span><br><span class="line">&gt;     该方法的作用是:如果池中已经包含一个等于此 String 的字符串， 则返回代表池中这个字符串的 String 对象；</span><br><span class="line">&gt;     否则，将此 String 对象包含的字符串添加到常量池中， 并且返回此 String 对象的引用 。</span><br><span class="line">&gt; 由于常量池分配在方法区内，我们可以通过-XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小， 从而间接限制其中常量池的容量。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h6 id="内存溢出原因："><a href="#内存溢出原因：" class="headerlink" title="内存溢出原因："></a>内存溢出原因：</h6><blockquote><p>1.内存中加载的数据量过于庞大， 如一次从数据库取出过多数据；</p><p>2.集合类中有对对象的引用， 使用完后未清空， 使得 JVM 不能回收；<br>3.代码中存在死循环或循环产生过多重复的对象实体；<br>4.启动参数内存值设定的过小。</p></blockquote><h6 id="内存溢出解决方法："><a href="#内存溢出解决方法：" class="headerlink" title="内存溢出解决方法："></a>内存溢出解决方法：</h6><blockquote><p>(1) 修改 JVM 启动参数， 直接增加内存。 (-Xms， -Xmx 参数一定不要忘记加。一般要将-Xms 和-Xmx 选项设置为相同， 以避免在每次 GC 后调整堆的大小； 建  议堆的最大值设置为可用内存的最大值的 80%)。  </p><p>(2) 检查错误日志， 查看“OutOfMemory” 错误前是否有其它异常或错误。 </p><p>(3)对代码进行走查和分析， 找出可能发生内存溢出的位置</p><p>(4)  使用内存查看工具动态查看内存使用情况（Jconsole）。</p></blockquote><h2 id="减少gc次数的方法："><a href="#减少gc次数的方法：" class="headerlink" title="减少gc次数的方法："></a>减少gc次数的方法：</h2><blockquote><p><strong>（1）对象不用时最好显式置为 Null</strong></p><pre><code>一般而言,为 Null 的对象都会被作为垃圾处理,所以将不用的对象显式地设  为 Null,有利于 GC 收集器判定垃圾,从而提高了 GC 的效率。  </code></pre><p><strong>（2）尽量少用 System.gc()</strong>  </p><pre><code>此函数建议 JVM进行主 GC,虽然只是建议而非一定,但很多情况下它会触发  主 GC,从而增加主 GC 的频率,也即增加了间歇性停顿的次数。  </code></pre><p><strong>（3）尽量少用静态变量</strong>  </p><pre><code>静态变量属于全局变量,不会被 GC 回收,它们会一直占用内存。  </code></pre><p><strong>（4） 尽量使用 StringBuffer,而不用 String 来累加字符串。</strong><br>    由于 String 是固定长的字符串对象,累加 String 对象时,并非在一个 String  对象中扩增,而是重新创建新的 String 对象,如 Str5=Str1+Str2+Str3+Str4,这条  语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新  的 String 对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多  的垃圾。 避免这种情况可以改用 StringBuffer 来累加字符串,因 StringBuffer 是可变长的,它在原有基础上进行扩增,不会产生中间对象。<br><strong>（5）分散对象创建或删除的时间</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM 在面临这种情况时,只能进行主 GC,以回收内存或整合</span><br><span class="line">&gt; 内存碎片从而增加主 GC 的频率。集中删除对象,道理也是一样的。 它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大</span><br><span class="line">&gt; 增加了下一次创建新对象时强制主 GC 的机会。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（6） <strong>尽量少用 finalize 函数。 因为它会加大 GC 的工作量， 因此尽量少</strong>用finalize 方式回收资源。  </p><p><strong>（7） 如果需要使用经常用到的图片， 可以使用软引用类型， 它可以尽可能</strong></p><p><strong>（8）能用基本类型如 int,long,就不用 Integer,Long 对象</strong></p><pre><code>基本类型变量占用的内存资源比相应包装类对象占用的少得多,如果没有必要,最好使用基本变量。  </code></pre><p><strong>（9） 增大-Xmx 的值。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h2&gt;&lt;h6 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;概念：&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;一个不再被程序使用的对象或者变量还在内存中占有存储空间。&lt;/p&gt;
&lt;p&gt;（1）堆中申请的空间没有被释放&lt;/p&gt;
&lt;p&gt;（2）对象不在使用但还在内存中保留&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA虚拟机" scheme="http://blogs.qiulig.website/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://blogs.qiulig.website/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java_深拷贝和浅拷贝</title>
    <link href="http://blogs.qiulig.website/2019/05/Java-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://blogs.qiulig.website/2019/05/Java-深拷贝和浅拷贝/</id>
    <published>2019-05-30T09:08:44.000Z</published>
    <updated>2019-05-30T12:44:26.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>对基本数据类型进行了拷贝</p><p>对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。</p><h6 id="即"><a href="#即" class="headerlink" title="即"></a>即</h6><pre><code>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝</code></pre><a id="more"></a><h6 id="底层实现："><a href="#底层实现：" class="headerlink" title="底层实现："></a>底层实现：</h6><p>（1）对类实现Cloneable接口（implements Cloneable），并且重写clone</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;  String name;</span><br><span class="line">&gt;  String <span class="keyword">int</span> age;</span><br><span class="line">&gt;  Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line">&gt;  <span class="meta">@Override</span></span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;  <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（2）用clone()方法创建新的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;     A a = <span class="keyword">new</span> A();</span><br><span class="line">&gt;     A aclone = (A)a.clone();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>对基本数据类型进行了拷贝</p><p>对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量</p><h6 id="即-1"><a href="#即-1" class="headerlink" title="即"></a>即</h6><pre><code>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容</code></pre><h6 id="底层实现：-1"><a href="#底层实现：-1" class="headerlink" title="底层实现："></a>底层实现：</h6><ol><li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li><li><p>继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，<strong>再进行一次 clone()</strong>。对A而言就是深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;     String name;</span><br><span class="line">&gt;     String <span class="keyword">int</span> age;</span><br><span class="line">&gt;     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;     <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;        <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>一个对象内部只有基本数据类型，那用 clone() 方法获取到的就是这个对象的深拷贝，而如果其内部还有引用数据类型，那用 clone() 方法就是一次浅拷贝的操作。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对基本数据类型进行了拷贝&lt;/p&gt;
&lt;p&gt;对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。&lt;/p&gt;
&lt;h6 id=&quot;即&quot;&gt;&lt;a href=&quot;#即&quot; class=&quot;headerlink&quot; title=&quot;即&quot;&gt;&lt;/a&gt;即&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="http://blogs.qiulig.website/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="http://blogs.qiulig.website/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【42】接雨水</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-42-接雨水/</id>
    <published>2019-05-30T07:31:57.000Z</published>
    <updated>2019-05-30T08:07:56.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/42.png" alt="图"></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>思路1：转化成每个位置留下水量的总和</p><pre><code>i位置上留下的水为[0 , (i-1)]的最大值max1,(i+1,length)位置上的max2的两者较小值-该位置的高度：min(max2-max1) - arr[i]。</code></pre><p>思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。</p><p>思路3：跟思路2一致，减掉了一个指针</p><p>思路4：左边最大值小于右边最大值，左指针右滑，左指针位置上能装的水就是左边最大值减去左指针指的值，若左指针指向的值大于左边大值，就不减，说明不能储水，更新左边最大值，当右边最大值小于左边最大值时，右指针左滑，做法跟前类似，直到左指针小于等于右指针跳出循环。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>思路1代码：转化成每个位置留下水量的总和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getWater1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; i; l++) &#123;</span><br><span class="line">                leftMax = Math.max(arr[l], leftMax);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = i + <span class="number">1</span>; r &lt; arr.length; r++) &#123;</span><br><span class="line">            rightMax = Math.max(arr[r], rightMax);</span><br><span class="line">            &#125;</span><br><span class="line">            value += Math.max(<span class="number">0</span>, Math.min(leftMax, rightMax) - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>思路2代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMaxs[<span class="number">0</span>] = arr[<span class="number">0</span>];<span class="comment">//左指针初始化为第一个数</span></span><br><span class="line">        <span class="comment">//求左边的max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            leftMaxs[i] = Math.max(leftMaxs[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] rightMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMaxs[n - <span class="number">1</span>] = arr[n + <span class="number">1</span>];<span class="comment">//右指针初始化为数组最后一个数</span></span><br><span class="line"><span class="comment">//求右边的max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightMaxs[i] = Math.max(rightMaxs[i + <span class="number">1</span>], arr[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            value += Math.max(<span class="number">0</span>, Math.min(leftMaxs[i - <span class="number">1</span>], rightMaxs[i - <span class="number">1</span>]) - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>思路3代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路3：减少一个指针</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> n = arr.length - <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span>[] rightMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">     rightMaxs[n - <span class="number">1</span>] = arr[n + <span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         rightMaxs[i] = Math.max(rightMaxs[i + <span class="number">1</span>], arr[i + <span class="number">2</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">         value += Math.max(<span class="number">0</span>, Math.min(leftMax, rightMaxs[i - <span class="number">1</span>]) - arr[i]);</span><br><span class="line">         leftMax = Math.max(leftMax, arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>思路4代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap4</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rightMax = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;<span class="comment">//从第二个查看是否能蓄水</span></span><br><span class="line">        <span class="keyword">int</span> r = arr.length - <span class="number">2</span>;<span class="comment">////从倒数第二个查看是否能蓄水</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt;= rightMax) &#123;</span><br><span class="line">                value += Math.max(<span class="number">0</span>, leftMax - arr[l]);</span><br><span class="line">                leftMax = Math.max(leftMax, arr[l++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value += Math.max(<span class="number">0</span>, rightMax - arr[r]);</span><br><span class="line">                rightMax = Math.max(rightMax, arr[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p>思路1提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_11.png" alt="接雨水"></p><p>思路2提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_12.png" alt="接雨水"></p><p>思路3提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_13.png" alt="接雨水"></p><p>思路4提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_14.png" alt="接雨水"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="滑动窗口法" scheme="http://blogs.qiulig.website/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【11】盛最多水的容器</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-11-盛最多水的容器/</id>
    <published>2019-05-30T07:20:14.000Z</published>
    <updated>2019-05-30T08:07:38.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定  <em>n</em>  个非负整数  <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画  <em>n</em>  条垂直线，垂直线  <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><a id="more"></a><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://github.com/qiulig/IMG/raw/master/11.png" alt="图"></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.  解题思路"></a>2.  解题思路</h3><p>这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。</p><p>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量  res  来持续存储到目前为止所获得的最大面积。 </p><p>在每一步中，我们会找出指针所指向的两条线段形成的区域，更新  res，并将指向较短线段的指针向较长线段那端移动一步。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            res = Math.max(res,(right-left)*Math.min(height[left],height[right]));</span><br><span class="line">            <span class="comment">//舍弃高度较小的</span></span><br><span class="line">            <span class="keyword">if</span> ((height[left] &gt; height[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/11_1.png" alt="盛最多水的容器"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定  &lt;em&gt;n&lt;/em&gt;  个非负整数  &lt;em&gt;a&lt;/em&gt;1，&lt;em&gt;a&lt;/em&gt;2，…，&lt;em&gt;a&lt;/em&gt;n，每个数代表坐标中的一个点 (&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;ai&lt;/em&gt;) 。在坐标内画  &lt;em&gt;n&lt;/em&gt;  条垂直线，垂直线  &lt;em&gt;i&lt;/em&gt; 的两个端点分别为 (&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;ai&lt;/em&gt;) 和 (&lt;em&gt;i&lt;/em&gt;, 0)。找出其中的两条线，使得它们与 &lt;em&gt;x&lt;/em&gt; 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="滑动窗口法" scheme="http://blogs.qiulig.website/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【10】正则表达式匹配</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-10-正则表达式匹配/</id>
    <published>2019-05-30T03:13:17.000Z</published>
    <updated>2019-05-31T06:56:57.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>)。实现支持  <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。<a id="more"></a></p><p>‘.’ 匹配任意单个字符。<br>‘*’ 匹配零个或多个前面的元素。</p><p>匹配应该覆盖<strong>整个</strong>字符串 (<code>s</code>) ，而不是部分字符串。</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li></ul><p><strong>示例 1:</strong></p><p><strong>输入:</strong><br>s = “aa”<br>p = “a”<br><strong>输出:</strong> false<br><strong>解释:</strong> “a” 无法匹配 “aa” 整个字符串。</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong><br>s = “aa”<br>p = “a<em>“<br><strong>输出:</strong> true<br><strong>解释:</strong> ‘</em>‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong><br>s = “ab”<br>p = “.<em>“<br><strong>输出:</strong> true<br><strong>解释:</strong> “.</em>“ 表示可匹配零个或多个(‘*’)任意字符(‘.’)。</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong><br>s = “aab”<br>p = “c<em>a</em>b”<br><strong>输出:</strong> true<br><strong>解释:</strong> ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong><br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br><strong>输出:</strong> false</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：</p><blockquote><p>跟剑指offer的52题一致</p><p>这道题的核心其实在于分析’<em>‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’</em>‘的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。</p><p><strong>情况1：Patttern第二个字符是’*’时</strong>：</p><p>1.第一个字符不匹配（’.’与任意字符视作匹配），那么’*’只能代表匹配0次</p><p>‘ba’与’a*ba’，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式</p><p>2.第一个字符匹配，那么’*’可能代表匹配0次，1次，多次，</p><p>(1)’aaa’与’a*aaa’: 匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；</p><p>(2)’aba’与’a*ba’:匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；</p><p>(3)’aaaba’与’a*ba’:匹配多次时，字符串往后移动一个字符，模式不变；</p><p><strong>情况2：Patttern第二个字符不是’*’时：</strong></p><p>(1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。</p><p>(2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。</p></blockquote><p>方法2：动态规划</p><blockquote><p>定义一个dp[][]数组，其中d[i][j]表示s[0,i]和p[0][j]是否匹配</p><p>dp初始化:dp[0][0] = true，代表str为空串，pattern为空串的情况</p><pre><code>求dp[0][j]即求str为空串，pattern是否匹配当遇到后一个为 * 时，且dp[0][i-1]为true则匹配(匹配前面字符0次)，标记dp[0][i+1] = true</code></pre><p>情况1：当前字母匹配，str和pattern都往后移动一位</p><pre><code>dp[i+1][j+1] = dp[i][j]</code></pre><p>情况2：后一个pattern是   *  ,前一个pattern跟str不匹配,str不变，pattern后移动两位</p><pre><code>dp[i+1][j+1] = dp[i+1][j-1]</code></pre><p>情况3：后一个pattern是 * ,前一个pattern跟str匹配</p><pre><code>(1)匹配0次，str不动，pattern后移2位        dp[i+1][j+1] = dp[i+1][j-1](2)匹配一次，str移动1位，pattern移动2位        dp[i+1][j+1] =dp[i][j-1](3)匹配多次，str移动1次，pattern不动        dp[i+1][j+1] = dp[i][j+1]</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> matchCore(str.toCharArray(), <span class="number">0</span>, pattern.toCharArray(), <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">       <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//pattern先到尾，匹配失败</span></span><br><span class="line">       <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;</span><br><span class="line">       <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位</span></span><br><span class="line">       <span class="comment">//   //如果当前pattern的下一个是*并且没有超出pattern的长度时</span></span><br><span class="line">       <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">           <span class="comment">// //如果当前字符str[index]和pattern[index]相等，或者当前pattern为‘.’</span></span><br><span class="line">           <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">               <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//模式后移2，视为x*匹配0个字符(当前pattern[index+1]='*'且str[index]!=pattern[index]）</span></span><br><span class="line">                       || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//视为模式匹配1个字符 (当前pattern[i+1]='*'且str[index]=pattern[index])</span></span><br><span class="line">                       || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配1个，再匹配str中的下一个（当前pattern[index]='.'）</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//当前字符str[index]和pattern[index]不相等&amp;&amp;当前pattern不为‘.’</span></span><br><span class="line">               <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">       <span class="comment">//pattern[index]='.'的情况，strindex和pattern都加1向下匹配</span></span><br><span class="line">       <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">           <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">           <span class="comment">//i= 0，j= 0表示str和pattern为空串，匹配成功标true</span></span><br><span class="line">           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//str为空串，pattern不为空串的情况</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">               <span class="comment">//前一个为true后一个为*，*匹配0个，则标记下一个为true</span></span><br><span class="line">               <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i - <span class="number">1</span>]) &#123;</span><br><span class="line">                   dp[<span class="number">0</span>][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">                   <span class="comment">//当前字母匹配，字符str和pattern都后移动一位</span></span><br><span class="line">                   <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span> || p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                       dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//后一个字符是*</span></span><br><span class="line">                   <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                       <span class="comment">//str与pattern不匹配</span></span><br><span class="line">                       <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j - <span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                           <span class="comment">//str不变，pattern后移动两位</span></span><br><span class="line">                           dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">//匹配0次，str不动，pattern后移2位，匹配一次，str移动一位，pattern移动2位，匹配多次，str移动1次，pattern不动</span></span><br><span class="line">                          dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j-<span class="number">1</span>] || dp[i][j - <span class="number">1</span>] || dp[i][j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/10_1.jpg" alt="单纯的匹配"></p><p><img src="https://github.com/qiulig/IMG/raw/master/10_2.jpg" alt="正则表达式匹配"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 (&lt;code&gt;s&lt;/code&gt;) 和一个字符模式 (&lt;code&gt;p&lt;/code&gt;)。实现支持  &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;*&amp;#39;&lt;/code&gt; 的正则表达式匹配。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【234】回文链表</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-234-回文链表/</id>
    <published>2019-05-29T12:00:10.000Z</published>
    <updated>2019-05-29T12:32:07.324Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请判断一个链表是否为回文链表。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 1-&gt;2<br><strong>输出:</strong> false</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;2-&gt;1<br><strong>输出:</strong> true</p><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：将链表的数值依次入栈，然后弹栈跟listnode从头到尾比较</p><p>方法2：快慢指针弦找到中间点，再反转后面链表，再遍历比较</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            ListNode res = head;</span><br><span class="line">            <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (res!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.pop() == res.val)&#123;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode lat = head.next;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="comment">//快慢指针,pre一次一步，lat一次两步</span></span><br><span class="line">        <span class="keyword">while</span>(lat != <span class="keyword">null</span> &amp;&amp; lat.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            lat = lat.next.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转置后半链表</span></span><br><span class="line">        ListNode cur = pre.next;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode q = cur.next;</span><br><span class="line">            cur.next = p;</span><br><span class="line">            p = cur;</span><br><span class="line">            cur = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历比较</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val != head.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/234-1.jpg" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/234-2.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【9】回文数</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-9-回文数/</id>
    <published>2019-05-29T11:27:03.000Z</published>
    <updated>2019-05-29T11:46:21.854Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 121<br><strong>输出:</strong> true</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> -121<br><strong>输出:</strong> false<br><strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 10<br><strong>输出:</strong> false<br><strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：转换成字符串，将字符串反转进行比较是否相等</p><p>方法2：用一个stack存入数字从低位到高位的数；依次弹出（高位到低位弹出）跟每次数值取余的数进行对比</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        String res = x+<span class="string">""</span>;</span><br><span class="line">        String ans = <span class="keyword">new</span> StringBuilder(x+<span class="string">""</span>).reverse().toString();</span><br><span class="line">        <span class="keyword">if</span>(res.equals(ans))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            stack.push(x%<span class="number">10</span>);</span><br><span class="line">            x = x /<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (res&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.pop()==res%<span class="number">10</span>)&#123;</span><br><span class="line">                res = res/<span class="number">10</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/9-1.png" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/9-2.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【8】字符串转换成整数</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-8-字符串转换成整数/</id>
    <published>2019-05-29T03:30:30.000Z</published>
    <updated>2019-05-29T11:15:39.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。<a id="more"></a></p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “42”<br><strong>输出:</strong> 42</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “   -42”<br><strong>输出:</strong> -42<br><strong>解释:</strong> 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “4193 with words”<br><strong>输出:</strong> 4193<br><strong>解释:</strong> 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> “words and 987”<br><strong>输出:</strong> 0<br><strong>解释:</strong> 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> “-91283472332”<br><strong>输出:</strong> -2147483648<br><strong>解释:</strong> 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1)  用一个标志位flag记录字符串的正负号</p><p>(2)  依次进行叠加，如果遇到溢出，返回它的最大值或者最小值</p><p>最大溢出判断：</p><pre><code>res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//去掉前后空格</span></span><br><span class="line"></span><br><span class="line">        String str = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>||str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断只有符号的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">1</span>&amp;&amp;(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>||str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//为正数，flag设为1，负数设为 -1,并截取后面的字符串进行字符串转换成整数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>&amp;&amp; (str.charAt(<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">1</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">1</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>&amp;&amp;(str.charAt(<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">1</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">1</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((str.charAt(<span class="number">0</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">0</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">0</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字符串转换成整数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> flag,String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> pop = str.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//只需要判断上溢出情况，因为我们将符号单独拎出来了</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag==<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//上溢，输出最大值</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//下溢出，输出最小值</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = res*<span class="number">10</span> +pop;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//不是有效的字符[0-9]，直接退出</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/8.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;请你来实现一个 &lt;code&gt;atoi&lt;/code&gt; 函数，使其能将字符串转换成整数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【7】整数反转</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-7-整数反转/</id>
    <published>2019-05-28T13:08:00.000Z</published>
    <updated>2019-05-28T14:17:23.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 123<br><strong>输出:</strong> 321</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> -123<br><strong>输出:</strong> -321</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 120<br><strong>输出:</strong> 21</p><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>主要是注意溢出问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; （<span class="number">1</span>）当x&gt;<span class="number">0</span>时，溢出考虑上界</span><br><span class="line">&gt;     <span class="number">1</span>)如果 result 的值大于 Integer.MAX_VALUE / <span class="number">10</span> ，那么一定会溢出</span><br><span class="line">&gt;     <span class="number">2</span>)如果 result 的值等于 Integer.MAX_VALUE / <span class="number">10</span>，那么 pop 的值如果大于 Integer.MAX_VALUE % <span class="number">10</span> 也会溢出</span><br><span class="line">&gt; (<span class="number">2</span>) 当x&lt;<span class="number">0</span> 时，溢出考虑下界</span><br><span class="line">&gt;     <span class="number">1</span>)result 的值小于 Integer.MIN_VALUE / <span class="number">10</span> ，那么一定会溢出</span><br><span class="line">&gt;     <span class="number">2</span>)result 的值等于 Integer.MIN_VALUE / <span class="number">10</span>，那么 pop 的值如果小于于 Integer.MIN_VALUE % <span class="number">10</span> 也会溢出</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x%<span class="number">10</span>;</span><br><span class="line">        x = x/<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//考虑上界溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">//考虑下界溢出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; Integer.MIN_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res*<span class="number">10</span> +pop;<span class="comment">//得到最后一位</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/7.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>得到的最短的回文长度</title>
    <link href="http://blogs.qiulig.website/2019/05/%E5%9B%9E%E6%96%87/"/>
    <id>http://blogs.qiulig.website/2019/05/回文/</id>
    <published>2019-05-28T11:41:20.000Z</published>
    <updated>2019-05-28T12:34:58.008Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>京京和东东是好朋友。东东很喜欢回文。回文是指从前往后读和从后往前读是一样的词语。京京准备给东东一个惊喜，先取定一个字符串s，然后在后面附上0个或者更多个字母形成回文，京京希望这个回文越短越好。请帮助京京计算他能够得到的最短的回文长度。</p><a id="more"></a><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>输入包括一个字符串s，字符串s长度length(1 ≤ length ≤ 50)。</p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>输出一个整数，表示京京能够得到的最短的回文长度。</p><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>abab</p><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><p>5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>转化成求字符串中的最长回文子串的大小，结果即不是回文那部分逆序即可。</p><p>从左往右，</p><p>三个概念：回文半径数组pArr[]，回文右边界pr，取得回文右边界的轴中心i</p><p>1）没在回文右边界里边，暴力</p><p>2）i’在回文范围里，回文右边界不扩</p><p>3）i’在回文范围外，回文右边界不扩</p><p>4）i’压线，回文右边界扩</p><p>直到回文右边界第一次到达最后一个字符</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//manacher预处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">char</span>[] manacherString(String str) &#123;</span><br><span class="line"><span class="keyword">char</span>[] charArr = str.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != res.length; i++) &#123;</span><br><span class="line">res[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">'#'</span> : charArr[index++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">shortestEnd</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] charArr = manacherString(str);</span><br><span class="line"><span class="keyword">int</span>[] pArr = <span class="keyword">new</span> <span class="keyword">int</span>[charArr.length];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pR = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxContainsEnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != charArr.length; i++) &#123;</span><br><span class="line">pArr[i] = pR &gt; i ? Math.min(pArr[<span class="number">2</span> * index - i], pR - i) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])</span><br><span class="line">pArr[i]++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + pArr[i] &gt; pR) &#123;</span><br><span class="line">pR = i + pArr[i];</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右边界到达最后一个字符就结束，那个中心就是包含最后一个字符的最长的回文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pR == charArr.length) &#123;</span><br><span class="line">    <span class="comment">//得到那个中心</span></span><br><span class="line"></span><br><span class="line">maxContainsEnd = pArr[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原来的长度 + 扩充的长度（字符最大的半径[str.length+1-回文最大的半径maxContainEnd]）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str.length() + str.length() - maxContainsEnd + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sr.nextLine();</span><br><span class="line">        System.out.println(shortestEnd(s));      </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;京京和东东是好朋友。东东很喜欢回文。回文是指从前往后读和从后往前读是一样的词语。京京准备给东东一个惊喜，先取定一个字符串s，然后在后面附上0个或者更多个字母形成回文，京京希望这个回文越短越好。请帮助京京计算他能够得到的最短的回文长度。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="京东笔试题" scheme="http://blogs.qiulig.website/categories/%E4%BA%AC%E4%B8%9C%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
      <category term="manacher算法" scheme="http://blogs.qiulig.website/tags/manacher%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【5】最长回文子串</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-5-最长回文子串/</id>
    <published>2019-05-28T05:46:56.000Z</published>
    <updated>2019-05-28T12:38:07.493Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串  <code>s</code>，找到  <code>s</code>  中最长的回文子串。你可以假设 <code>s</code>  的最大长度为 1000。<a id="more"></a></p><p><strong>示例 1：</strong></p><p><strong>输入:</strong> “babad”<br><strong>输出:</strong> “bab”<br><strong>注意:</strong> “aba” 也是一个有效答案。</p><p><strong>示例 2：</strong></p><p><strong>输入:</strong> “cbbd”<br><strong>输出:</strong> “bb”</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><h5 id="方法1：暴力破解方法"><a href="#方法1：暴力破解方法" class="headerlink" title="方法1：暴力破解方法"></a>方法1：暴力破解方法</h5><h5 id="方法2：动态规划"><a href="#方法2：动态规划" class="headerlink" title="方法2：动态规划"></a>方法2：动态规划</h5><blockquote><p>新建一个dp[i][j]代表的意思是索引从i到j的子字符串是否是回文，假设s = cbbd,则可以dp对应坐标索引下的子字符串：</p><table><thead><tr><th></th><th>i = 0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>j = 0</td><td>c</td><td>cb</td><td>cbb</td><td>cbbd</td></tr><tr><td>1</td><td></td><td>b</td><td>bb</td><td>bbd</td></tr><tr><td>2</td><td></td><td></td><td>b</td><td>bd</td></tr><tr><td>3</td><td></td><td></td><td></td><td>d</td></tr></tbody></table><p>如果dp[i][j]所代表的字符串为回文，则将dp设为1.由上表可以总结出：</p><p>（1）当i = j 时，dp[j][i]  = 1</p><p>（2）i-j=1时,比如dp[1][2]为bb，表示两个相邻的字符，此时我们只要判断str[1]==str[2]就能得出dp[1][2]的结果</p><p>（3）i-j&gt;1时，我们来看dp[0][2]，首先还是要判断开头和结尾是否相等，也就是判断 str[0]==str[2]，假如此时str[0]=str[2]，我们还要再看剩下的子串是否回文， 我们可以直接从dp[j+1][i-1]来判断剩下的子串，把结果直接拿来用,判断是否是1（1表示回文）</p><p>即有公式</p><pre><code>dp[i][j] = (dp[i+1][j-1] &amp;&amp;s[i]=S[j]​) == true?1:0</code></pre><p>dp数组初始化如下：</p><pre><code>dp[i][i] = 1</code></pre><p>   dp[i][i+1] = ( S[i] == S[i+1] ?1:0;</p></blockquote><h5 id="方法3：中心扩展方法"><a href="#方法3：中心扩展方法" class="headerlink" title="方法3：中心扩展方法"></a>方法3：中心扩展方法</h5><blockquote><p>回文中心的两侧互为镜像。因此，回文可以从他的中心展开，并且只有2n-1个这样的中心(一个元素为中心的情况有n个，两个元素为中心的情况有n-1个)</p></blockquote><h5 id="方法4：manacher算法"><a href="#方法4：manacher算法" class="headerlink" title="方法4：manacher算法"></a>方法4：manacher算法</h5><blockquote><p>（1）预处理：回文的长度可奇可偶，故在每个字符的左右都加上一个特殊字符“#”,得到长度为奇数的字符串</p><p>（2）回文子串的半径：以中间的 ‘1’ 为中心的回文子串 “#2#2#1#2#2#” 的半径是6，而未添加#号的回文子串为 “22122”，长度是5，为半径减1。</p><p>（3）子串的起始位置：（字符串前面在加一个特殊字符”\$”,在字符末尾加另一个特殊字符”.”）中间位置减去半径再除以2。</p><p>（4）子串的终点位置：起点位置+半径-1</p><p>（5）马拉车核心</p><pre><code>p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;</code></pre><p>其中p[i]代表以i为中心的半径，id为能延伸到最右端的位置的那个回文子串的中心点位置，mx是回文串能延伸到的最右端的位置</p><p><img src="https://github.com/qiulig/IMG/raw/master/5_manecher1.png" alt="manecher"></p><p>1)mx - i &gt; p[j]，即以j为半径的回文在以id为半径的回文内(j跟i是对称的),其中 j = 2*id - i，因为 j 到 id 之间到距离等于 id 到 i 之间到距离，为 i - id，所以 j = id - (i - id) = 2*id - i.</p><p><img src="https://github.com/qiulig/IMG/raw/master/5_manecher2.png" alt="manecher"></p><p>2)mx - i &lt; p[j],即以j为中心的回文子串不一定完全包含于以id为中心的回文子串中，基于对称性可知，图中两个绿框所包围的部分是相同的，也就是说以i为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 p[i] = mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了，这就是后面紧跟到while循环的作用。</p><p>3)对于 mx &lt;= i 的情况，无法对 P[i]做更多的假设，只能P[i] = 1，然后再去匹配了。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>思路1：暴力破解方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       String temp = <span class="string">""</span>;</span><br><span class="line">       String res  =<span class="string">""</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;s.length();j++)&#123;</span><br><span class="line">               temp = temp+s.charAt(j);</span><br><span class="line">               <span class="comment">//re用来保存子字符串反转的结果</span></span><br><span class="line"></span><br><span class="line">               String re  = <span class="keyword">new</span> StringBuffer(temp).reverse().toString();</span><br><span class="line">               <span class="comment">//子字符串跟反转的字符串相等则为回文</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(temp.equals(re))&#123;</span><br><span class="line">                   res = res.length()&gt;temp.length()?res:temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = <span class="string">""</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：动态规划思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个行列均为字符串长度的二维数组，创建时默认初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++)&#123;</span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;<span class="comment">//如果是回文字符串</span></span><br><span class="line">              <span class="comment">//新得到的回文比之前的回文字符串要长，更新字符串长度，记录字符串</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; max)&#123;</span><br><span class="line">                        max = j - i + <span class="number">1</span>;</span><br><span class="line">                        res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3：中心扩展方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span>  String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i); <span class="comment">//奇数的回文，中心有一个字母，以该字母往外扩</span></span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);  <span class="comment">//偶数的回文，中心有两个字母，以这两个字母往外扩</span></span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：马拉车算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) </span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"> <span class="comment">//manacher预处理</span></span><br><span class="line">        <span class="comment">//起点加特殊字符$ </span></span><br><span class="line">        String t = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="comment">//每个字符左右都加特殊字符 #</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            t += s.charAt(i);</span><br><span class="line">            t += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点加特殊字符&amp;</span></span><br><span class="line">        t+=<span class="string">"&amp;"</span>;</span><br><span class="line"> <span class="comment">//马拉车算法实现</span></span><br><span class="line">        <span class="comment">//定义半径</span></span><br><span class="line">        <span class="keyword">int</span> []p = <span class="keyword">new</span> <span class="keyword">int</span>[t.length()];</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.length()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//mancher核心算法</span></span><br><span class="line">            p[i] = mx &gt; i ? Math.min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//半径往外扩</span></span><br><span class="line">            <span class="keyword">while</span> (t.charAt(i + p[i]) == t.charAt(i-p[i]))</span><br><span class="line">                ++p[i];</span><br><span class="line">            <span class="comment">//以i为中心的回文子串不一定完全包含于以id为中心的回文子串中</span></span><br><span class="line">            <span class="keyword">if</span> ((mx-i) &lt;  p[i]) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">                resLen = p[i];</span><br><span class="line">                resCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring((resCenter - resLen) / <span class="number">2</span>, (resCenter - resLen) / <span class="number">2</span> + resLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/5_2.png" alt="动态规划"></p><p><img src="https://github.com/qiulig/IMG/raw/master/5_3.png" alt="中心扩展"></p><p><img src="https://github.com/qiulig/IMG/raw/master/5_4.png" alt="马拉车算法"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串  &lt;code&gt;s&lt;/code&gt;，找到  &lt;code&gt;s&lt;/code&gt;  中最长的回文子串。你可以假设 &lt;code&gt;s&lt;/code&gt;  的最大长度为 1000。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="manacher算法" scheme="http://blogs.qiulig.website/tags/manacher%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【4】寻找两个有序数组的中位数</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-4-寻找两个有序数组的中位数/</id>
    <published>2019-05-27T13:14:23.000Z</published>
    <updated>2019-05-27T14:01:46.551Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code>  和 <code>nums2</code>。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。<a id="more"></a></p><p><strong>示例 1:</strong></p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0</p><p><strong>示例 2:</strong></p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>排序输出中间值，但是复杂度不符合题意</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：复杂度不符合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = ArrayUtils.addAll(nums1, nums2);</span><br><span class="line">        Arrays.sort(ints);</span><br><span class="line">        <span class="keyword">if</span>(ints.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (ints[(ints.length+<span class="number">1</span>)/<span class="number">2</span>]+ints[(ints.length+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>d;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> ints[(ints.length-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：复杂度还是不符合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1Length = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2Length = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> totalLength = n1Length + n2Length;</span><br><span class="line">        <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArrayIndex = totalLength / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n1Index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2Index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> last1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (arrayIndex &lt;= maxArrayIndex) &#123;</span><br><span class="line">            last2 = last1;</span><br><span class="line">            <span class="keyword">if</span> (n1Index &gt;= n1Length) &#123;</span><br><span class="line">                last1 = nums2[n2Index++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n2Index &gt;= n2Length) &#123;</span><br><span class="line">                last1 = nums1[n1Index++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[n1Index] &lt;= nums2[n2Index]) &#123;</span><br><span class="line">                    last1 = nums1[n1Index++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    last1 = nums2[n2Index++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arrayIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (last1 + last2) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> last1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/4.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个大小为 m 和 n 的有序数组 &lt;code&gt;nums1&lt;/code&gt;  和 &lt;code&gt;nums2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p&gt;
&lt;p&gt;你可以假设 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; 不会同时为空。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【3】无重复字符的最长子串</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-3-无重复字符的最长子串/</id>
    <published>2019-05-27T12:54:34.000Z</published>
    <updated>2019-05-29T05:56:41.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “abcabcbb”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;abc&quot;，所以其</code>长度为 3。</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “bbbbb”<br><strong>输出:</strong> 1<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;b&quot;</code>，所以其长度为 1。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “pwwkew”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;wke&quot;</code>，所以其长度为 3。<br>     请注意，你的答案必须是 <strong>子串</strong> 的长度，<code>&quot;pwke&quot;</code> 是一个<em>子序列，</em>不是子串。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>滑动窗口思想</p><pre><code>准备一个list用于滑动窗口，</code></pre><p>（1）当list里面没有该字符时，加入该字符，list.size()就是无重复字符发长度。依次跟MaxLength比较取最大</p><p>（2）当list里面存在该值时，移除list里面该字符出现的第一个索引所在位置之前的所有字符[因为要求最长字串，即连续，所以要移除之前全部的字符]</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MaxLength = <span class="number">0</span>;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(s.charAt(i)))&#123;</span><br><span class="line">                list.add(s.charAt(i));</span><br><span class="line">                MaxLength = Math.max(MaxLength,list.size());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(s.charAt(i));</span><br><span class="line">                <span class="keyword">int</span> index = list.indexOf(s.charAt(i)); <span class="comment">//返回指定元素的第一个匹配项的索引在此列表中</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    list.remove(index--); <span class="comment">// 移除该值以及该字符前面所有的字符</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/3.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【2】两数相加</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-2-两数相加/</id>
    <published>2019-05-27T12:33:46.000Z</published>
    <updated>2019-05-27T12:53:03.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给出两个 <strong>非空</strong>  的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<a id="more"></a></p><p><strong>示例：</strong></p><p><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出：</strong>7 -&gt; 0 -&gt; 8<br><strong>原因：</strong>342 + 465 = 807</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>（1）设置一个进位位flag,flag的值为(当前两链表值相加+flag)/10,链表存储的值为(当前两链表值相加+flag)%10，依次遍历直到两个链表都到达尾部</p><p>（2）如果结束了flag不为0，则将flag的值继续添加到结果链表的尾部。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            ListNode ress = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode res = ress;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span> ||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = l1!=<span class="keyword">null</span> ?l1.val:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> y = l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> value = x+y+flag;  </span><br><span class="line"></span><br><span class="line">                flag = value/<span class="number">10</span>;  <span class="comment">//等到进位位</span></span><br><span class="line"></span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(value%<span class="number">10</span>);</span><br><span class="line">                res = res.next;   </span><br><span class="line">                <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag&gt;<span class="number">0</span>)  <span class="comment">//如果到最后一个数相加还有进位位，则链表长度扩展一位</span></span><br><span class="line"></span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">            <span class="keyword">return</span> ress.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/2.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给出两个 &lt;strong&gt;非空&lt;/strong&gt;  的链表用来表示两个非负的整数。其中，它们各自的位数是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且它们的每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【1】两数之和</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-1-两数之和/</id>
    <published>2019-05-27T12:15:26.000Z</published>
    <updated>2019-05-27T12:53:37.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数数组  <code>nums</code> 和一个目标值  <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<a id="more"></a></p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9</p><p>所以返回 [<strong>0, 1</strong>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>依次遍历数组里面的数值</p><p>（1）用一个hashmap存储（target-nums[i],索引位置）</p><p>（2）如果下一次出现nums[i],说明找到了。直接将她的坐标跟之前存储的坐标存到结果。</p><p>如示例：</p><p>   i = 0 时， map存入（7,0）</p><p>   i= 1时，发现map.get(num[i]) = map.get(7)!=null, 存在，即找到了，直接将map.get(7) =0,i = 1,这两个值存到结果res里面返回。 </p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">            <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(nums[i])!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    res= <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(target-nums[i],i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-我的提交记录"><a href="#4-我的提交记录" class="headerlink" title="4.我的提交记录"></a>4.我的提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/1.png" alt="两数之和"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组  &lt;code&gt;nums&lt;/code&gt; 和一个目标值  &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
</feed>
