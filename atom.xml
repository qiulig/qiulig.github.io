<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0972e01a5f38f38e77d0154479c21150</icon>
  <subtitle>菜鸟要更加努力才能追上别人的步伐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blogs.qiulig.website/"/>
  <updated>2019-06-08T16:27:13.463Z</updated>
  <id>http://blogs.qiulig.website/</id>
  
  <author>
    <name>qiulig</name>
    <email>qiuling_long@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode_【96】不同二叉搜索树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-96-%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-96-不同二叉搜索树/</id>
    <published>2019-06-08T15:53:51.000Z</published>
    <updated>2019-06-08T16:27:13.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>      <span class="number">3</span>     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">&gt;  \     /    /     / \     \</span><br><span class="line">&gt;  <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>     <span class="number">1</span>   <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">&gt;  /   /      \               \</span><br><span class="line">&gt;  <span class="number">2</span>  <span class="number">1</span>        <span class="number">2</span>               <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划：</p><p>(1)初始化</p><pre><code>n  = 1时，只含有1，1作为根节点，此时二叉搜索数个数为1；</code></pre><p>(2) 算法</p><pre><code>    （1）假设n个节点存在二叉排序树的个数是dp[i]，令f[i]为以i为根的二叉搜索树的个数，则                dp[n] = f[1] + f[2] + f[3] + f[4] + ... + f[n]     （2）当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则                f [i]  = dp[i-1] * dp[n-i]综合两个公式可以得到卡特兰数公式</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  dp[n] = dp[<span class="number">0</span>] * dp[n-<span class="number">1</span>] + dp[<span class="number">1</span>] * dp[n-<span class="number">2</span>]+...+dp[n-<span class="number">1</span>] * dp[<span class="number">0</span>]</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * C(<span class="number">2</span>n,n)</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * (<span class="number">4</span>*n-<span class="number">2</span>)/(n-<span class="number">1</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n个节点存在二叉树的个数</span></span><br><span class="line">        <span class="keyword">long</span> []dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//以i为根节点的二叉树个数</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]*(<span class="number">4</span>*i-<span class="number">2</span>)/(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/96.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【70】爬楼梯</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-70-爬楼梯/</id>
    <published>2019-06-08T14:47:57.000Z</published>
    <updated>2019-06-08T15:31:47.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><a id="more"></a><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li><p>2 阶</p><p>示例 2：</p></li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><p>初始化：</p><pre><code>可知dp[0]  = 0;dp[1] = 1;dp[2] = 2;即跳0级有一种方法，一级有1种方法，2级有2种方法</code></pre><p>算法核心：</p><pre><code>dp[i] = dp[i-1] +dp[i-2] ,即爬i阶台阶的方法等于爬i-2阶台阶的方法加上爬i-1阶台阶的方法</code></pre><p>方法2：</p><pre><code>剑指offer第8题</code></pre><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n ;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;=n ;i++)&#123;</span><br><span class="line">            res = one + two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/70.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【64】最小路径和</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-64-最小路径和/</id>
    <published>2019-06-08T14:06:23.000Z</published>
    <updated>2019-06-08T14:17:10.474Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><a id="more"></a><p>示例:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果数组只有一个数，则路径最小即为该值，dp[0][0] = 0;</p><p> (1)动态规划初始化</p><pre><code>1)只有一行，则路径总和最小为 dp[0][i] = dp[0][i-1] + grid[0][i];2)只有一列，则路径总和最小为 dp[i][0] = dp[i-1][0]+grid[i][0];</code></pre><p>(2) 动态规划核心算法</p><p>  每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：</p><pre><code>dp[i][j] = grid[i][j] + min( dp[i-1][j] , dp[i][j-1]);</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划核心</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                dp[i][j] = grid[i][j]+(dp[i-<span class="number">1</span>][j]&lt;dp[i][j-<span class="number">1</span>]?dp[i-<span class="number">1</span>][j]:dp[i][j-<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/64.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;说明：每次只能向下或者向右移动一步。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【63】不同路径2</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-63-不同路径2/</id>
    <published>2019-06-08T13:38:57.000Z</published>
    <updated>2019-06-08T13:58:25.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><a id="more"></a><p>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果第一个格点 obstacleGrid[0][0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。</p><p>如果 obstacleGrid[0][0] 是 0，我们初始化这个值为 1 然后继续算法。<br>(1)动态规划初始化</p><pre><code>1)obstacleGrid[0][0] == 0,表示没障碍，路径只有一条；dp[0][0] = 1;2)遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[0][j] = dp[0][j-1]。             3)遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[i][0] = obstacleGrid[i-1][0]。</code></pre><p>(2) 动态规划核心算法</p><pre><code>从 obstacleGrid[1][1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 dp[i][j] = dp[i-1][j] + dp[i][j-1]。如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> col = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span> ? <span class="number">0</span> : dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>? <span class="number">0</span>:dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                    dp[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/63.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。&lt;/p&gt;
&lt;p&gt;说明：m 和 n 的值均不超过 100。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="-数组类型题 - 动态规划" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【62】不同的路径</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-62-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-62-不同的路径/</id>
    <published>2019-06-08T03:35:18.000Z</published>
    <updated>2019-06-08T03:42:05.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j]+arr[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/62.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【53】最大子序和</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-53-最大子序和/</id>
    <published>2019-06-08T02:52:18.000Z</published>
    <updated>2019-06-08T03:35:49.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><blockquote><ol><li>定义一个函数f(n)，以第n个数为结束点的子数列的最大和，存在一个递推关系f(n) = max(f(n-1) + A[n], A[n]);</li><li>将这些最大和保存下来后，取最大的那个就是，最大子数组和。因为最大连续子数组 等价于 最大的以n个数为结束点的子数列</li></ol></blockquote><p>方法2：</p><blockquote><p>用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。</p><pre><code>(1)当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令    cur = 0.表示从下一个数开始累加。(2)当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最    大值即可。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        ans[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = ans[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//依次求出以第n个数为结束点的子序列最大和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            ans[i] = Math.max(ans[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="comment">//求出最大和</span></span><br><span class="line">            res = Math.max(res,ans[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            cur = cur + nums[i];</span><br><span class="line">            ans = Math.max(cur,ans);</span><br><span class="line">            cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/53_1.jpg" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/53_2.jpg" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【264】丑数2</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-264-%E4%B8%91%E6%95%B02/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-264-丑数2/</id>
    <published>2019-06-06T12:36:33.000Z</published>
    <updated>2019-06-06T12:44:44.497Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>编写一个程序，找出第  <code>n</code>  个丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code>  的<strong>正整数</strong>。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> n = 10<br><strong>输出:</strong> 12</p><a id="more"></a><p><strong>解释:</strong> <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> 是前 10 个丑数。</p><p><strong>说明:</strong></p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>剑指offer-【33】</p><p>丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an</p><p>所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2<em>a1, 2</em>a2, 2*a3 …..</p><p>包含3的有序丑数序列:3<em>a1, 3</em>a2, 3<em>a3 ….. 包含5的有序丑数序列:5</em>a1, 5<em>a2, 5</em>a3 …..</p><p>以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i] =Math.min(Math.min(arr[t2]*<span class="number">2</span>,arr[t3]*<span class="number">3</span>),arr[t5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr[t2]*<span class="number">2</span> == arr[i])&#123;</span><br><span class="line">                t2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[t3]*<span class="number">3</span> == arr[i])&#123;</span><br><span class="line">                t3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[t5]*<span class="number">5</span> == arr[i])&#123;</span><br><span class="line">                t5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/264.png" alt="丑数2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个程序，找出第  &lt;code&gt;n&lt;/code&gt;  个丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 &lt;code&gt;2, 3, 5&lt;/code&gt;  的&lt;strong&gt;正整数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; n = 10&lt;br&gt;&lt;strong&gt;输出:&lt;/strong&gt; 12&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【263】丑数</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-263-%E4%B8%91%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-263-丑数/</id>
    <published>2019-06-06T12:23:27.000Z</published>
    <updated>2019-06-06T12:48:44.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 6<br><strong>输出:</strong> true<br><strong>解释:</strong> 6 = 2 × 3</p><a id="more"></a><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 8<br><strong>输出:</strong> true<br><strong>解释:</strong> 8 = 2 × 2 × 2</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 14<br><strong>输出:</strong> false<br><strong>解释:</strong> <code>14</code> 不是丑数，因为它包含了另外一个质因数 <code>7</code>。</p><p><strong>说明：</strong></p><ol><li><code>1</code> 是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>丑数只能被2，3，5整除，所以丑数为2*i+3*j+5*k = num[i,j,k为任意整数]</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">3</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">5</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> num==<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/263.png" alt="丑数"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个程序判断给定的数是否为丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 &lt;code&gt;2, 3, 5&lt;/code&gt; 的&lt;strong&gt;正整数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 6&lt;br&gt;&lt;strong&gt;输出:&lt;/strong&gt; true&lt;br&gt;&lt;strong&gt;解释:&lt;/strong&gt; 6 = 2 × 3&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_23合并K个排序链表</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-23%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-23合并K个排序链表/</id>
    <published>2019-06-06T11:21:49.000Z</published>
    <updated>2019-06-06T12:45:41.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><p><strong>输入:</strong><br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br><strong>输出:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：</p><pre><code>(1)利用priorityQueue的性质，每放一个数字进去就给你从小到大排好序了(2)队列的性质是先进先出，故依次poll出来就是从小到大的顺序，将该数值放到listNode里面即可。</code></pre><p>方法2：</p><pre><code>借用合并两个链表的代码，依次将list[]分成两部分，在分别合并，执行用时为6ms</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode ans = res;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; lists.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lists[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(lists[i].val);</span><br><span class="line">                lists[i] = lists[i].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode(queue.poll());</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = lists.length/<span class="number">2</span>;</span><br><span class="line">        ListNode[] l1 = <span class="keyword">new</span> ListNode[mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++)&#123;</span><br><span class="line">            l1[i] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode[] l2 = <span class="keyword">new</span> ListNode[lists.length-mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid,j=<span class="number">0</span>; i &lt; lists.length; i++,j++)&#123;</span><br><span class="line">            l2[j] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(mergeKLists(l1),mergeKLists(l2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            head.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            head.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/23.jpg" alt="合并K个排序的链表"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;合并 &lt;em&gt;k&lt;/em&gt; 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt;&lt;br&gt;[&lt;br&gt;  1-&amp;gt;4-&amp;gt;5,&lt;br&gt;  1-&amp;gt;3-&amp;gt;4,&lt;br&gt;  2-&amp;gt;6&lt;br&gt;]&lt;br&gt;&lt;strong&gt;输出:&lt;/strong&gt; 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【21】合并两个有序链表</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-21合并两个有序链表/</id>
    <published>2019-06-06T09:31:36.000Z</published>
    <updated>2019-06-06T10:58:52.644Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例：</strong></p><p><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1) 判断是否有空链表，如果有则直接返回另一个不为空有序链表</p><p>(2) 依次判断是否有对应链表大小，小的加入res链表，并移动</p><p>注：该题与剑指offer-[16]题一致，还可以用递归。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span> &amp;&amp;l2!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span> &amp;&amp; l1!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            ListNode ans = res;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l1.val&gt;l2.val)&#123;</span><br><span class="line">                    res.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/21.png" alt="合并有序链表"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【19】删除链表的倒数第N个节点</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-19-删除链表的倒数第N个节点/</id>
    <published>2019-06-06T08:00:45.000Z</published>
    <updated>2019-06-06T08:37:44.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong><em>n</em> = 2</strong>.</p><p>当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p><p><strong>说明：</strong></p><p>给定的  <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>双指针</p><p>(1)第一个指针curNode先走n步</p><p>(2)然后第二个指针preNode再重头跟刚刚第一个指针curNode走,直到走到尾部【preNode走了(len-N)步,即下一个节点就是要删除的节点】</p><p>(3)此时的preNode的下一个即为倒数第N个节点，将其删除即可</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode preNode = head;</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> preNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preNode = preNode.next;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/19.jpg" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个链表，删除链表的倒数第 &lt;em&gt;n&lt;/em&gt; 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个链表: &lt;strong&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/strong&gt;, 和 &lt;strong&gt;&lt;em&gt;n&lt;/em&gt; = 2&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;当删除了倒数第二个节点后，链表变为 &lt;strong&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;5&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定的  &lt;em&gt;n&lt;/em&gt; 保证是有效的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你能尝试使用一趟扫描实现吗？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【434】字符串中的单词数</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-434-字符串中的单词数/</id>
    <published>2019-06-06T06:25:04.000Z</published>
    <updated>2019-06-06T12:46:22.435Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> “Hello, my name is John”<br><strong>输出:</strong> 5</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>每次出现非空字符，看看上一个是不是空格，如果是，发现一个新单词</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> lastIsBlank = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                lastIsBlank = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastIsBlank) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIsBlank = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/434.png" alt="字符串中的单词数"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。&lt;/p&gt;
&lt;p&gt;请注意，你可以假定字符串里不包括任何不可打印的字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; “Hello, my name is John”&lt;br&gt;&lt;strong&gt;输出:&lt;/strong&gt; 5&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【13】罗马数字转整数</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-13-罗马数字转整数/</id>
    <published>2019-06-05T13:32:34.000Z</published>
    <updated>2019-06-05T13:56:34.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th><strong>字符</strong></th><th><strong>数值</strong></th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。<a id="more"></a></p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “III”<br><strong>输出:</strong> 3</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “IV”<br><strong>输出:</strong> 4</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “IX”<br><strong>输出:</strong> 9</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>通常情况下，<strong>罗马数字中小的数字在大的数字的右边</strong>。这句话很关键，意思是要变成罗马数字，必须先排列大的数</p><p>（1）res初始化为字符串的最后一个字符所代表的数字</p><p>（2）从字符串数组尾部开始遍历，</p><pre><code>1)如果下一个字符所代表的数字小于当前字符所代表的数字，则res减去下一个字符所代表的数字：如IV,下一个字符I所代表数字1&lt;当前字符所代表数字5，res = res-12)如果下一个字符所代表的数字大于当前字符所代表的数字，则res加上下一个字符所代表的数字如VI,下一个字符V 所代表数字5&gt;当前字符I所代表数字1,res = res+5</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'I'</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">int</span> res = map.get(s.charAt(s.length()-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//罗马数字中大的数字在小的数字的右边，用减法</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(s.charAt(i))&gt;map.get(s.charAt(i-<span class="number">1</span>)))&#123;</span><br><span class="line">                res -=map.get(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//罗马数字中小的数字在大的数字的右边，用加法</span></span><br><span class="line">                res +=map.get(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/13.png" alt="罗马数字转整数"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;罗马数字包含以下七种字符: &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;字符&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;数值&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例如， 罗马数字 2 写做 &lt;code&gt;II&lt;/code&gt; ，即为两个并列的 1。12 写做 &lt;code&gt;XII&lt;/code&gt; ，即为 &lt;code&gt;X&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。 27 写做 &lt;code&gt;XXVII&lt;/code&gt;, 即为 &lt;code&gt;XX&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【12】整数转罗马数字</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-12-整数转罗马数字/</id>
    <published>2019-06-05T12:56:48.000Z</published>
    <updated>2019-06-05T14:00:11.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th style="text-align:center"><strong>字符</strong></th><th style="text-align:center"><strong>数值</strong></th></tr></thead><tbody><tr><td style="text-align:center">I</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">500</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><a id="more"></a><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 3<br><strong>输出:</strong> “III”</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 4<br><strong>输出:</strong> “IV”</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 9<br><strong>输出:</strong> “IX”</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> 58<br><strong>输出:</strong> “LVIII”<br><strong>解释:</strong> L = 50, V = 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> 1994<br><strong>输出:</strong> “MCMXCIV”<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>通常情况下，<strong>罗马数字中小的数字在大的数字的右边</strong>。这句话很关键，意思是要变成罗马数字，必须先排列大的数</p><p>（1）定义一个arr[],代表能用罗马数字代表的数</p><p>（2）定义一个str[],里面的字符串分别与数字arr[]里面的数字相对应，两个的联系即arr[i]  —–&gt;str[i]</p><p>（3）定义一个i,i从0开始，找到数组中第一个小于等于num的值，第一个罗马数字就是str[i],再依次循环知道num==0</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>   arr [] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>,<span class="number">100</span>,  <span class="number">90</span>, <span class="number">50</span>,  <span class="number">40</span>, <span class="number">10</span>,   <span class="number">9</span>,  <span class="number">5</span>,   <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        String str[] = &#123; <span class="string">"M"</span>,<span class="string">"CM"</span>, <span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//一般情况下罗马数字小的在大的右边</span></span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>&amp;&amp; i&lt;arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= arr[i])&#123;</span><br><span class="line">                num  = num-arr[i];</span><br><span class="line">                res.append(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/12.jpg" alt="整数转罗马数字"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;罗马数字包含以下七种字符： &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;字符&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;数值&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;I&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;V&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;X&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;C&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;D&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;500&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;M&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例如， 罗马数字 2 写做 &lt;code&gt;II&lt;/code&gt; ，即为两个并列的 1。12 写做 &lt;code&gt;XII&lt;/code&gt; ，即为 &lt;code&gt;X&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。 27 写做 &lt;code&gt;XXVII&lt;/code&gt;, 即为 &lt;code&gt;XX&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://blogs.qiulig.website/2019/06/%E6%AD%BB%E9%94%81/"/>
    <id>http://blogs.qiulig.website/2019/06/死锁/</id>
    <published>2019-06-03T02:25:30.000Z</published>
    <updated>2019-06-03T03:14:02.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><pre><code>两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</code></pre><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>） <span class="string">'互斥条件'</span>： 一个资源每次只能被一个进程使用。</span><br><span class="line">（<span class="number">2</span>） <span class="string">'请求与保持条件'</span>： 一个进程因请求资源而阻塞时， 对已获得的资源保持不放。</span><br><span class="line">（<span class="number">3</span>） <span class="string">'不可剥夺条件'</span>:进程已获得的资源， 在末使用完之前， 不能强行剥夺。</span><br><span class="line">（<span class="number">4</span>） <span class="string">'环路等待条件'</span>:若干进程之间形成一种头尾相接的循环等待资源关系。</span><br><span class="line">    只要系统发生了死锁， 这些条件必然成立， 而只要上述条件之一不满足， 就不会发生死锁。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">'破坏互斥条件'</span></span><br><span class="line">     如果<span class="string">'允许系统资源都能共享使用'</span>， 则系统不会进入死锁状态。 但有些资源根本不能同时访问， 如打印机等临界资源只能互斥使用。 所以， </span><br><span class="line">    破坏互斥条件而预防死锁的方法不太可行， 而且在有的场合应该保护这种互斥性。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) <span class="string">'破坏不剥夺条件'</span></span><br><span class="line"></span><br><span class="line">    当一个已保持了某些不可剥夺资源的进程， <span class="string">'请求新的资源而得不到满足时，它必须释放已经保持的所有资源， 待以后需要时再重新申请。'</span> 这</span><br><span class="line">    意味着， 一个进程已占有的资源会被暂时释放， 或者说是被剥夺了，或从而破坏了不可剥夺条件。该策略实现起来比较复杂， 释放已获得</span><br><span class="line">    的资源可能造成前一阶段工作的失效， <span class="string">'反复地申请和释放资源会增加系统开销， 降低系统吞吐量'</span>。 这种方法常用于状态易于保存和恢复的资</span><br><span class="line">    源，如 CPU 的寄存器及内存资源， 一般不能用于打印机之类的资源。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) <span class="string">'破坏请求和保持条件'</span></span><br><span class="line"></span><br><span class="line">    釆用<span class="string">'预先静态分配方法'</span>， 即<span class="string">'进程在运行前一次申请完它所需要的全部资源'</span>， 在它的资源未满足前，不把它投入运行。 一旦投入运行后， 这</span><br><span class="line">    些资源就一直归它所有， 也不再提出其他资源请求， 这样就可以保证系统不会发生死锁。</span><br><span class="line">    这种方式实现简单， 但缺点也显而易见， 系统资源被严重浪费， 其中有些资源可能仅在运行初期或运行快结束时才使用， 甚至根本不使用。 </span><br><span class="line">    而且还会导致“饥饿” 现象， 当由于个别资源长期被其他进程占用时， 将致使等待该资源的进程迟迟不能开始运行。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) <span class="string">'破坏环路等待条件'</span></span><br><span class="line"></span><br><span class="line">    为了破坏循环等待条件， 可釆用<span class="string">'顺序资源分配法'</span>。 首先给系统中的资源编号，规定每个进程， 必须按编号递增的顺序请求资源， 同类资源</span><br><span class="line">    一次申请完。 也就是说， 只要进程提出申请分配资源 Ri， 则该进程在以后的资源申请中， 只能申请编号大于 Ri 的资源。</span><br><span class="line"></span><br><span class="line">    这种方法存在的问题是， 编号必须相对稳定， 这就<span class="string">'限制了新类型设备的增加'</span>；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的</span><br><span class="line">    顺序， 但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费； 此外， 这种按规定次序申请资源的方法， 也必</span><br><span class="line">    然会给用户的编程带来麻烦。</span><br></pre></td></tr></table></figure><h3 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h3><blockquote><p>我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。</p><p>为保证资金的安全，银行家规定：</p><pre><code>(1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客；(2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量；(3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款；(4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，</span><br><span class="line">&gt; (<span class="number">1</span>)如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。</span><br><span class="line">&gt; (<span class="number">2</span>)当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。</span><br><span class="line">&gt; (<span class="number">3</span>)若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="检测死锁-死锁定理"><a href="#检测死锁-死锁定理" class="headerlink" title="检测死锁(死锁定理)"></a>检测死锁(死锁定理)</h3><p>通常分析描述死锁，可以用资源分配图。关于资源分配图，要仅仅抓住两点：</p><ul><li>请求边</li><li>分配边</li></ul><p>关键在找：空闲资源。如果空闲资源可以满足某个进程，这个进程就可以解脱了，把它摘除资源分配图，再看剩下的资源分配图，策略相同。</p><p><strong>在资源分配图中，把分配的资源与进程连好，再看进程请求边。按照分配边分配好以后，剩余的资源就是空闲资源。此时再来分析进程Pi的请求边，如果空闲资源都能满足Pi的请求，也就意味着Pi可以从这个纠缠的图中得到解脱。删除Pi的所有相关的资源：已分配的+请求的。再递归处理剩下的资源分配图</strong>。</p><p>参看：<a href="https://blog.csdn.net/jgm20475/article/details/81297819" target="_blank" rel="noopener">https://blog.csdn.net/jgm20475/article/details/81297819</a></p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>1、资源剥夺法</p><pre><code>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</code></pre><p>2、撤销进程法</p><pre><code>强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</code></pre><p>3、进程回退法</p><pre><code>让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;死锁的概念&quot;&gt;&lt;a href=&quot;#死锁的概念&quot; class=&quot;headerlink&quot; title=&quot;死锁的概念&quot;&gt;&lt;/a&gt;死锁的概念&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;产生死锁的原因&quot;&gt;&lt;a href=&quot;#产生死锁的原因&quot; class=&quot;headerlink&quot; title=&quot;产生死锁的原因&quot;&gt;&lt;/a&gt;产生死锁的原因&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;） &lt;span class=&quot;string&quot;&gt;&#39;互斥条件&#39;&lt;/span&gt;： 一个资源每次只能被一个进程使用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;） &lt;span class=&quot;string&quot;&gt;&#39;请求与保持条件&#39;&lt;/span&gt;： 一个进程因请求资源而阻塞时， 对已获得的资源保持不放。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;） &lt;span class=&quot;string&quot;&gt;&#39;不可剥夺条件&#39;&lt;/span&gt;:进程已获得的资源， 在末使用完之前， 不能强行剥夺。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;） &lt;span class=&quot;string&quot;&gt;&#39;环路等待条件&#39;&lt;/span&gt;:若干进程之间形成一种头尾相接的循环等待资源关系。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    只要系统发生了死锁， 这些条件必然成立， 而只要上述条件之一不满足， 就不会发生死锁。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blogs.qiulig.website/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MYSQL" scheme="http://blogs.qiulig.website/tags/MYSQL/"/>
    
      <category term="多线程" scheme="http://blogs.qiulig.website/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁" scheme="http://blogs.qiulig.website/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>SQL-优化查询</title>
    <link href="http://blogs.qiulig.website/2019/06/SQL-%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/"/>
    <id>http://blogs.qiulig.website/2019/06/SQL-优化查询/</id>
    <published>2019-06-01T08:15:26.000Z</published>
    <updated>2019-06-01T08:49:41.872Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化查询的方法"><a href="#优化查询的方法" class="headerlink" title="优化查询的方法"></a>优化查询的方法</h1><h2 id="1-使用索引"><a href="#1-使用索引" class="headerlink" title="1.使用索引"></a>1.使用索引</h2><pre><code>尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。</code></pre><h2 id="2-优化SQL语句"><a href="#2-优化SQL语句" class="headerlink" title="2.优化SQL语句"></a>2.优化SQL语句</h2><h3 id="2-1-explain查看SQL语句执行效果"><a href="#2-1-explain查看SQL语句执行效果" class="headerlink" title="2.1 explain查看SQL语句执行效果"></a>2.1 explain查看SQL语句执行效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句，</span><br><span class="line"> 把关键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-任何地方都不要使用-select-from-t-，-用具体的字段列表代替“-”-，-不要返回用不到的任何字段。"><a href="#2-2-任何地方都不要使用-select-from-t-，-用具体的字段列表代替“-”-，-不要返回用不到的任何字段。" class="headerlink" title="2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*” ， 不要返回用不到的任何字段。"></a>2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*” ， 不要返回用不到的任何字段。</h3><h3 id="2-3-不在索引列做运算或者使用函数。"><a href="#2-3-不在索引列做运算或者使用函数。" class="headerlink" title="2.3 不在索引列做运算或者使用函数。"></a>2.3 不在索引列做运算或者使用函数。</h3><h3 id="2-4-查询尽可能使用-limit-减少返回的行数，-减少数据传输时间和带宽浪费。"><a href="#2-4-查询尽可能使用-limit-减少返回的行数，-减少数据传输时间和带宽浪费。" class="headerlink" title="2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。"></a>2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。</h3><h2 id="3-优化数据库对象"><a href="#3-优化数据库对象" class="headerlink" title="3.优化数据库对象"></a>3.优化数据库对象</h2><h3 id="3-1-优化表的数据类型"><a href="#3-1-优化表的数据类型" class="headerlink" title="3.1 优化表的数据类型"></a>3.1 优化表的数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="function">procedure <span class="title">analyse</span><span class="params">()</span>函数对表进行分析， 该函数可以对表中列的数据类型提出优化建议。 能小就用小。 </span></span><br><span class="line"><span class="function">表数据类型第一个原则是： 使用能正确的表示和存储数据的最短类型。 这样可以减少对磁盘空间、 内存、 cpu 缓存的使用。</span></span><br><span class="line"><span class="function">使用方法： 'select * from 表名 procedure <span class="title">analyse</span><span class="params">()</span></span>;<span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="3-2-对表进行拆分"><a href="#3-2-对表进行拆分" class="headerlink" title="3.2 对表进行拆分"></a>3.2 对表进行拆分</h3><pre><code>通过拆分表可以提高表的访问效率。  </code></pre><p><strong>1.垂直拆分</strong><br><code>把主键和一些列放在一个表中， 然后把主键和另外的列放在另一个表中。 如果一个表中某些列常用， 而另外一些不常用， 则可以采用垂直拆分。</code><br><strong>2.水平拆分</strong><br>        <code>根据一列或者多列数据的值把数据行放到二个独立的表中。</code></p><h3 id="3-3-使用中间表来提高查询速度"><a href="#3-3-使用中间表来提高查询速度" class="headerlink" title="3.3 使用中间表来提高查询速度"></a>3.3 使用中间表来提高查询速度</h3><pre><code>创建中间表， 表结构和源表结构完全相同， 转移要统计的数据到中间表， 然后在中间表上进行统计， 得出想要的结果。</code></pre><h2 id="4-硬件优化"><a href="#4-硬件优化" class="headerlink" title="4.硬件优化"></a>4.硬件优化</h2><h3 id="4-1-CPU-的优化"><a href="#4-1-CPU-的优化" class="headerlink" title="4.1 CPU 的优化"></a>4.1 CPU 的优化</h3><pre><code>选择多核和主频高的 CPU。  </code></pre><h3 id="4-2-内存的优化"><a href="#4-2-内存的优化" class="headerlink" title="4.2 内存的优化"></a>4.2 内存的优化</h3><pre><code>使用更大的内存。 将尽量多的内存分配给 MYSQL 做缓存。  </code></pre><h3 id="4-3-磁盘-I-O-的优化"><a href="#4-3-磁盘-I-O-的优化" class="headerlink" title="4.3 磁盘 I/O 的优化"></a>4.3 磁盘 I/O 的优化</h3><h4 id="4-3-1-使用磁盘阵列"><a href="#4-3-1-使用磁盘阵列" class="headerlink" title="4.3.1 使用磁盘阵列"></a>4.3.1 使用磁盘阵列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)RAID <span class="number">0</span> 没有数据冗余， 没有数据校验的磁盘陈列。 实现 RAID <span class="number">0</span>至少需要两块以上的硬盘， 它将两块以上的硬盘合并成一块， 数据连续地</span><br><span class="line">分割在每块盘上。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)RAID1 是将一个两块硬盘所构成 RAID 磁盘阵列， 其容量仅等于一块硬盘的容量， 因为另一块只是当作数据“镜像”。 </span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)RAID-<span class="number">0</span>+<span class="number">1</span> 磁盘阵列。 RAID <span class="number">0</span>+<span class="number">1</span>是 RAID <span class="number">0</span> 和 RAID <span class="number">1</span> 的组合形式。 它在提供与 RAID <span class="number">1</span> 一样的数据安全保障的同时,也提供了与 RAID <span class="number">0</span> </span><br><span class="line">近似的存储性能。</span><br></pre></td></tr></table></figure><h4 id="4-3-2-调整磁盘调度算法"><a href="#4-3-2-调整磁盘调度算法" class="headerlink" title="4.3.2 调整磁盘调度算法"></a>4.3.2 调整磁盘调度算法</h4><pre><code>选择合适的磁盘调度算法， 可以减少磁盘的寻道时间。</code></pre><h3 id="5-MYSQL自身的优化"><a href="#5-MYSQL自身的优化" class="headerlink" title="5.MYSQL自身的优化"></a>5.MYSQL自身的优化</h3><pre><code>对 MySQL 自身的优化主要是对其配置文件 my.cnf 中的各项参数进行优化调整。 如指定 MySQL 查询缓冲区的大小， 指定 MySQL 允许的最大连接进程数等。</code></pre><h2 id="6-应用优化"><a href="#6-应用优化" class="headerlink" title="6.应用优化"></a>6.应用优化</h2><h3 id="6-1-使用数据库连接池"><a href="#6-1-使用数据库连接池" class="headerlink" title="6.1 使用数据库连接池"></a>6.1 使用数据库连接池</h3><h3 id="6-2-使用查询缓存"><a href="#6-2-使用查询缓存" class="headerlink" title="6.2 使用查询缓存"></a>6.2 使用查询缓存</h3><pre><code>它的作用是存储 select 查询的文本及其相应结果。 如果随后收到一个相同的查询， 服务器会从查询缓存中直接得到查询结果。 查询缓存适用的对象是更新不频繁的表， 当表中数据更改后， 查询缓存中的相关条目就会被清空</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>(1) 选取最适合的字段</strong>：在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。还可以将字段设置为NOT NULL,在查询时就不用比较null值了</p><p><strong>(2) 使用连接（JOIN）来替代子查询</strong></p><p><strong>(3) 使用联合（UNION)来代替手动创建的临时表</strong>：它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。</p><p><strong>(4) 使用事务</strong>：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><p><strong>(5) 锁定表</strong>：事务会将数据库锁定，因此其他用户请求只能暂时等待直到事务结束，会造成响应延迟。我们可以通过锁定表的方法来获得更好的性能</p><p><strong>(6) 使用外键</strong>。锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p><p><strong>(7) 使用索引</strong>。索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><p><strong>(8) 优化的查询语句</strong>。</p><p><strong>(9) 分库分表</strong>：可以按照业务分库，分流数据库并发压力，使数据库表更加有条理性</p><p><strong>(10) 数据库引擎</strong>：一种是innodb、一种是myisam</p><p>myisam快，是因为他的数据存储结构、索引存储结构和innodb不一样的，mysiam的索引结构是在内存中存的。 当然，myisam也有弱点，那就是他是表级锁，而innodb是行级锁，所以，mysiam适用于一次插入，多次查询的表，或者是读写分离中的读库中的表，而对于修改插入删除操作比较频繁的表，就很不合适了</p><p><strong>(11) 读写分离</strong>：数据库并发大的情况下，最好的做法就是进行横向扩展，增加机器，以提升抗并发能力，而且还兼有数据备份功能</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;优化查询的方法&quot;&gt;&lt;a href=&quot;#优化查询的方法&quot; class=&quot;headerlink&quot; title=&quot;优化查询的方法&quot;&gt;&lt;/a&gt;优化查询的方法&lt;/h1&gt;&lt;h2 id=&quot;1-使用索引&quot;&gt;&lt;a href=&quot;#1-使用索引&quot; class=&quot;headerlink&quot; title=&quot;1.使用索引&quot;&gt;&lt;/a&gt;1.使用索引&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-优化SQL语句&quot;&gt;&lt;a href=&quot;#2-优化SQL语句&quot; class=&quot;headerlink&quot; title=&quot;2.优化SQL语句&quot;&gt;&lt;/a&gt;2.优化SQL语句&lt;/h2&gt;&lt;h3 id=&quot;2-1-explain查看SQL语句执行效果&quot;&gt;&lt;a href=&quot;#2-1-explain查看SQL语句执行效果&quot; class=&quot;headerlink&quot; title=&quot;2.1 explain查看SQL语句执行效果&quot;&gt;&lt;/a&gt;2.1 explain查看SQL语句执行效果&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 把关键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blogs.qiulig.website/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MYSQL" scheme="http://blogs.qiulig.website/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>设计模式—-6大原则</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94-6%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式—-6大原则/</id>
    <published>2019-06-01T06:32:35.000Z</published>
    <updated>2019-06-01T07:40:59.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>六原则一法则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s( Single-Resposibility Principle ): 单一职责原则。</span><br><span class="line">o( Open-Closed principle ): 开放封闭原则。</span><br><span class="line">l( Liskov-Substituion Principle ): 里氏替换原则。</span><br><span class="line">d( Dependecy-Inversion Principle ): 依赖倒置原则。</span><br><span class="line">i( Interface-Segregation Principle ): 接口隔离原则。</span><br><span class="line"> 合成/聚合复用。</span><br><span class="line"> 迪米特法则（最少知道）&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-单一职责"><a href="#1-单一职责" class="headerlink" title="(1)单一职责"></a>(1)单一职责</h2><blockquote><p><strong><em>一个类的功能要单一， 一个类只负责一个职责。 一个类只做它该做的事情(高内聚)</em></strong>。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的的破坏</p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>如果只让一个类完成它该做的事,而不涉及与它无关的领域就是践行了高内聚的原则</code></pre><h2 id="2-开放-封闭"><a href="#2-开放-封闭" class="headerlink" title="(2)开放-封闭"></a>(2)开放-封闭</h2><p> 软件实体(类、模块、函数等) <code></code>对修改关闭。 对扩展开放`</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'有新的需求或变化时， 可以对现有代码进行扩展， 以适应新的情况。'</span></span><br><span class="line"><span class="string">'对修改封闭， 意味着类一旦设计完成， 就可以独立其工作， 而不要对类尽任何修改。'</span></span><br><span class="line"> 在开发阶段， 我们都知道， 如果对一个功能进行扩展， 如果只是一味地对方法进行修改， 可能会造成一些问题， 诸如可能会引入新的 bug，</span><br><span class="line"> 或者增加代码的复杂度， 对代码结构造成破坏、 冗余， 还需要重新进行全面的测试。 那么该怎么解决这些问题？ 很简单，这就需要系统能</span><br><span class="line"> 够支持扩展， 只有扩展性良好的系统， 才能在不进行修改已有实现代码的基础上， 引进新的功能。</span><br></pre></td></tr></table></figure><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><pre><code>可维护性，可扩展性，可复用，灵活性好</code></pre><h2 id="3-里氏替换"><a href="#3-里氏替换" class="headerlink" title="(3)里氏替换"></a>(3)里氏替换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何使用基类的地方， 都能够使用子类替换， 而且在替换子类 后， 系统能够正常工作。</span><br></pre></td></tr></table></figure><pre><code> 子类一定是增加父类的能力而不是减少父类的能力，  因为子类比父类的能力更多， 把能力多的对象当成能力少的对象来用当然没有任何问题。一个 软件实体如果使用的是一个基类， 那么当把这个基类替换成继承该基类的子类， 程序的行为不会发生任何变化。软件实体察觉不出基类对象和子类对象的区别。</code></pre><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><pre><code>1. 提高代码的重用性，子类拥有父类的方法和属性；  2. 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；  </code></pre><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><pre><code>1. 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；  2. 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成     非常糟糕的结果，要重构大量的代码。  </code></pre><h2 id="4-接口隔离"><a href="#4-接口隔离" class="headerlink" title="(4)接口隔离"></a>(4)接口隔离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'使用多个专门的接口比使用单一的总接口要好。一个类对另外一个类的依赖性应当是建立在最小的接口上的。'</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将接口粒度最小化，将功能划分到每一个不能再分的子角色， 为每一个子角色创建接口通过这样，才不会让接口的实现类实现一些不必要的功能。 </span><br><span class="line">建立单一的接口， 不要建立臃肿的庞大的接口， 也就是说接口的方法尽量少。接口要小而专， 绝不能大而全。 臃肿的接口是对接口的污染,</span><br><span class="line">既然接口表示能力,那么一个接口只应该描述一种能力， 接口也应该是高度内聚的。</span><br></pre></td></tr></table></figure><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><pre><code>实现模块间的松耦合</code></pre><h2 id="5-依赖倒置"><a href="#5-依赖倒置" class="headerlink" title="(5)依赖倒置"></a>(5)依赖倒置</h2><figure class="highlight plain"><figcaption><span>而不是依赖于具体， 也就是我们经常听到的“要面向接口编程” 。``` </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们的类要依赖于抽象， 而不是依赖于具体， 也就是我们经常听到的“要面向接口编程” 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    该原则说得具体一些就是声明方法的参数类型、 方法的返回类型、 变量的引用类型时， <span class="string">'尽可能使用抽象类型而不用具体类型，'</span> 因为抽象</span><br><span class="line">类型可以被它的任何一个子类型所替代</span><br><span class="line">（<span class="number">1</span>）高层模块不应该依赖低层模块，两个都应该依赖抽象</span><br><span class="line">（<span class="number">2</span>）抽象不应该依赖细节，细节应该依赖抽象</span><br></pre></td></tr></table></figure><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><pre><code>通过抽象（抽象类或接口） 使各个类或模块的实现彼此独立， 不相互影响， 实现模块间的松耦合。 减少类间的耦合性。</code></pre><h2 id="6-合成-聚合复用"><a href="#6-合成-聚合复用" class="headerlink" title="(6)合成/聚合复用"></a>(6)合成/聚合复用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。'</span></span><br></pre></td></tr></table></figure><p>   在面向对象设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生改变，则子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了合成/聚合复用原则，也就是在实际开发设计中，尽量使用合成/聚合，不要使用类继承.一般而言，如果一个角色得到了更多的责任，那么可以使用合成/聚合关系将新的责任委派到合适的对象。当然，这种复用也有缺点。</p><pre><code>最主要的缺点就是通过这种复用建造的系统会有较多的对象需要管理。</code></pre><h2 id="迪米特法则-最少知道法则"><a href="#迪米特法则-最少知道法则" class="headerlink" title="迪米特法则(最少知道法则)"></a>迪米特法则(最少知道法则)</h2><pre><code>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类要调用另一个类的某种方法，可以通过第三方转发这个调用</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在类的结构设计上，每个类都应当尽量降低成员的访问权限</span><br></pre></td></tr></table></figure><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><pre><code>类间解耦，降低耦合度，只有弱耦合之后，类的复用性才可以提高</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;六原则一法则&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s( Single-Resposibility Principle ): 单一职责原则。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o( Open-Closed principle ): 开放封闭原则。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;l( Liskov-Substituion Principle ): 里氏替换原则。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d( Dependecy-Inversion Principle ): 依赖倒置原则。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i( Interface-Segregation Principle ): 接口隔离原则。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 合成/聚合复用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 迪米特法则（最少知道）&amp;lt;!--more--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的【IO】、【NIO】、【AIO】</title>
    <link href="http://blogs.qiulig.website/2019/06/JAVA%E4%B8%AD%E7%9A%84NIO-BIO/"/>
    <id>http://blogs.qiulig.website/2019/06/JAVA中的NIO-BIO/</id>
    <published>2019-06-01T01:08:24.000Z</published>
    <updated>2019-06-01T02:27:04.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h2><table><thead><tr><th><strong>IO</strong></th><th><strong>NIO</strong></th></tr></thead><tbody><tr><td>面向流</td><td>面向缓冲</td></tr><tr><td>阻塞IO</td><td>非阻塞IO</td></tr><tr><td>无</td><td>选择器</td></tr></tbody></table><blockquote><p><strong>1.面向流与面向缓冲</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Java IO 面向流意味着每次从流中读一个或多个字节， 直至读取所有字节，它们没有被缓存在任何地方。 此外， 它不能前后</span><br><span class="line">&gt; 移动流中的数据。</span><br><span class="line">&gt;     Java NIO 中把数据读取到一个缓冲区中， 需要时可在缓冲区中前后移动。 这就增加了处理过程中的灵活性。而且， 需确保当</span><br><span class="line">&gt; 更多的数据读入缓冲区时， 不要覆盖缓冲区里尚未处理的数据。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><a id="more"></a><p><strong>2.阻塞与非阻塞 IO</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Java IO 的各种流是阻塞的。 这意味着， 当一个线程调用 read() 或 write() 时， 该线程被阻塞， 直到有一些数据被读取,</span><br><span class="line">&gt; 或数据完全写入。 <span class="string">'该线程在此期间不能再干任何事情了'</span>。</span><br><span class="line">&gt;     Java NIO 的非阻塞模式， 使一个线程从某通道发送请求读取数据， 但是它仅能得到目前可用的数据， 如果<span class="string">'目前没有数据可用时，</span></span><br><span class="line"><span class="string">&gt; 就什么都不会获取， 而不是保持线程阻塞， 所以直至数据变的可以读取之前， 该线程可以继续做其他的事情。'</span> 非阻塞写也是如此。 一</span><br><span class="line">&gt; 个线程请求写入一些数据到某通道， 但不需要等待它完全写入， 这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用</span><br><span class="line">&gt; 于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel)。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>3.选择器（Selector）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Java NIO 的选择器允许一个单独的线程来监视多个输入通道， 你可以注册多个通道使用一个选择器， 然后使用一个单独的线程</span><br><span class="line">&gt; 来“选择”通道： 这些通道里已经有可以处理的输入， 或者选择已准备写入的通道。 为了将 Channel和Selector 配合使用,必须将</span><br><span class="line">&gt; channel 注册到 selector 上， 通过SelectableChannel.register()方法来实现。 这种选择机制，使得一个单独的线程很容易来</span><br><span class="line">&gt; 管理多个通道。 <span class="string">'只要 Channel 向 Selector 注册了某种特定的事件，Selector 就会监听这些事件是否会发生，一旦发生某个</span></span><br><span class="line"><span class="string">&gt; 便会通知对应的 Channel。 使用选择器， 借助单一线程， 就可对数量庞大的活动 I/O 通道实施监控和维护'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="IO同步阻塞"><a href="#IO同步阻塞" class="headerlink" title="IO同步阻塞"></a>IO同步阻塞</h2><h3 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="(1)阻塞IO"></a>(1)阻塞IO</h3><blockquote><p> 最传统的一种IO模型，即在<strong>读写数据过程中会发生阻塞现象</strong>。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解绑block状态。典型的阻塞IO模型的例子为：data = socket.read()；如果数据没有就绪，就会一直阻塞在read方法。</p></blockquote><h3 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="(2)非阻塞IO"></a>(2)非阻塞IO</h3><blockquote><p> 当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个Error时，它就知道数据还没准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次受到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就是说<strong>非阻塞IO模型不会交出CPU，而会一直占用CPU</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">&gt;   data = socket.read();</span><br><span class="line">&gt;   <span class="keyword">if</span>(data != error)&#123;</span><br><span class="line">&gt;     处理数据</span><br><span class="line">&gt;     <span class="keyword">break</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-多路复用IO-同步非阻塞NIO"><a href="#3-多路复用IO-同步非阻塞NIO" class="headerlink" title="(3)多路复用IO[同步非阻塞NIO]"></a>(3)多路复用IO[同步非阻塞NIO]</h3><blockquote><p>在多路复用IO模型中(实际上就说NIO)，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。通过一个线程就可以管理多个socket，只有在真正有socket读写事件进行时，才会使用IO资源进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。</p></blockquote><h3 id="4-信号驱动IO"><a href="#4-信号驱动IO" class="headerlink" title="(4)信号驱动IO"></a>(4)信号驱动IO</h3><blockquote><p>在信号驱动IO模型中，<strong>当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数</strong>，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p></blockquote><h3 id="5-异步IO-异步非阻塞AIO"><a href="#5-异步IO-异步非阻塞AIO" class="headerlink" title="(5)异步IO[异步非阻塞AIO]"></a>(5)异步IO[异步非阻塞AIO]</h3><p>应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。</p><p>在异步IO模型中，<strong>当用户线程发起read操作之后，立刻就可以开始去做其它的事</strong>。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求一个成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，<strong>当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了</strong>。也就是说用户线程完全不需要实际的整个IO操作是如何进行的。只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p><h2 id="NIO同步非阻塞"><a href="#NIO同步非阻塞" class="headerlink" title="NIO同步非阻塞"></a>NIO同步非阻塞</h2><p><img src="https://github.com/qiulig/IMG/raw/master/NIO.png" alt="NIO图解"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h5 id="1-缓冲区-buffer"><a href="#1-缓冲区-buffer" class="headerlink" title="1.缓冲区(buffer)"></a>1.缓冲区(buffer)</h5><pre><code>缓冲区实际上是一个容器对象， 其实就是一个数组， &apos;在 NIO 库中,所有数据都是用缓冲区处理的。&apos;在读取数据时， 它是直接读到缓冲区中的； 在写入数据时， 它也是写入到缓冲区中的； 任何时候访问 NIO 中的数据， 都是将它放到缓冲区中。 在 NIO 中， 所有的缓冲区类型都继承于抽象类 Buffer， 最常用的就是 ByteBuffer。  </code></pre><h5 id="2-通道-channel"><a href="#2-通道-channel" class="headerlink" title="2.通道(channel)"></a>2.通道(channel)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'通道是一个对象， 通过它可以读取和写入数据'</span>， 所有数据都通过 Buffer 对象来处理。 我们永远不会将字节直接写入通道中，相反是将数据写入</span><br><span class="line"></span><br><span class="line">包含一个或者多个字节的缓冲区。 同样不会直接从通道中读取字节， 而是将数据从通道读入缓冲区， 再从缓冲区获取这个字节。 而流只是在一个</span><br><span class="line"></span><br><span class="line">方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类， 比如 InputStream 只能进行读取操作， OutputStream 只能进行写操</span><br><span class="line"></span><br><span class="line">作)， 而<span class="string">'通道是双向的， 可以用于读、 写或者同时用于读写'</span>。</span><br></pre></td></tr></table></figure><h5 id="3-选择器（selector）"><a href="#3-选择器（selector）" class="headerlink" title="3.选择器（selector）"></a>3.选择器（selector）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Selector 的作用就是用来轮询每个注册的 Channel，一旦发现 Channel 有注册的事件发生， 便获取事件然后进行处理。'</span> </span><br><span class="line">用单线程处理一个 Selector， 然后通过 Selector.select()方法来获取到达事件， 在获取了到达事件之后， 就可以逐个地对这些事件进行</span><br><span class="line">响应处理。</span><br><span class="line">    <span class="string">'服务端和客户端各自维护一个管理通道的对象， 我们称之为 selector， 该对象能检测一个或多个通道（channel） 上的事件。'</span> </span><br><span class="line">我们以服务端为例， 如果服务端的 selector 上注册了读事件， 某时刻客户端给服务端送了一些数据， 阻塞 I/O这时会调用 read()方法阻</span><br><span class="line">塞地读取数据， 而 NIO 的服务端会在 selector 中添加一个读事件。 服务端的处理线程会轮询地访问 selector， 如果访问selector 时</span><br><span class="line">发现有感兴趣的事件到达， 则处理这些事件， 如果没有感兴趣的事件到达， 则处理线程会一直阻塞直到感兴趣的事件到达为止。</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IO和NIO的区别&quot;&gt;&lt;a href=&quot;#IO和NIO的区别&quot; class=&quot;headerlink&quot; title=&quot;IO和NIO的区别&quot;&gt;&lt;/a&gt;IO和NIO的区别&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;IO&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;NIO&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;面向流&lt;/td&gt;
&lt;td&gt;面向缓冲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;阻塞IO&lt;/td&gt;
&lt;td&gt;非阻塞IO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;选择器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.面向流与面向缓冲&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;     Java IO 面向流意味着每次从流中读一个或多个字节， 直至读取所有字节，它们没有被缓存在任何地方。 此外， 它不能前后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; 移动流中的数据。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;     Java NIO 中把数据读取到一个缓冲区中， 需要时可在缓冲区中前后移动。 这就增加了处理过程中的灵活性。而且， 需确保当&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; 更多的数据读入缓冲区时， 不要覆盖缓冲区里尚未处理的数据。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="http://blogs.qiulig.website/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="http://blogs.qiulig.website/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="线程" scheme="http://blogs.qiulig.website/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计模式—-工厂模式</title>
    <link href="http://blogs.qiulig.website/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/05/设计模式—-工厂模式/</id>
    <published>2019-05-31T11:21:52.000Z</published>
    <updated>2019-05-31T15:50:00.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的<strong>实例化延迟</strong>到其子类。</p><p><strong>提供一个创建对象实例的功能，而无须关心其具体实现</strong>。被创建实例的类型可以是接口、抽象类，也可以是具体的类。工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。<a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/设计模式之工厂模式.png" alt="工厂模式结构图"></p><h3 id="1-简单工厂方法"><a href="#1-简单工厂方法" class="headerlink" title="1.简单工厂方法"></a>1.简单工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISample <span class="title">creator</span><span class="params">(<span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (which==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleA();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (which==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实例时</span></span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">1</span>);</span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="2-抽象工厂"><a href="#2-抽象工厂" class="headerlink" title="2.抽象工厂"></a>2.抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample <span class="title">creator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实现接口的实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleA</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2A</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//创建工厂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BombFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleB</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1、可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。</p><p>2、可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。<br>3、可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。  </p><!--more--></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上<strong>增加了系统的复杂度，同时也增加了系统具体类的依赖</strong>。</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </p><p>2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </p><p>3、设计一个连接服务器的框架，需要三个议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的&lt;strong&gt;实例化延迟&lt;/strong&gt;到其子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提供一个创建对象实例的功能，而无须关心其具体实现&lt;/strong&gt;。被创建实例的类型可以是接口、抽象类，也可以是具体的类。工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-原型模式</title>
    <link href="http://blogs.qiulig.website/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/05/设计模式-原型模式/</id>
    <published>2019-05-31T07:53:34.000Z</published>
    <updated>2019-05-31T08:09:55.600Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节。<a id="more"></a></p><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1.浅拷贝"></a>1.浅拷贝</h3><pre><code>对类实现Cloneable接口（implements Cloneable），并且重写clone对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型创建成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2.深拷贝"></a>2.深拷贝</h3><pre><code>对其中的引用类型的成员变量进行实现Cloneable接口，重写clone，就变成深拷贝了对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">     String name;</span><br><span class="line"></span><br><span class="line">     String <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1.如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程。</p><p>2.使用原型模式创建对象比直接 new 一个对象在性能上要好的多，因为 Object 类的 clone 方法是一个本地方法，它直接操作内存中的二进制流，特别  是复制大对象时，性能的差别非常明显。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p><strong>在需要重复地创建相似对象时可以考虑使用原型模式</strong>。</p><p>比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数  很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h2&gt;&lt;p&gt;创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
