<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0972e01a5f38f38e77d0154479c21150</icon>
  <subtitle>菜鸟要更加努力才能追上别人的步伐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blogs.qiulig.website/"/>
  <updated>2019-08-01T07:22:16.099Z</updated>
  <id>http://blogs.qiulig.website/</id>
  
  <author>
    <name>qiulig</name>
    <email>qiuling_long@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表题【翻转链表】【环形链表】【删除重复元素】【两数相加】【相交链表】</title>
    <link href="http://blogs.qiulig.website/2019/08/%E9%93%BE%E8%A1%A8%E9%A2%98%E3%80%90%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%91%E3%80%90%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E3%80%91%E3%80%90%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E3%80%91%E3%80%90%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E3%80%91%E3%80%90%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/08/链表题【翻转链表】【环形链表】【删除重复元素】【两数相加】【相交链表】/</id>
    <published>2019-08-01T07:19:11.000Z</published>
    <updated>2019-08-01T07:22:16.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-翻转链表"><a href="#1-翻转链表" class="headerlink" title="1.翻转链表"></a>1.翻转链表</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a><br>递归：</p><ul><li>在遍历链表时，将当前节点cur的next指向前一个元素，</li><li>由于节点没有引用上一个节点，故初始时设置前一个节点pre = null,</li><li>在更改引用之前，还需要另一个指针来存储下一个节点next = cur.next。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时 :1 ms, 在所有 Java 提交中击败了85.90%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗 :36.1 MB, 在所有 Java 提交中击败了55.82%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;  <span class="comment">//将下一个节点记录</span></span><br><span class="line">        cur.next = pre;  <span class="comment">//当前节点指向上一个节点</span></span><br><span class="line">        pre = cur;   <span class="comment">//记录当前节点</span></span><br><span class="line">        cur = next; <span class="comment">//将下一个节点变成当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代：假设链表为 n1–&gt;n2–&gt;n3—n&gt;4–&gt;null,若某部分已经被翻转了  n1–&gt;n2–&gt;<code>n3&lt;--n4</code>，我们希望3指向2，所以有n3.next.next = n2,要注意n1的下一个必须指向null,故还有个head.next = null操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode res = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-翻转链表II"><a href="#2-翻转链表II" class="headerlink" title="2.翻转链表II"></a>2.翻转链表II</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a><br> 假设以 head – 1–2–3–4–中的1~4进行反转</p><blockquote><ul><li>先让头指针的next指向2，</li><li>再让1的next指向3，</li><li>最后将2的next指向1，</li><li><p>完成第一次交换，顺序变成header–2–1–3–4,</p><ul><li>然后进行相同的交换将结点3移动到结点2的前面，然后再将结点4移动到结点3的前面就完成了反转。</li><li><p>同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">&gt;        ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">&gt;        res.next = head;</span><br><span class="line">&gt;        ListNode pre = res;</span><br><span class="line">&gt;        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">&gt;            pre = pre.next;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        head = pre.next;</span><br><span class="line">&gt;        <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; n; i++)&#123;</span><br><span class="line">&gt;            ListNode nextnode = head.next;</span><br><span class="line">&gt;            head.next = nextnode.next;</span><br><span class="line">&gt;            nextnode.next = pre.next;</span><br><span class="line">&gt;            pre.next = nextnode;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        <span class="keyword">return</span> res.next;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><h3 id="3-环形链表"><a href="#3-环形链表" class="headerlink" title="3.环形链表"></a>3.环形链表</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a><br>方法1：HashSet,如果当前结点存在于哈希表中，说明有环，否则遍历完全，返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     Set&lt;ListNode&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">     <span class="keyword">while</span> (head !=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(res.contains(head))&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             res.add(head);</span><br><span class="line">         &#125;</span><br><span class="line">         head = head.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>方法2：快慢指针，快指针先于慢指针一步，如果有环，总有一个时刻快指针会追上慢指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了92.84%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :39.6 MB, 在所有 Java 提交中击败了47.88%的用户</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       ListNode fast = head.next;</span><br><span class="line">       ListNode slow = head;</span><br><span class="line">       <span class="keyword">while</span>(fast !=slow)&#123;</span><br><span class="line">           <span class="keyword">if</span>(fast==<span class="keyword">null</span> || fast.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-环形链表II"><a href="#4-环形链表II" class="headerlink" title="4.环形链表II"></a>4.环形链表II</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><ul><li><p>快慢指针：当fast和slow在环中相遇时，设头节点到入环结点的长度为x,入环结点到相遇点长度为y,相遇点到入环结点长度为z,则有(x+y)*2 = x+y+z+y,即x = z,把快指针设为头节点，慢指针还在相遇点，两个指针相遇之时就是入环点所在之处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.71%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :36.3 MB, 在所有 Java 提交中击败了5.03%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          ListNode fast = head;</span><br><span class="line">          ListNode slow = head;</span><br><span class="line">          <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              fast = fast.next.next;</span><br><span class="line">              slow = slow.next;</span><br><span class="line">              <span class="comment">//环内相遇</span></span><br><span class="line">              <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                  <span class="comment">//快指针重头走</span></span><br><span class="line">                  fast = head;</span><br><span class="line">                  <span class="comment">//快慢指针同时走，相等时即入环结点处</span></span><br><span class="line">                  <span class="keyword">while</span>(fast !=slow)&#123;</span><br><span class="line">                      fast = fast.next;</span><br><span class="line">                      slow = slow.next;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> fast;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//走到尾巴了，说明没有环</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-两数相加"><a href="#5-两数相加" class="headerlink" title="5.两数相加"></a>5.两数相加</h3><p>  &emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode ress = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode res = ress;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span> ||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = l1!=<span class="keyword">null</span> ?l1.val:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> value = x+y+flag;</span><br><span class="line">        flag = value/<span class="number">10</span>;</span><br><span class="line">        res.next = <span class="keyword">new</span> ListNode(value%<span class="number">10</span>);</span><br><span class="line">        res = res.next;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag&gt;<span class="number">0</span>)</span><br><span class="line">        res.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">    <span class="keyword">return</span> ress.next;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-两数相加II"><a href="#6-两数相加II" class="headerlink" title="6.两数相加II"></a>6.两数相加II</h3><p>  &emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii/submissions/</a></p><p>  思路1：使用翻转，进行计算，结果再次翻转即可</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">if</span>(l2 == <span class="keyword">null</span> &amp;&amp; l1!=<span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> l1;</span><br><span class="line">  ListNode head1 = reverseList(l1);</span><br><span class="line">  ListNode head2 = reverseList(l2);</span><br><span class="line">  ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">  ListNode ans = res;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (head1!=<span class="keyword">null</span> || head2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> x = head1 == <span class="keyword">null</span> ? <span class="number">0</span> : head1.val;</span><br><span class="line">      <span class="keyword">int</span> y = head2 ==<span class="keyword">null</span> ? <span class="number">0</span>:head2.val;</span><br><span class="line">      res.next = <span class="keyword">new</span> ListNode((x+y+count)%<span class="number">10</span>);</span><br><span class="line">      count = (x + y +count)/<span class="number">10</span>;</span><br><span class="line">      res = res.next;</span><br><span class="line">      <span class="keyword">if</span>(head1!=<span class="keyword">null</span>) head1 = head1.next;</span><br><span class="line">      <span class="keyword">if</span>(head2!=<span class="keyword">null</span>) head2 = head2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count != <span class="number">0</span>)&#123;</span><br><span class="line">      res.next = <span class="keyword">new</span> ListNode(count);</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode root = reverseList(ans.next);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode nextnode = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nextnode;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   思路2： 不使用翻转，使用栈进行存储 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">      Stack&lt;Integer&gt; stack1=<span class="keyword">new</span> Stack();</span><br><span class="line">      Stack&lt;Integer&gt; stack2=<span class="keyword">new</span> Stack();</span><br><span class="line">      ListNode node1=l1;</span><br><span class="line">      <span class="comment">//将l1的值入栈</span></span><br><span class="line">      <span class="keyword">while</span>(node1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          stack1.push(node1.val);</span><br><span class="line">          node1=node1.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将l2的值入栈</span></span><br><span class="line">      ListNode node2=l2;</span><br><span class="line">      <span class="keyword">while</span>(node2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          stack2.push(node2.val);</span><br><span class="line">          node2=node2.next;</span><br><span class="line">      &#125;</span><br><span class="line">      ListNode head=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">//依次弹出</span></span><br><span class="line">      <span class="keyword">while</span>(!stack1.isEmpty()||!stack2.isEmpty()||flag!=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(!stack1.isEmpty())</span><br><span class="line">              value+=stack1.pop();</span><br><span class="line">          <span class="keyword">if</span>(!stack2.isEmpty())</span><br><span class="line">              value+=stack2.pop();</span><br><span class="line">          value+=flag;</span><br><span class="line">          ListNode node=<span class="keyword">new</span> ListNode(value%<span class="number">10</span>);</span><br><span class="line">          flag=value/<span class="number">10</span>;</span><br><span class="line">          <span class="comment">//计算的低位依次向后移动</span></span><br><span class="line">          node.next=head;</span><br><span class="line">          <span class="comment">//head存储上一次计算得到的值</span></span><br><span class="line">          head=node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="7-删除排序链表中的重复元素"><a href="#7-删除排序链表中的重复元素" class="headerlink" title="7.删除排序链表中的重复元素"></a>7.删除排序链表中的重复元素</h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       ListNode node = head;</span><br><span class="line">       <span class="keyword">while</span>(node!=<span class="keyword">null</span> &amp;&amp; node.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="comment">//如果相等则跳过这个数</span></span><br><span class="line">           <span class="keyword">if</span>(node.val == node.next.val)&#123;</span><br><span class="line">               node.next = node.next.next;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               node = node.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="8-删除排序链表中的重复元素II"><a href="#8-删除排序链表中的重复元素II" class="headerlink" title="8.删除排序链表中的重复元素II"></a>8.删除排序链表中的重复元素II</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//head的首部也是重复的数</span></span><br><span class="line">    <span class="keyword">if</span>(head.val==head.next.val)&#123;</span><br><span class="line">        <span class="comment">//node的首部为重复的数，此时head的首部也是重复的数</span></span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        <span class="comment">//如果node的首部一直跟head的相同，则一直向后移动，直到不是重复的数</span></span><br><span class="line">        <span class="keyword">while</span>( node != <span class="keyword">null</span> &amp;&amp; head.val == node.val )&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归node结点，此时node结点为删除了前面重复的数</span></span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//不相等就向下移动，递归删除后面重复的数</span></span><br><span class="line">        head.next = deleteDuplicates(head.next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-相交链表"><a href="#9-相交链表" class="headerlink" title="9.相交链表"></a>9.相交链表</h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a><br>关键：消除两个链表的长度差</p><ul><li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li><li>如果 pA 到了末尾，则 pA = headB 继续遍历</li><li>如果 pB 到了末尾，则 pB = headA 继续遍历</li><li><p>比较长的链表指针指向较短链表head时，长度差就消除了</p><p>如此，只需要将最短链表遍历两次即可找到位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">ListNode pA = headA, pB = headB;</span><br><span class="line"><span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">    pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">    pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;链表的定义&quot;&gt;&lt;a href=&quot;#链表的定义&quot; class=&quot;headerlink&quot; title=&quot;链表的定义&quot;&gt;&lt;/a&gt;链表的定义&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &amp;#123; val = x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法【区间调度】【集合覆盖】【背包问题】【旅行商问题】【哈夫曼构造价值树】</title>
    <link href="http://blogs.qiulig.website/2019/07/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://blogs.qiulig.website/2019/07/贪心算法/</id>
    <published>2019-07-30T10:43:14.000Z</published>
    <updated>2019-07-30T10:48:18.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><blockquote><p>&emsp;在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。<br>&emsp;贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略<strong>必须具备无后效性</strong>，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。<a id="more"></a></p></blockquote><h3 id="1-区间调度问题"><a href="#1-区间调度问题" class="headerlink" title="1.区间调度问题"></a>1.区间调度问题</h3><p> 假设有如下课程，希望尽可能多的将课程安排在一间教室里：<br>|课程|开始时间  |结束时间<br>|–|–|–|<br>| 美术 | 9AM  |10AM|<br>英语|9：30AM|10:30AM|<br>数学|10AM|11AM|<br>计算机|10：30AM|11:30AM|<br>音乐|11AM|12AM|<br>算法设计：</p><ul><li>1.选择结束最早的课，便是要在这教室上课的第一节课 </li><li>2.接下来，选择第一堂课结束后才开始的课，并且结束最早的课，这将是第二节在教室上的课。</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String subject[] = &#123;<span class="string">"英语"</span>,<span class="string">"数学"</span>,<span class="string">"计算机"</span>,<span class="string">"音乐"</span>,<span class="string">"美术"</span>&#125;;</span><br><span class="line">        Work[]  works = &#123;</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">1</span>,<span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">4</span>, <span class="number">7</span>),</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">6</span>, <span class="number">9</span>),</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">8</span>, <span class="number">10</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> result = solution(works);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(Work[] works)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//works里面已经按end从小到大排序了</span></span><br><span class="line">        Arrays.sort(works);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前工作的结束时间</span></span><br><span class="line">        <span class="keyword">int</span> endTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;works.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(endTime&lt;works[i].getStart())&#123;</span><br><span class="line">                count++;</span><br><span class="line">                endTime = works[i].getEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//end 从小到大排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            Work work = (Work) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.end &gt; work.getEnd())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.end == work.getEnd())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同问题：2019届爱奇艺校招笔试题第三题_库特君的面条: &emsp;&emsp;<a href="https://blog.csdn.net/qq_17556191/article/details/95003363" target="_blank" rel="noopener">https://blog.csdn.net/qq_17556191/article/details/95003363</a></p><h3 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2.背包问题"></a>2.背包问题</h3><p>见：<a href="https://blog.csdn.net/qq_17556191/article/details/94764606" target="_blank" rel="noopener">https://blog.csdn.net/qq_17556191/article/details/94764606</a></p><h3 id="3-集合覆盖问题"><a href="#3-集合覆盖问题" class="headerlink" title="3.集合覆盖问题"></a>3.集合覆盖问题</h3><p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号。<br>|广播台|覆盖地区  |<br>|–|–|<br>| K1 |ID,NV,UT  |<br>K2|WA,ID,MT|<br>K3|OR,NV,CA|<br>K4|NV,UT|<br>K5|CA,AZ|<br>…|…|<br>算法设计：<br>(1) 选出一个广播台，即它覆盖了最多未覆盖的地区即便包含一些已覆盖的地区也没关系<br>(2) 重复第一步直到覆盖了全部的地区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_tanxin_jihefugai</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        broadcasts.put(<span class="string">"K1"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"ID"</span>,<span class="string">"NV"</span>,<span class="string">"UT"</span>&#125;)));</span><br><span class="line">        broadcasts.put(<span class="string">"K2"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"WA"</span>,<span class="string">"ID"</span>,<span class="string">"MT"</span>&#125;)));</span><br><span class="line">        broadcasts.put(<span class="string">"K3"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"OR"</span>,<span class="string">"NV"</span>,<span class="string">"CA"</span>&#125;)));</span><br><span class="line">        broadcasts.put(<span class="string">"K4"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"NV"</span>,<span class="string">"UT"</span>&#125;)));</span><br><span class="line">        broadcasts.put(<span class="string">"K5"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"CA"</span>,<span class="string">"AZ"</span>&#125;)));</span><br><span class="line">        <span class="comment">//需要覆盖的全部地区</span></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"ID"</span>,<span class="string">"NV"</span>,<span class="string">"UT"</span>,<span class="string">"WA"</span>,<span class="string">"MT"</span>,<span class="string">"OR"</span>,<span class="string">"CA"</span>,<span class="string">"AZ"</span>&#125;));</span><br><span class="line">        <span class="comment">//所选择的广播台列表</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//(1) 选出一个广播台，即它覆盖了最多未覆盖的地区即便包含一些已覆盖的地区也没关系</span></span><br><span class="line">        <span class="comment">// (2) 重复第一步直到可以覆盖了全部的地区</span></span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String maxKey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(allAreas.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            maxKey = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//一轮轮选出（之前未覆盖的）数量最多的电台</span></span><br><span class="line">            <span class="keyword">for</span>(String key:broadcasts.keySet())&#123;</span><br><span class="line">                tempSet.clear();</span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                <span class="comment">//求出2个集合的交集，得到的交集的电台存在tempSet里面</span></span><br><span class="line">                tempSet.retainAll(allAreas);</span><br><span class="line">                <span class="comment">//如果该集合包含的地区数量比原本的集合多</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size()&gt;<span class="number">0</span> &amp;&amp; (maxKey == <span class="keyword">null</span> || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                    <span class="comment">//得到要存入的电台key</span></span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到未覆盖电台数的最大的那个电台</span></span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lists.add(maxKey);</span><br><span class="line">                <span class="comment">//将覆盖地区移除allAreas</span></span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"selects:"</span> + lists);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-旅行商问题"><a href="#4-旅行商问题" class="headerlink" title="4.旅行商问题"></a>4.旅行商问题</h3><p>&emsp;给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。<br>算法设计：<br>随机选一个城市开始，以寻找离该城市最近点作为下一个城市旅行城市，此后寻找离最后加入路线的城市最近的城市，直到最后。【类似于广度优先遍历】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旅行商问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String city[] = &#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"F"</span>,<span class="string">"G"</span>,<span class="string">"H"</span>,<span class="string">"I"</span>,<span class="string">"J"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> x[] = &#123;<span class="number">2066</span>,<span class="number">935</span>,<span class="number">1270</span>,<span class="number">1389</span>,<span class="number">984</span>,<span class="number">2253</span>,<span class="number">949</span>,<span class="number">87</span>,<span class="number">3094</span>,<span class="number">2706</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> y[] = &#123;<span class="number">2333</span>,<span class="number">1304</span>,<span class="number">200</span>,<span class="number">700</span>,<span class="number">2810</span>,<span class="number">478</span>,<span class="number">3025</span>,<span class="number">2483</span>,<span class="number">1883</span>,<span class="number">3130</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> distance[][] = Caldistance(x,y);</span><br><span class="line">        solve(distance,city);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[][] Caldistance(<span class="keyword">int</span> x[],<span class="keyword">int</span> y[])&#123;</span><br><span class="line">        <span class="keyword">double</span> [][] distance = <span class="keyword">new</span> <span class="keyword">double</span>[x.length][x.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;x.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;x.length;j++)&#123;</span><br><span class="line">                <span class="comment">//欧式距离</span></span><br><span class="line">                distance[i][j] = Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span>[][]distance,String []city)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录访问过的城市</span></span><br><span class="line">        <span class="keyword">int</span> visited[] = <span class="keyword">new</span> <span class="keyword">int</span>[distance.length];</span><br><span class="line">        <span class="comment">//记录依次访问的城市，得到最小的距离</span></span><br><span class="line">        String path[] = <span class="keyword">new</span> String[distance.length];</span><br><span class="line">        <span class="comment">//假设从第一个城市A开始</span></span><br><span class="line">        path[<span class="number">0</span>] = <span class="string">"A"</span>;</span><br><span class="line">        <span class="comment">//访问过的点记录为1</span></span><br><span class="line">        visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前正在访问的点</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一次设下一个城市为Index为1的B城市</span></span><br><span class="line">        <span class="keyword">int</span> nextCityIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//初始化最小的距离</span></span><br><span class="line">        <span class="keyword">double</span> mindistance = Double.MAX_VALUE;</span><br><span class="line">        <span class="comment">//记录以及访问过多少个城市了</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;city.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;city.length;i++)&#123;</span><br><span class="line">                <span class="comment">//如果该点没被访问</span></span><br><span class="line">                <span class="keyword">if</span>(visited[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//求出 从正在访问的点k到下一个点的最小距离，即为下一个要被访问的城市</span></span><br><span class="line">                    <span class="keyword">if</span>(distance[k][i]&lt;mindistance)&#123;</span><br><span class="line">                        mindistance  = distance[k][i];</span><br><span class="line">                        <span class="comment">//获取下一个要被访问的城市的下标索引</span></span><br><span class="line">                        nextCityIndex = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//依次访问的点的总路程</span></span><br><span class="line">            sum = sum + mindistance;</span><br><span class="line">            <span class="comment">//将得到的下一个要访问的城市加入到path中</span></span><br><span class="line">            path[count++] = city[nextCityIndex];</span><br><span class="line">            <span class="comment">//该点被访问，置为1</span></span><br><span class="line">            visited[nextCityIndex] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将访问的城市起点改成求得的下一个城市的点的坐标索引</span></span><br><span class="line">            k = nextCityIndex;</span><br><span class="line">            <span class="comment">//再次初始化</span></span><br><span class="line">            mindistance = Double.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得出依次访问的结果，输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;path.length;i++)&#123;</span><br><span class="line">            System.out.print(path[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-哈夫曼构造价值树"><a href="#5-哈夫曼构造价值树" class="headerlink" title="5.哈夫曼构造价值树"></a>5.哈夫曼构造价值树</h3><p>哈夫曼见： <a href="https://blog.csdn.net/likunkun__/article/details/80258515" target="_blank" rel="noopener">https://blog.csdn.net/likunkun__/article/details/80258515</a><br>相同题型：切金条： <a href="https://blog.csdn.net/qq_34115899/article/details/79723970" target="_blank" rel="noopener">https://blog.csdn.net/qq_34115899/article/details/79723970</a></p><p>参考：图解贪婪算法  <a href="https://blog.csdn.net/a8082649/article/details/82079779" target="_blank" rel="noopener">https://blog.csdn.net/a8082649/article/details/82079779</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。&lt;br&gt;&amp;emsp;贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略&lt;strong&gt;必须具备无后效性&lt;/strong&gt;，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blogs.qiulig.website/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心算法" scheme="http://blogs.qiulig.website/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【俄罗斯套娃信封问题】【堆积木】</title>
    <link href="http://blogs.qiulig.website/2019/07/%E3%80%90%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98%E3%80%91%E3%80%90%E5%A0%86%E7%A7%AF%E6%9C%A8%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/【俄罗斯套娃信封问题】【堆积木】/</id>
    <published>2019-07-30T10:40:48.000Z</published>
    <updated>2019-07-30T10:47:32.399Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a>俄罗斯套娃信封问题</h3><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/russian-doll-envelopes/</a></p><blockquote><p>&emsp;给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<a id="more"></a><br>&emsp;请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。<br><strong>说明:</strong><br>&emsp;不允许旋转信封。<br><strong>示例:<br>输入:</strong><br>&emsp; envelopes = [[5,4],[6,4],[6,7],[2,3]]<br><strong>输出:</strong><br>&emsp; 3<br><strong>解释:</strong> 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路1：动态规划<br>以envelopes =[[4,5],[4,6],[6,7],[2,3],[1,1]]为例；</p><ul><li><p>1.先将envelopes的长度进行从小到大排序，在长度相等的情况下，对它的宽度也进行从小到大排序得到 [1,1],[2,3],[4,5],[4,6],[4,7]</p><blockquote><p>Arrays.sort(envelopes, new Comparator&lt;int[]&gt;(){</p><p>&emsp;&emsp; public int compare(int[] o1,int [] o2){</p><p>&emsp;&emsp;&emsp;&emsp;//判断第一个元素是否相等</p><p>&emsp;&emsp;&emsp;&emsp; if (o1[0] == o2[0]) {</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o1[1] - o2[1];</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;} else {</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o1[0] - o2[0];</p><p>&emsp;&emsp;&emsp;&emsp;}</p><p>&emsp;&emsp;&emsp; }</p><p>&emsp;&emsp;});</p></blockquote></li><li><p>2.因为f[i]表示第i个信封可以嵌套的最大信封数,结果要求最多有多少个信封，最多信封为嵌套信封加本身的信封，故将其每个位置初始化为1。</p></li><li><p>3.for语句嵌套，如果第i个信封的长度和宽度都大于第j个信封，则可以把它嵌套到i里面信封里面，所以此时第i个信封可以嵌套的最大信封数为f[i] = Math.max(f[i],f[j]+1);</p></li><li><p>4.最多的信封数即为f[]里面存在的最大的数。返回结果。</p></li></ul><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(envelopes==<span class="keyword">null</span>||envelopes.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//长度从小到大排序，在长度相等的情况下，高度从小到大排序</span></span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1,<span class="keyword">int</span> [] o2)</span></span>&#123;</span><br><span class="line">                <span class="comment">//判断第一个元素是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> n=envelopes.length;</span><br><span class="line">        <span class="comment">//f[i]表示第i个信封可以嵌套的最大信封数</span></span><br><span class="line">        <span class="comment">//5个信封的初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            f[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//第i个信封的长度和宽度都大于第j个信封，则可以把它嵌套到i里面信封里面</span></span><br><span class="line">                <span class="keyword">if</span>(envelopes[j][<span class="number">0</span>]&lt;envelopes[i][<span class="number">0</span>]&amp;&amp;envelopes[j][<span class="number">1</span>]&lt;envelopes[i][<span class="number">1</span>])&#123;</span><br><span class="line">                    f[i]=Math.max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res,f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：</p><ul><li>1.envelopes的长度进行从小到大排序，在长度相等的情况下，对它的宽度也进行从大到小排序得到 [1,1],[2,3],[4,6],[4,5],[4,7]，最后问题转换成求 1，3，6，5，7中的最大递增子序列</li><li>2.定义一个ends数组。ends[i]代表遍历到目前为止，所有长度为i+1的递增子序列的最小结尾数。初始化ends[0] = 1;即1 ，3，6，5，7遍历到1的时候，长度为1的递增子序列的最小结尾数就是1。</li><li><p>一次更新ends数组，for循环遍历1，3，6，5，7，从i=1遍历到尾部。在ends里面进行二分查找，查找此刻dots[i]在ends的哪个部分，如果是没更新到的地方则更新此时的ends[i];如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dots.length; i++) &#123;</span><br><span class="line">     l = <span class="number">0</span>;</span><br><span class="line">     r = right;</span><br><span class="line">     <span class="comment">//当要算以dots[i]结尾的最长递增子序列时，</span></span><br><span class="line">     <span class="comment">//二分查找去ends里面更新长度为i的最小结尾数</span></span><br><span class="line">     <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">         mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span> (dots[i].h &gt; ends[mid]) &#123;</span><br><span class="line">             l = mid + <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             r = mid - <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     right = Math.max(right, l);</span><br><span class="line">     <span class="comment">//更新最小结尾数</span></span><br><span class="line">     ends[l] = dots[i].h;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>第一次遍历: i = 1; l = r =mid = 0;&emsp;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dot[1].h = 3 &gt; ends[0] = 1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;l = 1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;right = 1;ends[1] = 3;<br>第二次遍历: i = 2; l=0,r = 1,mid = 0;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dot[2].h = 6 &gt; ends[0] = 1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;l = 1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mid = 1,l =2<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;right = 2,end[2] = 6;<br>&emsp;&emsp;…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by qiulig on 2019/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_354</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行用时 :33 ms, 在所有 Java 提交中击败了87.11%的用户</span></span><br><span class="line">    <span class="comment">//内存消耗 :47.1 MB, 在所有 Java 提交中击败了80.68%的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] envelopes=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        System.out.print(maxEnvelopes(envelopes));</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dot</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Dot</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">                w = weight;</span><br><span class="line">                h = hight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//长度从小到大排序，在长度相等的情况下，高度从大到小排序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DotComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Dot</span>&gt; </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dot o1, Dot o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.w != o2.w) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.w - o2.w;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o2.h - o1.h;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] es)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (es == <span class="keyword">null</span> || es.length == <span class="number">0</span> || es[<span class="number">0</span>] == <span class="keyword">null</span> || es[<span class="number">0</span>].length != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Dot[] dots = <span class="keyword">new</span> Dot[es.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; es.length; i++) &#123;</span><br><span class="line">                dots[i] = <span class="keyword">new</span> Dot(es[i][<span class="number">0</span>], es[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//排序之后长度w： 1  2  4  4  6</span></span><br><span class="line">            <span class="comment">//    对应高度h： 1  3  6  5  7</span></span><br><span class="line">            <span class="comment">//最后问题转换成求 1  3  6  5  7中的最大递增子序列</span></span><br><span class="line">            Arrays.sort(dots, <span class="keyword">new</span> DotComparator());</span><br><span class="line">            <span class="comment">//ends[i]代表遍历到目前为止，所有长度为i+1的递增子序列的最小结尾数</span></span><br><span class="line">            <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[es.length];</span><br><span class="line">            <span class="comment">//代表第一个信封的长度为1的最小结尾数是dots[0].h</span></span><br><span class="line">            ends[<span class="number">0</span>] = dots[<span class="number">0</span>].h;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dots.length; i++) &#123;</span><br><span class="line">                l = <span class="number">0</span>;</span><br><span class="line">                r = right;</span><br><span class="line">                <span class="comment">//当要算以dots[i]结尾的最长递增子序列时，</span></span><br><span class="line">                <span class="comment">//二分查找去ends里面更新长度为i的最小结尾数</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dots[i].h &gt; ends[mid]) &#123;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                right = Math.max(right, l);</span><br><span class="line">                <span class="comment">//更新最小结尾数</span></span><br><span class="line">                ends[l] = dots[i].h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果信封可旋转，则我们可以把输入稍微定死，输入[w,h]定死了大的数的代表的是信封的长，小的数代表的是信封的宽，即如果输入w&lt;h，则把他们互换一下位置。</p><h3 id="搭积木"><a href="#搭积木" class="headerlink" title="搭积木"></a>搭积木</h3><p><a href="https://www.nowcoder.com/questionTerminal/55371b74b2f243e3820e57ee4c7b5504" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/55371b74b2f243e3820e57ee4c7b5504</a></p><blockquote><p>&emsp;小明有一袋子长方形的积木，如果一个积木A的长和宽都不大于另外一个积木B的长和宽，则积木A可以搭在积木B的上面。好奇的小明特别想知道这一袋子积木最多可以搭多少层，你能帮他想想办法吗？    定义每一个长方形的长L和宽W都为正整数，并且1 &lt;= W &lt;= L &lt;= INT_MAX, 袋子里面长方形的个数为N, 并且 1 &lt;= N &lt;= 1000000.    假如袋子里共有5个积木分别为 (2, 2), (2, 4), (3, 3), (2, 5), (4, 5), 则不难判断这些积木最多可以搭成4层, 因为(2, 2) &lt; (2, 4) &lt; (2, 5) &lt; (4, 5)。 </p></blockquote><blockquote><ul><li><p>同如上思路2，先将宽度进行排序，将问题转化成求长度的最大递增子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>package 拼多多;<br>import java.util.*;<br>public class Main_3{<br>    static class Rectangle{<br>        private int Weight; //宽度<br>        private int Len;  //长度<br>        public Rectangle(int x, int y){<br>            Weight = x;<br>            Len = y;<br>        }<br>    }<br>    public static void main(String[] args){<br>        Scanner sc = new Scanner(System.in);<br>        int n = sc.nextInt();<br>        ArrayList<rectangle> list = new ArrayList&lt;&gt;();<br>        for(int i = 0; i &lt; n; i++){<br>            int x = sc.nextInt();<br>            int y = sc.nextInt();<br>            Rectangle r = new Rectangle(x, y);<br>            list.add(r);<br>        }<br>        //排序，宽度从小到大，在宽度一样的情况下，长度从小到大<br>        Collections.sort(list, new Comparator<rectangle>(){<br>            @Override<br>            public int compare(Rectangle o1, Rectangle o2) {<br>                if(o1.Weight == o2.Weight)<br>                    return o1.Len - o2.Len;<br>                else<br>                    return o1.Weight -o2.Weight;<br>            }<br>        });<br>        //最后问题转换成求长度的最大递增子序列<br>        //用于代表遍历到目前为止，所有长度为i+1的递增子序列的最小结尾数<br>        int[] arr = new int[n];<br>        int max = 1;<br>        arr[0] = list.get(0).Len;<br>        for(int i = 1; i &lt; n; i++){<br>            if(list.get(i).Len &gt;= arr[max-1]){<br>                arr[max++] = list.get(i).Len;<br>            }else{<br>                int left = 0;<br>                int right = max -1;<br>                int L = list.get(i).Len;<br>                while(left &lt; right){<br>                    int mid = (left + right) &gt;&gt; 1;<br>                    if(arr[mid] == L){<br>                        left = mid;<br>                        break;<br>                    }else if(arr[mid] &gt; L){<br>                        right–;<br>                    }else<br>                        left++;<br>                }<br>                arr[left] = L;<br>            }<br>        }<br>        System.out.println(max);<br>    }<br>}</rectangle></rectangle></p><p><img src="https://img-blog.csdnimg.cn/20190730112202118.png" alt="在这里插入图片描述"></p><h3 id="拼多多学霸批的堆积木"><a href="#拼多多学霸批的堆积木" class="headerlink" title="拼多多学霸批的堆积木"></a>拼多多学霸批的堆积木</h3><blockquote><p>已知N个积木的长度，当堆积木的时候，要求每层积木的长度严格比其下方的积木小，而且每块积木只能承受自身重量的7倍，问可以堆多高的积木<br>给了个测试用例<br>输入：<br>10<br>1    2    3    4    5    6    7    8    9    10<br>1    1    1    1    1    1    1    1    1    10<br>输出：9</p><ul><li>个人思路觉得这题还是上面堆积木，俄罗斯套信封题一样，只是积木的长度 = 俄罗斯信封的长度，积木的重量*7 = 俄罗斯信封的高度。应该是这样子叭叭叭<del>~</del><del>~</del><del>~</del>~~~小菜鸟不知了。。。。。。。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;俄罗斯套娃信封问题&quot;&gt;&lt;a href=&quot;#俄罗斯套娃信封问题&quot; class=&quot;headerlink&quot; title=&quot;俄罗斯套娃信封问题&quot;&gt;&lt;/a&gt;俄罗斯套娃信封问题&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/russian-doll-envelopes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/russian-doll-envelopes/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
      <category term="剑指offer" scheme="http://blogs.qiulig.website/categories/leetcode/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="贪心算法" scheme="http://blogs.qiulig.website/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>结构型模式之【代理模式】【享元模式】【桥接模式】【适配器模式】【外观模式】【组合模式】【装饰模式】</title>
    <link href="http://blogs.qiulig.website/2019/07/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/结构型模式之【代理模式】【享元模式】【桥接模式】【适配器模式】【外观模式】【组合模式】【装饰模式】/</id>
    <published>2019-07-27T09:31:18.000Z</published>
    <updated>2019-07-27T09:35:12.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><code>代理模式</code></h2><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote><p>&emsp;（1）<strong>抽象角色</strong>(Subject)：通过接口或抽象类声明真实角色实现的业务方法。<br>&emsp;（2）<strong>代理角色</strong>（Proxy）：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。<br>&emsp;（3）<strong>真实角色</strong>(RealSubject)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p><a id="more"></a></blockquote><h3 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h3><blockquote><ul><li>（1）<strong>远程代理</strong>。为一个位于不同的地址空间的对象提供一个本地的代理对象。这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。这样可以隐藏一个对象存在于不同地址空间的事实，使得客户端可以访问在远程机器上的对象。</li><li><p>（2）<strong>虚拟代理</strong>。根据需要创建开销很大的对象。如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时</p><pre><code>才会被真正创建。</code></pre></li><li>（3）<strong>安全代理</strong>。用来控制真实对象访问时的权限。</li><li>（4）<strong>智能指引</strong>。当调用真实对象时，代理处理另外的一些事。</li></ul></blockquote><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>&emsp;&emsp;Spring 的AOP</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>   &emsp;&emsp;1.职责清晰：  真实角色就是实现实际的业务逻辑，不用关心其他非本职的事物<br>&emsp;&emsp;2.高扩展性：  真实角色可以随时更换或扩展，只需要实现接口就行，而代理不需要有任何变化</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>  &emsp;(1)由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。<br>    &emsp;(2)实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>&emsp;&ensp;由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Proxy proxy=<span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之前的预处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之后的后续处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>在实现阶段不需要关心代理谁，在运行阶段会动态生成一个代理类去代理指定的对象</p></blockquote><p><strong>默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用CGlib来生成代理</strong></p><h3 id="1-jdk动态代理：接口-InvocationHandler-目标对象"><a href="#1-jdk动态代理：接口-InvocationHandler-目标对象" class="headerlink" title="(1)jdk动态代理：接口+InvocationHandler+目标对象"></a>(1)jdk动态代理：<strong>接口+InvocationHandler+目标对象</strong></h3><blockquote><p>&emsp;主要用到java.lang.reflect中的两个类：<strong>‘Proxy和InvocationHandler’</strong><br>InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类代码，动态的将横切逻辑与业务逻辑编织在一起<br>     &emsp;&emsp;1.定义业务逻辑接口<br>    &emsp;&emsp;2.实现业务逻辑接口创建业务实现类<br>     &emsp;&emsp;3.实现（implements）InvacationHandler代理接口，创建代理类<br>     &emsp;&emsp;4.创建业务类和代理类对象，通过代理类对象.bind(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。<br><strong>缺点</strong>：要求目标类必须实现对应方法非接口，它<strong>只能为接口创建代理</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvocationHandler + invoke()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理类的实例</span></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="comment">// 将被代理者的实例传进动态代理类的构造函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖InvocationHandler接口中的invoke()方法</span></span><br><span class="line"><span class="comment">     * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构</span></span><br><span class="line"><span class="comment">     * 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到</span></span><br><span class="line"><span class="comment">     * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊</span></span><br><span class="line"><span class="comment">     * 代码切入的扩展点了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * before ：doSomething();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object result = method.invoke(<span class="keyword">this</span>.obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * after : doSomething();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-cglib动态代理：接口或类-MethodInterceptor-目标对象"><a href="#2-cglib动态代理：接口或类-MethodInterceptor-目标对象" class="headerlink" title="(2)cglib动态代理：接口或类+MethodInterceptor+目标对象"></a>(2)cglib动态代理：<strong>接口或类+MethodInterceptor+目标对象</strong></h3><blockquote><p>主要用到java.lang.reflect中的两个类:’MethodInterceptor和CglibProcy’<br>    &emsp;1.定义业务类，无需实现接口（也可以实现）<br>     &emsp;2.实现MethodInterceptor方法代理接口，创建代理类<br>     &emsp;3.创建业务类和代理类对象，通过代理类对象.getInstance(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。<br>特点：<code>能代理类和接口，但是不能代理final类</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MethodIntercepter + intercept()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Proxy instance = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getInstance</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        sayBefore();</span><br><span class="line">        Object result = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">        sayAfter();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"before..."</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayAfter</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"after..."</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a><code>享元模式</code></h2><blockquote><p>&emsp;运用<strong>共享技术</strong>有效地支持<strong>大量细粒度对象的复用</strong>。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。<!--more--></p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><p>&emsp;在享元模式中引入了享元工厂类FlyweightFactory，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。<br>&emsp;<strong>享元工厂类：FlyweightFactory<br>&emsp;享元类：ConcreteFlyweight<br>&emsp;享元对象：Flyweight</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个HashMap用于存储享元对象，实现享元池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap flyweights = newHashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果对象存在，则直接从享元池获取</span></span><br><span class="line">        <span class="keyword">if</span>(flyweights.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>(Flyweight)flyweights.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Flyweight fw = newConcreteFlyweight();</span><br><span class="line">            flyweights.put(key,fw);</span><br><span class="line">            <span class="keyword">return</span> fw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><blockquote><p>&emsp;&emsp;当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。</p></blockquote><p>&emsp;<strong>1.String中的享元模式</strong></p><blockquote><p> &emsp;&emsp;Java中将String类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。</p></blockquote><p>&emsp;<strong>2.Integer中的享元模式</strong></p><blockquote><p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code>之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象</p></blockquote><p>&emsp; <strong>3.Long中的享元模式</strong></p><blockquote><p>与Integer原理类似</p></blockquote><p>&emsp;<strong>4.Apache Commons Pool2中的享元模式（对象池）</strong></p><blockquote><p>将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用，从而在一定程度上减少频繁创建对象所造成的开销。用于充当保存对象的“容器”的对象，被称为“对象池”</p></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a><code>桥接模式</code></h2><blockquote><p>&emsp;将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p></blockquote><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="string">'实现化'</span>（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</span><br><span class="line">- <span class="string">'具体实现化'</span>（Concrete Implementor）角色：给出实现化角色接口的具体实现。</span><br><span class="line">- <span class="string">'抽象化'</span>（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</span><br><span class="line">- <span class="string">'扩展抽象化'</span>（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</span><br></pre></td></tr></table></figure><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><blockquote><ul><li>(1) 由于抽象与实现分离，所以扩展能力强；</li><li><p>(2) 可动态的切换实现</p><p>&emsp;&emsp;&ensp;由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。</p></li><li>(3) 实现细节对客户端透明，可以对用户隐藏实现细节。</li></ul></blockquote><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><blockquote><ul><li>(1) 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</li><li>(2) 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。</li></ul></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><ul><li>(1)当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>(2)当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li><li>(3)当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li></ul></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Implementor imple=<span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs=<span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体实现化(Concrete Implementor)角色被访问"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Implementor imple;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.imple=imple;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(imple);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"扩展抽象化(Refined Abstraction)角色被访问"</span> );</span><br><span class="line">       imple.OperationImpl();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><code>适配器模式</code></h2><blockquote><p>&emsp;<code>将一个类的接口转换成客户希望的另外一个接口</code>。Adapter模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式分为<code>类结构型模式</code>和<code>对象结构型模式</code>两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p></blockquote><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>&emsp;对类适配器来说，更换适配器的实现过程比较复杂。</p><h3 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h3><ol><li><strong>目标（Target）接口</strong>：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li><strong>适配者（Adaptee）类</strong>：它是被访问和适配的现存组件库中的组件接口。</li><li><strong>适配器（Adapter）类</strong>：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ol><h3 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h3><p>适配器模式（Adapter）通常适用于以下场景。</p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>&emsp;<a href="https://blog.csdn.net/wwwdc1012/article/details/82780560" target="_blank" rel="noopener">https://blog.csdn.net/wwwdc1012/article/details/82780560</a></p><h4 id="1-spring-AOP中的适配器模式"><a href="#1-spring-AOP中的适配器模式" class="headerlink" title="(1)spring AOP中的适配器模式"></a>(1)spring AOP中的适配器模式</h4><blockquote><ul><li>在Spring的Aop中，使用的 Advice（通知） 来增强被代理类的功能。</li><li>Advice的类型有：MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice</li><li>在每个类型 Advice 都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptorSpring</li><li>需要将每个 Advice 都封装成对应的拦截器类型，返回给容器，所以需要<strong>使用适配器模式对 Advice 进行转换</strong></li></ul></blockquote><h4 id="2-spring-JPA中的适配器模式"><a href="#2-spring-JPA中的适配器模式" class="headerlink" title="(2)spring JPA中的适配器模式"></a>(2)spring JPA中的适配器模式</h4><blockquote><ul><li>在Spring的ORM包中，对于JPA的支持也是采用了适配器模式，首先定义了一个接口的 JpaVendorAdapter，然后不同的持久层框架都实现此接口。<ul><li>jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，因此最好在这里设置；</li><li>目前Spring提供 HibernateJpaVendorAdapter、OpenJpaVendorAdapter、EclipseLinkJpaVendorAdapter、TopLinkJpaVendorAdapter 四个实现。</li></ul></li><li>其中最重要的属性是 database，用来指定使用的数据库类型，从而能根据数据库类型来决定比如如何将数据库特定异常转换为Spring的一致性异常，目前支持如下数据库<ul><li>DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、SQL_SERVER、SYBASE</li></ul></li></ul></blockquote><h4 id="3-spring-MVC中的适配器模式"><a href="#3-spring-MVC中的适配器模式" class="headerlink" title="(3)spring MVC中的适配器模式"></a>(3)spring MVC中的适配器模式</h4><blockquote><p>Spring MVC中的适配器模式主要用于执行目标 Controller 中的请求处理方法。在Spring MVC中，<strong>DispatcherServlet 作为用户，HandlerAdapter 作为期望接口</strong>，具体的适配器实现类用于对目标类进行适配，<strong>Controller 作为需要适配的类。</strong></p></blockquote><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a><code>外观模式</code></h2><blockquote><p>&emsp;&emsp;<strong>为多个子系统提供一个统一的接口</strong>，而使这些子系统更加容易被访问的模式。降低系统的耦合度。<br>&emsp;&emsp;迪米特法则的典型应用，但是增加新的子系统可能需要修改外观类或客户端的源代码，<strong>违背了“开闭原则”</strong>。</p></blockquote><!--more--><h3 id="组成-3"><a href="#组成-3" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'外观'</span>（Facade）角色：为多个子系统对外提供一个共同的接口。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'子系统'</span>（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'客户'</span>（Client）角色：通过一个外观角色访问各个子系统的功能。</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><ul><li>(1) 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以<strong>简化子系统之间的依赖关系</strong>。</li><li>(2) 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>(3) 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而<strong>提高子系统的独立性和可移植性</strong>。</li></ul></blockquote><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Facade f=<span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1=<span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2=<span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3=<span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统01的method1()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统02的method2()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统03的method3()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a><code>组合模式</code></h2><blockquote><p>&emsp;有时又叫作<strong>部分-整体模式</strong>，将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p></blockquote><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ol><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这<strong>简化了客户端代码</strong>；</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，<strong>满足“开闭原则”；</strong></li></ol><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p> &emsp; 1.设计较复杂，客户端需要花更多时间理清类之间的层次关系；</p><p>  &emsp; 2.不容易限制容器中的构件；</p><p>  &emsp; 3.不容易用继承的方法来增加构件的新功能；</p><h3 id="组成-4"><a href="#组成-4" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'抽象构件'</span>（Component）角色：它的主要作用是为树叶构件和树枝构件<span class="string">'声明公共接口，并实现它们的默认行为'</span>。在透明式的组合模式中抽象</span><br><span class="line">    构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'树叶构件'</span>（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于<span class="string">'实现抽象构件角色中声明的公共接口'</span>。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'树枝构件'</span>（Composite）角色：是组合中的分支节点对象，它有子节点。它<span class="string">'实现了抽象构件角色中声明的接口'</span>，它的主要作用是存储和管理</span><br><span class="line">    子部件，通常包含 Add()、Remove()、GetChild() 等方法。</span><br></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="emsp-1-透明式"><a href="#emsp-1-透明式" class="headerlink" title="&emsp; (1) 透明式"></a>&emsp; (1) 透明式</h4><blockquote><p>&emsp; <strong>抽象构件声明了所有子类中的全部方法</strong>，包括add,remove等，使树叶和树枝具备完全一致的行为接口。所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。<br>&emsp;<strong>缺点</strong>：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会<strong>带来一些安全性问题</strong>。</p></blockquote><h4 id="emsp-2-安全式"><a href="#emsp-2-安全式" class="headerlink" title="&emsp;(2) 安全式"></a>&emsp;(2) 安全式</h4><blockquote><p>&emsp;<strong>抽象构件不去声明add、remove方法</strong>，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题。<br>&emsp; <strong>缺点</strong>：由于不够透明，树叶和树枝不具备相同的接口，客户端的调用需要做相应的判断<strong>带来不便。</strong></p></blockquote><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>  &emsp; 1.在需要表示一个对象整体与部分的层次结构的场合。</p><p>  &emsp; 2.要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。<br>&emsp;&emsp;Java  AWT/Swing中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component c0=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component c1=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">"1"</span>); </span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">"2"</span>); </span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">"3"</span>);          </span><br><span class="line">        c0.add(leaf1); </span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2); </span><br><span class="line">        c1.add(leaf3);          </span><br><span class="line">        c0.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123; &#125;           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123; &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"树叶"</span>+name+<span class="string">"：被访问！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children=<span class="keyword">new</span> ArrayList&lt;Component&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a><code>装饰模式</code></h2><p>&emsp;指在不改变现有对象结构的情况下，<strong>动态地给该对象增加一些职责</strong>（即增加其额外功能）的模式，它属于对象结构型模式。<br>&emsp;就增加功能来说，装饰模式比生成子类更为灵活。</p><!--more--><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><ul><li>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。</li><li>如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。</li></ul><h3 id="组成-5"><a href="#组成-5" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-   <span class="string">'抽象构件'</span>（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</span><br><span class="line">-   <span class="string">'具体构件'</span>（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</span><br><span class="line">-   <span class="string">'抽象装饰'</span>（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</span><br><span class="line">-   <span class="string">'具体装饰'</span>（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</span><br></pre></td></tr></table></figure><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>当需要给一个<strong>现有类添加附加职责</strong>，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li><li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用<strong>继承关系很难实现</strong>，而采用装饰模式却很好实现。</li><li>当对象的<strong>功能要求可以动态地添加，也可以再动态地撤销时</strong>。</li></ul><h3 id="实际中的应用"><a href="#实际中的应用" class="headerlink" title="实际中的应用"></a>实际中的应用</h3><blockquote><p> Java I/O 标准库的设计。例如，</p><ul><li>(1) InputStream 的子类 FilterInputStream，</li><li>(2) OutputStream 的子类 FilterOutputStream，</li><li>(3) Reader 的子类BufferedReader 以及 FilterReader，</li><li>(4) Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</li></ul></blockquote><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component p=<span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        Component d=<span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建具体构件角色"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用具体构件角色的方法operation()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component=component;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为具体构件角色增加额外的功能addedFunction()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;&lt;code&gt;代理模式&lt;/code&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;（1）&lt;strong&gt;抽象角色&lt;/strong&gt;(Subject)：通过接口或抽象类声明真实角色实现的业务方法。&lt;br&gt;&amp;emsp;（2）&lt;strong&gt;代理角色&lt;/strong&gt;（Proxy）：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。&lt;br&gt;&amp;emsp;（3）&lt;strong&gt;真实角色&lt;/strong&gt;(RealSubject)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>2019届华为秋招笔试题【数字反转相加】【消除重复数字】【仿LISP运算】</title>
    <link href="http://blogs.qiulig.website/2019/07/2019%E5%B1%8A%E5%8D%8E%E4%B8%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC%E7%9B%B8%E5%8A%A0%E3%80%91%E3%80%90%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E3%80%91%E3%80%90%E4%BB%BFLISP%E8%BF%90%E7%AE%97%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/2019届华为秋招笔试题【数字反转相加】【消除重复数字】【仿LISP运算】/</id>
    <published>2019-07-27T09:24:29.000Z</published>
    <updated>2019-07-27T09:25:59.578Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数字反转相加"><a href="#数字反转相加" class="headerlink" title="数字反转相加"></a><code>数字反转相加</code></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请您写一个 reversoAdd函数，该函数根据输入的两个正整数a和b, 字按照高位在右边的方式反转后求和。<br>例如，reverseAdd(123, 456) == 321 + 654 = 975</p><a id="more"></a><p><strong>输入描述:</strong><br>函数原型: int reverseAdd (int a, int b);<br><strong>输入:</strong><br>输入的a, b参数均为有效取值范围[1, 70000]区间上的正整数。100和200反转后的值为1和2 (前导0被忽略)<br><strong>输出描述:</strong><br> <strong>输出:</strong><br>通过函数返回值输出结果。<br>若输入的a或b参数超出了取值范围(小于1或者大于70000)，则应输出-1:否则应按照要求输出数字反转后的和。<br>注意:最终交付的函数代码中不要向控制台打印输出任何信息。<br><strong>输入样例:</strong><br>123, 456<br><strong>输出样例:</strong><br>975</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>想法就是把它变成String类型，再利用String类型的reverse()函数进行反转，再将其变成Integer类型进行运算</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> b = sr.nextInt();</span><br><span class="line">        reverseAdd(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">reverseAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((a&lt;=<span class="number">1</span> &amp;&amp; a&gt;=<span class="number">70000</span>) || (b&lt;=<span class="number">1</span> &amp;&amp; b&gt;=<span class="number">70000</span>))</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           String  str1 =<span class="keyword">new</span> StringBuilder(a +<span class="string">""</span>).reverse().toString();</span><br><span class="line">           String str2 =<span class="keyword">new</span> StringBuilder( b +<span class="string">""</span>).reverse().toString();</span><br><span class="line">           <span class="keyword">return</span> Integer.parseInt(str1) +Integer.parseInt(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消除重复数字"><a href="#消除重复数字" class="headerlink" title="消除重复数字"></a><code>消除重复数字</code></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个正整数，给出消除重复数字以后最大的整数<br><strong>输入描述:</strong><br>正整数，注意考虑长整数<br><strong>输出描述:</strong><br>消除重复数字以后的最大整数输入样例:423234输出样例:432</p></blockquote><h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：（垃圾选手第一式，复杂度高）</p><blockquote><ul><li>用list1存放出现一次的数字，用list2存放重复的数字。然后将他们放到优先队列自动排序，因为优先队列从小到大排序的，所以重写它的比较方法new Comparator()…,最后再依次将他们按顺序加到res里面</li></ul></blockquote><p>方法2：</p><blockquote><ul><li>桶排序思想，因为数字无疑就是0-9，所以创建一个长度为10的数组，将每个数字依次入桶。桶中不为空代表这个常整数有该值，然后将桶内的数依次拼凑成最大的数。count[0] ~count[9]依次存放0-9</li><li>设置一个list存放一共出现了几个不同的数了，当list.size == 10,代表所有数字都出现过了，后面再怎么出现的数都是重复的。可以提前终止while语句。</li></ul></blockquote><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">long</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放出现一次的数</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存放重复的数</span></span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (<span class="keyword">int</span>)a % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (!list1.contains(temp) &amp;&amp; !list2.contains(temp)) &#123;</span><br><span class="line">                list1.add(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list1.remove(Integer.valueOf(temp));</span><br><span class="line">                list2.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            a = a / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现Comparator,将优先队列从大到小排列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2-o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list1.size();i++)&#123;</span><br><span class="line">            queue.add(list1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list2.size();i++)&#123;</span><br><span class="line">            queue.add(list2.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//利用桶计数方法，判断哪个值出现过</span></span><br><span class="line">        <span class="keyword">int</span> count[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//用来计数，如果前面出现了0-9的所有数，则提前结束循环</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (a!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp =(<span class="keyword">int</span>) a%<span class="number">10</span>;</span><br><span class="line">            count[temp]++;</span><br><span class="line">            <span class="comment">//list里面存放没出现的值</span></span><br><span class="line">            <span class="keyword">if</span>(!list.contains(temp))&#123;</span><br><span class="line">                list.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否提前结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a = a / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果的生成</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = count.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                res = res*<span class="number">10</span> + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="仿LISP运算"><a href="#仿LISP运算" class="headerlink" title="仿LISP运算"></a><code>仿LISP运算</code></h2><h3 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp;LISP语言唯一的语法就是括号要配对。<br>&emsp;形如 (OP P1 P2 …)，括号内元素由单个空格分割。<br>&emsp;其中第一个元素OP为操作符，后续元素均为其参数，参数个数取决于操作符类型<br>&emsp;注意：参数 P1, P2 也有可能是另外一个嵌套的 (OP P1 P2 …)<br>&emsp;当前OP类型为add/sub/mul/div(全小写)，分别代表整数的加减乘除法。简单起见，所以OP参数个数为2<br><strong>举例</strong><br>&emsp;&emsp;输入：(mul 3 -7)输出：-21<br>&emsp;&emsp;输入：(add 1 2) 输出：3<br>&emsp;&emsp;输入：(sub (mul 2 4) (div 9 3)) 输出 ：5<br>&emsp;&emsp;输入：(div 1 0) 输出：error<br><strong>输入描述</strong>：<br>&emsp;&emsp;合法C字符串，字符串长度不超过512，用例保证了无语法错误<br><strong>输出描述</strong>：<br>&emsp;&emsp;合法C字符串，字符包括’0’-‘9’及负号’-‘或者’error’</p></blockquote><h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>按照题意模拟语法运算规则</p></blockquote><h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sr.nextLine();</span><br><span class="line">        solution(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; operStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> paramOne = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> paramTwo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> chas = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(chas == <span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="comment">//截取符号位</span></span><br><span class="line">                operStack.push(str.substring(i+<span class="number">1</span>,i+<span class="number">4</span>));</span><br><span class="line">                <span class="comment">//这里为空格的索引位置</span></span><br><span class="line">                i = i + <span class="number">4</span>;</span><br><span class="line">                <span class="comment">//符号位后第一个数字的索引坐标</span></span><br><span class="line">                mark = i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chas == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mark &lt; i)&#123;</span><br><span class="line">                    <span class="comment">//所有数字的截取</span></span><br><span class="line">                    numStack.push(Integer.valueOf(str.substring(mark,i)));</span><br><span class="line">                    i++;</span><br><span class="line">                    mark = i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//得到一次（）的对应，就进行一次计算</span></span><br><span class="line">                paramOne = numStack.pop();</span><br><span class="line">                paramTwo = numStack.pop();</span><br><span class="line">                calc(numStack,operStack,paramOne,paramTwo);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//空格位将数字进行区分</span></span><br><span class="line">                <span class="keyword">if</span>(chas == <span class="string">' '</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mark &lt; i )&#123;</span><br><span class="line">                        numStack.push(Integer.valueOf(str.substring(mark,i)));</span><br><span class="line">                        <span class="comment">//下一个数字的索引为空格后面一位，故mark = i+1;</span></span><br><span class="line">                        mark = i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果还有没计算完的，就进行再次计算</span></span><br><span class="line">        <span class="keyword">while</span> (!operStack.isEmpty())&#123;</span><br><span class="line">            paramTwo = numStack.pop();</span><br><span class="line">            paramOne = numStack.pop();</span><br><span class="line">            calc(numStack,operStack,paramOne,paramTwo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(Stack&lt;Integer&gt; numStack, Stack&lt;String&gt; operStack, <span class="keyword">int</span> paramOne, <span class="keyword">int</span> paramTwo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(operStack.pop())&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                numStack.push(paramOne + paramTwo);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sub"</span>:</span><br><span class="line">                numStack.push(paramOne - paramTwo);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"mul"</span>:</span><br><span class="line">                numStack.push(paramOne * paramTwo);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"div"</span>:</span><br><span class="line">                <span class="keyword">if</span>(paramTwo == <span class="number">0</span>)</span><br><span class="line">                    System.out.println(<span class="string">"error"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    numStack.push(paramOne / paramTwo);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目及代码整理自牛客技术资料<br>如有错误请指出！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数字反转相加&quot;&gt;&lt;a href=&quot;#数字反转相加&quot; class=&quot;headerlink&quot; title=&quot;数字反转相加&quot;&gt;&lt;/a&gt;&lt;code&gt;数字反转相加&lt;/code&gt;&lt;/h2&gt;&lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;请您写一个 reversoAdd函数，该函数根据输入的两个正整数a和b, 字按照高位在右边的方式反转后求和。&lt;br&gt;例如，reverseAdd(123, 456) == 321 + 654 = 975&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔试题" scheme="http://blogs.qiulig.website/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2019届百度秋招笔试题【混战世界】【字符串计数】</title>
    <link href="http://blogs.qiulig.website/2019/07/2019%E5%B1%8A%E7%99%BE%E5%BA%A6%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E6%B7%B7%E6%88%98%E4%B8%96%E7%95%8C%E3%80%91%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E6%95%B0%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/2019届百度秋招笔试题【混战世界】【字符串计数】/</id>
    <published>2019-07-27T09:21:52.000Z</published>
    <updated>2019-07-27T09:23:54.671Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="混战世界"><a href="#混战世界" class="headerlink" title="混战世界"></a><code>混战世界</code></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp;战乱年代。整个世界各个军阀的英团泄战，你是P7军团的战略参谋，你手下n(保证为3的倍数)个士兵，第i个土兵的物理攻击数值为Ai，魔法攻击数值为Bi，你需要将这些士兵三等分为三个连，<a id="more"></a></p><ul><li>第一个连需要去物理空间参加物理对抗战争，战斗力估值W1为士兵的物理攻击数值之和:</li><li>第二个连需要去魔法空间参加魔法对抗战争，战斗力估值W2为士兵的魔法攻击数值之和:</li><li>第三个连需要去虚幻空间参加物理魔法装备的综合对抗战争，战斗力估值W3为所有士兵的物理攻击数值、魔法攻击数值之和除以2。</li></ul><p>你希望W1+W2+W3最大。这样才最有可能胜利。<br><strong>输入描述:</strong><br>&emsp;第一行一个整数n，保证为3的倍数。(3≤n≤1000）<br>&emsp; 第二行n个整数， 第i个数表示Ai。<br>&emsp; 第三行n个整数，第i个数表示Bi。(I≤Ai，  Di≤1000)<br><strong>输出描述:</strong><br>&emsp;一个小数，表示最大数之和,保留两位小数(四舍五入)。<br><strong>输入样例:</strong><br>&emsp;6<br>&emsp;1   7   3   4   5   9<br>&emsp;2   3   9   4   3   3<br>输出样例:<br>&emsp;35.00</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>设一个人的物理值为A,魔法值为B.<br>派去一连可得A的贡献，二连可得B, 三连可得(A+B)/2。</p><ul><li>去一连与去三连相比差了(A-B)/2.去二连比去三连也差(A-B)/2。这样，可以根据每个人的A-B数值进行排序，</li><li>由题意可知，A越大越适合去1连，B越大越适合去2连，故（A-B）/2中，较大者1连，较小者去2连，中间的去3连。</li></ul></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int a[] = &#123;1,7,3,4,5,9&#125;;</span></span><br><span class="line"><span class="comment">//        int b[] = &#123;2,3,9,4,3,3&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(String.format("%.2f",solution(a,b)));</span></span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> b[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          a[i] = sr.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          b[i] = sr.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        solution(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[])</span></span>&#123;</span><br><span class="line">        Diff []list= <span class="keyword">new</span> Diff[A.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            list[i] = <span class="keyword">new</span> Diff(i,A[i] - B[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//里面的list已经从小到大排序了</span></span><br><span class="line">        Arrays.sort(list);</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//取值,较小的去2连，中间的去三连，较大的去1连</span></span><br><span class="line">        <span class="keyword">int</span> Avglen = list.length/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">            <span class="comment">//（A-B）较小者去2连</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>&lt;=i &amp;&amp; i&lt;Avglen )&#123;</span><br><span class="line">                res += B[list[i].index];</span><br><span class="line">                <span class="comment">//（A-B）中间者去3连,这里注意要乘个1.0,避免除以2会强转为int型</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= Avglen &amp;&amp; i&lt; <span class="number">2</span> *Avglen )&#123;</span><br><span class="line">                res += ((A[list[i].index] + B[list[i].index])*<span class="number">1.0</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//(A-B)较大者去1连</span></span><br><span class="line">                res += A[list[i].index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.00"</span>);</span><br><span class="line">        System.out.println(df.format(res));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于存储索引坐标以及（Ai-Bi）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Diff</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Diff</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照（A-B）/2 进行排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">          Diff diff = (Diff) o;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">this</span>.value &gt; diff.value)</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.value == diff.value)</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190725102038741.png" alt="在这里插入图片描述"></p><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><blockquote><p>java里面保留数值的位数(四舍五人)<br>方法1：<br>  &emsp; &emsp;System.out.println(String.format(“%.2f”,num));<br> 方法2：<br>  &emsp; &emsp;DecimalFormat df = new DecimalFormat(“#.00”);<br> &emsp;  &emsp;System.out.println(df.format(num));</p></blockquote><h2 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a><code>字符串计数</code></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp; 给定一个仅由小写字母组成且长度不超过10^6的字符串，将首字符移到末尾并记录所得的字符串，不断重复该操作，虽然记录了无限个字符串，但其中不同字符串的数目却是有限的，那么一共记录了多少个不同的字符串？<br> &emsp;<strong>样例输入</strong><br>&emsp;&emsp; abab<br>&emsp;<strong>样例输出</strong><br>&emsp;&emsp; 2<br>&emsp;<strong>样例解释</strong><br>&emsp;&emsp; 记录了abab和baba这2个不同的字符串。</p></blockquote><h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：对字符串不断进行重组，对不同的字符串进行入队，最后返回队列的大小即为不同的字符串个数</p></blockquote><blockquote><p>方法2：利用kmp算法的next数组，可以求出字符串的最小循环周期T，这就是答案</p></blockquote><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sr.nextLine();</span><br><span class="line">        System.out.println(solution(str));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.trim().equals(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String temp = str;</span><br><span class="line">            list.add(str);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">                <span class="comment">//首字符移到末尾并记录所得的字符串，</span></span><br><span class="line">                temp = temp.substring(<span class="number">1</span>,temp.length())+temp.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//如果list里面没有该字符串则加入list</span></span><br><span class="line">                <span class="keyword">if</span>(!list.contains(temp))&#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>请检查是否存在数组越界等非法访问情况<br>case通过率为50.00%<br><br><br>不知道哪里错了。哭泣</p></blockquote><p>方法2：KMP算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sr.nextLine();</span><br><span class="line">        System.out.println(kmp(str));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">int</span> [] next = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len )&#123;</span><br><span class="line">            <span class="keyword">if</span>(k== -<span class="number">1</span> || str.charAt(k) == str.charAt(j))&#123;</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀，这里next[len]表示len-1之前的模式串，即为str时,有k的相同的前缀和后缀</span></span><br><span class="line">        <span class="comment">//所以循环周期T为 总长度-相同前缀数</span></span><br><span class="line">        <span class="keyword">int</span> res = len % (len - next[len]);</span><br><span class="line">        <span class="keyword">if</span>(res != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> len-next[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019072510251487.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;混战世界&quot;&gt;&lt;a href=&quot;#混战世界&quot; class=&quot;headerlink&quot; title=&quot;混战世界&quot;&gt;&lt;/a&gt;&lt;code&gt;混战世界&lt;/code&gt;&lt;/h2&gt;&lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;战乱年代。整个世界各个军阀的英团泄战，你是P7军团的战略参谋，你手下n(保证为3的倍数)个士兵，第i个土兵的物理攻击数值为Ai，魔法攻击数值为Bi，你需要将这些士兵三等分为三个连，&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔试题" scheme="http://blogs.qiulig.website/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="kmp算法" scheme="http://blogs.qiulig.website/tags/kmp%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2019届爱奇艺秋招笔试题【局长的食物】【清雨的自助餐】【库特君的面条】</title>
    <link href="http://blogs.qiulig.website/2019/07/2019%E5%B1%8A%E7%88%B1%E5%A5%87%E8%89%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E5%B1%80%E9%95%BF%E7%9A%84%E9%A3%9F%E7%89%A9%E3%80%91%E3%80%90%E6%B8%85%E9%9B%A8%E7%9A%84%E8%87%AA%E5%8A%A9%E9%A4%90%E3%80%91%E3%80%90%E5%BA%93%E7%89%B9%E5%90%9B%E7%9A%84%E9%9D%A2%E6%9D%A1%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/2019届爱奇艺秋招笔试题【局长的食物】【清雨的自助餐】【库特君的面条】/</id>
    <published>2019-07-27T09:20:15.000Z</published>
    <updated>2019-07-27T09:21:21.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="局长的食物"><a href="#局长的食物" class="headerlink" title="局长的食物"></a><code>局长的食物</code></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp; 每天局长会吃一份食物，或者买一份食物（即每天只能进行吃或买其中的一种动作），这样过了M天现在局长想知道M天后第p种食物的份数排名（从大到小，相同算并列，例如3 3 2，则排名为1 1 3）N,M,P&lt;=100,Ai&lt;=1000。<a id="more"></a><br><strong>输入描述</strong>：<br>&emsp;第一行N M P<br>&emsp;第二行N个数Ai<br>&emsp;接下来M行，每行Ai或者Bi分别表示买一份食物i，吃一份食物i<br><strong>输出</strong><br>&emsp;一个答案<br><strong>输入样例:</strong><br>&emsp;3 4 2 5 3 1 B 1 A 2 A 2 A 3<br><strong>输出样例</strong>：<br>&emsp;1</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：<br>&emsp;&emsp;&emsp;模拟吃东西的过程：关键在于吃一份食物还是买一份食物数据的存储方式，本次的数据存储方式为 List&lt;List&lt; String &gt; &gt;,注意后面的Integer.parseInt的转型。更好的方法是用对象存储<br>方法2：<br>&emsp;&emsp;&emsp; 用class存储数据</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1: 用List&lt;List&lt; String &gt; &gt;存储数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> M  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> P  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            a[i] = sr.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            List&lt;String&gt; temp= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            temp.add(sr.next());</span><br><span class="line">            temp.add(sr.next());</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(solution(list,P,a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">solution</span><span class="params">(List&lt;List&lt;String&gt;&gt; list, <span class="keyword">int</span> p, <span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="comment">// 买一份食物</span></span><br><span class="line">            <span class="keyword">if</span>(list.get(i).get(<span class="number">0</span>).equals( <span class="string">"A"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> index = Integer.parseInt(list.get(i).get(<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">                a[index] ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//吃一份食物</span></span><br><span class="line">                <span class="keyword">int</span> index = Integer.parseInt(list.get(i).get(<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">                a[index] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第p种食物的份数排名</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p-<span class="number">1</span>]&lt;a[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190725105531311.png" alt="在这里插入图片描述"><br>方法2：用对象存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> <span class="keyword">import</span> java.util.List;</span><br><span class="line"> <span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> M  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> P  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            a[i] = sr.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Category&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> Category(sr.next(),sr.nextInt()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(solution(lists,P,a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">solution</span><span class="params">(List&lt;Category&gt; lists, <span class="keyword">int</span> p, <span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class="line">            <span class="comment">//买一份食物</span></span><br><span class="line">            <span class="keyword">if</span>(lists.get(i).x.equals(<span class="string">"A"</span>))&#123;</span><br><span class="line">                a[lists.get(i).getIndex()-<span class="number">1</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//吃一份食物</span></span><br><span class="line">                a[lists.get(i).getIndex()-<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第p种食物的份数排名</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p-<span class="number">1</span>]&lt;a[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//存储 [A 2] 等数据</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Category</span></span>&#123;</span><br><span class="line">    String x;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Category</span><span class="params">(String x, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190725105625850.png" alt="在这里插入图片描述"></p><h2 id="清雨的自助餐"><a href="#清雨的自助餐" class="headerlink" title="清雨的自助餐"></a><code>清雨的自助餐</code></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp; 清雨又在吃自助餐了。<br>&emsp;排在清雨面前的有N种食物，排成一排，清雨可以选择其中的若干种食物，但是不能连续选择相邻的食物。因为清雨很挑食，当所有食物都不合口味时，他可以一种都不选，即一个都不选也算为一种方法。<br>请问他有多少种选择食物的方法呢？<br><strong>输入</strong><br>&emsp;一个整数n（1 &lt;= n &lt;= 90）<br><strong>输出</strong><br>&emsp;一个正整数表示答案<br><strong>样例输入</strong><br>&emsp;3<br><strong>样例输出</strong><br>&emsp;5</p></blockquote><h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><blockquote><p>动态规划问题：dp[i]表示有(i+1)种食物的时候有多少种选择的方法</p><ul><li>初始化<ul><li>dp[0]  = 2，表示有1种食物，可以选择吃或者不吃2种方法</li><li>dp[1] = 3,表示有两种食物，可以选择不吃，吃第一种，吃第二种 3种方法</li></ul></li><li>动态规划状态转移矩阵<ul><li>如果选这个食物(第i+1种食物)，则选择为dp[i-2]种选法，若不选择这个食物,则方法数为dp[i-1]{因为相邻而不能选}即</li><li>dp[i] = dp[i-2] + dp[i-1]; </li></ul></li></ul></blockquote><p>注：该题也可以用斐波那契数列的应用，只是初始值变了，具体参看剑指offer_【7】斐波那契数组:<a href="https://blog.csdn.net/qq_17556191/article/details/94436130" target="_blank" rel="noopener">https://blog.csdn.net/qq_17556191/article/details/94436130</a></p><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sr.nextInt();</span><br><span class="line">        System.out.println(solution(N));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> dp[] = <span class="keyword">new</span> <span class="keyword">long</span>[num];</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//只有一种食物，可以选择 吃 或者不吃2种方法</span></span><br><span class="line">            dp[<span class="number">1</span>] = <span class="number">3</span>;  <span class="comment">//有2种食物，选择 不吃 ，吃第一种食物，吃第二种食物。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num; i++) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[num - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/2019072510531954.png" alt="在这里插入图片描述"></p><h2 id="库特君的面条"><a href="#库特君的面条" class="headerlink" title="库特君的面条"></a><code>库特君的面条</code></h2><h3 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>题目描述：<br>库特君在吃面条！<br>&emsp;他将面条放在了数轴上，每根面条对应数轴上的两个点a和b，他想知道在任意两根面条不重叠(端点可以重叠）的情况下最多能选出多少根面条。<br>1 &lt;= n &lt;= 100<br>-999 &lt;= a<br><strong>输入描述：</strong><br>&emsp;&emsp;第一行为一个整数N<br>&emsp;&emsp;接下来，N行每行N个整数a和b<br><strong>输出描述：</strong><br>&emsp;&emsp;一个数的答案<br><strong>输出样例</strong>：<br>&emsp;&emsp;3   6  3  1  3  2  5<br><strong>输出样例：</strong><br>&emsp;&emsp;2</p></blockquote><h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>贪心算法的区间调度问题</p><ul><li>贪心策略：在不与已选区域重叠的前提下，优先选择右端点最小的区间，所以按照区间右端点排序后，依次检查，不重叠就选择，并更新已选区域的最右端，方便判断重叠。</li></ul><p>算法设计：</p><ul><li>如果被检查的活动i的开始时间小于最近选择的活动j的结束时间，则不选择活动i,否则选择活动i<ul><li>1.选择最早结束的面条，便是最开始要选择的没有重叠的第一根面条</li><li>2.选择第一根面条结束后[右端点值]才开始的第二根面条[该面条的左端点大于等于第一根面条的右端点]，并且此时右端点结束最早的面条，这将是要选择的第二根面条。</li><li>3.更新右端点值，重复以上。</li></ul></li></ul></blockquote><h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//贪心算法的区间调度问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sr.nextInt();</span><br><span class="line">        List&lt;Work&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = sr.nextInt();</span><br><span class="line">            <span class="keyword">int</span> x2 = sr.nextInt();</span><br><span class="line">            <span class="comment">//题目说了x1&lt;x2,但是给出的样例出现了问题，故用个if语句</span></span><br><span class="line">            <span class="keyword">if</span>(x1&lt;x2)</span><br><span class="line">                lists.add(<span class="keyword">new</span> Work(x1,x2));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lists.add(<span class="keyword">new</span> Work(x2,x1));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(solution(lists));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//解决方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(List&lt;Work&gt; works)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//works里面已经按end从小到大排序了，这时在将start进行排序，找到第一个要进行的工作</span></span><br><span class="line">        Collections.sort(works);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前工作的结束时间</span></span><br><span class="line">        <span class="keyword">int</span> endTime = works.get(<span class="number">0</span>).getEnd();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;works.size();i++)&#123;</span><br><span class="line">            <span class="comment">// 第二根面条的开始时间大于第一个面条的结束时间</span></span><br><span class="line">            <span class="keyword">if</span>(endTime&lt;=works.get(i).getStart())&#123;</span><br><span class="line">                <span class="comment">//这个面条可选，没有覆盖之前的面条</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//更新右端点</span></span><br><span class="line">                endTime = works.get(i).getEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//end 从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Work work = (Work) o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.end &gt; work.getEnd())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.end == work.getEnd())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190725103625192.png" alt="在这里插入图片描述"><br>题目整理自牛客技术篇<br>个人想法，如有错误请指出！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;局长的食物&quot;&gt;&lt;a href=&quot;#局长的食物&quot; class=&quot;headerlink&quot; title=&quot;局长的食物&quot;&gt;&lt;/a&gt;&lt;code&gt;局长的食物&lt;/code&gt;&lt;/h2&gt;&lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp; 每天局长会吃一份食物，或者买一份食物（即每天只能进行吃或买其中的一种动作），这样过了M天现在局长想知道M天后第p种食物的份数排名（从大到小，相同算并列，例如3 3 2，则排名为1 1 3）N,M,P&amp;lt;=100,Ai&amp;lt;=1000。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔试题" scheme="http://blogs.qiulig.website/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="http://blogs.qiulig.website/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2019届vivo秋招笔试题【字符串排序】【链表奇数位正序偶数位逆序】【最长回文子串】</title>
    <link href="http://blogs.qiulig.website/2019/07/2019%E5%B1%8Avivo%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E3%80%91%E3%80%90%E9%93%BE%E8%A1%A8%E5%A5%87%E6%95%B0%E4%BD%8D%E6%AD%A3%E5%BA%8F%E5%81%B6%E6%95%B0%E4%BD%8D%E9%80%86%E5%BA%8F%E3%80%91%E3%80%90%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/2019届vivo秋招笔试题【字符串排序】【链表奇数位正序偶数位逆序】【最长回文子串】/</id>
    <published>2019-07-27T09:17:19.000Z</published>
    <updated>2019-07-27T09:19:45.558Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a><code>字符串排序</code></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>请对组字符串进行排序，字符串由大小写字母和数字组成，需要满足以下比较规则</p><ul><li>1、长度不同时，长度较短在排前面</li><li>2、长度相同时，按照字典顺序排列（AaBb-Zz, 0-9顺序)，即大写字母在小写字母前，数字排在字母后，要求时间复杂度为O(nlogn)。<a id="more"></a></li></ul><p>比如:<br> abc Abc 123 1bc CBD abed a<br>排序后结果为:<br>a  1  Abc abc  CBD 1bc 123 abcd</p><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>ASCII码：0-9（对应数值48-59）；A-Z（对应数值65-90）；a-z（对应数值97-122）；<br>排序为（AaBb-Zz, 0-9顺序),不符合常规字典排序，故这里我重新定义了ASCII码，因为A和a的ascii码相差32，这里定义A的ascii码为32，依次排序为<br>| 字符 | 重新定义的ASCII码 | 字符 | 重新定义的ASCII码 | 字符 | 重新定义的ASCII码 |<br>| — | — | — | — | — | — |<br>| A | 32 | L | 54 | v | 75 |<br>| a | 33 | l | 55 | W | 76 |<br>| B | 34 | M | 56 | w | 77 |<br>| b | 35 | m | 57 | X | 78 |<br>| C | 36 | N | 58 | x | 79 |<br>| c | 37 | n | 59 | Y | 80 |<br>| D | 38 | O | 60 | y | 81 |<br>| d | 39 | o | 61 | Z | 82 |<br>| E | 40 | P | 62 | z | 83 |<br>| e | 41 | p | 63 | 0 | 84 |<br>| F | 42 | Q | 64 | 1 | 85 |<br>| f | 43 | q | 65 | 2 | 86 |<br>| G | 44 | R | 66 | 3 | 87 |<br>| g | 45 | r | 67 | 4 | 88 |<br>| H | 46 | S | 68 | 5 | 89 |<br>| h | 47 | s | 69 | 6 | 90 |<br>| I | 48 | T | 70 | 7 | 91 |<br>| i | 49 | t | 71 | 8 | 92 |<br>| J | 50 | U | 72 | 9 | 93 |<br>| j | 51 | u | 73 |  |  |<br>| K | 52 | V | 74 |  |  |<br>| k | 53 |  |  |  |  |<br>故可以根据原来的ascii推出现在定义的ASCII码：</p><ul><li>(1) 假设字符为 A-Z,则有 ascii = (str1.charAt(i) - ‘A’) * 2 + 32;</li><li>(2) 假设字符为 a-z,则有 ascii = (str1.charAt(i) - ‘a’) * 2 + 33;</li><li>(3) 假设字符为 0-9,则有 ascii = str1.charAt(i) + 36;</li></ul><blockquote><p>(1) 用TreeSet存储字符串，因为TreeMap会自动给其排序<br>(2) 重写Compare方法，将其长度按照从小到大排序</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[]arr = &#123;<span class="string">"abc"</span>,<span class="string">"Abc"</span>,<span class="string">"123"</span>,<span class="string">"1"</span>,<span class="string">"1bc"</span>,<span class="string">"CBD"</span>,<span class="string">"abcd"</span>,<span class="string">"a"</span>&#125;;</span><br><span class="line">        Set strSet = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                String str1 = (String) o1;</span><br><span class="line">                String str2 = (String) o2;</span><br><span class="line">                <span class="keyword">int</span> temp = str1.length()-str2.length();</span><br><span class="line">                <span class="comment">//如果两个数组的长度相等则直接按字典序排列,但是这个字典序不是常规的[0-9 A-Z a-z ]</span></span><br><span class="line">                <span class="comment">//而是[AaBb-Zz 0-9]类型，故不能直接用str1.compareTo(str2)方法，要重新计算他的ascii码</span></span><br><span class="line">                <span class="comment">//如果两个数组的长度相等则直接按字典序排列</span></span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span>  t1=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span>  t2=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.length();i++)&#123;</span><br><span class="line">                        <span class="keyword">char</span> c1=str1.charAt(i);</span><br><span class="line">                        <span class="keyword">char</span> c2=str2.charAt(i);</span><br><span class="line">                        <span class="comment">//第一个字符串的新的ascii码计算</span></span><br><span class="line">                        <span class="comment">//A-Z范围，计算重新定义的ascii码 </span></span><br><span class="line">                        <span class="keyword">if</span>(c1&gt;=<span class="string">'A'</span>&amp;&amp;c1&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">                            t1 = (c1-<span class="string">'A'</span>) * <span class="number">2</span> + <span class="number">32</span>;</span><br><span class="line">                        <span class="comment">//a-z范围，计算重新定义的ascii码 </span></span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c1&gt;=<span class="string">'a'</span>&amp;&amp;c1&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">                            t1 = (c1-<span class="string">'a'</span>) * <span class="number">2</span> + <span class="number">33</span>;</span><br><span class="line">                        <span class="comment">//0-9范围，计算重新定义的ascii码 </span></span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c1&gt;=<span class="string">'0'</span>&amp;&amp;c1&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                            t1 = c1 + <span class="number">36</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//第二个字符串新的ascii计算</span></span><br><span class="line">                        <span class="keyword">if</span>(c2&gt;=<span class="string">'A'</span>&amp;&amp;c2&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">                            t2 = (c2 -<span class="string">'A'</span>) * <span class="number">2</span> + <span class="number">32</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c2&gt;=<span class="string">'a'</span>&amp;&amp;c2&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">                            t2 = (c2-<span class="string">'a'</span>) * <span class="number">2</span> + <span class="number">33</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c2&gt;=<span class="string">'0'</span>&amp;&amp;c2&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                            t2=c2 + <span class="number">36</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(t1!=t2)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> t1-t2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">// 字符串长度不等，直接返回长度较小的，从小到大的字符串排序</span></span><br><span class="line">                    <span class="keyword">return</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  return temp == 0 ?str1.compareTo(str2) : temp ;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            strSet.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Iterator it = strSet.iterator(); it.hasNext();)&#123;</span><br><span class="line">            System.out.print(it.next()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表奇数位正序偶数位逆序"><a href="#链表奇数位正序偶数位逆序" class="headerlink" title="链表奇数位正序偶数位逆序"></a><code>链表奇数位正序偶数位逆序</code></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>设C={a1, b1, a2, b2…an, bn}为线性表，采用带头结点的hc单链表存放，设计一个算法，将其拆分为两个线性表，使得奇数位保持正序，偶数位转化为逆序。即:<br>A = {a1，a2….an}, B= {bn….b2,b1)</p></blockquote><h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><ul><li>用odd和head存放奇数位数值，head用于指针的移动和将数值的添加到链表尾部，odd代表以-1为节点的奇数位链表</li><li>用even和tail存放偶数位数值，tail用于指针的移动和将数值的添加到链表尾部，even代表以-1为节点的偶数位链表</li><li>odd.next即代表奇数位的线性表数值链起来的链表</li><li>even.next要进行链表反转，最后存到evenRes里面即代表偶数位的线性表数值链起来的链表</li></ul></blockquote><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奇数位正序，偶数位逆序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next ;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(ListNode temp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//奇数（正序输出）</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode odd = head;</span><br><span class="line">        <span class="comment">//偶数（需要逆序输出）</span></span><br><span class="line">        ListNode tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode even = tail;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//奇数位head</span></span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> !=<span class="number">0</span>)&#123;</span><br><span class="line">                head.next = temp;</span><br><span class="line">                <span class="comment">//指针移动</span></span><br><span class="line">                temp  = temp.next;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//偶数位逆序</span></span><br><span class="line">                tail.next = temp;</span><br><span class="line">                <span class="comment">//指针移动</span></span><br><span class="line">                temp = temp.next;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个怎么说捏</span></span><br><span class="line">        <span class="comment">//假设是0--1--2--3</span></span><br><span class="line">        <span class="comment">//遍历到这的时候为  odd : -1 -- 0 -- 2 -- 3   even ： -1 -- 1 -- 3 ，所以要截断</span></span><br><span class="line">        <span class="comment">//反正 tail 或者 head 都会包含链表的最后一个值，有一个是不需要的。</span></span><br><span class="line">        tail.next =<span class="keyword">null</span>;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表反转</span></span><br><span class="line">        ListNode evenRes = reverseList(even.next);</span><br><span class="line">        System.out.print(<span class="string">"奇数位的排序为："</span>);</span><br><span class="line">        printRes(odd.next);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">"偶数位的排序为："</span>);</span><br><span class="line">        printRes(evenRes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表反转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = node;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next; <span class="comment">//记录下一个节点</span></span><br><span class="line">            cur.next = pre;  <span class="comment">//当前节点指向上一个节点</span></span><br><span class="line">            pre = cur;  <span class="comment">//记录当前节点</span></span><br><span class="line">            cur = next;  <span class="comment">//将下一个节点变成当前节点 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印结果</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRes</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(node.val+<span class="string">" "</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><code>最长回文子串</code></h2><h3 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>定义前后两端完全一致的字符串为对称字符串，如“abba”,”caddac”,编写程序，输出字符串”abcdefiiaaovivoovivcaideumncca”的最长对称子字符串。</p></blockquote><h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>同leetcode_【5】最长回文子串：<a href="https://blog.csdn.net/qq_17556191/article/details/94620675" target="_blank" rel="noopener">https://blog.csdn.net/qq_17556191/article/details/94620675</a><br>题解：<br><a href="https://qiulig.github.io/%2F2019%2F05%2Fleetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F" target="_blank" rel="noopener">https://qiulig.github.io/%2F2019%2F05%2Fleetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</a><br>以下用动态规划重写：dp[i][j]代表的意思是索引从i到j的子字符串是否是回文，假设s = cbbd,则可以dp对应坐标索引下的子字符串：</p><blockquote><table><thead><tr><th></th><th>i = 0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>j = 0</td><td>c</td><td>cb</td><td>cbb</td><td>cbbd</td></tr><tr><td>1</td><td></td><td>b</td><td>bb</td><td>bbd</td></tr><tr><td>2</td><td></td><td></td><td>b</td><td>bd</td></tr><tr><td>3</td><td></td><td></td><td></td><td>d</td></tr><tr><td>1.动态规划初始化</td><td></td><td></td><td></td><td></td></tr><tr><td>- 对角线dp[i][i]:代表当前字符str.charAt(i),故初始化为true</td><td></td><td></td><td></td><td></td></tr><tr><td>- 相邻的两个字符初始化，两个字符相等就可以了。str.charAt(i) == str.charAt(j)</td><td></td><td></td><td></td></tr></tbody></table></blockquote><p>2.动态规划状态转移矩阵</p><blockquote><ul><li><p>假设要求dp[0][2]，首先还是要判断开头和结尾是否相等，也就是判断 str.charAt(0)==str.charAt(2)，假如此时str.charAt(0)==str.charAt(2)，我们还要再看剩下的子串是否回文， 我们可以直接从dp[i+1][j-1]来判断剩下的子串，把结果直接拿来用,判断是否是true（true表示回文）</p><p>即有公式</p><p>   dp[i][j] = dp[i+1][j-1] &amp;&amp;str.charAt(0)==str.charAt(2) ?true:false</p></li></ul></blockquote><h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"abcdefiiaaovivoovivcaideumncca"</span>;</span><br><span class="line">        solution(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> arr[] = str.toCharArray();</span><br><span class="line">        <span class="comment">//dp[i][j]代表i~j的字符串的回文长度</span></span><br><span class="line">        <span class="keyword">boolean</span> [][]dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[str.length()][str.length()];</span><br><span class="line">        <span class="comment">//初始化对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化相邻的两个字符是否为回文</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=arr.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = str.charAt(i) == str.charAt(i+<span class="number">1</span>)?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">2</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                    <span class="comment">//两端的数相等以及中间的数是回文</span></span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; str.charAt(i) == str.charAt(j) ? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] == <span class="keyword">true</span> &amp;&amp; j - i + <span class="number">1</span>&gt;max)&#123;</span><br><span class="line">                    max = j-i+<span class="number">1</span>;</span><br><span class="line">                    res = str.substring(i,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(max);</span></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理自牛客资料技术篇</p><p>个人想法，如有错误请指出！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串排序&quot;&gt;&lt;a href=&quot;#字符串排序&quot; class=&quot;headerlink&quot; title=&quot;字符串排序&quot;&gt;&lt;/a&gt;&lt;code&gt;字符串排序&lt;/code&gt;&lt;/h2&gt;&lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;p&gt;请对组字符串进行排序，字符串由大小写字母和数字组成，需要满足以下比较规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、长度不同时，长度较短在排前面&lt;/li&gt;
&lt;li&gt;2、长度相同时，按照字典顺序排列（AaBb-Zz, 0-9顺序)，即大写字母在小写字母前，数字排在字母后，要求时间复杂度为O(nlogn)。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="笔试题" scheme="http://blogs.qiulig.website/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】_leetcode刷题的各种股票问题</title>
    <link href="http://blogs.qiulig.website/2019/07/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91-leetcode%E5%88%B7%E9%A2%98%E7%9A%84%E5%90%84%E7%A7%8D%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://blogs.qiulig.website/2019/07/【动态规划】-leetcode刷题的各种股票问题/</id>
    <published>2019-07-27T09:14:56.000Z</published>
    <updated>2019-07-27T09:16:51.726Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-leetcode-121-买卖股票的最佳时机"><a href="#1-leetcode-121-买卖股票的最佳时机" class="headerlink" title="1.leetcode_121.买卖股票的最佳时机"></a>1.leetcode_121.买卖股票的最佳时机</h3><blockquote><p>&emsp; 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多<strong>只允许完成一笔交易</strong>（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><a id="more"></a><p>注意你不能在买入股票前卖出股票。<br>示例 1:<br> &emsp; <strong>输入:</strong><br>  &emsp;  &emsp; [7,1,5,3,6,4]<br> &emsp; <strong>输出:</strong><br>  &emsp;  &emsp;  5<br> &emsp;  &emsp; 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:<br> &emsp; <strong>输入:</strong><br>  &emsp;  &emsp; [7,6,4,3,1]<br> &emsp; <strong>输出:</strong><br>  &emsp;  &emsp;  0<br> &emsp;  &emsp; 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><h6 id="方法1"><a href="#方法1" class="headerlink" title="方法1:"></a>方法1:</h6><p> <img src="https://img-blog.csdnimg.cn/20190709165453991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="方法2：动态规划"><a href="#方法2：动态规划" class="headerlink" title="方法2：动态规划"></a>方法2：动态规划</h6><blockquote><p> dp[i][0]代表第i+1天没有持股票，dp[i][1]代表第i+1天持有股票</p><ul><li><p>初始化：</p><ul><li><p>dp[0][0] = 0;    &emsp;&emsp;&emsp;&ensp;&ensp; 第一天没有持股，这时候相当于没有买入，故为0</p><p> dp[0][1] = -prices[0];&emsp; 第一天持股，相当于买入，这时候为-pricrs[0]</p></li><li>状态转移方程：</li><li><p>没有持股 =max(昨天没有持股今天维持现状 , 昨天持股，今天卖出）</p><p>&emsp;  &emsp; &emsp; &emsp;<code>dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);</code>  </p></li><li><p>持股 = max(昨天持股今天维持现状，（之前没有交易，今天买入)）【因为只能完成一笔交易，故今天买入，则前面就相当于一直没有进行交易为利润为0】</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;<code>dp[i][1] = Math.max(dp[i-1][1], -1 * prices[i])</code></p></li></ul></li></ul></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p> 方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(minPrice&gt;prices[i])&#123;</span><br><span class="line">              minPrice = prices[i];</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxProfit&lt;prices[i] - minPrice)&#123;</span><br><span class="line">              maxProfit = prices[i] - minPrice;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxProfit;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> 方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">         dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求第(i+1)天持股或者不持股的最大收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">             dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">             dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -<span class="number">1</span> * prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展1"><a href="#拓展1" class="headerlink" title="拓展1"></a>拓展1</h4><pre><code>以上题目中的“只允许完成一笔交易” 变成 “可以完成无数比交易”</code></pre><p> 同：leetcode-122:买卖股票的最佳时机 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/submissions/</a><br> 动态规划：</p><blockquote><p> dp[i][0]代表第i+1天没有持股票，dp[i][1]代表第i+1天持有股票</p><ul><li>初始化：<ul><li>dp[0][0] = 0; &emsp;&emsp; &emsp;  &emsp;            第一天没有持股，这时候相当于没有买入，故为0</li><li>dp[0][1] = -prices[0]; &emsp;  第一天持股，相当于买入，这时候为-prices[0]</li></ul></li></ul></blockquote><blockquote><ul><li><p>状态转移方程：</p><ul><li><p>没有持股 =max(昨天没有持股今天维持现状 , 昨天持股，今天卖出）</p><p>&emsp;&emsp;&emsp;<code>dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);</code>   //</p></li><li><p>持股 = max(昨天持股今天维持现状，（昨天没有持股，今天买入))【相对于之前，这里改变了】</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp; `dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]) ` </code></pre></li></ul></li></ul></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求第(i+1)天持股或者不持股的最大收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="拓展2："><a href="#拓展2：" class="headerlink" title="拓展2："></a>拓展2：</h4><pre><code>在拓展1的基础上[可以完成无数比交易]，每次 sell 之后要等一天才能继续交易。</code></pre><p>同：leetcode-309:最佳买卖股票时机含冷冻期 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a><br> 动态规划：</p><blockquote><p> dp[i][0]代表第i+1天没有持股票，dp[i][1]代表第i+1天持有股票</p><ul><li>初始化：<ul><li>dp[0][0] = 0;   &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; //第1天没有持股，这时候相当于没有买入，故为0</li><li>dp[1][0] =Math.max(0,prices[1]-prices[0]); //第2天没有持股，这时候max(第一天没持股，第一天持股第二天卖出)</li><li>dp[0][1] = -prices[0];&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &ensp; //第1天持股维持，相当于买入，这时候为-prices[0]</li><li>dp[1][1] = Math.max(-prices[0],-prices[1]);//第2天持股，这时候max(第一天持股维持，第一天没持股第二天买入)</li></ul></li></ul></blockquote><blockquote><ul><li><p>状态转移方程：</p><ul><li><p>没有持股 =max(昨天没有持股今天维持现状 , (昨天持股，今天卖出))</p><p>&emsp;&emsp;&emsp; <code>dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);</code></p></li><li><p>持股 = max(昨天持股今天维持现状，（前天没有持股，今天买入))即：第i天要买的时候，要从前天的状态进行判断</p><p>&emsp;&emsp;&emsp;<code>dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);</code></p></li></ul></li></ul></blockquote><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit4</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(prices.length == <span class="number">0</span> ||prices.length == <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">      <span class="comment">//初始化</span></span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      dp[<span class="number">1</span>][<span class="number">0</span>] =Math.max(<span class="number">0</span>,prices[<span class="number">1</span>]-prices[<span class="number">0</span>]);</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">      dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>],-prices[<span class="number">1</span>]);</span><br><span class="line">      <span class="comment">//动态规划</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">               dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">          dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">      <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="拓展3："><a href="#拓展3：" class="headerlink" title="拓展3："></a>拓展3：</h5><pre><code>每次买入交易要支付手续费。</code></pre><p> leetcode-714:买卖股票的最佳时机含手续费 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a><br>动态规划</p><blockquote><p> dp[i][0]代表第i+1天没有持股票，dp[i][1]代表第i+1天持有股票</p><ul><li><p>初始化：</p><ul><li><p>dp[0][0] = 0;      &emsp; &emsp; &emsp; &emsp;      第一天没有持股，这时候相当于没有买入，故为0</p><p> dp[0][1] = -prices[0] - fee; &emsp; 第一天持股，相当于买入，这时候为-prices[0] - fee ,本次以买入作为交易的开始，每次买入就扣除手续费，卖出的时候就不扣除手续费了。</p></li></ul></li></ul></blockquote><blockquote><ul><li><p>状态转移方程：</p><ul><li><p>没有持股 =max(昨天没有持股今天维持现状 , 昨天持股，今天卖出）【买入扣除手续费，卖出就不扣除了，因为买卖都完成才扣一次手续费】</p><p>&emsp; &emsp; <code>dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);</code></p></li><li><p>持股 = max(昨天持股今天维持现状，（昨天没有持股，今天买入))</p><p>&emsp; &emsp; <code>dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i] - fee);</code></p></li></ul></li></ul></blockquote><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit5</span><span class="params">(<span class="keyword">int</span>[] prices,<span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]-fee;</span><br><span class="line">       <span class="comment">//求第(i+1)天持股或者不持股的最大收益</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">         dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">       <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="拓展4："><a href="#拓展4：" class="headerlink" title="拓展4："></a>拓展4：</h5><pre><code>以上题目中的“只允许完成一笔交易” 变成 “只允许完成2笔交易”</code></pre><p> 同： <a href="https://www.nowcoder.com/questionTerminal/3e8c66829a7949d887334edaa5952c28" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/3e8c66829a7949d887334edaa5952c28</a><br> 已调试通过<br> 同： leetcode-123. 买卖股票的最佳时机 III :<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/submissions/</a><br>动态规划</p><blockquote><p> dp[i][k][0]代表第i+1天交易k次并且没有持股票，dp[i][k][1]代表第i+1天交易k次并且持有股票</p><ul><li><p>初始化：</p><ul><li>dp[0][1][0] = 0; &emsp; &emsp;&emsp;&ensp;//第一天，交易次数为1，没持股，相当于就没买入</li><li>dp[0][1][1] = -prices[0];  //第一天，交易次数为1，持股，相当于买入股票</li><li>dp[0][2][0] = 0;   &emsp;&emsp;&emsp;&ensp;//第一天,交易次数为2，没持股，相当于买入卖出买入卖出，没有盈利</li><li>dp[0][2][1] = -prices[0];  //第一天，交易次数为2，持股，相当于买入再卖出（交易1次）再买入</li><li>状态转移方程：</li><li><p>第(i+1)天交易数为2，没持股 = max(前一天交易数为2没持股维持，前一天交易数为2持股今天卖出)</p><pre><code>&amp;emsp;&amp;emsp; &amp;emsp;`dp[i][2][0] = Math.max(dp[i-1][2][0],dp[i-1][2][1] + prices[i]);`</code></pre></li><li><p>第(i+1)天交易数为2，持股 = 前一天交易数为2持股维持，<strong>前一天交易数为1</strong>没持股今天买入[买入之前必须卖出，故之前交易数应该为1而不是为2]</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp;`dp[i][2][1] = Math.max(dp[i-1][2][1],dp[i-1][1][0] - prices[i]);`</code></pre></li><li><p>第(i+1)天交易数为1，没持股 = max(前一天交易数为1没持股维持，<strong>前一天交易数为1</strong>持股今天卖出)[卖出之前必须买入，故交易数为1而不是0]</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp;` dp[i][1][0] = Math.max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]);`</code></pre></li><li><p>第(i+1)天交易数为1，持股 = max(前一天交易数为1持股维持，(没交易，今天买入))</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp; ` dp[i][1][1] = Math.max(dp[i-1][1][1],-1 * prices[i]);`</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="keyword">import</span> java.util.*;</span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">&gt;          <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">&gt;              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;        <span class="comment">//dp[i][k][0]代表第(i+1)天交易次数为k,没持股</span></span><br><span class="line">&gt;        <span class="keyword">int</span> dp[][][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">&gt;        <span class="comment">//初始化</span></span><br><span class="line">&gt;        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">&gt;        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">&gt;        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;   </span><br><span class="line">&gt;        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">&gt;            <span class="comment">//动态规划</span></span><br><span class="line">&gt;        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">&gt;            dp[i][<span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">&gt;            dp[i][<span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">&gt;            dp[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">&gt;            dp[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>],-<span class="number">1</span> * prices[i]);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><h4 id="拓展5："><a href="#拓展5：" class="headerlink" title="拓展5："></a>拓展5：</h4><pre><code>以上题目中的“只允许完成一笔交易” 变成 “只允许完成k笔交易”</code></pre><p>leetcode-188: 买卖股票的最佳时机IV：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a><br>动态规划：</p><blockquote><p> dp[i][k][0]代表第i+1天交易k次并且没有持股票，dp[i][k][1]代表第i+1天交易k次并且持有股票</p><ul><li>初始化：<ul><li>dp[0][i][0] = 0;   【i为交易成交的笔数】即第一天,持续的买入卖出买入卖出，没收益</li><li>dp[0][i][1] = -prices[0]; 【i为交易成交的笔数】即第一天,持续的买入卖出买入，收益为买入的-prices[0]</li></ul></li></ul></blockquote><blockquote><ul><li><p>状态转移方程：</p><ul><li><p>第(i+1)天交易数为j，没持股 = max(前一天交易数为j没持股维持，前一天交易数为j持股今天卖出)</p><pre><code>&amp;emsp;&amp;emsp; &amp;emsp;`  dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);`</code></pre><ul><li><p>第(i+1)天交易数为j，持股 = max(前一天交易数为j持股维持，前一天交易数为j没持股今天买入)</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp; `dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i]);`</code></pre></li></ul></li></ul></li></ul></blockquote><p>答案超出内存限制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[][][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//第一天,买入卖出买入卖出，没收益</span></span><br><span class="line">           dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>]; </span><br><span class="line">       &#125;</span><br><span class="line">         <span class="comment">//求第(i+1)天持股或者不持股的最大收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k;j &gt;= <span class="number">1</span>;j --) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>], dp[i-<span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时间再想想，觉得思路应该是对的，但是这些题应该有更优的解法，动态规划时间复杂度还是有点高的。<br> 整理自：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-leetcode-121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#1-leetcode-121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;1.leetcode_121.买卖股票的最佳时机&quot;&gt;&lt;/a&gt;1.leetcode_121.买卖股票的最佳时机&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp; 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多&lt;strong&gt;只允许完成一笔交易&lt;/strong&gt;（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>创建型模式之【单例模式】【工厂模式】【原型模式】【建造者模式】</title>
    <link href="http://blogs.qiulig.website/2019/07/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/创建型模式之【单例模式】【工厂模式】【原型模式】【建造者模式】/</id>
    <published>2019-07-26T16:09:45.000Z</published>
    <updated>2019-07-26T16:11:49.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>    单例模式包括<br>    &emsp;（1）私有的构造方法<br>      &emsp;（2）含有一个该类的静态私有对象private static<br>     &emsp;（3）提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</p></blockquote><a id="more"></a><h3 id="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"><a href="#懒汉模式：全局的单例在第一次使用时构建（延迟初始化）" class="headerlink" title="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"></a>懒汉模式：全局的单例在第一次使用时构建（延迟初始化）</h3><p>&emsp;<strong>优点：</strong><br>        &emsp;&emsp;避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法。<br>     &emsp;<strong>缺点</strong>：<br>             &emsp; &emsp;懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉模式：全局的单例实例在类装载时构建"><a href="#饿汉模式：全局的单例实例在类装载时构建" class="headerlink" title="饿汉模式：全局的单例实例在类装载时构建"></a>饿汉模式：全局的单例实例在类装载时构建</h3><pre><code>&amp;emsp;&amp;emsp;1.线程安全   &amp;emsp;&amp;emsp;2.在类加载的同时已经创建好一个静态对象，调用时反应速度快  </code></pre><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><blockquote><p>资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h3><p>&emsp;&emsp;数据库连接池，多线程连接池。Windows应用管理器</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><ul><li>1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，<strong>确保所有的对象都访问一个实例</strong> </li><li>2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。  </li><li>3.<strong>提供了对唯一实例的受控访问</strong>。  </li><li>4.由于在系统内存中只存在一个对象，因此可以<strong>节约系统资源</strong>，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。  </li><li>5.允许可变数目的实例。  </li><li>6.<strong>避免对共享资源的多重占用。</strong></li></ul></blockquote><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>单例模式可能<strong>导致内存泄漏（OOM）</strong></p><ul><li>&emsp;1.<strong>不适用于变化的对象</strong>，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。  <ul><li>&emsp;2.由于单利模式中没有抽象层，因此单例类的<strong>扩展有很大的困难</strong>。  </li><li>&emsp;3.单例类的职责过重，在一定程度上<strong>违背了“单一职责原则”</strong>。  </li></ul></li><li>&emsp;4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li></ul></blockquote><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>&emsp;&emsp;定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的<strong>实例化延迟</strong>到其子类。<br>&emsp;&emsp;<strong>提供一个创建对象实例的功能，而无须关心其具体实现</strong>。被创建实例的类型可以是接口、抽象类，也可以是具体的类。工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。<!--more--></p><p><img src="https://img-blog.csdnimg.cn/20190717103842500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-简单工厂方法"><a href="#1-简单工厂方法" class="headerlink" title="1.简单工厂方法"></a>1.简单工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISample <span class="title">creator</span><span class="params">(<span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (which==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleA();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (which==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实例时</span></span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">1</span>);</span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="2-抽象工厂"><a href="#2-抽象工厂" class="headerlink" title="2.抽象工厂"></a>2.抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample <span class="title">creator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实现接口的实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleA</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2A</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//创建工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BombFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleB</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><blockquote><p>&emsp;1、可以一定程度上<strong>解耦</strong>，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。<br>&emsp;2、可以一定程度<strong>增加扩展性</strong>，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。<br>&emsp;3、可以一定程度<strong>增加代码的封装性、可读性</strong>。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。  </p><!--more--></blockquote><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>&emsp;&emsp;每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上<strong>增加了系统的复杂度，同时也增加了系统具体类的依赖</strong>。</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>&emsp;1、<strong>日志记录器</strong>：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </p><p>&emsp;2、<strong>数据库访问</strong>，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </p><p>&emsp;3、<strong>设计一个连接服务器的框架</strong>，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p></blockquote><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>&emsp;&ensp;创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是<strong>从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节</strong>。<!--more--></p><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1.浅拷贝"></a>1.浅拷贝</h3><blockquote><ul><li>对类实现Cloneable接口（implements Cloneable），并且重写clone</li><li>对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象.</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Realizetype()&#123;</span><br><span class="line">    System.out.println(<span class="string">"具体原型创建成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2.深拷贝"></a>2.深拷贝</h3><blockquote><ul><li>对其中的引用类型的成员变量进行实现Cloneable接口，重写clone，就变成深拷贝了</li><li>对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">     String name;</span><br><span class="line"></span><br><span class="line">     String <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><blockquote><p>&emsp;1.如果创建新的对象比较复杂时，可以利用<strong>原型模式简化对象的创建过程</strong>。<br>&emsp;2.使用原型模式创建对象比直接 new 一个对象在<strong>性能</strong>上要好的多，因为 Object 类的 clone 方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p><strong>在需要重复地创建相似对象时可以考虑使用原型模式</strong>。</p><p>&emsp;&emsp;比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。</p></blockquote><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>&emsp;&emsp;将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示</p><!--more--><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol><li><strong>产品角色</strong>（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。</li><li><strong>抽象建造者</strong>（Builder）：它是一个包含创建产品各个子部件的抽象方法的<strong>接口</strong>，通常还包含一个返回复杂产品的方法 getResult()。</li><li><strong>具体建造者</strong>(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li><strong>指挥者</strong>（Director）：构建一个使用builder接口的对象。它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>&emsp;&emsp;主要用于创建一些复杂的对象，这些对象内部间的建造顺序是稳定的，但对象内部的构建通常面临着复杂的变化。</p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>&emsp;（1）使得建造代码与表示代码分离，由于建造者隐藏了产品如何组装，所以若需要改变一个产品内部表示，只需要在定义一个具体的建造者就可以了。</p><p>&emsp;（2） 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</p><p>&emsp;（3）<strong>增加新的具体建造者无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统扩展方便，符合 <strong>“开闭原则”</strong></p><p>&emsp;（4）<strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;br&gt;    单例模式包括&lt;br&gt;    &amp;emsp;（1）私有的构造方法&lt;br&gt;      &amp;emsp;（2）含有一个该类的静态私有对象private static&lt;br&gt;     &amp;emsp;（3）提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="http://blogs.qiulig.website/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的涉及的题</title>
    <link href="http://blogs.qiulig.website/2019/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B6%89%E5%8F%8A%E7%9A%84%E9%A2%98/"/>
    <id>http://blogs.qiulig.website/2019/07/二叉树的涉及的题/</id>
    <published>2019-07-26T13:10:00.000Z</published>
    <updated>2019-07-26T13:21:08.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line">       TreeNode(<span class="keyword">int</span> x) &#123; </span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-二叉树的最大深度"><a href="#1-二叉树的最大深度" class="headerlink" title="1.二叉树的最大深度"></a>1.二叉树的最大深度</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left =  maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-二叉树的最小深度"><a href="#2-二叉树的最小深度" class="headerlink" title="2.二叉树的最小深度"></a>2.二叉树的最小深度</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((root.left == <span class="keyword">null</span>) &amp;&amp; (root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> minDepth = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           minDepth = Math.min(minDepth, minDepth(root.left));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           minDepth = Math.min(minDepth, minDepth(root.right));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> minDepth + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="3-求完全二叉树中节点的个数"><a href="#3-求完全二叉树中节点的个数" class="headerlink" title="3..求完全二叉树中节点的个数"></a>3..求完全二叉树中节点的个数</h2><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">int</span> left = countNodes(root.left);</span><br><span class="line">       <span class="keyword">int</span> right = countNodes(root.right);</span><br><span class="line">       <span class="keyword">return</span> left+right +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4. 平衡二叉树"></a>4. 平衡二叉树</h2><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(getDepth(root.left)-getDepth(root.right))&lt;=<span class="number">1</span>)&#123;      </span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp;isBalanced(root.right);   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-二叉树的完全性检验"><a href="#5-二叉树的完全性检验" class="headerlink" title="5.二叉树的完全性检验"></a>5.二叉树的完全性检验</h2><p><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//加入根节点</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">boolean</span> hasNoChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (hasNoChild) &#123;</span><br><span class="line">                <span class="comment">//上一层中左子树不为空，右子树为空，如果遍历到左子树，这时候左子树有孩子，则代表上一层不完全填满</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span> || node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;  <span class="comment">//左右子树不为空</span></span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123; <span class="comment">//左子树不为空,右子树为空</span></span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                    hasNoChild = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;<span class="comment">//左子树为空，右子树不为空</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//左右子树都为空</span></span><br><span class="line">                    hasNoChild = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-相同的树"><a href="#6-相同的树" class="headerlink" title="6.相同的树"></a>6.相同的树</h2><p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> ||q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val !=q.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-对称二叉树"><a href="#7-对称二叉树" class="headerlink" title="7.对称二叉树"></a>7.对称二叉树</h2><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Symmetric</span><span class="params">(TreeNode leftroot,TreeNode rightroot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> &amp;&amp; rightroot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> || rightroot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot.val != rightroot.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(leftroot.left,rightroot.right) &amp;&amp; Symmetric(leftroot.right,rightroot.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node1 = queue.poll();</span><br><span class="line">            TreeNode node2 = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> &amp;&amp; node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> || node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">if</span>(node1.val!=node2.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            queue.add(node1.left);</span><br><span class="line">            queue.add(node2.right);</span><br><span class="line">            queue.add(node1.right);</span><br><span class="line">            queue.add(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-翻转二叉树"><a href="#8-翻转二叉树" class="headerlink" title="8.翻转二叉树"></a>8.翻转二叉树</h2><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-二叉搜索树的最近公共祖先"><a href="#9-二叉搜索树的最近公共祖先" class="headerlink" title="9.二叉搜索树的最近公共祖先"></a>9.二叉搜索树的最近公共祖先</h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//都在右子树</span></span><br><span class="line">        <span class="keyword">if</span>(p.val &gt;root.val &amp;&amp; q.val &gt;root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val&lt;root.val &amp;&amp; q.val &lt;root.val)&#123; <span class="comment">//都在左子树</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//一个在左子树，一个在右子树</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-二叉树的最近公共祖先"><a href="#10-二叉树的最近公共祖先" class="headerlink" title="10.二叉树的最近公共祖先"></a>10.二叉树的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span> || root==p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">return</span> left==<span class="keyword">null</span> ? right : right == <span class="keyword">null</span>?left:root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-最深叶节点的最近公共祖先"><a href="#11-最深叶节点的最近公共祖先" class="headerlink" title="11.最深叶节点的最近公共祖先"></a>11.最深叶节点的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="comment">//如果左右子树深度相同，表示获取到了最深叶子节点的最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果左右子树不等高，高度小的那个子树节点的叶子节点的深度肯定不是最深的（因为比高度大的子树深度小）。</span></span><br><span class="line">        <span class="comment">//所以，最深叶子节点肯定在深度较大的子树当中，采用深度优先搜索，每次只要继续往深度更大的子树进行递归即可。</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lcaDeepestLeaves(root.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lcaDeepestLeaves(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-节点与其祖先中间的最大差值"><a href="#12-节点与其祖先中间的最大差值" class="headerlink" title="12.节点与其祖先中间的最大差值"></a>12.节点与其祖先中间的最大差值</h2><p><a href="https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> AncestorDiff(root,root.val,root.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每条从根节点到叶子节点的路径中的最大值和最小值，并求出差值更新全局变量</span></span><br><span class="line">    <span class="comment">//一口气遍历到叶子节点，遍历的时候动态保存当前路径的最大节点值和最小节点值</span></span><br><span class="line">    <span class="comment">//每当遍历一次叶子节点，将保存好的最大值与最小值之间的差与全局变量 maxvalue 比较，并且取较大值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">AncestorDiff</span><span class="params">(TreeNode root, <span class="keyword">int</span> max_value, <span class="keyword">int</span> min_value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> max_value-min_value;</span><br><span class="line">        max_value = root.val &gt; max_value ? root.val : max_value;</span><br><span class="line">        min_value = root.val &lt; min_value ? root.val : min_value;</span><br><span class="line">        <span class="keyword">return</span> Math.max(AncestorDiff(root.left,max_value,min_value),AncestorDiff(root.right,max_value,min_value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-从前序与中序遍历序列构造二叉树"><a href="#13-从前序与中序遍历序列构造二叉树" class="headerlink" title="13.从前序与中序遍历序列构造二叉树"></a>13.从前序与中序遍历序列构造二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//前序的第一个数即为树的根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序中的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">                <span class="comment">//pre[1,i+1] 和in[0,i]构成左子树的遍历</span></span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                <span class="comment">//pre[i+1,len-1]和in[i+1,len-1]构成右子树的遍历</span></span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-从中序与后序遍历序列构造二叉树"><a href="#14-从中序与后序遍历序列构造二叉树" class="headerlink" title="14.从中序与后序遍历序列构造二叉树"></a>14.从中序与后序遍历序列构造二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.length == <span class="number">0</span>||postorder.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//后序的最后一个为根结点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序中的根节点位置</span></span><br><span class="line">                <span class="keyword">if</span>(inorder[i] == postorder[postorder.length-<span class="number">1</span>])&#123;</span><br><span class="line">                  <span class="comment">//in[0,i]和pos[0,i-1]构成左子树的遍历</span></span><br><span class="line">                    root.left = buildTree(Arrays.copyOfRange(inorder,<span class="number">0</span>,i),Arrays.copyOfRange(postorder,<span class="number">0</span>,i));</span><br><span class="line">                     <span class="comment">//in[i+1,len-1]和pos[i,len-2]构成左子树的遍历</span></span><br><span class="line">                    root.right = buildTree(Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length),Arrays.copyOfRange(postorder,i,postorder.length-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-把二叉树转换成累加树"><a href="#15-把二叉树转换成累加树" class="headerlink" title="15.把二叉树转换成累加树"></a>15.把二叉树转换成累加树</h2><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历结果为从小到大，要变成累加树，则中序遍历反过来相加变成节点值即可。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//遍历右子树</span></span><br><span class="line">           convertBST(root.right);</span><br><span class="line">           <span class="comment">//改变值，依次累加即可</span></span><br><span class="line">           root.val = root.val+num;</span><br><span class="line">           <span class="comment">//存储上一层的值</span></span><br><span class="line">           num = root.val;</span><br><span class="line">           <span class="comment">//遍历左子树</span></span><br><span class="line">           convertBST(root.left);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-不同的二叉搜索树"><a href="#16-不同的二叉搜索树" class="headerlink" title="16.不同的二叉搜索树"></a>16.不同的二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br>动态规划</p><ul><li><p>初始化</p><p>假设n个节点存在二叉搜索树的个数是dp（n）,令f(i) 为以i为根的二叉搜索树的个数，则有</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;  <code>dp(n) = f(1) + f(2) + f(3) +... + f(n)</code></p><p>当i为根节点时，其左子树的个数为(i - 1),右子树的个数为（n-i）,则</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;  <code>f(i) = dp(i-1) *dp(n-i)</code></p><p>结合两个式子可以得到卡特兰数：</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp; <code>dp(n) = dp(0) *dp(n-1) +dp(1) *dp(n-2) +... +dp(n-1)</code>*dp(0)</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;&emsp; &emsp; &ensp; <code>= dp(n-1) * C(2n,n)</code></p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;&emsp; &emsp; &ensp; <code>= dp(n-1) * (4*n-2)/(n-1)</code></p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n个节点存在二叉树的个数</span></span><br><span class="line">        <span class="keyword">long</span> []dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//以i为根节点的二叉树个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//以0为根节点的</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]*(<span class="number">4</span>*i-<span class="number">2</span>)/(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-不同的二叉搜索树-II"><a href="#17-不同的二叉搜索树-II" class="headerlink" title="17.不同的二叉搜索树 II"></a>17.不同的二叉搜索树 II</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees=generate(start,i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归遍历右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees=generate(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//先序遍历存入以i为根节点的二叉搜索树</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left:leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right:rightTrees)&#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left=left;</span><br><span class="line">                    root.right=right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-在二叉树中增加一行"><a href="#18-在二叉树中增加一行" class="headerlink" title="18.在二叉树中增加一行"></a>18.在二叉树中增加一行</h2><p><a href="https://leetcode-cn.com/problems/add-one-row-to-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-one-row-to-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">           TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">           <span class="comment">//如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</span></span><br><span class="line">            <span class="keyword">if</span>(d == <span class="number">1</span>)&#123;</span><br><span class="line">                node.left = root;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d == <span class="number">0</span>)&#123;</span><br><span class="line">                node.right = root;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; d&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                root.left = addOneRow(root.left ,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">                root.right = addOneRow(root.right,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-验证一棵树是不是二叉搜索树"><a href="#19-验证一棵树是不是二叉搜索树" class="headerlink" title="19.验证一棵树是不是二叉搜索树"></a>19.验证一棵树是不是二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据二叉搜索树的中序遍历为从小到大的思路写的</span></span><br><span class="line"><span class="comment">//修改一下二叉搜索树的非递归写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">double</span> inorder = - Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt;= inorder)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二叉树的定义&quot;&gt;&lt;a href=&quot;#二叉树的定义&quot; class=&quot;headerlink&quot; title=&quot;二叉树的定义&quot;&gt;&lt;/a&gt;二叉树的定义&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            val = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>树的【前序遍历】【中序遍历】【后序遍历】【层遍历】【BFS】【DFS】</title>
    <link href="http://blogs.qiulig.website/2019/07/%E6%A0%91%E7%9A%84%E3%80%90%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%B1%82%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90BFS%E3%80%91%E3%80%90DFS%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/树的【前序遍历】【中序遍历】【后序遍历】【层遍历】【BFS】【DFS】/</id>
    <published>2019-07-26T13:08:30.000Z</published>
    <updated>2019-07-26T13:20:53.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉树的数据结构"><a href="#二叉树的数据结构" class="headerlink" title="二叉树的数据结构"></a>二叉树的数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line">       TreeNode(<span class="keyword">int</span> x) &#123; </span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-二叉树的前序遍历"><a href="#1-二叉树的前序遍历" class="headerlink" title="1.二叉树的前序遍历"></a>1.二叉树的前序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.62%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.1 MB, 在所有 Java 提交中击败了40.72%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**依次将每层的结点入栈，入栈顺序是右--左，方便弹出时出栈为左---右**/</span></span><br><span class="line">     <span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了6.05%的用户</span></span><br><span class="line">    <span class="comment">//内存消耗 :35 MB, 在所有 Java 提交中击败了40.72%的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">//入栈下一层的右节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入栈下一层的左节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加入根节点</span></span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-二叉树的中序遍历"><a href="#2-二叉树的中序遍历" class="headerlink" title="2.二叉树的中序遍历"></a>2.二叉树的中序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.55%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :34.7 MB, 在所有 Java 提交中击败39.5的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">              inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了55.11%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.1 MB, 在所有 Java 提交中击败了39.36%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            TreeNode cur = root;</span><br><span class="line">            <span class="keyword">while</span> (cur!=<span class="keyword">null</span> ||!stack.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//循环直到找到最左子树</span></span><br><span class="line">                <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(cur);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                ans.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="3-二叉树的后序遍历"><a href="#3-二叉树的后序遍历" class="headerlink" title="3. 二叉树的后序遍历"></a>3. 二叉树的后序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.71%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.6 MB, 在所有 Java 提交中击败了36.80%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(root.left !=<span class="keyword">null</span>)</span><br><span class="line">            postorderTraversal(root.left);</span><br><span class="line">         <span class="keyword">if</span>(root.right !=<span class="keyword">null</span>)</span><br><span class="line">            postorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了61.53%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.8 MB, 在所有 Java 提交中击败了35.50%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里先加入根结点</span></span><br><span class="line">    stack.addLast(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      TreeNode node = stack.pollLast();</span><br><span class="line">      <span class="comment">//在res的头部添加，依次添加的为 根，然后再添加为 右--根，再添加为左--右--根</span></span><br><span class="line">      res.addFirst(node.val);  </span><br><span class="line">      <span class="comment">//在stack中依次加入左--右，方便下次先弹出右子树，再弹出左子树</span></span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.addLast(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.addLast(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-二叉树的层序遍历"><a href="#4-二叉树的层序遍历" class="headerlink" title="4.二叉树的层序遍历"></a>4.二叉树的层序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了90.77%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :37 MB, 在所有 Java 提交中击败了43.02%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() == level)</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        ans.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了58.74%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :36.7 MB, 在所有 Java 提交中击败了43.83%的用户</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//用于存一层的结果</span></span><br><span class="line">           ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="comment">//这一层的结点个数</span></span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count;i++)&#123;</span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               <span class="comment">//存入下一层的左右子树</span></span><br><span class="line">               <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               <span class="comment">//添加当前层的值到tmp    </span></span><br><span class="line">               tmp.add(node.val);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将一层的结果存到结果集中</span></span><br><span class="line">           res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-二叉树的深度优先遍历"><a href="#5-二叉树的深度优先遍历" class="headerlink" title="5.二叉树的深度优先遍历"></a>5.二叉树的深度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ans.add(root.val);</span><br><span class="line">               DFS(root.left);</span><br><span class="line">               DFS(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">//先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-二叉树的广度优先遍历"><a href="#6-二叉树的广度优先遍历" class="headerlink" title="6.二叉树的广度优先遍历"></a>6.二叉树的广度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> res;</span><br><span class="line">         Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">         queue.add(root);</span><br><span class="line">         <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">             TreeNode node = queue.poll();</span><br><span class="line">             <span class="comment">////先往queue中压入左节点，再压右节点。</span></span><br><span class="line">             <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.left);</span><br><span class="line">             <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.right);</span><br><span class="line">             res.add(node.val);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="N叉树的数据结构"><a href="#N叉树的数据结构" class="headerlink" title="N叉树的数据结构"></a>N叉树的数据结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-N叉树的前序遍历"><a href="#1-N叉树的前序遍历" class="headerlink" title="1. N叉树的前序遍历"></a>1. N叉树的前序遍历</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了88.62%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :52.2 MB, 在所有 Java 提交中击败了78.78%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加根</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">//递归孩子结点</span></span><br><span class="line">        <span class="keyword">for</span>(Node node:root.children)&#123;</span><br><span class="line">            preorder(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :8 ms, 在所有 Java 提交中击败了28.21%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :54.5 MB, 在所有 Java 提交中击败了64.22%的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;Node&gt; stack= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Node node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.children.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//stack从右到左入栈，以达到弹出先弹左子树再弹右子树</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = node.children.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    stack.add(node.children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-N叉树的中序遍历"><a href="#2-N叉树的中序遍历" class="headerlink" title="2. N叉树的中序遍历"></a>2. N叉树的中序遍历</h2><p> &emsp;&emsp;&emsp;&emsp;没找到相关题，略过~~~</p><h2 id="3-N叉树的后序遍历"><a href="#3-N叉树的后序遍历" class="headerlink" title="3. N叉树的后序遍历"></a>3. N叉树的后序遍历</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了90.67%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :58.9 MB, 在所有 Java 提交中击败了25.73%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            postorder(node);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Node node = stack.pollLast();</span><br><span class="line">           <span class="comment">//在res的头部添加，依次添加的为 根，然后再添加为 右--根，再添加为左--右--根</span></span><br><span class="line">            res.addFirst(node.val);</span><br><span class="line">            <span class="comment">//判断是否有孩子结点</span></span><br><span class="line">            <span class="keyword">if</span>(node.children.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//从左到右依次入栈，方便后面先取出右子树</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;node.children.size();i++)&#123;</span><br><span class="line">                    stack.addLast(node.children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-N叉树的层序遍历"><a href="#4-N叉树的层序遍历" class="headerlink" title="4. N叉树的层序遍历"></a>4. N叉树的层序遍历</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了98.57%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :58.8 MB, 在所有 Java 提交中击败了40.01%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == level)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        res.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.children.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Node node : root.children)</span><br><span class="line">                 helper(node,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :7 ms, 在所有 Java 提交中击败了64.89的用户</span></span><br><span class="line">    <span class="comment">//内存消耗 :52.6 MB, 在所有 Java 提交中击败了79.34%的用户</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//用于存上一层的结果</span></span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//这一层的结点个数</span></span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                <span class="comment">//添加当前层的值到tmp    </span></span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">//存入下一层的孩子</span></span><br><span class="line">                <span class="keyword">if</span>(node.children.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;node.children.size();j++)&#123;</span><br><span class="line">                        queue.add(node.children.get(j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将一层的结果存到结果集中</span></span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树的数据结构&quot;&gt;&lt;a href=&quot;#二叉树的数据结构&quot; class=&quot;headerlink&quot; title=&quot;二叉树的数据结构&quot;&gt;&lt;/a&gt;二叉树的数据结构&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            val = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法-【全排列】【组合总和】【n皇后】【子集】</title>
    <link href="http://blogs.qiulig.website/2019/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E3%80%90%E5%85%A8%E6%8E%92%E5%88%97%E3%80%91%E3%80%90%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E3%80%91%E3%80%90n%E7%9A%87%E5%90%8E%E3%80%91%E3%80%90%E5%AD%90%E9%9B%86%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/回溯算法-【全排列】【组合总和】【n皇后】【子集】/</id>
    <published>2019-07-22T11:32:30.000Z</published>
    <updated>2019-07-26T13:20:36.568Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>&emsp;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。即从一条路往前走，能进则进，不能进则退回来，换一条路再试。<a id="more"></a></p><h2 id="如何使用回溯算法"><a href="#如何使用回溯算法" class="headerlink" title="如何使用回溯算法"></a>如何使用回溯算法</h2><p>&emsp;回溯我认为也就是一种递归，有以下四个参数，当然不一定是我所举例的类型，要看题目而定<br>&emsp;&emsp;(1)一个全局变量集合保存所有满足条件的答案，举例：List&lt;List<integer>&gt; res<br>&emsp;&emsp;(2)一个集合保存一个满足条件的答案，举例：List<integer> tmpList<br>核心：根据各个题情况变换<br><!--more--><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//add进去的值根据题意变换</span></span><br><span class="line">              tmplist.add(i);</span><br><span class="line">              <span class="comment">//递归,这里根据题意变换回溯，这仅仅是个例子</span></span><br><span class="line">              backtrack( k - <span class="number">1</span>, n, i+<span class="number">1</span>,tmplist, result);</span><br><span class="line">              <span class="comment">//将这个集合清空，方便下一个满足条件的答案</span></span><br><span class="line">              tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></integer></integer></p><h2 id="leetcode-【46】全排列-I"><a href="#leetcode-【46】全排列-I" class="headerlink" title="leetcode_【46】全排列 I"></a>leetcode_【46】全排列 I</h2><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p><blockquote><p><strong>题目描述：</strong><br>   &emsp;给定一个没有重复数字的序列，返回其所有可能的全排列。<br><strong>输入：</strong><br>&emsp;&emsp;[1,2,3]<br><strong>输出：</strong><br>&emsp;&emsp;[<br> &emsp;&emsp; [1,2,3],<br> &emsp;&emsp; [1,3,2],<br> &emsp;&emsp; [2,1,3],<br> &emsp;&emsp; [2,3,1],<br>&emsp;&emsp;  [3,1,2],<br> &emsp;&emsp; [3,2,1]<br>&emsp;&emsp; ]</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>&emsp; 回溯算法：</p><blockquote><ul><li>将第j个数字与第 j , j +1 , j + 2 ,…, len(nums) - 1个数字分别交换，得到 len(nums) - j 种情况；</li><li>在每种情况下递归，将第j+1处数字与第j+1,j+2,…,len(nums) - 1处数字分别交换；<ul><li>每个递归跳出后，要将交换过的元素还原，这样才能实现第一条所说的内容。<ul><li>直到j == len(nums) - 1，代表此种交换组合下已经交换完毕，记录答案。</li></ul></li></ul></li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p> 第一版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//执行用时 :41 ms, 在所有 Java 提交中击败了5.01%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :44.4 MB, 在所有 Java 提交中击败了5.03%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        permute(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,ArrayList&lt;Integer&gt; tempList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//start为左边界值，要跟右边界的数进行交换</span></span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(tempList))&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//将第j个数字与第 j , j +1 , j + 2 ,..., len(nums) - 1个数字分别交换</span></span><br><span class="line">            swap(nums,start,i);</span><br><span class="line">            tempList.add(nums[start]);</span><br><span class="line">            backTrace(nums,start+<span class="number">1</span>,tempList,res);</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 每个递归跳出后，要将交换过的元素还原</span></span><br><span class="line">            swap(nums,start,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">        nums[start] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二版：leetcode官网解答</p><blockquote><p>这里有一个回溯函数，使用第一个整数的索引作为参数 backtrack(first)。</p><ul><li>如果第一个整数有索引 n，意味着当前排列已完成。</li><li>遍历索引 first 到索引 n - 1 的所有整数。<ul><li>在排列中放置第 i 个整数， 即 swap(nums[first], nums[i]).</li><li>继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).</li><li>现在回溯，即通过 swap(nums[first], nums[i]) 还原.</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了87.64%的用户</span></span><br><span class="line"> <span class="comment">//内存消耗 :38.5 MB, 在所有 Java 提交中击败了67.89%的用户</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n,ArrayList&lt;Integer&gt; nums, List&lt;List&lt;Integer&gt;&gt; output, <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一个整数有索引 n，意味着当前排列已完成。</span></span><br><span class="line">        <span class="keyword">if</span> (first == n)</span><br><span class="line">            output.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(nums));</span><br><span class="line">        <span class="comment">// 遍历索引 first 到索引 n - 1 的所有整数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//在排列中放置第 i 个整数</span></span><br><span class="line">            Collections.swap(nums, first, i);</span><br><span class="line">            <span class="comment">//  继续生成从第 i 个整数开始的所有排列</span></span><br><span class="line">             backtrack(n, nums, output, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            Collections.swap(nums, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert nums into list since the output is a list of lists</span></span><br><span class="line">        ArrayList&lt;Integer&gt; nums_lst = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            nums_lst.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        backtrack(n, nums_lst, output, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【47】全排列-II"><a href="#leetcode-【47】全排列-II" class="headerlink" title="leetcode_【47】全排列 II"></a>leetcode_【47】全排列 II</h2><p> <a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii/</a></p><blockquote><p><strong>题目描述：</strong><br>&emsp;给定一个可能包含重复数字的序列，返回其所有可能的不重复全排列。<br><strong>输入：</strong><br>&emsp;&emsp;[1,1,2]<br><strong>输出：</strong><br>&emsp;&emsp;[<br> &emsp;&emsp; [1,1,2],<br> &emsp;&emsp; [1,2,1],<br> &emsp;&emsp; [2,1,1],<br> &emsp;&emsp; ]</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>第一版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//执行用时 :742 ms, 在所有 Java 提交中击败了8.80%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :45.7 MB, 在所有 Java 提交中击败了44.99%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span>  List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,ArrayList&lt;Integer&gt; tempList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//start为边界值</span></span><br><span class="line">            <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">                <span class="comment">//加了这一句</span></span><br><span class="line">                <span class="keyword">if</span>(!res.contains(tempList))&#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">                swap(nums,start,i);</span><br><span class="line">                tempList.add(nums[start]);</span><br><span class="line">                backTrace(nums,start+<span class="number">1</span>,tempList,res);</span><br><span class="line">                tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">                swap(nums,start,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优化的第二版:leetcode官网解答<br><img src="https://img-blog.csdnimg.cn/20190722151516219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722151537389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190722151548299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722151600826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :6 ms, 在所有 Java 提交中击败了63.63%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :42.8 MB, 在所有 Java 提交中击败了76.28%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findPermuteUnique</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> depth, Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="comment">// 修改 2：因为排序以后重复的数一定不会出现在开始，故 i &gt; 0</span></span><br><span class="line">                <span class="comment">// 和之前的数相等，并且之前的数还未使用过，只有出现这种情况，才会出现相同分支</span></span><br><span class="line">                <span class="comment">// 这种情况跳过即可</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                stack.add(nums[i]);</span><br><span class="line">                findPermuteUnique(nums, depth + <span class="number">1</span>, stack);</span><br><span class="line">                stack.pop();</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改 1：首先排序，之后才有可能发现重复分支</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        findPermuteUnique(nums, <span class="number">0</span>, <span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permuteUnique = solution.permuteUnique(nums);</span><br><span class="line">        System.out.println(permuteUnique);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【77】组合"><a href="#leetcode-【77】组合" class="headerlink" title="leetcode_【77】组合"></a>leetcode_【77】组合</h2><p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations/</a></p><blockquote><p>&emsp;给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>    示例:<br>    输入:<br>    &emsp;&emsp;n = 4, k = 2<br>    输出:<br>   &emsp;&ensp; [<br>  &emsp;&emsp;  [2,4],<br>   &emsp;&emsp; [3,4],<br>   &emsp;&emsp; [2,3],<br>   &emsp;&emsp; [1,2],<br>   &emsp;&emsp; [1,3],<br> &emsp;&emsp;   [1,4],<br> &emsp;&ensp;   ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//执行用时 :40 ms, 在所有 Java 提交中击败了52.77%的用户</span></span><br><span class="line">&gt; <span class="comment">//内存消耗 :52.5 MB, 在所有 Java 提交中击败了26.41%的用户</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">&gt;         List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;         backtrack(k,n,<span class="number">1</span>,<span class="keyword">new</span> ArrayList(),res);</span><br><span class="line">&gt;         <span class="keyword">return</span> res;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n,<span class="keyword">int</span> start,List&lt;Integer&gt; tmplist,List&lt;List&lt;Integer&gt;&gt; result)</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">&gt;             result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">&gt;         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">&gt;             <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">&gt;                 tmplist.add(i);</span><br><span class="line">&gt;                 <span class="comment">//递归，这里回溯 从 i+1  ~ n 中 k-1 个数的组合，直到k == 0就可将这次结果存到res里面</span></span><br><span class="line">&gt;                 backtrack( k - <span class="number">1</span>, n, i+<span class="number">1</span>,tmplist, result);</span><br><span class="line">&gt;                 tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="leetcode-【39】组合总和-I"><a href="#leetcode-【39】组合总和-I" class="headerlink" title="leetcode_【39】组合总和 I"></a>leetcode_【39】组合总和 I</h2><p>&emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum/</a></p><blockquote><p>&emsp;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以&gt;使数字和为 target 的组合。<br>&emsp;candidates 中的<strong>数字可以无限制重复被选取。</strong><br><strong>说明：</strong><br>&emsp; (1)所有数字（包括 target）都是正整数。<br>&emsp;(2)解集不能包含重复的组合。<br>       <strong><strong>示例 1:<br>       输入:</strong></strong><br>      &emsp;&emsp; candidates = [2,3,6,7], target = 7,<br>       <strong>所求解集为:</strong><br>      &emsp;&emsp; [<br>     &emsp;&emsp;  [7],<br>      &emsp;&emsp; [2,2,3]<br>      &emsp;&emsp; ]<br>       <strong>示例 2:<br>       输入:</strong><br>       &emsp;&emsp;candidates = [2,3,5], target = 8,<br>       <strong>所求解集为:</strong><br>       &emsp;&emsp;[<br>         &emsp;&emsp;[2,2,2,2],<br>        &emsp;&emsp; [2,3,3],<br>        &emsp;&emsp; [3,5]<br>       &emsp;&emsp;]</p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :7 ms, 在所有 Java 提交中击败了81.11%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :39.1 MB, 在所有 Java 提交中击败了87.66%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">          <span class="comment">//存放结果</span></span><br><span class="line">          List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="comment">//排序</span></span><br><span class="line">          Arrays.sort(candidates);</span><br><span class="line">          <span class="comment">//从第一个数开始递归</span></span><br><span class="line">          calculate(candidates,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,ArrayList&lt;Integer&gt; tmpList,List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存入结果集</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123;</span><br><span class="line">                <span class="comment">//加入</span></span><br><span class="line">                tmpList.add(candidates[i]);</span><br><span class="line">                <span class="comment">//递归,candidates 中的数字可以使用无数次，故start还是从 i 开始</span></span><br><span class="line">                calculate( candidates, target - candidates[i], i, tmpList,result);</span><br><span class="line">                <span class="comment">//清空所得到的一次结果的list</span></span><br><span class="line">                tmpList.remove(tmpList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【40】组合总和-II"><a href="#leetcode-【40】组合总和-II" class="headerlink" title="leetcode_【40】组合总和 II"></a>leetcode_【40】组合总和 II</h2><p>&emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii/</a></p><blockquote><p>&emsp;&emsp;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>&emsp;<strong>candidates 中的数字可以只能使用一次。</strong><br><strong>说明：</strong><br>&emsp; (1)所有数字（包括 target）都是正整数。<br>&emsp;(2)解集不能包含重复的组合。<br><strong>输入:</strong><br>&emsp;&emsp;candidates = [10,1,2,7,6,1,5], target = 8，<br><strong>所求解集为:</strong><br>       &emsp;&ensp; [<br>      &emsp;&emsp;  [1, 7],<br>       &emsp;&emsp; [1, 2, 5],<br>       &emsp;&emsp; [2, 6],<br>      &emsp;&emsp;  [1, 1, 6]<br>      &emsp;&ensp;  ]<br>        <strong>示例 2:<br>        输入:</strong><br>        &emsp;&emsp; candidates = [2,5,2,1,2], target = 5,<br>        <strong>所求解集为:</strong><br>       &emsp;&ensp; [<br>          &emsp;&emsp;[1,2,2],<br>         &emsp;&emsp; [5]<br>       &emsp;&ensp; ]       </p></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//执行用时 :30 ms, 在所有 Java 提交中击败了22.59%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :45 MB, 在所有 Java 提交中击败了27.34%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="comment">//从下标为0，目标为target的开始回溯</span></span><br><span class="line">        backTrace(candidates,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//解集不能包含重复的组合。 </span></span><br><span class="line">            Collections.sort(tmpList);</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(tmpList))&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123;</span><br><span class="line">                tmpList.add(candidates[i]);</span><br><span class="line">                <span class="comment">//回溯,因为candidates 中的数字可以只能使用一次，所以这里start变成了i+1</span></span><br><span class="line">                backTrace(candidates, target - candidates[i], i + <span class="number">1</span>, tmpList, res);</span><br><span class="line">                tmpList.remove(tmpList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【216】组合总和III"><a href="#leetcode-【216】组合总和III" class="headerlink" title="leetcode_【216】组合总和III"></a>leetcode_【216】组合总和III</h2><p>  <a href="https://leetcode-cn.com/problems/combination-sum-iii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iii/submissions/</a></p><blockquote><p>&emsp;&emsp;找出所有相加之和为 n 的 k 个数的组合。组合中<strong>只允许含有 1 - 9 的正整数</strong>，并且每种组合中不存在重复的数字。<br> <strong>说明：</strong><br>        &emsp;所有数字都是正整数。<br>       &emsp; 解集不能包含重复的组合。<br>        <strong>示例 1:<br>        输入:</strong><br>        &emsp;&emsp; k = 3, n = 7<br>        <strong>输出:</strong><br>        &emsp;&emsp; [[1,2,4]]<br>        <strong>示例 2:<br>        输入:</strong><br>        &emsp;&emsp;k = 3, n = 9<br>        <strong>输出:</strong><br>        &emsp;&emsp; [[1,2,6], [1,3,5], [2,3,4]]</p></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//执行用时 :5 ms, 在所有 Java 提交中击败了8.96%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :34.1 MB, 在所有 Java 提交中击败了28.88%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrace(k,n,<span class="number">1</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target,<span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == k &amp;&amp; target == <span class="number">0</span>)&#123;</span><br><span class="line">            Collections.sort(tmpList);</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(tmpList))</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">// 组合数中只包含1-9的数，故i&lt;=9</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= <span class="number">9</span> ;i++)&#123;</span><br><span class="line">                tmpList.add(i);</span><br><span class="line">                backTrace(k-<span class="number">1</span>,target - i,i+<span class="number">1</span>,tmpList,res);</span><br><span class="line">                tmpList.remove(tmpList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【377】组合总和-IV"><a href="#leetcode-【377】组合总和-IV" class="headerlink" title="leetcode_【377】组合总和 IV"></a>leetcode_【377】组合总和 IV</h2><blockquote><p>&emsp;给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。<br>        示例:<br>       &emsp;&emsp; nums = [1, 2, 3]<br>        &emsp;&emsp;target = 4<br>        所有可能的组合为：<br>      &emsp;&emsp;  (1, 1, 1, 1)<br>      &emsp;&emsp;  (1, 1, 2)<br>       &emsp;&emsp; (1, 2, 1)<br>       &emsp;&emsp; (1, 3)<br>       &emsp;&emsp; (2, 1, 1)<br>       &emsp;&emsp; (2, 2)<br>       &emsp;&emsp; (3, 1)<br>        请注意，顺序不同的序列被视作不同的组合。<br>        因此输出为 7。</p></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>   回溯超出内存限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrace(nums,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length &amp;&amp; target &gt;= nums[i];i++)&#123;</span><br><span class="line">                tmpList.add(nums[i]);</span><br><span class="line">                backTrace(nums,target - nums[i],i,tmpList,res);</span><br><span class="line">                tmpList.remove(tmpList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划：dp[i] 代表组成i 能有多少种组合数，即dp[1] = 2代表 和为1的组合个数为2</p><blockquote><ul><li>初始化<ul><li><code>dp[0] = 1</code>;即组成和为0的组合数为1，即都nums里面的数都不取</li></ul></li><li><p>状态转移方程：</p><ul><li><p><code>dp[i]=dp[ i - nums[0] ]+dp[ i - nums[1] ]+dp[ i - nums[2] ] + ...</code></p><p>举个例子 : 比如nums=[1,3,4],target=7;dp[7]=dp[6]+dp[4]+dp[3]</p></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :5 ms, 在所有 Java 提交中击败了68.54%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :34.3 MB, 在所有 Java 提交中击败了39.00%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">combinationSum6</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - nums[j] &gt;= <span class="number">0</span> )&#123;</span><br><span class="line">                dp[i] += dp[i-nums[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【51】N皇后-I"><a href="#leetcode-【51】N皇后-I" class="headerlink" title="leetcode_【51】N皇后 I"></a>leetcode_【51】N皇后 I</h2><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p><blockquote><p>&emsp; n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>  &emsp;  给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>  &emsp;  每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br>        <strong>示例:<br>        输入:</strong><br>        &emsp;  4<br>        <strong>输出:</strong><br>       &emsp; &ensp;   [<br>       &emsp; &emsp;  [“.Q..”,  // 解法 1<br>        &emsp; &emsp; “…Q”,<br>       &emsp; &emsp;  “Q…”,<br>       &emsp; &emsp;  “..Q.” ],<br>        &emsp; &ensp; [ “..Q.”,  // 解法 2<br>        &emsp; &emsp; “Q…”,<br>      &emsp; &emsp;   “…Q”,<br>       &emsp; &emsp;  “.Q..”]<br>       &emsp; &ensp;  ]<br>        <strong>解释:</strong> 4 皇后问题存在两个不同的解法。</p></blockquote><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><blockquote><ul><li>回溯函数 <code>backtrack(row = 0)</code>.<ul><li>从第一个 <code>row = 0</code> 开始.</li><li>循环列并且试图在每个 <code>column</code> 中放置皇后.<ul><li>如果方格 <code>(row, column)</code> 不在攻击范围内<ul><li>在 <code>(row, column)</code> 方格上放置皇后</li><li>排除对应行，列和两个对角线的位置。</li><li>If 所有的行被考虑过，<code>row == NunOfQueen</code><ul><li>意味着我们找到了一个解</li></ul></li><li>else<ul><li>继续考虑接下来的皇后放置 backtrack(row + 1).</li></ul></li><li>回溯：将在 (row, column) 方格的皇后移除.</li></ul></li></ul></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.Arrays.回溯;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//执行用时 :9 ms, 在所有 Java 提交中击败了53.89%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :39.3 MB, 在所有 Java 提交中击败了84.75%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_51</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//用于存储行</span></span><br><span class="line">        List&lt;Integer&gt; col = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储正对角线</span></span><br><span class="line">        List&lt;Integer&gt; z_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储负对角线</span></span><br><span class="line">        List&lt;Integer&gt; f_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//从第一个row = 0开始</span></span><br><span class="line">        backtrack(<span class="number">0</span>, n, res, <span class="keyword">new</span> ArrayList&lt;String&gt;(), col, z_diagonal, f_diagonal);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> NumOfQueen, List&lt;List&lt;String&gt;&gt; res, ArrayList&lt;String&gt; tmplist, List&lt;Integer&gt; col, List&lt;Integer&gt; z_diagonal, List&lt;Integer&gt; f_diagonal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//到达了最后一行</span></span><br><span class="line">        <span class="keyword">if</span> (row == NumOfQueen) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; NumOfQueen; column++) &#123;</span><br><span class="line">            <span class="comment">//如果不在攻击范围内（不在同一行或者同一列 &amp;&amp; 负对角线和相等 &amp;&amp;  正对角线差相等）</span></span><br><span class="line">            <span class="keyword">if</span> (!col.contains(column) &amp;&amp; !f_diagonal.contains(row + column) &amp;&amp; !z_diagonal.contains(row - column)) &#123;</span><br><span class="line">                col.add(column);</span><br><span class="line">                f_diagonal.add(row + column);</span><br><span class="line">                z_diagonal.add(row - column);</span><br><span class="line">                <span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[NumOfQueen];</span><br><span class="line">                Arrays.fill(s, <span class="string">'.'</span>);</span><br><span class="line">                <span class="comment">//这一行的j位置放皇后</span></span><br><span class="line">                s[column] = <span class="string">'Q'</span>;</span><br><span class="line">                tmplist.add(<span class="keyword">new</span> String(s));</span><br><span class="line">                <span class="comment">//回溯算法</span></span><br><span class="line">                backtrack(row+<span class="number">1</span>,NumOfQueen,res,tmplist,col,z_diagonal,f_diagonal);</span><br><span class="line">                tmplist.remove(tmplist.size() - <span class="number">1</span>);</span><br><span class="line">                col.remove(Integer.valueOf(column));</span><br><span class="line">                f_diagonal.remove(Integer.valueOf(row + column));</span><br><span class="line">                z_diagonal.remove(Integer.valueOf(row - column));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【52】N皇后-II"><a href="#leetcode-【52】N皇后-II" class="headerlink" title="leetcode_【52】N皇后 II"></a>leetcode_【52】N皇后 II</h2><p><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens-ii/</a></p><blockquote><p>&emsp; n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>  &emsp;  给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>  &emsp;  每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br>        <strong>示例:<br>        输入:</strong><br>        &emsp;  4<br>        <strong>输出:</strong><br>       &emsp; 2<br>        <strong>解释</strong>：4皇后存在两种不同的解法<br>       &emsp; &ensp;   [<br>       &emsp; &emsp;  [“.Q..”,  // 解法 1<br>        &emsp; &emsp; “…Q”,<br>       &emsp; &emsp;  “Q…”,<br>       &emsp; &emsp;  “..Q.” ],<br>        &emsp; &ensp; [ “..Q.”,  // 解法 2<br>        &emsp; &emsp; “Q…”,<br>      &emsp; &emsp;   “…Q”,<br>       &emsp; &emsp;  “.Q..”]<br>       &emsp; &ensp;  ]</p></blockquote><p>   如leetcode_【51】代码返回res.size();</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时</span></span><br><span class="line"> :<span class="number">29</span> ms, 在所有 Java 提交中击败了<span class="number">5.45</span>%的用户</span><br><span class="line"><span class="comment">//内存消耗 :34.8 MB, 在所有 Java 提交中击败了41.25%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用于存储行</span></span><br><span class="line">        List&lt;Integer&gt; col = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储正对角线</span></span><br><span class="line">        List&lt;Integer&gt; z_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储负对角线</span></span><br><span class="line">        List&lt;Integer&gt; f_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//从第一个row = 0开始</span></span><br><span class="line">        backtrack(<span class="number">0</span>, n, res, <span class="keyword">new</span> ArrayList&lt;String&gt;(), col, z_diagonal, f_diagonal);</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> NumOfQueen, List&lt;List&lt;String&gt;&gt; res, ArrayList&lt;String&gt; tmplist, List&lt;Integer&gt; col, List&lt;Integer&gt; z_diagonal, List&lt;Integer&gt; f_diagonal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//到达了最后一行</span></span><br><span class="line">        <span class="keyword">if</span> (row == NumOfQueen) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; NumOfQueen; column++) &#123;</span><br><span class="line">            <span class="comment">//如果不在攻击范围内（不在同一行或者同一列 &amp;&amp; 负对角线和相等 &amp;&amp;  正对角线差相等）</span></span><br><span class="line">            <span class="keyword">if</span> (!col.contains(column) &amp;&amp; !f_diagonal.contains(row + column) &amp;&amp; !z_diagonal.contains(row - column)) &#123;</span><br><span class="line">                col.add(column);</span><br><span class="line">                f_diagonal.add(row + column);</span><br><span class="line">                z_diagonal.add(row - column);</span><br><span class="line">                <span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[NumOfQueen];</span><br><span class="line">                Arrays.fill(s, <span class="string">'.'</span>);</span><br><span class="line">                <span class="comment">//这一行的j位置放皇后</span></span><br><span class="line">                s[column] = <span class="string">'Q'</span>;</span><br><span class="line">                tmplist.add(<span class="keyword">new</span> String(s));</span><br><span class="line">                <span class="comment">//回溯算法</span></span><br><span class="line">                backtrack(row+<span class="number">1</span>,NumOfQueen,res,tmplist,col,z_diagonal,f_diagonal);</span><br><span class="line">                tmplist.remove(tmplist.size() - <span class="number">1</span>);</span><br><span class="line">                col.remove(Integer.valueOf(column));</span><br><span class="line">                f_diagonal.remove(Integer.valueOf(row + column));</span><br><span class="line">                z_diagonal.remove(Integer.valueOf(row - column));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【78】子集I"><a href="#leetcode-【78】子集I" class="headerlink" title="leetcode_【78】子集I"></a>leetcode_【78】子集I</h2><p>   <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p><blockquote><p>&emsp;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>        &emsp;说明：解集不能包含重复的子集。<br>        &emsp;示例:<br>        输入:<br>        &emsp;&emsp;nums = [1,2,3]<br>        输出:<br>       &emsp;&ensp; [<br>      &emsp;&emsp;  [3],<br>       &emsp;&emsp;  [1],<br>         &emsp;&emsp; [2],<br>         &emsp;&emsp; [1,2,3],<br>         &emsp;&emsp; [1,3],<br>         &emsp;&emsp; [2,3],<br>         &emsp;&emsp; [1,2],<br>         &emsp;&emsp; []<br>      &emsp;&ensp;  ]</p></blockquote><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了87.86%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :37 MB, 在所有 Java 提交中击败了44.12%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmplist, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            tmplist.add(nums[i]);</span><br><span class="line">            backTrace(nums,i+<span class="number">1</span>,tmplist,res);</span><br><span class="line">            tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【90】子集-II"><a href="#leetcode-【90】子集-II" class="headerlink" title="leetcode_【90】子集 II"></a>leetcode_【90】子集 II</h2><p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets-ii/</a></p><blockquote><p>   给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>        说明：解集不能包含重复的子集。<br>        示例:<br>        输入:<br>        &emsp; [1,2,2]<br>        输出:<br>       &emsp; &ensp;  [<br>       &emsp; &emsp;  [2],<br>         &emsp; &emsp; [1],<br>        &emsp; &emsp; [1,2,2],<br>        &emsp; &emsp; [2,2],<br>         &emsp; &emsp; [1,2],<br>        &emsp; &emsp; []<br>        &emsp; &ensp; ]</p></blockquote><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了87.52%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :38.5 MB, 在所有 Java 提交中击败了47.42%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmplist, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//和上一个数字相等则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmplist.add(nums[i]);</span><br><span class="line">                backTrace(nums,i+<span class="number">1</span>,tmplist,res);</span><br><span class="line">                tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回溯算法&quot;&gt;&lt;a href=&quot;#回溯算法&quot; class=&quot;headerlink&quot; title=&quot;回溯算法&quot;&gt;&lt;/a&gt;回溯算法&lt;/h2&gt;&lt;p&gt;&amp;emsp;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。即从一条路往前走，能进则进，不能进则退回来，换一条路再试。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="回溯算法" scheme="http://blogs.qiulig.website/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【102】二叉树的层次遍历</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-102-二叉树的层次遍历/</id>
    <published>2019-06-30T08:00:33.000Z</published>
    <updated>2019-07-06T02:54:11.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。<a id="more"></a></p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">3</span></span><br><span class="line">&gt;     / \</span><br><span class="line">&gt;    <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">&gt;       / \</span><br><span class="line">&gt;      <span class="number">15</span>  <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>同【剑指offer - 60】</p><p>BFS广度优先搜索的扩展题</p><p>迭代思想：</p><p>我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。</p><p>第 0 层只包含根节点 root ，算法实现如下：</p><pre><code>(1)初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。(2)当队列非空的时候：    1) 在输出结果 levels 中插入一个空列表，开始当前层的算法。    2)计算当前层有多少个元素：等于队列的长度。    3)将这些元素从队列中弹出，并加入 levels 当前层的空列表中。    4)将他们的孩子节点作为下一层压入队列中。    5)进入下一层 level++。</code></pre><p>递归思想：<br>    最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下：<br>    (1)输出列表称为 ans，当前最高层数就是列表的长度 len(ans)。比较访问节点所在的层次 level 和当前最高层次 len(ans) 的大小，如果前者更大就向 ans 添加一个空列表。<br>    (2)将当前节点插入到对应层的列表 ans[level] 中。<br>    (3)递归非空的孩子节点：helper(node.left , level + 1)。helper(node.right, level + 1)。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> ms, 在所有 Java 提交中击败了<span class="number">55.91</span>%的用户</span><br><span class="line"></span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">36.5</span> MB, 在所有 Java 提交中击败了<span class="number">44.59</span>%的用户</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//用于记录所有结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//用于保存当前层的节点数</span></span><br><span class="line">           ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="comment">//当前层包含的节点个数</span></span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count;i++)&#123;</span><br><span class="line">              <span class="comment">//删除并返回queue中的头元素，删掉根（上一层结点元素）</span></span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               <span class="comment">//加入左子树</span></span><br><span class="line">               <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               <span class="comment">//加入右子树</span></span><br><span class="line">               <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               <span class="comment">//加入当前层的节点</span></span><br><span class="line">               tmp.add(node.val);</span><br><span class="line">           &#125;</span><br><span class="line">           lists.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line">    <span class="number">2</span> ms, 在所有 Java 提交中击败了<span class="number">92.32</span>%的用户</span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">37.1</span> MB, 在所有 Java 提交中击败了<span class="number">42.97</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() == level)</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        ans.get(level).add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/102.png" alt="leetcode提交结果-迭代"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【108】将有序数组转换成二叉搜索树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-108-将有序数组转换成二叉搜索树/</id>
    <published>2019-06-30T07:08:20.000Z</published>
    <updated>2019-06-30T07:43:16.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<a id="more"></a></p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;           <span class="number">0</span></span><br><span class="line">&gt;          / \</span><br><span class="line">&gt;        -<span class="number">3</span>   <span class="number">9</span></span><br><span class="line">&gt;        /   /</span><br><span class="line">&gt;      -<span class="number">10</span>  <span class="number">5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>将一个排序array转化为平衡二叉搜索树：<br>平衡二叉树：对于每个根节点，左右子树高度差 &lt;= 1；<br>二叉搜索树：对于每个节点，其左子树值&lt;此节点值，右子树&gt;此节点值。<br>要满足以上两个特点，我们自然想到以array中点值作为根节点值，并递归重建，这样就可以同时保证以上两个条件。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">3</span> ms, 在所有 Java 提交中击败了<span class="number">8.50</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">40.2</span> MB, 在所有 Java 提交中击败了<span class="number">29.40</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将最中间的数作为根节点</span></span><br><span class="line">        TreeNode root =<span class="keyword">new</span> TreeNode( nums[nums.length/<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//以中间的树为分界，左边归属于左子树，右边归属于右子树</span></span><br><span class="line">        root.left = sortedArrayToBST(Arrays.copyOfRange(nums,<span class="number">0</span>,nums.length/<span class="number">2</span>));</span><br><span class="line">        root.right = sortedArrayToBST(Arrays.copyOfRange(nums,nums.length/<span class="number">2</span>+<span class="number">1</span>,nums.length));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时为2ms的范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右等分建立左右子树，中间节点作为子树根节点，递归该过程</span></span><br><span class="line">        <span class="keyword">return</span> nums == <span class="keyword">null</span> ? <span class="keyword">null</span> : buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">        root.left = buildTree(nums, left, mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        root.right = buildTree(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/108.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【106】从中序与后序遍历序列构造二叉树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-106-从中序与后序遍历序列构造二叉树/</id>
    <published>2019-06-30T03:00:24.000Z</published>
    <updated>2019-06-30T03:14:11.409Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。<a id="more"></a></p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;       <span class="number">3</span></span><br><span class="line">&gt;      /  \</span><br><span class="line">&gt;     <span class="number">9</span>    <span class="number">20</span></span><br><span class="line">&gt;    /  \</span><br><span class="line">&gt;   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>中序<code>9,3,15,20,7</code>,后序 <code>9,15,7,20,3</code></p><p>有如下特征：</p><ol><li>后序中最后一位<code>1</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>root</code>；</li><li>中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li><li>后序中结点分布应该是：<code>[左子树结点，右子树结点，根结点]</code>；</li><li>根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；</li><li>如果我们要后序遍历生成二叉树的话，下一层递归应该是：<ul><li>左子树：<code>root.left = buildTree(中序左子树范围，后序左子树范围);</code>；</li><li>右子树：<code>root.right = buildTree(中序右子树范围，后序左子树范围，);</code>。</li></ul></li><li>每一层递归都要返回当前根结点<code>root</code>；</li></ol></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">42</span> ms, 在所有 Java 提交中击败了<span class="number">15.47</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">78.1</span> MB, 在所有 Java 提交中击败了<span class="number">5.17</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.length == <span class="number">0</span>||postorder.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//根节点为后序遍历的最后一个节点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">              <span class="comment">//找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点</span></span><br><span class="line">                <span class="keyword">if</span>(inorder[i] == postorder[postorder.length-<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="comment">//递归构建左子树，此时,中序缩小为[0,i),后序的范围缩小为[0,i]</span></span><br><span class="line">                    root.left = buildTree(Arrays.copyOfRange(inorder,<span class="number">0</span>,i),Arrays.copyOfRange(postorder,<span class="number">0</span>,i));</span><br><span class="line">              <span class="comment">//递归构建右子树,中序缩小为[i+1,len),后序的范围缩小为[i,len-1),</span></span><br><span class="line">                    root.right = buildTree(Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length),Arrays.copyOfRange(postorder,i,postorder.length-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/106.png" alt="重构二叉树"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;根据一棵树的中序遍历与后序遍历构造二叉树。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【105】从前序与中序遍历序列构造二叉树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-105-从前序与中序遍历序列构造二叉树/</id>
    <published>2019-06-30T01:54:21.000Z</published>
    <updated>2019-06-30T03:14:57.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>根据一棵树的前序遍历与中序遍历构造二叉树。<a id="more"></a></p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">3</span></span><br><span class="line">&gt;     / \</span><br><span class="line">&gt;    <span class="number">9</span>   <span class="number">20</span></span><br><span class="line">&gt;       /  \</span><br><span class="line">&gt;      <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>同【剑指offer_4】</p><p>前序<code>3,9,20,15,7</code>  ，中序<code>9,3,15,20,7</code>；</p><p>有如下特征：</p><ol><li>前序中左起第一位<code>3</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>root</code>；</li><li>中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li><li>前序中结点分布应该是：<code>[根结点，左子树结点，右子树结点]</code>；</li><li>根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；</li><li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul><li>左子树：<code>root.left = buildTree(前序左子树范围，中序左子树范围);</code>；</li><li>右子树：<code>root.right = buildTree(前序右子树范围，中序右子树范围);</code>。</li></ul></li><li>每一层递归都要返回当前根结点<code>root</code>；</li></ol></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">43</span> ms, 在所有 Java 提交中击败了<span class="number">15.42</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">76.5</span> MB, 在所有 Java 提交中击败了<span class="number">6.76</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="comment">//找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点  </span></span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">             <span class="comment">//递归构建左子树，此时前序的范围缩小为[1,i],中序缩小为[0,i)     </span></span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">             <span class="comment">//递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len)   </span></span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时32ms的范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length != inorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildHelper(preorder, inorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildHelper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preL &gt; preR) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preL]);</span><br><span class="line">        <span class="keyword">int</span> rootIdx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = inL; i &lt;= inR; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == preorder[preL]) &#123;</span><br><span class="line">                rootIdx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rootIdx == -<span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        root.left = buildHelper(preorder, inorder, preL + <span class="number">1</span>, rootIdx - inL + preL, inL, rootIdx - <span class="number">1</span>);</span><br><span class="line">        root.right = buildHelper(preorder, inorder, rootIdx - inL + preL + <span class="number">1</span>, preR, rootIdx + <span class="number">1</span>, inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/105.png" alt="重构二叉树"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;根据一棵树的前序遍历与中序遍历构造二叉树。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【101】对称二叉树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-101-对称二叉树/</id>
    <published>2019-06-30T01:11:24.000Z</published>
    <updated>2019-06-30T10:41:14.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，检查它是否是镜像对称的。<a id="more"></a></p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;       <span class="number">1</span></span><br><span class="line">&gt;    /     \</span><br><span class="line">&gt;   <span class="number">2</span>       <span class="number">2</span></span><br><span class="line">&gt;  /  \    /  \</span><br><span class="line">&gt; <span class="number">3</span>   <span class="number">4</span>   <span class="number">4</span>   <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">1</span></span><br><span class="line">&gt;     /  \</span><br><span class="line">&gt;    <span class="number">2</span>    <span class="number">2</span></span><br><span class="line">&gt;     \    \</span><br><span class="line">&gt;      <span class="number">3</span>    <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：递归</p><blockquote><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p><p>如果同时满足下面的条件，两个树互为镜像：</p><p>(1)它们的两个根结点具有相同的值。<br>(2)每个树的右子树都与另一个树的左子树镜像对称。</p><p>递归过程：</p><ul><li>判断两个指针当前节点值是否相等</li><li>判断 A 的右子树与 B 的左子树是否对称</li><li>判断 A 的左子树与 B 的右子树是否对称</li></ul></blockquote><p>方法2：迭代</p><blockquote><p>类似于广度优先遍历BFS，用一个队列queue存储左右节点。其中队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。</p><p>(1) 最初，队列中包含的是 root 以及 root。每次提取两个结点并比较它们的值。</p><p>(2)当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><p>(3)然后，将两个结点的左右子结点按相反的顺序插入队列中。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">     <span class="number">2</span> ms, 在所有 Java 提交中击败了<span class="number">84.89</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">35.5</span> MB, 在所有 Java 提交中击败了<span class="number">80.63</span>%的用户</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Symmetric</span><span class="params">(TreeNode leftroot,TreeNode rightroot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> &amp;&amp; rightroot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> || rightroot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot.val != rightroot.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(leftroot.left,rightroot.right) &amp;&amp; Symmetric(leftroot.right,rightroot.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">3</span> ms, 在所有 Java 提交中击败了<span class="number">28.02</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line"></span><br><span class="line">    <span class="number">35.7</span> MB, 在所有 Java 提交中击败了<span class="number">80.01</span>%的用户</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node1 = queue.poll();</span><br><span class="line">            TreeNode node2 = queue.poll();</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> &amp;&amp; node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> || node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">if</span>(node1.val!=node2.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            queue.add(node1.left);</span><br><span class="line">            queue.add(node2.right);</span><br><span class="line">            queue.add(node1.right);</span><br><span class="line">            queue.add(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/101.png" alt="对称二叉树-递归"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【100】相同的树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-100-相同的树/</id>
    <published>2019-06-29T13:28:03.000Z</published>
    <updated>2019-06-30T02:06:24.896Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; 示例 <span class="number">1</span>:</span><br><span class="line">&gt; 输入:   <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">&gt;       /  \       /  \</span><br><span class="line">&gt;      <span class="number">2</span>    <span class="number">3</span>     <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt; 输出: <span class="keyword">true</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; 示例 <span class="number">2</span>:</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入:    <span class="number">1</span>      <span class="number">1</span></span><br><span class="line">&gt;         /       \</span><br><span class="line">&gt;        <span class="number">2</span>         <span class="number">2</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">1</span>,<span class="number">2</span>],     [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 输出: <span class="keyword">false</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; 示例 <span class="number">3</span>:</span><br><span class="line">&gt; 输入:      <span class="number">1</span>        <span class="number">1</span></span><br><span class="line">&gt;          /  \     /  \</span><br><span class="line">&gt;         <span class="number">2</span>    <span class="number">1</span>   <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 输出：<span class="keyword">false</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>最简单的策略是使用递归。检查p和q节点是否不是空，它们的值是否相等。如果所有检查都正常，则递归地为子节点执行相同操作。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line">    <span class="number">1</span> ms, 在所有 Java 提交中击败了<span class="number">86.63</span>%的用户</span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">34.2</span> MB, 在所有 Java 提交中击败了<span class="number">85.19</span>%的用户</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> ||q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val !=q.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4. 提交结果"></a>4. 提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/100.png" alt="相同的树"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个二叉树，编写一个函数来检验它们是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【104】二叉树的最大深度</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-104-二叉树的最大深度/</id>
    <published>2019-06-29T13:02:06.000Z</published>
    <updated>2019-06-30T02:44:20.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><blockquote><p>给定一个二叉树，找出其最大深度。<a id="more"></a></p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">3</span></span><br><span class="line">&gt;     /  \</span><br><span class="line">&gt;    <span class="number">9</span>   <span class="number">20</span></span><br><span class="line">&gt;       /  \</span><br><span class="line">&gt;      <span class="number">15</span>  <span class="number">7</span></span><br><span class="line">&gt; 返回它的最大深度 <span class="number">3</span> 。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>同 【剑指offer38题】</p><p>递归实现</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line">    <span class="number">1</span> ms, 在所有 Java 提交中击败了<span class="number">98.19</span>%的用户</span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">37.5</span> MB, 在所有 Java 提交中击败了<span class="number">45.48</span>%的用户</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> left_height =  maxDepth(root.left);</span><br><span class="line">             <span class="keyword">int</span> right_height = maxDepth(root.right);</span><br><span class="line">             <span class="keyword">return</span> Math.max(left_height,right_height)+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/104.png" alt="二叉树的最大深度"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
</feed>
