<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0972e01a5f38f38e77d0154479c21150</icon>
  <subtitle>菜鸟要更加努力才能追上别人的步伐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blogs.qiulig.website/"/>
  <updated>2019-07-26T13:21:08.084Z</updated>
  <id>http://blogs.qiulig.website/</id>
  
  <author>
    <name>qiulig</name>
    <email>qiuling_long@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树的涉及的题</title>
    <link href="http://blogs.qiulig.website/2019/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B6%89%E5%8F%8A%E7%9A%84%E9%A2%98/"/>
    <id>http://blogs.qiulig.website/2019/07/二叉树的涉及的题/</id>
    <published>2019-07-26T13:10:00.000Z</published>
    <updated>2019-07-26T13:21:08.084Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line">       TreeNode(<span class="keyword">int</span> x) &#123; </span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-二叉树的最大深度"><a href="#1-二叉树的最大深度" class="headerlink" title="1.二叉树的最大深度"></a>1.二叉树的最大深度</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left =  maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-二叉树的最小深度"><a href="#2-二叉树的最小深度" class="headerlink" title="2.二叉树的最小深度"></a>2.二叉树的最小深度</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((root.left == <span class="keyword">null</span>) &amp;&amp; (root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> minDepth = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           minDepth = Math.min(minDepth, minDepth(root.left));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           minDepth = Math.min(minDepth, minDepth(root.right));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> minDepth + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="3-求完全二叉树中节点的个数"><a href="#3-求完全二叉树中节点的个数" class="headerlink" title="3..求完全二叉树中节点的个数"></a>3..求完全二叉树中节点的个数</h2><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">int</span> left = countNodes(root.left);</span><br><span class="line">       <span class="keyword">int</span> right = countNodes(root.right);</span><br><span class="line">       <span class="keyword">return</span> left+right +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4. 平衡二叉树"></a>4. 平衡二叉树</h2><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(getDepth(root.left)-getDepth(root.right))&lt;=<span class="number">1</span>)&#123;      </span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp;isBalanced(root.right);   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-二叉树的完全性检验"><a href="#5-二叉树的完全性检验" class="headerlink" title="5.二叉树的完全性检验"></a>5.二叉树的完全性检验</h2><p><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//加入根节点</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">boolean</span> hasNoChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (hasNoChild) &#123;</span><br><span class="line">                <span class="comment">//上一层中左子树不为空，右子树为空，如果遍历到左子树，这时候左子树有孩子，则代表上一层不完全填满</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span> || node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;  <span class="comment">//左右子树不为空</span></span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123; <span class="comment">//左子树不为空,右子树为空</span></span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                    hasNoChild = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;<span class="comment">//左子树为空，右子树不为空</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//左右子树都为空</span></span><br><span class="line">                    hasNoChild = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-相同的树"><a href="#6-相同的树" class="headerlink" title="6.相同的树"></a>6.相同的树</h2><p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> ||q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val !=q.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-对称二叉树"><a href="#7-对称二叉树" class="headerlink" title="7.对称二叉树"></a>7.对称二叉树</h2><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Symmetric</span><span class="params">(TreeNode leftroot,TreeNode rightroot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> &amp;&amp; rightroot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> || rightroot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot.val != rightroot.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(leftroot.left,rightroot.right) &amp;&amp; Symmetric(leftroot.right,rightroot.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node1 = queue.poll();</span><br><span class="line">            TreeNode node2 = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> &amp;&amp; node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> || node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">if</span>(node1.val!=node2.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            queue.add(node1.left);</span><br><span class="line">            queue.add(node2.right);</span><br><span class="line">            queue.add(node1.right);</span><br><span class="line">            queue.add(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-翻转二叉树"><a href="#8-翻转二叉树" class="headerlink" title="8.翻转二叉树"></a>8.翻转二叉树</h2><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-二叉搜索树的最近公共祖先"><a href="#9-二叉搜索树的最近公共祖先" class="headerlink" title="9.二叉搜索树的最近公共祖先"></a>9.二叉搜索树的最近公共祖先</h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//都在右子树</span></span><br><span class="line">        <span class="keyword">if</span>(p.val &gt;root.val &amp;&amp; q.val &gt;root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val&lt;root.val &amp;&amp; q.val &lt;root.val)&#123; <span class="comment">//都在左子树</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//一个在左子树，一个在右子树</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-二叉树的最近公共祖先"><a href="#10-二叉树的最近公共祖先" class="headerlink" title="10.二叉树的最近公共祖先"></a>10.二叉树的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span> || root==p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">return</span> left==<span class="keyword">null</span> ? right : right == <span class="keyword">null</span>?left:root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-最深叶节点的最近公共祖先"><a href="#11-最深叶节点的最近公共祖先" class="headerlink" title="11.最深叶节点的最近公共祖先"></a>11.最深叶节点的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="comment">//如果左右子树深度相同，表示获取到了最深叶子节点的最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果左右子树不等高，高度小的那个子树节点的叶子节点的深度肯定不是最深的（因为比高度大的子树深度小）。</span></span><br><span class="line">        <span class="comment">//所以，最深叶子节点肯定在深度较大的子树当中，采用深度优先搜索，每次只要继续往深度更大的子树进行递归即可。</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lcaDeepestLeaves(root.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lcaDeepestLeaves(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-节点与其祖先中间的最大差值"><a href="#12-节点与其祖先中间的最大差值" class="headerlink" title="12.节点与其祖先中间的最大差值"></a>12.节点与其祖先中间的最大差值</h2><p><a href="https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> AncestorDiff(root,root.val,root.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每条从根节点到叶子节点的路径中的最大值和最小值，并求出差值更新全局变量</span></span><br><span class="line">    <span class="comment">//一口气遍历到叶子节点，遍历的时候动态保存当前路径的最大节点值和最小节点值</span></span><br><span class="line">    <span class="comment">//每当遍历一次叶子节点，将保存好的最大值与最小值之间的差与全局变量 maxvalue 比较，并且取较大值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">AncestorDiff</span><span class="params">(TreeNode root, <span class="keyword">int</span> max_value, <span class="keyword">int</span> min_value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> max_value-min_value;</span><br><span class="line">        max_value = root.val &gt; max_value ? root.val : max_value;</span><br><span class="line">        min_value = root.val &lt; min_value ? root.val : min_value;</span><br><span class="line">        <span class="keyword">return</span> Math.max(AncestorDiff(root.left,max_value,min_value),AncestorDiff(root.right,max_value,min_value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-从前序与中序遍历序列构造二叉树"><a href="#13-从前序与中序遍历序列构造二叉树" class="headerlink" title="13.从前序与中序遍历序列构造二叉树"></a>13.从前序与中序遍历序列构造二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//前序的第一个数即为树的根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序中的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">                <span class="comment">//pre[1,i+1] 和in[0,i]构成左子树的遍历</span></span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                <span class="comment">//pre[i+1,len-1]和in[i+1,len-1]构成右子树的遍历</span></span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-从中序与后序遍历序列构造二叉树"><a href="#14-从中序与后序遍历序列构造二叉树" class="headerlink" title="14.从中序与后序遍历序列构造二叉树"></a>14.从中序与后序遍历序列构造二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.length == <span class="number">0</span>||postorder.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//后序的最后一个为根结点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序中的根节点位置</span></span><br><span class="line">                <span class="keyword">if</span>(inorder[i] == postorder[postorder.length-<span class="number">1</span>])&#123;</span><br><span class="line">                  <span class="comment">//in[0,i]和pos[0,i-1]构成左子树的遍历</span></span><br><span class="line">                    root.left = buildTree(Arrays.copyOfRange(inorder,<span class="number">0</span>,i),Arrays.copyOfRange(postorder,<span class="number">0</span>,i));</span><br><span class="line">                     <span class="comment">//in[i+1,len-1]和pos[i,len-2]构成左子树的遍历</span></span><br><span class="line">                    root.right = buildTree(Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length),Arrays.copyOfRange(postorder,i,postorder.length-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-把二叉树转换成累加树"><a href="#15-把二叉树转换成累加树" class="headerlink" title="15.把二叉树转换成累加树"></a>15.把二叉树转换成累加树</h2><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历结果为从小到大，要变成累加树，则中序遍历反过来相加变成节点值即可。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//遍历右子树</span></span><br><span class="line">           convertBST(root.right);</span><br><span class="line">           <span class="comment">//改变值，依次累加即可</span></span><br><span class="line">           root.val = root.val+num;</span><br><span class="line">           <span class="comment">//存储上一层的值</span></span><br><span class="line">           num = root.val;</span><br><span class="line">           <span class="comment">//遍历左子树</span></span><br><span class="line">           convertBST(root.left);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-不同的二叉搜索树"><a href="#16-不同的二叉搜索树" class="headerlink" title="16.不同的二叉搜索树"></a>16.不同的二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br>动态规划</p><ul><li><p>初始化</p><p>假设n个节点存在二叉搜索树的个数是dp（n）,令f(i) 为以i为根的二叉搜索树的个数，则有</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;  <code>dp(n) = f(1) + f(2) + f(3) +... + f(n)</code></p><p>当i为根节点时，其左子树的个数为(i - 1),右子树的个数为（n-i）,则</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;  <code>f(i) = dp(i-1) *dp(n-i)</code></p><p>结合两个式子可以得到卡特兰数：</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp; <code>dp(n) = dp(0) *dp(n-1) +dp(1) *dp(n-2) +... +dp(n-1)</code>*dp(0)</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;&emsp; &emsp; &ensp; <code>= dp(n-1) * C(2n,n)</code></p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;&emsp; &emsp; &ensp; <code>= dp(n-1) * (4*n-2)/(n-1)</code></p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n个节点存在二叉树的个数</span></span><br><span class="line">        <span class="keyword">long</span> []dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//以i为根节点的二叉树个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//以0为根节点的</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]*(<span class="number">4</span>*i-<span class="number">2</span>)/(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-不同的二叉搜索树-II"><a href="#17-不同的二叉搜索树-II" class="headerlink" title="17.不同的二叉搜索树 II"></a>17.不同的二叉搜索树 II</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees=generate(start,i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归遍历右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees=generate(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//先序遍历存入以i为根节点的二叉搜索树</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left:leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right:rightTrees)&#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left=left;</span><br><span class="line">                    root.right=right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-在二叉树中增加一行"><a href="#18-在二叉树中增加一行" class="headerlink" title="18.在二叉树中增加一行"></a>18.在二叉树中增加一行</h2><p><a href="https://leetcode-cn.com/problems/add-one-row-to-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-one-row-to-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">           TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">           <span class="comment">//如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</span></span><br><span class="line">            <span class="keyword">if</span>(d == <span class="number">1</span>)&#123;</span><br><span class="line">                node.left = root;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d == <span class="number">0</span>)&#123;</span><br><span class="line">                node.right = root;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; d&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                root.left = addOneRow(root.left ,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">                root.right = addOneRow(root.right,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-验证一棵树是不是二叉搜索树"><a href="#19-验证一棵树是不是二叉搜索树" class="headerlink" title="19.验证一棵树是不是二叉搜索树"></a>19.验证一棵树是不是二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据二叉搜索树的中序遍历为从小到大的思路写的</span></span><br><span class="line"><span class="comment">//修改一下二叉搜索树的非递归写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">double</span> inorder = - Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt;= inorder)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二叉树的定义&quot;&gt;&lt;a href=&quot;#二叉树的定义&quot; class=&quot;headerlink&quot; title=&quot;二叉树的定义&quot;&gt;&lt;/a&gt;二叉树的定义&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            val = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>树的【前序遍历】【中序遍历】【后序遍历】【层遍历】【BFS】【DFS】</title>
    <link href="http://blogs.qiulig.website/2019/07/%E6%A0%91%E7%9A%84%E3%80%90%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%B1%82%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90BFS%E3%80%91%E3%80%90DFS%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/树的【前序遍历】【中序遍历】【后序遍历】【层遍历】【BFS】【DFS】/</id>
    <published>2019-07-26T13:08:30.000Z</published>
    <updated>2019-07-26T13:20:53.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉树的数据结构"><a href="#二叉树的数据结构" class="headerlink" title="二叉树的数据结构"></a>二叉树的数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line">       TreeNode(<span class="keyword">int</span> x) &#123; </span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-二叉树的前序遍历"><a href="#1-二叉树的前序遍历" class="headerlink" title="1.二叉树的前序遍历"></a>1.二叉树的前序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.62%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.1 MB, 在所有 Java 提交中击败了40.72%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**依次将每层的结点入栈，入栈顺序是右--左，方便弹出时出栈为左---右**/</span></span><br><span class="line">     <span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了6.05%的用户</span></span><br><span class="line">    <span class="comment">//内存消耗 :35 MB, 在所有 Java 提交中击败了40.72%的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">//入栈下一层的右节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入栈下一层的左节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加入根节点</span></span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-二叉树的中序遍历"><a href="#2-二叉树的中序遍历" class="headerlink" title="2.二叉树的中序遍历"></a>2.二叉树的中序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.55%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :34.7 MB, 在所有 Java 提交中击败39.5的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">              inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了55.11%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.1 MB, 在所有 Java 提交中击败了39.36%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            TreeNode cur = root;</span><br><span class="line">            <span class="keyword">while</span> (cur!=<span class="keyword">null</span> ||!stack.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//循环直到找到最左子树</span></span><br><span class="line">                <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(cur);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                ans.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="3-二叉树的后序遍历"><a href="#3-二叉树的后序遍历" class="headerlink" title="3. 二叉树的后序遍历"></a>3. 二叉树的后序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.71%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.6 MB, 在所有 Java 提交中击败了36.80%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(root.left !=<span class="keyword">null</span>)</span><br><span class="line">            postorderTraversal(root.left);</span><br><span class="line">         <span class="keyword">if</span>(root.right !=<span class="keyword">null</span>)</span><br><span class="line">            postorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了61.53%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.8 MB, 在所有 Java 提交中击败了35.50%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里先加入根结点</span></span><br><span class="line">    stack.addLast(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      TreeNode node = stack.pollLast();</span><br><span class="line">      <span class="comment">//在res的头部添加，依次添加的为 根，然后再添加为 右--根，再添加为左--右--根</span></span><br><span class="line">      res.addFirst(node.val);  </span><br><span class="line">      <span class="comment">//在stack中依次加入左--右，方便下次先弹出右子树，再弹出左子树</span></span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.addLast(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.addLast(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-二叉树的层序遍历"><a href="#4-二叉树的层序遍历" class="headerlink" title="4.二叉树的层序遍历"></a>4.二叉树的层序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了90.77%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :37 MB, 在所有 Java 提交中击败了43.02%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() == level)</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        ans.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了58.74%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :36.7 MB, 在所有 Java 提交中击败了43.83%的用户</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//用于存一层的结果</span></span><br><span class="line">           ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="comment">//这一层的结点个数</span></span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count;i++)&#123;</span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               <span class="comment">//存入下一层的左右子树</span></span><br><span class="line">               <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               <span class="comment">//添加当前层的值到tmp    </span></span><br><span class="line">               tmp.add(node.val);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将一层的结果存到结果集中</span></span><br><span class="line">           res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-二叉树的深度优先遍历"><a href="#5-二叉树的深度优先遍历" class="headerlink" title="5.二叉树的深度优先遍历"></a>5.二叉树的深度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ans.add(root.val);</span><br><span class="line">               DFS(root.left);</span><br><span class="line">               DFS(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">//先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-二叉树的广度优先遍历"><a href="#6-二叉树的广度优先遍历" class="headerlink" title="6.二叉树的广度优先遍历"></a>6.二叉树的广度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> res;</span><br><span class="line">         Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">         queue.add(root);</span><br><span class="line">         <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">             TreeNode node = queue.poll();</span><br><span class="line">             <span class="comment">////先往queue中压入左节点，再压右节点。</span></span><br><span class="line">             <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.left);</span><br><span class="line">             <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.right);</span><br><span class="line">             res.add(node.val);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="N叉树的数据结构"><a href="#N叉树的数据结构" class="headerlink" title="N叉树的数据结构"></a>N叉树的数据结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-N叉树的前序遍历"><a href="#1-N叉树的前序遍历" class="headerlink" title="1. N叉树的前序遍历"></a>1. N叉树的前序遍历</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了88.62%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :52.2 MB, 在所有 Java 提交中击败了78.78%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加根</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">//递归孩子结点</span></span><br><span class="line">        <span class="keyword">for</span>(Node node:root.children)&#123;</span><br><span class="line">            preorder(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :8 ms, 在所有 Java 提交中击败了28.21%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :54.5 MB, 在所有 Java 提交中击败了64.22%的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;Node&gt; stack= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Node node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.children.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//stack从右到左入栈，以达到弹出先弹左子树再弹右子树</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = node.children.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    stack.add(node.children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-N叉树的中序遍历"><a href="#2-N叉树的中序遍历" class="headerlink" title="2. N叉树的中序遍历"></a>2. N叉树的中序遍历</h2><p> &emsp;&emsp;&emsp;&emsp;没找到相关题，略过~~~</p><h2 id="3-N叉树的后序遍历"><a href="#3-N叉树的后序遍历" class="headerlink" title="3. N叉树的后序遍历"></a>3. N叉树的后序遍历</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了90.67%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :58.9 MB, 在所有 Java 提交中击败了25.73%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            postorder(node);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Node node = stack.pollLast();</span><br><span class="line">           <span class="comment">//在res的头部添加，依次添加的为 根，然后再添加为 右--根，再添加为左--右--根</span></span><br><span class="line">            res.addFirst(node.val);</span><br><span class="line">            <span class="comment">//判断是否有孩子结点</span></span><br><span class="line">            <span class="keyword">if</span>(node.children.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//从左到右依次入栈，方便后面先取出右子树</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;node.children.size();i++)&#123;</span><br><span class="line">                    stack.addLast(node.children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-N叉树的层序遍历"><a href="#4-N叉树的层序遍历" class="headerlink" title="4. N叉树的层序遍历"></a>4. N叉树的层序遍历</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了98.57%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :58.8 MB, 在所有 Java 提交中击败了40.01%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == level)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        res.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.children.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Node node : root.children)</span><br><span class="line">                 helper(node,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :7 ms, 在所有 Java 提交中击败了64.89的用户</span></span><br><span class="line">    <span class="comment">//内存消耗 :52.6 MB, 在所有 Java 提交中击败了79.34%的用户</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//用于存上一层的结果</span></span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//这一层的结点个数</span></span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                <span class="comment">//添加当前层的值到tmp    </span></span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">//存入下一层的孩子</span></span><br><span class="line">                <span class="keyword">if</span>(node.children.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;node.children.size();j++)&#123;</span><br><span class="line">                        queue.add(node.children.get(j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将一层的结果存到结果集中</span></span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树的数据结构&quot;&gt;&lt;a href=&quot;#二叉树的数据结构&quot; class=&quot;headerlink&quot; title=&quot;二叉树的数据结构&quot;&gt;&lt;/a&gt;二叉树的数据结构&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            val = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法-【全排列】【组合总和】【n皇后】【子集】</title>
    <link href="http://blogs.qiulig.website/2019/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E3%80%90%E5%85%A8%E6%8E%92%E5%88%97%E3%80%91%E3%80%90%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E3%80%91%E3%80%90n%E7%9A%87%E5%90%8E%E3%80%91%E3%80%90%E5%AD%90%E9%9B%86%E3%80%91/"/>
    <id>http://blogs.qiulig.website/2019/07/回溯算法-【全排列】【组合总和】【n皇后】【子集】/</id>
    <published>2019-07-22T11:32:30.000Z</published>
    <updated>2019-07-26T13:20:36.568Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>&emsp;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。即从一条路往前走，能进则进，不能进则退回来，换一条路再试。<a id="more"></a></p><h2 id="如何使用回溯算法"><a href="#如何使用回溯算法" class="headerlink" title="如何使用回溯算法"></a>如何使用回溯算法</h2><p>&emsp;回溯我认为也就是一种递归，有以下四个参数，当然不一定是我所举例的类型，要看题目而定<br>&emsp;&emsp;(1)一个全局变量集合保存所有满足条件的答案，举例：List&lt;List<integer>&gt; res<br>&emsp;&emsp;(2)一个集合保存一个满足条件的答案，举例：List<integer> tmpList<br>核心：根据各个题情况变换<br><!--more--><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//add进去的值根据题意变换</span></span><br><span class="line">              tmplist.add(i);</span><br><span class="line">              <span class="comment">//递归,这里根据题意变换回溯，这仅仅是个例子</span></span><br><span class="line">              backtrack( k - <span class="number">1</span>, n, i+<span class="number">1</span>,tmplist, result);</span><br><span class="line">              <span class="comment">//将这个集合清空，方便下一个满足条件的答案</span></span><br><span class="line">              tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></integer></integer></p><h2 id="leetcode-【46】全排列-I"><a href="#leetcode-【46】全排列-I" class="headerlink" title="leetcode_【46】全排列 I"></a>leetcode_【46】全排列 I</h2><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p><blockquote><p><strong>题目描述：</strong><br>   &emsp;给定一个没有重复数字的序列，返回其所有可能的全排列。<br><strong>输入：</strong><br>&emsp;&emsp;[1,2,3]<br><strong>输出：</strong><br>&emsp;&emsp;[<br> &emsp;&emsp; [1,2,3],<br> &emsp;&emsp; [1,3,2],<br> &emsp;&emsp; [2,1,3],<br> &emsp;&emsp; [2,3,1],<br>&emsp;&emsp;  [3,1,2],<br> &emsp;&emsp; [3,2,1]<br>&emsp;&emsp; ]</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>&emsp; 回溯算法：</p><blockquote><ul><li>将第j个数字与第 j , j +1 , j + 2 ,…, len(nums) - 1个数字分别交换，得到 len(nums) - j 种情况；</li><li>在每种情况下递归，将第j+1处数字与第j+1,j+2,…,len(nums) - 1处数字分别交换；<ul><li>每个递归跳出后，要将交换过的元素还原，这样才能实现第一条所说的内容。<ul><li>直到j == len(nums) - 1，代表此种交换组合下已经交换完毕，记录答案。</li></ul></li></ul></li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p> 第一版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//执行用时 :41 ms, 在所有 Java 提交中击败了5.01%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :44.4 MB, 在所有 Java 提交中击败了5.03%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        permute(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,ArrayList&lt;Integer&gt; tempList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//start为左边界值，要跟右边界的数进行交换</span></span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(tempList))&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//将第j个数字与第 j , j +1 , j + 2 ,..., len(nums) - 1个数字分别交换</span></span><br><span class="line">            swap(nums,start,i);</span><br><span class="line">            tempList.add(nums[start]);</span><br><span class="line">            backTrace(nums,start+<span class="number">1</span>,tempList,res);</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 每个递归跳出后，要将交换过的元素还原</span></span><br><span class="line">            swap(nums,start,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">        nums[start] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二版：leetcode官网解答</p><blockquote><p>这里有一个回溯函数，使用第一个整数的索引作为参数 backtrack(first)。</p><ul><li>如果第一个整数有索引 n，意味着当前排列已完成。</li><li>遍历索引 first 到索引 n - 1 的所有整数。<ul><li>在排列中放置第 i 个整数， 即 swap(nums[first], nums[i]).</li><li>继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).</li><li>现在回溯，即通过 swap(nums[first], nums[i]) 还原.</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了87.64%的用户</span></span><br><span class="line"> <span class="comment">//内存消耗 :38.5 MB, 在所有 Java 提交中击败了67.89%的用户</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n,ArrayList&lt;Integer&gt; nums, List&lt;List&lt;Integer&gt;&gt; output, <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一个整数有索引 n，意味着当前排列已完成。</span></span><br><span class="line">        <span class="keyword">if</span> (first == n)</span><br><span class="line">            output.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(nums));</span><br><span class="line">        <span class="comment">// 遍历索引 first 到索引 n - 1 的所有整数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//在排列中放置第 i 个整数</span></span><br><span class="line">            Collections.swap(nums, first, i);</span><br><span class="line">            <span class="comment">//  继续生成从第 i 个整数开始的所有排列</span></span><br><span class="line">             backtrack(n, nums, output, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            Collections.swap(nums, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert nums into list since the output is a list of lists</span></span><br><span class="line">        ArrayList&lt;Integer&gt; nums_lst = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            nums_lst.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        backtrack(n, nums_lst, output, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【47】全排列-II"><a href="#leetcode-【47】全排列-II" class="headerlink" title="leetcode_【47】全排列 II"></a>leetcode_【47】全排列 II</h2><p> <a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii/</a></p><blockquote><p><strong>题目描述：</strong><br>&emsp;给定一个可能包含重复数字的序列，返回其所有可能的不重复全排列。<br><strong>输入：</strong><br>&emsp;&emsp;[1,1,2]<br><strong>输出：</strong><br>&emsp;&emsp;[<br> &emsp;&emsp; [1,1,2],<br> &emsp;&emsp; [1,2,1],<br> &emsp;&emsp; [2,1,1],<br> &emsp;&emsp; ]</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>第一版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//执行用时 :742 ms, 在所有 Java 提交中击败了8.80%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :45.7 MB, 在所有 Java 提交中击败了44.99%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span>  List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,ArrayList&lt;Integer&gt; tempList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//start为边界值</span></span><br><span class="line">            <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">                <span class="comment">//加了这一句</span></span><br><span class="line">                <span class="keyword">if</span>(!res.contains(tempList))&#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">                swap(nums,start,i);</span><br><span class="line">                tempList.add(nums[start]);</span><br><span class="line">                backTrace(nums,start+<span class="number">1</span>,tempList,res);</span><br><span class="line">                tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">                swap(nums,start,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优化的第二版:leetcode官网解答<br><img src="https://img-blog.csdnimg.cn/20190722151516219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722151537389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190722151548299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722151600826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :6 ms, 在所有 Java 提交中击败了63.63%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :42.8 MB, 在所有 Java 提交中击败了76.28%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findPermuteUnique</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> depth, Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="comment">// 修改 2：因为排序以后重复的数一定不会出现在开始，故 i &gt; 0</span></span><br><span class="line">                <span class="comment">// 和之前的数相等，并且之前的数还未使用过，只有出现这种情况，才会出现相同分支</span></span><br><span class="line">                <span class="comment">// 这种情况跳过即可</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                stack.add(nums[i]);</span><br><span class="line">                findPermuteUnique(nums, depth + <span class="number">1</span>, stack);</span><br><span class="line">                stack.pop();</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改 1：首先排序，之后才有可能发现重复分支</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        findPermuteUnique(nums, <span class="number">0</span>, <span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permuteUnique = solution.permuteUnique(nums);</span><br><span class="line">        System.out.println(permuteUnique);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【77】组合"><a href="#leetcode-【77】组合" class="headerlink" title="leetcode_【77】组合"></a>leetcode_【77】组合</h2><p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations/</a></p><blockquote><p>&emsp;给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>    示例:<br>    输入:<br>    &emsp;&emsp;n = 4, k = 2<br>    输出:<br>   &emsp;&ensp; [<br>  &emsp;&emsp;  [2,4],<br>   &emsp;&emsp; [3,4],<br>   &emsp;&emsp; [2,3],<br>   &emsp;&emsp; [1,2],<br>   &emsp;&emsp; [1,3],<br> &emsp;&emsp;   [1,4],<br> &emsp;&ensp;   ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//执行用时 :40 ms, 在所有 Java 提交中击败了52.77%的用户</span></span><br><span class="line">&gt; <span class="comment">//内存消耗 :52.5 MB, 在所有 Java 提交中击败了26.41%的用户</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">&gt;         List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;         backtrack(k,n,<span class="number">1</span>,<span class="keyword">new</span> ArrayList(),res);</span><br><span class="line">&gt;         <span class="keyword">return</span> res;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n,<span class="keyword">int</span> start,List&lt;Integer&gt; tmplist,List&lt;List&lt;Integer&gt;&gt; result)</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">&gt;             result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">&gt;         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">&gt;             <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">&gt;                 tmplist.add(i);</span><br><span class="line">&gt;                 <span class="comment">//递归，这里回溯 从 i+1  ~ n 中 k-1 个数的组合，直到k == 0就可将这次结果存到res里面</span></span><br><span class="line">&gt;                 backtrack( k - <span class="number">1</span>, n, i+<span class="number">1</span>,tmplist, result);</span><br><span class="line">&gt;                 tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="leetcode-【39】组合总和-I"><a href="#leetcode-【39】组合总和-I" class="headerlink" title="leetcode_【39】组合总和 I"></a>leetcode_【39】组合总和 I</h2><p>&emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum/</a></p><blockquote><p>&emsp;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以&gt;使数字和为 target 的组合。<br>&emsp;candidates 中的<strong>数字可以无限制重复被选取。</strong><br><strong>说明：</strong><br>&emsp; (1)所有数字（包括 target）都是正整数。<br>&emsp;(2)解集不能包含重复的组合。<br>       <strong><strong>示例 1:<br>       输入:</strong></strong><br>      &emsp;&emsp; candidates = [2,3,6,7], target = 7,<br>       <strong>所求解集为:</strong><br>      &emsp;&emsp; [<br>     &emsp;&emsp;  [7],<br>      &emsp;&emsp; [2,2,3]<br>      &emsp;&emsp; ]<br>       <strong>示例 2:<br>       输入:</strong><br>       &emsp;&emsp;candidates = [2,3,5], target = 8,<br>       <strong>所求解集为:</strong><br>       &emsp;&emsp;[<br>         &emsp;&emsp;[2,2,2,2],<br>        &emsp;&emsp; [2,3,3],<br>        &emsp;&emsp; [3,5]<br>       &emsp;&emsp;]</p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :7 ms, 在所有 Java 提交中击败了81.11%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :39.1 MB, 在所有 Java 提交中击败了87.66%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">          <span class="comment">//存放结果</span></span><br><span class="line">          List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="comment">//排序</span></span><br><span class="line">          Arrays.sort(candidates);</span><br><span class="line">          <span class="comment">//从第一个数开始递归</span></span><br><span class="line">          calculate(candidates,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,ArrayList&lt;Integer&gt; tmpList,List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存入结果集</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123;</span><br><span class="line">                <span class="comment">//加入</span></span><br><span class="line">                tmpList.add(candidates[i]);</span><br><span class="line">                <span class="comment">//递归,candidates 中的数字可以使用无数次，故start还是从 i 开始</span></span><br><span class="line">                calculate( candidates, target - candidates[i], i, tmpList,result);</span><br><span class="line">                <span class="comment">//清空所得到的一次结果的list</span></span><br><span class="line">                tmpList.remove(tmpList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【40】组合总和-II"><a href="#leetcode-【40】组合总和-II" class="headerlink" title="leetcode_【40】组合总和 II"></a>leetcode_【40】组合总和 II</h2><p>&emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii/</a></p><blockquote><p>&emsp;&emsp;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>&emsp;<strong>candidates 中的数字可以只能使用一次。</strong><br><strong>说明：</strong><br>&emsp; (1)所有数字（包括 target）都是正整数。<br>&emsp;(2)解集不能包含重复的组合。<br><strong>输入:</strong><br>&emsp;&emsp;candidates = [10,1,2,7,6,1,5], target = 8，<br><strong>所求解集为:</strong><br>       &emsp;&ensp; [<br>      &emsp;&emsp;  [1, 7],<br>       &emsp;&emsp; [1, 2, 5],<br>       &emsp;&emsp; [2, 6],<br>      &emsp;&emsp;  [1, 1, 6]<br>      &emsp;&ensp;  ]<br>        <strong>示例 2:<br>        输入:</strong><br>        &emsp;&emsp; candidates = [2,5,2,1,2], target = 5,<br>        <strong>所求解集为:</strong><br>       &emsp;&ensp; [<br>          &emsp;&emsp;[1,2,2],<br>         &emsp;&emsp; [5]<br>       &emsp;&ensp; ]       </p></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//执行用时 :30 ms, 在所有 Java 提交中击败了22.59%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :45 MB, 在所有 Java 提交中击败了27.34%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="comment">//从下标为0，目标为target的开始回溯</span></span><br><span class="line">        backTrace(candidates,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//解集不能包含重复的组合。 </span></span><br><span class="line">            Collections.sort(tmpList);</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(tmpList))&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123;</span><br><span class="line">                tmpList.add(candidates[i]);</span><br><span class="line">                <span class="comment">//回溯,因为candidates 中的数字可以只能使用一次，所以这里start变成了i+1</span></span><br><span class="line">                backTrace(candidates, target - candidates[i], i + <span class="number">1</span>, tmpList, res);</span><br><span class="line">                tmpList.remove(tmpList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【216】组合总和III"><a href="#leetcode-【216】组合总和III" class="headerlink" title="leetcode_【216】组合总和III"></a>leetcode_【216】组合总和III</h2><p>  <a href="https://leetcode-cn.com/problems/combination-sum-iii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iii/submissions/</a></p><blockquote><p>&emsp;&emsp;找出所有相加之和为 n 的 k 个数的组合。组合中<strong>只允许含有 1 - 9 的正整数</strong>，并且每种组合中不存在重复的数字。<br> <strong>说明：</strong><br>        &emsp;所有数字都是正整数。<br>       &emsp; 解集不能包含重复的组合。<br>        <strong>示例 1:<br>        输入:</strong><br>        &emsp;&emsp; k = 3, n = 7<br>        <strong>输出:</strong><br>        &emsp;&emsp; [[1,2,4]]<br>        <strong>示例 2:<br>        输入:</strong><br>        &emsp;&emsp;k = 3, n = 9<br>        <strong>输出:</strong><br>        &emsp;&emsp; [[1,2,6], [1,3,5], [2,3,4]]</p></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//执行用时 :5 ms, 在所有 Java 提交中击败了8.96%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :34.1 MB, 在所有 Java 提交中击败了28.88%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrace(k,n,<span class="number">1</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target,<span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == k &amp;&amp; target == <span class="number">0</span>)&#123;</span><br><span class="line">            Collections.sort(tmpList);</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(tmpList))</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">// 组合数中只包含1-9的数，故i&lt;=9</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= <span class="number">9</span> ;i++)&#123;</span><br><span class="line">                tmpList.add(i);</span><br><span class="line">                backTrace(k-<span class="number">1</span>,target - i,i+<span class="number">1</span>,tmpList,res);</span><br><span class="line">                tmpList.remove(tmpList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【377】组合总和-IV"><a href="#leetcode-【377】组合总和-IV" class="headerlink" title="leetcode_【377】组合总和 IV"></a>leetcode_【377】组合总和 IV</h2><blockquote><p>&emsp;给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。<br>        示例:<br>       &emsp;&emsp; nums = [1, 2, 3]<br>        &emsp;&emsp;target = 4<br>        所有可能的组合为：<br>      &emsp;&emsp;  (1, 1, 1, 1)<br>      &emsp;&emsp;  (1, 1, 2)<br>       &emsp;&emsp; (1, 2, 1)<br>       &emsp;&emsp; (1, 3)<br>       &emsp;&emsp; (2, 1, 1)<br>       &emsp;&emsp; (2, 2)<br>       &emsp;&emsp; (3, 1)<br>        请注意，顺序不同的序列被视作不同的组合。<br>        因此输出为 7。</p></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>   回溯超出内存限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrace(nums,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length &amp;&amp; target &gt;= nums[i];i++)&#123;</span><br><span class="line">                tmpList.add(nums[i]);</span><br><span class="line">                backTrace(nums,target - nums[i],i,tmpList,res);</span><br><span class="line">                tmpList.remove(tmpList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划：dp[i] 代表组成i 能有多少种组合数，即dp[1] = 2代表 和为1的组合个数为2</p><blockquote><ul><li>初始化<ul><li><code>dp[0] = 1</code>;即组成和为0的组合数为1，即都nums里面的数都不取</li></ul></li><li><p>状态转移方程：</p><ul><li><p><code>dp[i]=dp[ i - nums[0] ]+dp[ i - nums[1] ]+dp[ i - nums[2] ] + ...</code></p><p>举个例子 : 比如nums=[1,3,4],target=7;dp[7]=dp[6]+dp[4]+dp[3]</p></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :5 ms, 在所有 Java 提交中击败了68.54%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :34.3 MB, 在所有 Java 提交中击败了39.00%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">combinationSum6</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - nums[j] &gt;= <span class="number">0</span> )&#123;</span><br><span class="line">                dp[i] += dp[i-nums[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【51】N皇后-I"><a href="#leetcode-【51】N皇后-I" class="headerlink" title="leetcode_【51】N皇后 I"></a>leetcode_【51】N皇后 I</h2><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p><blockquote><p>&emsp; n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>  &emsp;  给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>  &emsp;  每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br>        <strong>示例:<br>        输入:</strong><br>        &emsp;  4<br>        <strong>输出:</strong><br>       &emsp; &ensp;   [<br>       &emsp; &emsp;  [“.Q..”,  // 解法 1<br>        &emsp; &emsp; “…Q”,<br>       &emsp; &emsp;  “Q…”,<br>       &emsp; &emsp;  “..Q.” ],<br>        &emsp; &ensp; [ “..Q.”,  // 解法 2<br>        &emsp; &emsp; “Q…”,<br>      &emsp; &emsp;   “…Q”,<br>       &emsp; &emsp;  “.Q..”]<br>       &emsp; &ensp;  ]<br>        <strong>解释:</strong> 4 皇后问题存在两个不同的解法。</p></blockquote><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><blockquote><ul><li>回溯函数 <code>backtrack(row = 0)</code>.<ul><li>从第一个 <code>row = 0</code> 开始.</li><li>循环列并且试图在每个 <code>column</code> 中放置皇后.<ul><li>如果方格 <code>(row, column)</code> 不在攻击范围内<ul><li>在 <code>(row, column)</code> 方格上放置皇后</li><li>排除对应行，列和两个对角线的位置。</li><li>If 所有的行被考虑过，<code>row == NunOfQueen</code><ul><li>意味着我们找到了一个解</li></ul></li><li>else<ul><li>继续考虑接下来的皇后放置 backtrack(row + 1).</li></ul></li><li>回溯：将在 (row, column) 方格的皇后移除.</li></ul></li></ul></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.Arrays.回溯;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//执行用时 :9 ms, 在所有 Java 提交中击败了53.89%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :39.3 MB, 在所有 Java 提交中击败了84.75%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_51</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//用于存储行</span></span><br><span class="line">        List&lt;Integer&gt; col = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储正对角线</span></span><br><span class="line">        List&lt;Integer&gt; z_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储负对角线</span></span><br><span class="line">        List&lt;Integer&gt; f_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//从第一个row = 0开始</span></span><br><span class="line">        backtrack(<span class="number">0</span>, n, res, <span class="keyword">new</span> ArrayList&lt;String&gt;(), col, z_diagonal, f_diagonal);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> NumOfQueen, List&lt;List&lt;String&gt;&gt; res, ArrayList&lt;String&gt; tmplist, List&lt;Integer&gt; col, List&lt;Integer&gt; z_diagonal, List&lt;Integer&gt; f_diagonal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//到达了最后一行</span></span><br><span class="line">        <span class="keyword">if</span> (row == NumOfQueen) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; NumOfQueen; column++) &#123;</span><br><span class="line">            <span class="comment">//如果不在攻击范围内（不在同一行或者同一列 &amp;&amp; 负对角线和相等 &amp;&amp;  正对角线差相等）</span></span><br><span class="line">            <span class="keyword">if</span> (!col.contains(column) &amp;&amp; !f_diagonal.contains(row + column) &amp;&amp; !z_diagonal.contains(row - column)) &#123;</span><br><span class="line">                col.add(column);</span><br><span class="line">                f_diagonal.add(row + column);</span><br><span class="line">                z_diagonal.add(row - column);</span><br><span class="line">                <span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[NumOfQueen];</span><br><span class="line">                Arrays.fill(s, <span class="string">'.'</span>);</span><br><span class="line">                <span class="comment">//这一行的j位置放皇后</span></span><br><span class="line">                s[column] = <span class="string">'Q'</span>;</span><br><span class="line">                tmplist.add(<span class="keyword">new</span> String(s));</span><br><span class="line">                <span class="comment">//回溯算法</span></span><br><span class="line">                backtrack(row+<span class="number">1</span>,NumOfQueen,res,tmplist,col,z_diagonal,f_diagonal);</span><br><span class="line">                tmplist.remove(tmplist.size() - <span class="number">1</span>);</span><br><span class="line">                col.remove(Integer.valueOf(column));</span><br><span class="line">                f_diagonal.remove(Integer.valueOf(row + column));</span><br><span class="line">                z_diagonal.remove(Integer.valueOf(row - column));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【52】N皇后-II"><a href="#leetcode-【52】N皇后-II" class="headerlink" title="leetcode_【52】N皇后 II"></a>leetcode_【52】N皇后 II</h2><p><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens-ii/</a></p><blockquote><p>&emsp; n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>  &emsp;  给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>  &emsp;  每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br>        <strong>示例:<br>        输入:</strong><br>        &emsp;  4<br>        <strong>输出:</strong><br>       &emsp; 2<br>        <strong>解释</strong>：4皇后存在两种不同的解法<br>       &emsp; &ensp;   [<br>       &emsp; &emsp;  [“.Q..”,  // 解法 1<br>        &emsp; &emsp; “…Q”,<br>       &emsp; &emsp;  “Q…”,<br>       &emsp; &emsp;  “..Q.” ],<br>        &emsp; &ensp; [ “..Q.”,  // 解法 2<br>        &emsp; &emsp; “Q…”,<br>      &emsp; &emsp;   “…Q”,<br>       &emsp; &emsp;  “.Q..”]<br>       &emsp; &ensp;  ]</p></blockquote><p>   如leetcode_【51】代码返回res.size();</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时</span></span><br><span class="line"> :<span class="number">29</span> ms, 在所有 Java 提交中击败了<span class="number">5.45</span>%的用户</span><br><span class="line"><span class="comment">//内存消耗 :34.8 MB, 在所有 Java 提交中击败了41.25%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用于存储行</span></span><br><span class="line">        List&lt;Integer&gt; col = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储正对角线</span></span><br><span class="line">        List&lt;Integer&gt; z_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储负对角线</span></span><br><span class="line">        List&lt;Integer&gt; f_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//从第一个row = 0开始</span></span><br><span class="line">        backtrack(<span class="number">0</span>, n, res, <span class="keyword">new</span> ArrayList&lt;String&gt;(), col, z_diagonal, f_diagonal);</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> NumOfQueen, List&lt;List&lt;String&gt;&gt; res, ArrayList&lt;String&gt; tmplist, List&lt;Integer&gt; col, List&lt;Integer&gt; z_diagonal, List&lt;Integer&gt; f_diagonal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//到达了最后一行</span></span><br><span class="line">        <span class="keyword">if</span> (row == NumOfQueen) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; NumOfQueen; column++) &#123;</span><br><span class="line">            <span class="comment">//如果不在攻击范围内（不在同一行或者同一列 &amp;&amp; 负对角线和相等 &amp;&amp;  正对角线差相等）</span></span><br><span class="line">            <span class="keyword">if</span> (!col.contains(column) &amp;&amp; !f_diagonal.contains(row + column) &amp;&amp; !z_diagonal.contains(row - column)) &#123;</span><br><span class="line">                col.add(column);</span><br><span class="line">                f_diagonal.add(row + column);</span><br><span class="line">                z_diagonal.add(row - column);</span><br><span class="line">                <span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[NumOfQueen];</span><br><span class="line">                Arrays.fill(s, <span class="string">'.'</span>);</span><br><span class="line">                <span class="comment">//这一行的j位置放皇后</span></span><br><span class="line">                s[column] = <span class="string">'Q'</span>;</span><br><span class="line">                tmplist.add(<span class="keyword">new</span> String(s));</span><br><span class="line">                <span class="comment">//回溯算法</span></span><br><span class="line">                backtrack(row+<span class="number">1</span>,NumOfQueen,res,tmplist,col,z_diagonal,f_diagonal);</span><br><span class="line">                tmplist.remove(tmplist.size() - <span class="number">1</span>);</span><br><span class="line">                col.remove(Integer.valueOf(column));</span><br><span class="line">                f_diagonal.remove(Integer.valueOf(row + column));</span><br><span class="line">                z_diagonal.remove(Integer.valueOf(row - column));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【78】子集I"><a href="#leetcode-【78】子集I" class="headerlink" title="leetcode_【78】子集I"></a>leetcode_【78】子集I</h2><p>   <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p><blockquote><p>&emsp;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>        &emsp;说明：解集不能包含重复的子集。<br>        &emsp;示例:<br>        输入:<br>        &emsp;&emsp;nums = [1,2,3]<br>        输出:<br>       &emsp;&ensp; [<br>      &emsp;&emsp;  [3],<br>       &emsp;&emsp;  [1],<br>         &emsp;&emsp; [2],<br>         &emsp;&emsp; [1,2,3],<br>         &emsp;&emsp; [1,3],<br>         &emsp;&emsp; [2,3],<br>         &emsp;&emsp; [1,2],<br>         &emsp;&emsp; []<br>      &emsp;&ensp;  ]</p></blockquote><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了87.86%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :37 MB, 在所有 Java 提交中击败了44.12%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmplist, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            tmplist.add(nums[i]);</span><br><span class="line">            backTrace(nums,i+<span class="number">1</span>,tmplist,res);</span><br><span class="line">            tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【90】子集-II"><a href="#leetcode-【90】子集-II" class="headerlink" title="leetcode_【90】子集 II"></a>leetcode_【90】子集 II</h2><p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets-ii/</a></p><blockquote><p>   给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>        说明：解集不能包含重复的子集。<br>        示例:<br>        输入:<br>        &emsp; [1,2,2]<br>        输出:<br>       &emsp; &ensp;  [<br>       &emsp; &emsp;  [2],<br>         &emsp; &emsp; [1],<br>        &emsp; &emsp; [1,2,2],<br>        &emsp; &emsp; [2,2],<br>         &emsp; &emsp; [1,2],<br>        &emsp; &emsp; []<br>        &emsp; &ensp; ]</p></blockquote><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了87.52%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :38.5 MB, 在所有 Java 提交中击败了47.42%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmplist, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//和上一个数字相等则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmplist.add(nums[i]);</span><br><span class="line">                backTrace(nums,i+<span class="number">1</span>,tmplist,res);</span><br><span class="line">                tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;回溯算法&quot;&gt;&lt;a href=&quot;#回溯算法&quot; class=&quot;headerlink&quot; title=&quot;回溯算法&quot;&gt;&lt;/a&gt;回溯算法&lt;/h2&gt;&lt;p&gt;&amp;emsp;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。即从一条路往前走，能进则进，不能进则退回来，换一条路再试。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="回溯算法" scheme="http://blogs.qiulig.website/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【102】二叉树的层次遍历</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-102-二叉树的层次遍历/</id>
    <published>2019-06-30T08:00:33.000Z</published>
    <updated>2019-07-06T02:54:11.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。<a id="more"></a></p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">3</span></span><br><span class="line">&gt;     / \</span><br><span class="line">&gt;    <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">&gt;       / \</span><br><span class="line">&gt;      <span class="number">15</span>  <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>同【剑指offer - 60】</p><p>BFS广度优先搜索的扩展题</p><p>迭代思想：</p><p>我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。</p><p>第 0 层只包含根节点 root ，算法实现如下：</p><pre><code>(1)初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。(2)当队列非空的时候：    1) 在输出结果 levels 中插入一个空列表，开始当前层的算法。    2)计算当前层有多少个元素：等于队列的长度。    3)将这些元素从队列中弹出，并加入 levels 当前层的空列表中。    4)将他们的孩子节点作为下一层压入队列中。    5)进入下一层 level++。</code></pre><p>递归思想：<br>    最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下：<br>    (1)输出列表称为 ans，当前最高层数就是列表的长度 len(ans)。比较访问节点所在的层次 level 和当前最高层次 len(ans) 的大小，如果前者更大就向 ans 添加一个空列表。<br>    (2)将当前节点插入到对应层的列表 ans[level] 中。<br>    (3)递归非空的孩子节点：helper(node.left , level + 1)。helper(node.right, level + 1)。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> ms, 在所有 Java 提交中击败了<span class="number">55.91</span>%的用户</span><br><span class="line"></span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">36.5</span> MB, 在所有 Java 提交中击败了<span class="number">44.59</span>%的用户</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//用于记录所有结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//用于保存当前层的节点数</span></span><br><span class="line">           ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="comment">//当前层包含的节点个数</span></span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count;i++)&#123;</span><br><span class="line">              <span class="comment">//删除并返回queue中的头元素，删掉根（上一层结点元素）</span></span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               <span class="comment">//加入左子树</span></span><br><span class="line">               <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               <span class="comment">//加入右子树</span></span><br><span class="line">               <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               <span class="comment">//加入当前层的节点</span></span><br><span class="line">               tmp.add(node.val);</span><br><span class="line">           &#125;</span><br><span class="line">           lists.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line">    <span class="number">2</span> ms, 在所有 Java 提交中击败了<span class="number">92.32</span>%的用户</span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">37.1</span> MB, 在所有 Java 提交中击败了<span class="number">42.97</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() == level)</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        ans.get(level).add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/102.png" alt="leetcode提交结果-迭代"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【108】将有序数组转换成二叉搜索树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-108-将有序数组转换成二叉搜索树/</id>
    <published>2019-06-30T07:08:20.000Z</published>
    <updated>2019-06-30T07:43:16.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<a id="more"></a></p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;           <span class="number">0</span></span><br><span class="line">&gt;          / \</span><br><span class="line">&gt;        -<span class="number">3</span>   <span class="number">9</span></span><br><span class="line">&gt;        /   /</span><br><span class="line">&gt;      -<span class="number">10</span>  <span class="number">5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>将一个排序array转化为平衡二叉搜索树：<br>平衡二叉树：对于每个根节点，左右子树高度差 &lt;= 1；<br>二叉搜索树：对于每个节点，其左子树值&lt;此节点值，右子树&gt;此节点值。<br>要满足以上两个特点，我们自然想到以array中点值作为根节点值，并递归重建，这样就可以同时保证以上两个条件。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">3</span> ms, 在所有 Java 提交中击败了<span class="number">8.50</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">40.2</span> MB, 在所有 Java 提交中击败了<span class="number">29.40</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将最中间的数作为根节点</span></span><br><span class="line">        TreeNode root =<span class="keyword">new</span> TreeNode( nums[nums.length/<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//以中间的树为分界，左边归属于左子树，右边归属于右子树</span></span><br><span class="line">        root.left = sortedArrayToBST(Arrays.copyOfRange(nums,<span class="number">0</span>,nums.length/<span class="number">2</span>));</span><br><span class="line">        root.right = sortedArrayToBST(Arrays.copyOfRange(nums,nums.length/<span class="number">2</span>+<span class="number">1</span>,nums.length));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时为2ms的范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右等分建立左右子树，中间节点作为子树根节点，递归该过程</span></span><br><span class="line">        <span class="keyword">return</span> nums == <span class="keyword">null</span> ? <span class="keyword">null</span> : buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">        root.left = buildTree(nums, left, mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        root.right = buildTree(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/108.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【106】从中序与后序遍历序列构造二叉树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-106-从中序与后序遍历序列构造二叉树/</id>
    <published>2019-06-30T03:00:24.000Z</published>
    <updated>2019-06-30T03:14:11.409Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。<a id="more"></a></p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;       <span class="number">3</span></span><br><span class="line">&gt;      /  \</span><br><span class="line">&gt;     <span class="number">9</span>    <span class="number">20</span></span><br><span class="line">&gt;    /  \</span><br><span class="line">&gt;   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>中序<code>9,3,15,20,7</code>,后序 <code>9,15,7,20,3</code></p><p>有如下特征：</p><ol><li>后序中最后一位<code>1</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>root</code>；</li><li>中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li><li>后序中结点分布应该是：<code>[左子树结点，右子树结点，根结点]</code>；</li><li>根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；</li><li>如果我们要后序遍历生成二叉树的话，下一层递归应该是：<ul><li>左子树：<code>root.left = buildTree(中序左子树范围，后序左子树范围);</code>；</li><li>右子树：<code>root.right = buildTree(中序右子树范围，后序左子树范围，);</code>。</li></ul></li><li>每一层递归都要返回当前根结点<code>root</code>；</li></ol></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">42</span> ms, 在所有 Java 提交中击败了<span class="number">15.47</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">78.1</span> MB, 在所有 Java 提交中击败了<span class="number">5.17</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.length == <span class="number">0</span>||postorder.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//根节点为后序遍历的最后一个节点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">              <span class="comment">//找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点</span></span><br><span class="line">                <span class="keyword">if</span>(inorder[i] == postorder[postorder.length-<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="comment">//递归构建左子树，此时,中序缩小为[0,i),后序的范围缩小为[0,i]</span></span><br><span class="line">                    root.left = buildTree(Arrays.copyOfRange(inorder,<span class="number">0</span>,i),Arrays.copyOfRange(postorder,<span class="number">0</span>,i));</span><br><span class="line">              <span class="comment">//递归构建右子树,中序缩小为[i+1,len),后序的范围缩小为[i,len-1),</span></span><br><span class="line">                    root.right = buildTree(Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length),Arrays.copyOfRange(postorder,i,postorder.length-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/106.png" alt="重构二叉树"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;根据一棵树的中序遍历与后序遍历构造二叉树。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【105】从前序与中序遍历序列构造二叉树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-105-从前序与中序遍历序列构造二叉树/</id>
    <published>2019-06-30T01:54:21.000Z</published>
    <updated>2019-06-30T03:14:57.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>根据一棵树的前序遍历与中序遍历构造二叉树。<a id="more"></a></p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">3</span></span><br><span class="line">&gt;     / \</span><br><span class="line">&gt;    <span class="number">9</span>   <span class="number">20</span></span><br><span class="line">&gt;       /  \</span><br><span class="line">&gt;      <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>同【剑指offer_4】</p><p>前序<code>3,9,20,15,7</code>  ，中序<code>9,3,15,20,7</code>；</p><p>有如下特征：</p><ol><li>前序中左起第一位<code>3</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>root</code>；</li><li>中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li><li>前序中结点分布应该是：<code>[根结点，左子树结点，右子树结点]</code>；</li><li>根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；</li><li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul><li>左子树：<code>root.left = buildTree(前序左子树范围，中序左子树范围);</code>；</li><li>右子树：<code>root.right = buildTree(前序右子树范围，中序右子树范围);</code>。</li></ul></li><li>每一层递归都要返回当前根结点<code>root</code>；</li></ol></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">43</span> ms, 在所有 Java 提交中击败了<span class="number">15.42</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">76.5</span> MB, 在所有 Java 提交中击败了<span class="number">6.76</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="comment">//找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点  </span></span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">             <span class="comment">//递归构建左子树，此时前序的范围缩小为[1,i],中序缩小为[0,i)     </span></span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">             <span class="comment">//递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len)   </span></span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时32ms的范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length != inorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildHelper(preorder, inorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildHelper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preL &gt; preR) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preL]);</span><br><span class="line">        <span class="keyword">int</span> rootIdx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = inL; i &lt;= inR; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == preorder[preL]) &#123;</span><br><span class="line">                rootIdx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rootIdx == -<span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        root.left = buildHelper(preorder, inorder, preL + <span class="number">1</span>, rootIdx - inL + preL, inL, rootIdx - <span class="number">1</span>);</span><br><span class="line">        root.right = buildHelper(preorder, inorder, rootIdx - inL + preL + <span class="number">1</span>, preR, rootIdx + <span class="number">1</span>, inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/105.png" alt="重构二叉树"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;根据一棵树的前序遍历与中序遍历构造二叉树。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【101】对称二叉树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-101-对称二叉树/</id>
    <published>2019-06-30T01:11:24.000Z</published>
    <updated>2019-06-30T10:41:14.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，检查它是否是镜像对称的。<a id="more"></a></p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;       <span class="number">1</span></span><br><span class="line">&gt;    /     \</span><br><span class="line">&gt;   <span class="number">2</span>       <span class="number">2</span></span><br><span class="line">&gt;  /  \    /  \</span><br><span class="line">&gt; <span class="number">3</span>   <span class="number">4</span>   <span class="number">4</span>   <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">1</span></span><br><span class="line">&gt;     /  \</span><br><span class="line">&gt;    <span class="number">2</span>    <span class="number">2</span></span><br><span class="line">&gt;     \    \</span><br><span class="line">&gt;      <span class="number">3</span>    <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：递归</p><blockquote><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p><p>如果同时满足下面的条件，两个树互为镜像：</p><p>(1)它们的两个根结点具有相同的值。<br>(2)每个树的右子树都与另一个树的左子树镜像对称。</p><p>递归过程：</p><ul><li>判断两个指针当前节点值是否相等</li><li>判断 A 的右子树与 B 的左子树是否对称</li><li>判断 A 的左子树与 B 的右子树是否对称</li></ul></blockquote><p>方法2：迭代</p><blockquote><p>类似于广度优先遍历BFS，用一个队列queue存储左右节点。其中队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。</p><p>(1) 最初，队列中包含的是 root 以及 root。每次提取两个结点并比较它们的值。</p><p>(2)当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><p>(3)然后，将两个结点的左右子结点按相反的顺序插入队列中。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">     <span class="number">2</span> ms, 在所有 Java 提交中击败了<span class="number">84.89</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">35.5</span> MB, 在所有 Java 提交中击败了<span class="number">80.63</span>%的用户</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Symmetric</span><span class="params">(TreeNode leftroot,TreeNode rightroot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> &amp;&amp; rightroot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> || rightroot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot.val != rightroot.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(leftroot.left,rightroot.right) &amp;&amp; Symmetric(leftroot.right,rightroot.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">3</span> ms, 在所有 Java 提交中击败了<span class="number">28.02</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line"></span><br><span class="line">    <span class="number">35.7</span> MB, 在所有 Java 提交中击败了<span class="number">80.01</span>%的用户</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node1 = queue.poll();</span><br><span class="line">            TreeNode node2 = queue.poll();</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> &amp;&amp; node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> || node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">if</span>(node1.val!=node2.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            queue.add(node1.left);</span><br><span class="line">            queue.add(node2.right);</span><br><span class="line">            queue.add(node1.right);</span><br><span class="line">            queue.add(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/101.png" alt="对称二叉树-递归"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【100】相同的树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-100-相同的树/</id>
    <published>2019-06-29T13:28:03.000Z</published>
    <updated>2019-06-30T02:06:24.896Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; 示例 <span class="number">1</span>:</span><br><span class="line">&gt; 输入:   <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">&gt;       /  \       /  \</span><br><span class="line">&gt;      <span class="number">2</span>    <span class="number">3</span>     <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt; 输出: <span class="keyword">true</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; 示例 <span class="number">2</span>:</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入:    <span class="number">1</span>      <span class="number">1</span></span><br><span class="line">&gt;         /       \</span><br><span class="line">&gt;        <span class="number">2</span>         <span class="number">2</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">1</span>,<span class="number">2</span>],     [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 输出: <span class="keyword">false</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; 示例 <span class="number">3</span>:</span><br><span class="line">&gt; 输入:      <span class="number">1</span>        <span class="number">1</span></span><br><span class="line">&gt;          /  \     /  \</span><br><span class="line">&gt;         <span class="number">2</span>    <span class="number">1</span>   <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 输出：<span class="keyword">false</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>最简单的策略是使用递归。检查p和q节点是否不是空，它们的值是否相等。如果所有检查都正常，则递归地为子节点执行相同操作。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line">    <span class="number">1</span> ms, 在所有 Java 提交中击败了<span class="number">86.63</span>%的用户</span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">34.2</span> MB, 在所有 Java 提交中击败了<span class="number">85.19</span>%的用户</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> ||q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val !=q.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4. 提交结果"></a>4. 提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/100.png" alt="相同的树"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个二叉树，编写一个函数来检验它们是否相同。&lt;/p&gt;
&lt;p&gt;如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【104】二叉树的最大深度</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-104-二叉树的最大深度/</id>
    <published>2019-06-29T13:02:06.000Z</published>
    <updated>2019-06-30T02:44:20.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><blockquote><p>给定一个二叉树，找出其最大深度。<a id="more"></a></p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">3</span></span><br><span class="line">&gt;     /  \</span><br><span class="line">&gt;    <span class="number">9</span>   <span class="number">20</span></span><br><span class="line">&gt;       /  \</span><br><span class="line">&gt;      <span class="number">15</span>  <span class="number">7</span></span><br><span class="line">&gt; 返回它的最大深度 <span class="number">3</span> 。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>同 【剑指offer38题】</p><p>递归实现</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line">    <span class="number">1</span> ms, 在所有 Java 提交中击败了<span class="number">98.19</span>%的用户</span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">37.5</span> MB, 在所有 Java 提交中击败了<span class="number">45.48</span>%的用户</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> left_height =  maxDepth(root.left);</span><br><span class="line">             <span class="keyword">int</span> right_height = maxDepth(root.right);</span><br><span class="line">             <span class="keyword">return</span> Math.max(left_height,right_height)+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/104.png" alt="二叉树的最大深度"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，找出其最大深度。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>深度优先遍历和广度优先遍历</title>
    <link href="http://blogs.qiulig.website/2019/06/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <id>http://blogs.qiulig.website/2019/06/深度优先遍历和广度优先遍历/</id>
    <published>2019-06-29T11:42:26.000Z</published>
    <updated>2019-06-30T07:44:39.262Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h2><blockquote><p> 假设给定图G的初态是所有顶点均未曾访问过。在G中任选一顶点v为初始出发点(源点)，则深度优先遍历可定义如下：<a id="more"></a></p><p>(1)首先访问出发点v，并将其标记为已访问过；</p><p>(2)然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和源点v有路径相通的顶点(亦称为从源点可达的顶点)均已被访问为止。</p><p>(3)若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点作为新的源点重复上述过程，直至图中所有顶点均已被访问为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;           A</span><br><span class="line">&gt;         /    \</span><br><span class="line">&gt;        B      C</span><br><span class="line">&gt;      /  \    /  </span><br><span class="line">&gt;     E    F  G</span><br><span class="line">&gt;         /</span><br><span class="line">&gt;        I</span><br><span class="line">&gt; 深度遍历结果为： A--B--E--F--I--C--G(假设先走子节点的的左侧)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>遍历过程如下：</p><blockquote><p><strong>先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。</strong></p><p>(1)首先将A节点压入栈中，stack（A）;</p><p>(2)将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)；</p><p>(3)将B节点弹出，同时将B的子节点F，E压入栈中，此时E在栈的顶部，stack（E,F,C）；</p><p>(4)将E节点弹出，没有子节点压入,此时E在栈的顶部，stack（F，C）；</p><p>(5)将F节点弹出，同时将F的子节点I压入，stack（I,C）；</p><p>(6)将I节点弹出，没有子节点压入,此时C在栈的顶部，stack（C）；</p><p>(7)将C节点弹出，同时将C的子节点G压入栈中，stack(G)；</p><p>(8)将C节点弹出，没有子节点压入，stack为空；</p><p>最终遍历完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   class TreeNode &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int val;</span></span><br><span class="line"><span class="comment">//        TreeNode left;</span></span><br><span class="line"><span class="comment">//        TreeNode right;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">//            this.val = val;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">//先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ans.add(root.val);</span><br><span class="line">               DFS(root.left);</span><br><span class="line">               DFS(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h2><blockquote><p>广度优先遍历从某个顶点出发，首先访问这个顶点，然后找出这个结点的所有未被访问的邻接点，访问完后再访问这些结点中第一个邻接点的所有结点，重复此方法，直到所有结点都被访问完为止。</p><p><strong>1、</strong>从图中某个顶点V0出发，并访问此顶点；</p><p><strong>2、</strong>从V0出发，访问V0的各个未曾访问的邻接点W1，W2，…,Wk;然后,依次从W1,W2,…,Wk出发访问各自未被访问的邻接点；</p><p><strong>3、</strong>重复步骤2，直到全部顶点都被访问为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;           A</span><br><span class="line">&gt;         /   \</span><br><span class="line">&gt;        B     C</span><br><span class="line">&gt;      /  \    /</span><br><span class="line">&gt;     E    F  G</span><br><span class="line">&gt;    /</span><br><span class="line">&gt;   I</span><br><span class="line">&gt; 深度遍历结果为： A--B--C--E--F--G--I(假设先走子节点的的左侧)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>遍历过程如下：</p><blockquote><p><strong>先往队列中插入左节点，再插右节点，这样出队就是先左节点后右节点了。</strong></p><p>(1)首先将A节点插入队列中，队列queue（A）;</p><p>(2)将A节点弹出，同时将A节点的左、右节点B、C依次插入队列，queue（B，C）；</p><p>(3)将B节点弹出，同时将B节点的左、右节点E、F依次插入队列，queue（C, E, F）；</p><p>(4将C节点弹出，同时将C节点的左节点G依次插入队列，queue（E , F , G）；</p><p>(5)将E节点弹出，同时将E节点的左节点I依次插入队列，queue（F , G , I）；</p><p>(6)将F节点弹出，F没有子节点插入，queue（G,I）；</p><p>(7)将G节点弹出，G没有子节点插入，queue（I）；</p><p>(8)将I节点弹出，I没有子节点插入，queue为空；</p><p>最终遍历完成。</p></blockquote><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class TreeNode &#123;</span></span><br><span class="line"><span class="comment">// int val;</span></span><br><span class="line"><span class="comment">// TreeNode left;</span></span><br><span class="line"><span class="comment">// TreeNode right;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">// this.val = val;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> res;</span><br><span class="line">         Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">         queue.add(root);</span><br><span class="line">         <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">             TreeNode node = queue.poll();</span><br><span class="line">             <span class="comment">////先往queue中压入左节点，再压右节点。</span></span><br><span class="line">             <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.left);</span><br><span class="line">             <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.right);</span><br><span class="line">             res.add(node.val);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;深度优先遍历-DFS&quot;&gt;&lt;a href=&quot;#深度优先遍历-DFS&quot; class=&quot;headerlink&quot; title=&quot;深度优先遍历(DFS)&quot;&gt;&lt;/a&gt;深度优先遍历(DFS)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 假设给定图G的初态是所有顶点均未曾访问过。在G中任选一顶点v为初始出发点(源点)，则深度优先遍历可定义如下：&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="深度优先遍历" scheme="http://blogs.qiulig.website/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
      <category term="广度优先遍历" scheme="http://blogs.qiulig.website/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【623】在二叉树中增加一行</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-623-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-623-在二叉树中增加一行/</id>
    <published>2019-06-29T09:18:34.000Z</published>
    <updated>2019-06-30T01:41:40.883Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。<a id="more"></a></p><p>添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。</p><p>将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。</p><p>如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt; 示例 <span class="number">1</span>:</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入:</span><br><span class="line">&gt;  二叉树如下所示:</span><br><span class="line">&gt;           <span class="number">4</span></span><br><span class="line">&gt;        /     \</span><br><span class="line">&gt;       <span class="number">2</span>       <span class="number">6</span></span><br><span class="line">&gt;      / \     /</span><br><span class="line">&gt;     <span class="number">3</span>   <span class="number">1</span>   <span class="number">5</span></span><br><span class="line">&gt; v = <span class="number">1</span></span><br><span class="line">&gt; d = <span class="number">2</span></span><br><span class="line">&gt; 输出:</span><br><span class="line">&gt;          <span class="number">4</span></span><br><span class="line">&gt;         /  \</span><br><span class="line">&gt;        <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">&gt;       / \</span><br><span class="line">&gt;      <span class="number">2</span>   <span class="number">6</span></span><br><span class="line">&gt;     / \  /</span><br><span class="line">&gt;    <span class="number">3</span>  <span class="number">1</span>  <span class="number">5</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; 示例 <span class="number">2</span>:</span><br><span class="line">&gt; 输入:</span><br><span class="line">&gt;  二叉树如下所示:</span><br><span class="line">&gt;       <span class="number">4</span></span><br><span class="line">&gt;      /</span><br><span class="line">&gt;     <span class="number">2</span></span><br><span class="line">&gt;    / \</span><br><span class="line">&gt;   <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">&gt; v = <span class="number">1</span></span><br><span class="line">&gt; d = <span class="number">3</span></span><br><span class="line">&gt; 输出:</span><br><span class="line">&gt;        <span class="number">4</span></span><br><span class="line">&gt;       /</span><br><span class="line">&gt;      <span class="number">2</span></span><br><span class="line">&gt;     / \</span><br><span class="line">&gt;    <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">&gt;   / \</span><br><span class="line">&gt;  <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">       TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">       <span class="comment">//d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</span></span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">1</span>)&#123;</span><br><span class="line">            node.left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; d&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            root.left = addOneRow(root.left ,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            root.right = addOneRow(root.right,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</span></span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">1</span>)&#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            node.left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        TreeNode temp;</span><br><span class="line">        <span class="comment">//计算层数，到达前一层结束</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(depth == d-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                temp = queue.remove();</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode parent;</span><br><span class="line">        <span class="comment">//分别插入</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            parent = queue.remove();</span><br><span class="line">            <span class="comment">//将v插到左子树</span></span><br><span class="line">            temp = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            temp.left = parent.left;</span><br><span class="line">            parent.left = temp;</span><br><span class="line">            <span class="comment">//将v插到右子树</span></span><br><span class="line">            temp = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            temp.right = parent.right;</span><br><span class="line">            parent.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/623.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【94】二叉树的中序遍历</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-94-二叉树的中序遍历/</id>
    <published>2019-06-28T12:23:52.000Z</published>
    <updated>2019-06-29T13:43:11.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，返回它的中序遍历。<a id="more"></a></p><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;        <span class="number">1</span></span><br><span class="line">&gt;         \</span><br><span class="line">&gt;          <span class="number">2</span></span><br><span class="line">&gt;         /</span><br><span class="line">&gt;        <span class="number">3</span></span><br><span class="line">&gt; 输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>思路1：使用递归</p><pre><code>中序遍历的 左子树--&gt; 跟--&gt; 右子树</code></pre><p>思路2：迭代</p><pre><code>用一个指针模拟访问过程，先遍历到root的最左节点，</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;              <span class="number">1</span></span><br><span class="line">&gt;            /    \</span><br><span class="line">&gt;           <span class="number">2</span>      <span class="number">3</span></span><br><span class="line">&gt;         /  \    / </span><br><span class="line">&gt;        <span class="number">4</span>    <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">&gt; (<span class="number">1</span>)第一次循环，栈stack里面放入root的左子树：分别放入<span class="number">1</span>--<span class="number">2</span>--<span class="number">4</span>为root的树，然后ans里面存入stack.pop(),即<span class="number">4</span>，cur = cur.right = <span class="keyword">null</span></span><br><span class="line">&gt; (<span class="number">2</span>)stack内有<span class="number">2</span>个TreeNode,进入第二次循环，ans.add(cur.val) = <span class="number">2</span>;cur = cur.right = <span class="number">5</span>;</span><br><span class="line">&gt; (<span class="number">3</span>)stack里面还有一个以<span class="number">1</span>为root的TreeNode,进入第三次循环，stack加入以<span class="number">5</span>为root的TreeNode,ans加入<span class="number">5</span>，cur = <span class="keyword">null</span>,</span><br><span class="line">&gt; (<span class="number">4</span>)stack里面还有一个以<span class="number">1</span>为root的TreeNode,进入第四次循环，ans加入<span class="number">1</span>，cur = cur.right = <span class="number">3</span></span><br><span class="line">&gt; (<span class="number">5</span>)cur!=<span class="keyword">null</span>,进入第四次循环,stack加入<span class="number">3</span>和<span class="number">6</span>为root的树，ans加入<span class="number">6</span>，cur = <span class="keyword">null</span></span><br><span class="line">&gt; (<span class="number">6</span>) stack里面还有一个以<span class="number">3</span>为root的TreeNode,进入第五次循环，ans加入<span class="number">3</span>，cur = <span class="keyword">null</span>,stack为空，结束循环</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">              inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">          List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">          TreeNode cur = root;</span><br><span class="line">          <span class="keyword">while</span> (cur!=<span class="keyword">null</span> ||!stack.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  stack.push(cur);</span><br><span class="line">                  cur = cur.left;</span><br><span class="line">              &#125;</span><br><span class="line">              cur = stack.pop();</span><br><span class="line">              ans.add(cur.val);</span><br><span class="line">              cur = cur.right;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/94.jpg" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个二叉树，返回它的中序遍历。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【717】1比特和2比特字符</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-717-1%E6%AF%94%E7%89%B9%E5%92%8C2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-717-1比特和2比特字符/</id>
    <published>2019-06-28T11:49:31.000Z</published>
    <updated>2019-06-30T01:42:16.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。<a id="more"></a></p></blockquote><blockquote><p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p></blockquote><blockquote><p>示例 1:</p><p>输入: </p><p>bits = [1, 0, 0] 输出: True 解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</p><p>示例 2:</p><p>输入: bits = [1, 1, 1, 0] 输出: False 解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>从倒数第二个开始计算1的个数，直到遇到0结束，如果此时得到的1的个数是奇数个，代表最后一个0是2比特中的0，如果是偶数个，代表最后一个0是1比特中的0.</p><p>如：</p><p>111110<strong>11111</strong>0 ： 得到的count = 5，则最后一个0是2比特中的0,返回false</p><p>111110<strong>1111</strong>0 ： 得到的count = 4，则最后一个0是1比特中的0，返回true</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = bits.length -<span class="number">2</span> ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(bits[i]==<span class="number">1</span>) count++;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = count % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span>  ret==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/717.png" alt="提交记录"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://blogs.qiulig.website/2019/06/背包问题/</id>
    <published>2019-06-20T10:56:03.000Z</published>
    <updated>2019-06-20T12:34:19.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><pre><code>给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</code></pre><a id="more"></a><p>可参考<a href="https://www.cnblogs.com/-guz/p/9866118.html" target="_blank" rel="noopener">https://www.cnblogs.com/-guz/p/9866118.html</a></p><h3 id="1-0-1背包问题"><a href="#1-0-1背包问题" class="headerlink" title="1.  0-1背包问题"></a>1.  0-1背包问题</h3><blockquote><p>我们有n种物品，物品i的重量为weight[i]，价格为value[i]。我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为total。如果限定<strong>每种物品只能选择0个或1个</strong>，求背包里面能放的最大价格。</p></blockquote><pre><code>情况1：第i件不放进去，所得价值f[i-1][v],即不放第i件，转化成前i-1件物品放入容量为v的背包中的情况情况2：第i件放进去，所得价值f[i-1][v-weight[i]] + c[i]，转化成前i-1件物品放入剩下的容量为v-w[i]的背包中的情况由此得到状态转移方程：注：f[i][v]表示重量不超过v公斤的最大价值        f[i][v] = Math.max(f[i-1][v],f[i-1][v-w[i]]+c[i])时间和空间复杂度都为O(Num*total)=O(N*N),可以将其压缩成空间为O(total) = O(N)    情况1：第i件不放进去，所得价值f[v]     情况2：第i件放进去，所得价值f[v-weight[i]]+c[i]     由此得到状态转移方程：            f[v] = Math.max(f[v],f[v-w[i]]+c[i])，f[v]表示重量不超过v公斤的最大价值</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//weight表示每件物品的重量，value代表每件物品的价值，total 表示容量，Num表示物品数量，设 f[v]表示重量不超过v公斤的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ZeroOnePackage</span><span class="params">(<span class="keyword">int</span> []weight,<span class="keyword">int</span> []value,<span class="keyword">int</span> []f,<span class="keyword">int</span> Num,<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = total;v&gt;=weight[i];v--)&#123; <span class="comment">//注意是逆序</span></span><br><span class="line">            f[v] = Math.max(f[v-weight[i]]+value[i],f[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[total];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2. 完全背包问题"></a>2. 完全背包问题</h3><p>有Num种物品和一个容量为total的背包，每种物品都有无限件可用。第i种物品的体重量是weight[i]，价值是value[i]。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</p><pre><code>    情况1：第i件不放进去，所得价值  f[i-1][v]    情况2：第i件放进去，所得价值  f[i-1][v-weight[i]]+c[i]由此得到状态转移方程：，f[i][v]表示前i个背包装入重量不超过v公斤的最大价值           f[i][v] = Math.max(f[i-1][v],f[i-1][v-n*w[i]]+n*c[i]){0&lt;n*value[i]&lt;total}时间和空间复杂度都为O(Num*total)=O(N*N),可以将其压缩成空间为O(total) = O(N)    情况1：第i件不放进去，所得价值f[v]    情况2：第i件放进去，所得价值f[v-weight[i]]+c[i]由此得到状态转移方程：f[v]表示重量不超过v公斤的最大价值            f[v] = Math.max(f[v],f[v-n*w[i]] + n*c[i])   {0&lt;n*value[i]&lt;total}</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//weight表示每件物品的重量，value代表每件物品的价值，total 表示容量，Num表示物品数量，设 f[v]表示重量不超过v公斤的最大价值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ZeroMorePackage</span><span class="params">(<span class="keyword">int</span> []weight,<span class="keyword">int</span> []value,<span class="keyword">int</span> []f,<span class="keyword">int</span> Num,<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Num;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v = weight[i];v&lt;=total;v++)&#123; <span class="comment">//注意是++</span></span><br><span class="line">                f[v] = Math.max(f[v-weight[i]]+value[i],f[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[total];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3.多重背包问题"></a>3.多重背包问题</h3><p>有Num种物品和一个容量为total的背包。第i种物品最多有eachNum[i]件可用，每件体积是weight[i]，价值是value[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量total，且价值总和最大。</p><pre><code>情况1：第i件不放进去，所得价值f[v]情况2：第i件放进去，所得价值f[v-weight[i]] + c[i]由此得到状态转移方程：f[v]表示装入重量不超过v公斤的最大价值      f[v] = Math.max(f[v] , f[v-n*w[i]] + n*c[i])  {0 &lt; k &lt; eachNum[i]，0&lt;k*value[i]&lt;total}，</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多重背包问题</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MorePackage</span><span class="params">(<span class="keyword">int</span> []weight,<span class="keyword">int</span> []value,<span class="keyword">int</span> []f,<span class="keyword">int</span> Num,<span class="keyword">int</span> total,<span class="keyword">int</span> eachNum[])</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Num;i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> v = total; v &gt;= <span class="number">0</span>; v--) &#123; <span class="comment">//注意是逆序</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= eachNum[i]; k++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (v - k * weight[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       f[v] = Math.max(f[v - k * weight[i]] + k * value[i], f[v]);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> f[total];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背包问题&quot;&gt;&lt;a href=&quot;#背包问题&quot; class=&quot;headerlink&quot; title=&quot;背包问题&quot;&gt;&lt;/a&gt;背包问题&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="http://blogs.qiulig.website/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="背包问题" scheme="http://blogs.qiulig.website/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【55】跳跃游戏</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-55-跳跃游戏/</id>
    <published>2019-06-20T02:03:46.000Z</published>
    <updated>2019-07-02T02:56:34.754Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。<a id="more"></a></p><p>示例 1:</p><p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。<br>示例 2:</p><p>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><pre><code>从左到右依次判断索引坐标i是否能跳到，当遍历到数组末尾时，当dp[nums.length-1]==true时说明能跳到这个位置。即可以跳到最后一个位置。</code></pre><p>方法2: 贪心算法</p><pre><code>从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意味着可以从第一个位置跳到最后的位置。</code></pre><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(nums==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> []dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">              <span class="comment">//如果之前j节点可达，并且从此节点可以跳到i</span></span><br><span class="line">              <span class="keyword">if</span>(dp[j] &amp;&amp; nums[j]+j&gt;=i)&#123;</span><br><span class="line">                  dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：贪心算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJump2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastPos = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= lastPos) &#123;</span><br><span class="line">                lastPos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastPos == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p>方法1：动态规划</p><p>![leetcode提交结果]</p><p>(<a href="https://github.com/qiulig/IMG/raw/master/55-1.jpg" target="_blank" rel="noopener">https://github.com/qiulig/IMG/raw/master/55-1.jpg</a>)</p><p>方法2：贪心算法</p><p>![leetcode提交结果]</p><p>(<a href="https://github.com/qiulig/IMG/raw/master/55-2.jpg" target="_blank" rel="noopener">https://github.com/qiulig/IMG/raw/master/55-2.jpg</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="http://blogs.qiulig.website/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-82.删除排序链表中的重复元素2</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-82-删除排序链表中的重复元素2/</id>
    <published>2019-06-19T11:45:00.000Z</published>
    <updated>2019-06-19T11:49:34.667Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。<a id="more"></a></p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br>示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>剑指offer-56题</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head.val==head.next.val)&#123;</span><br><span class="line">                ListNode node = head.next;</span><br><span class="line">                <span class="keyword">while</span>( node != <span class="keyword">null</span> &amp;&amp; head.val == node.val )&#123;</span><br><span class="line">                   node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> deleteDuplicates(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head.next = deleteDuplicates(head.next);</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-83.删除排序链表中的重复元素</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-83-删除排序链表中的重复元素/</id>
    <published>2019-06-19T11:13:17.000Z</published>
    <updated>2019-06-19T11:17:59.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><a id="more"></a><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode res = head;</span><br><span class="line">       <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span> &amp;&amp; head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val == head.next.val)&#123;</span><br><span class="line">                head.next = head.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/83.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-各种模式应用场景</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式-各种模式应用场景/</id>
    <published>2019-06-17T02:35:09.000Z</published>
    <updated>2019-06-17T08:27:08.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><pre><code>将对象的创建与使用分离。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。</code></pre><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-  单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</span><br><span class="line"></span><br><span class="line">-  原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</span><br><span class="line"></span><br><span class="line">-  工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</span><br><span class="line"></span><br><span class="line">-  抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</span><br><span class="line"></span><br><span class="line">-  建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</span><br><span class="line"></span><br><span class="line">以上 <span class="number">5</span> 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式，</span><br></pre></td></tr></table></figure><p>1.<strong>单例（Singleton）模式</strong></p><pre><code>某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</span><br><span class="line"><span class="number">2</span>.当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</span><br><span class="line"><span class="number">3</span>.当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</span><br></pre></td></tr></table></figure><p>2.<strong>原型（Prototype）模式</strong></p><pre><code>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果一个系统想要独立于它想要使用的对象时,可以使用原型模式,让系统只面向接口编程,在系统需要新的对象的时候,可以通过克隆原型来得到.  </span><br><span class="line"><span class="number">2</span>.如果需要实例化的类是在运行时刻动态指定时,可以使用原型模式,通过克隆原型来得到需要的实例.</span><br></pre></td></tr></table></figure><p>3.<strong>工厂方法（FactoryMethod）模式</strong></p><pre><code>定义一个用于创建产品的接口，由子类决定生产什么产品。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.客户类不关心使用哪个具体类,只关心该接口所提供的功能.  </span><br><span class="line"><span class="number">2</span>.创建过程比较复杂,例如需要初始化其他关联的资源类,读取配置文件等.  </span><br><span class="line"><span class="number">3</span>.接口有很多具体实现或者抽象类有很多具体子类时,  </span><br><span class="line"><span class="number">4</span>.不希望给客户程序暴露过多的此类的内部结构,隐藏这些细节可以降低耦合度.      </span><br><span class="line"><span class="number">5</span>.优化性能,比如缓存大对象或者初始化比较耗时的对象.</span><br></pre></td></tr></table></figure><p>4.<strong>抽象工厂（AbstractFactory）模式</strong></p><pre><code>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果希望一个系统独立于它的产品的创建,组合和表示的时候,换句话说,希望一个系统只是知道产品的接口,而不关心实现的时候.  </span><br><span class="line"><span class="number">2</span>.如果一个系统要由多个产品系列中的一个来配置的时候.换句话说,就是可以,就是可以动态地切换产品族的时候.  </span><br><span class="line"><span class="number">3</span>.如果强调一系列相关产品的接口,以便联合使用他们的时候</span><br></pre></td></tr></table></figure><p>5.<strong>建造者（Builder）模式</strong></p><pre><code>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果创建对象的算法,应该独立于该对象的组成部分以及它们的装配方式时  </span><br><span class="line"><span class="number">2</span>.如果同一个构建过程有着不同的表示时</span><br></pre></td></tr></table></figure><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><pre><code>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-   适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</span><br><span class="line">-   桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</span><br><span class="line">-   组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</span><br><span class="line">-   装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</span><br><span class="line">-   外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</span><br><span class="line">-   享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</span><br><span class="line">-   代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</span><br><span class="line">    以上 <span class="number">7</span> 种结构型模式，除了 适配器模式 分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式</span><br></pre></td></tr></table></figure><p><strong>1.适配器模式(Adapter)</strong></p><pre><code>将一个类的接口转换成客户希望的另外一个接口.适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果先要使用一个已经存在的类,但是它的接口不符合你的需求,这种情况可以使用适配器模式,来把已有的实现转换成你需要的接口.</span><br><span class="line"><span class="number">2</span>.如果你想创建一个可以复用的类,这个类可能和一些不兼容的类一起工作,这中情况可以使用适配器模式,到时候需要什么就适配什么. </span><br><span class="line"><span class="number">3</span>.如果你想使用一些已经窜在的子类,但不对每一个子类都进行适配,这中情况可以使用适配器模式,直接适配这些子类的父类就可以了.</span><br></pre></td></tr></table></figure><p><strong>2.桥接模式(Bridge)</strong></p><pre><code>将抽象部分与它的实现部分分离,使他们可以独立变化. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果你不希望在抽象部分和实现部分采用固定的绑定关系,可以采用桥接模式. </span><br><span class="line"><span class="number">2</span>.如果出现抽象部分和实现部分都能够扩展的情况,可以采用桥接模式,让抽象部分和实现部分独立地变化. </span><br><span class="line"><span class="number">3</span>.如果希望实现部分的修改不会对客户产生影响,可以采用桥接模式. </span><br><span class="line"><span class="number">4</span>.如果采用继承的实现方案,会导致产生很多子类,对于这种情况,可以考虑采用桥接模式.</span><br></pre></td></tr></table></figure><p><strong>3.组合模式(Composite)</strong></p><pre><code>将对象组合成属性结构以表示&quot;部分-整体&quot;的层次结构,组合模式使用的用户对单个对象和组合对象的使用具有一致性. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果你想表示对象的部分-整体层次结构,可以使用..把整体和部分的操作统一起来,使得层次结构实现更简单,从外部来使用,这个层次结构也容易. </span><br><span class="line"><span class="number">2</span>.如果希望同意地使用组合结构中的所有对象,可以选用,这正是组合模式提供的主要功能.</span><br></pre></td></tr></table></figure><p><strong>4.装饰器模式(Decorator Method)</strong></p><p> 动态的给一个对象增加一些额外的职责,就增加功能来说,装饰模式生成子类更为灵活. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果需要爱不影响其他对象的情况下,以动态,透明的方式给对象添加职责,可以使用装饰模式. </span><br><span class="line"><span class="number">2</span>.如果不适合使用子类来进行扩展的时候,可以考虑使用装饰模式.</span><br></pre></td></tr></table></figure><p><strong>5.外观模式(Facade)</strong></p><pre><code>为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层的接口,这个接口使得这一子系统更加同容易使用.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果希望为一个复杂的子系统提供一个简单接口的时候,可以考虑使用外观模式.使用外观对象来实现大部分客户需要的功能,从而简化客户的使用. </span><br><span class="line"><span class="number">2</span>.如果想要让客户程序和抽象类的实现部分松散耦合,可以考虑使用外观模式,使用外观对象来将这个子系统与他的客户分离开来,从而提高子系统的独立性和可移植性. </span><br><span class="line"><span class="number">3</span>.如果构建多层节后的系统,可以考虑使用外观模式使用外观模式对象作为每层的入口,这样可以简化层间调用,也可以松散出层次之间的依赖关系.</span><br></pre></td></tr></table></figure><p><strong>6.享元模式(Flyweight)</strong></p><pre><code>运用共享技术有效地支持大量细粒度的对象. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果一个应用程序使用了大量的细粒度对象,可以使用享元模式来减少对象的数量. </span><br><span class="line"><span class="number">2</span>.如果犹豫使用大量的对象,造成很大的存储开销,可以使用享元模式来减少对象数量,并节约内存. </span><br><span class="line"><span class="number">3</span>.如果对象的大多数状态都可以转变成外部状态,比如通过计算得到,或者从外部传入等,可以使用享元模式来实现内部状态和外部状态的分离.</span><br><span class="line"><span class="number">4</span>.如果不考虑对象的外部状态,可以用相对较少的共享对象取代很多组合对象,可以使用享元模式来共享对象.然后组合对象来使用这些共享对象.</span><br></pre></td></tr></table></figure><p><strong>7.代理模式(Proxy)</strong></p><pre><code>为其他对象提供一种代理以控制对这个对象的访问.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.需要为一个对象在不同的地址空间提供局部代表的时候,可以使用远程代理. </span><br><span class="line"><span class="number">2</span>.需要按照需要创建开销很大的对象的时候,可以使用虚代理. </span><br><span class="line"><span class="number">3</span>.需要控制对原始对象的访问的时候,可以使用保护代理. </span><br><span class="line"><span class="number">4</span>.需要在访问你对象执行一些附加操作的时候,可以使用智能指引代理.</span><br></pre></td></tr></table></figure><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><pre><code>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。  行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。  </code></pre><p>行为型模式是 设计模式中最为庞大的一类，它包含以下 11 种模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-   模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</span><br><span class="line">-   策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</span><br><span class="line">-   命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</span><br><span class="line">-   职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</span><br><span class="line">-   状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</span><br><span class="line">-   观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</span><br><span class="line">-   中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</span><br><span class="line">-   迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</span><br><span class="line">-   访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</span><br><span class="line">-   备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</span><br><span class="line">-   解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</span><br></pre></td></tr></table></figure><p><strong>1.策略模式(Strategy)</strong></p><pre><code>定义一系列的算法,把它们一个个封装起来,并且使他们可以相互替换.本模式使得算法可独立于使用它的客户而变化. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.出现有许多相关的类,仅仅是行为有差别的情况下,可以使用策略模式来使用多个行为中的一个来配置一个类的方法,实现算法动态切换 </span><br><span class="line"><span class="number">2</span>.出现同一算法,有很多不同实现的情况下,可以使用策略模式来把这些<span class="string">"不同的实现"</span>实现成为一个算法的类层次. </span><br><span class="line"><span class="number">3</span>.需要封装算法中,有与算法相关数据的情况下,可以使用策略模式来避免暴露这些跟算法相关的数据结构. </span><br><span class="line"><span class="number">4</span>.出现抽象一个定义了很多行为的类,并且是通过多个<span class="keyword">if</span>-<span class="keyword">else</span>语句来选择这些行为的情况下,可以使用策略模式来替换这些条件语句.</span><br></pre></td></tr></table></figure><p><strong>2.模版方法模式(TemplateMethod)</strong></p><pre><code>定义在一个操作中的算法框架,把一些步骤推迟到子类去实现.模版方法模式让子类不需要改变算法的结构而重新定义特定的算法步骤 </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</span><br></pre></td></tr></table></figure><p><strong>3.职责链模式(Chain Of Responsibility)</strong></p><pre><code>使多个对象都有机会处理请求,,从而避免请求的发送者和接收者之间耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果有多个对象可以处理同一个请求,但是具体由哪个对象来处理该请求,是运行时刻动态确定的. </span><br><span class="line"><span class="number">2</span>.如果你想在不明确指定接收者的情况下,向多个对象中的其中一个提交请求的话,可以使用职责链模式. </span><br><span class="line"><span class="number">3</span>.如果想要动态指定处理一个请求的对象结合,可以使用职责链模式.</span><br></pre></td></tr></table></figure><p><strong>4.命令模式(Command)</strong></p><pre><code>将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化,对请求排队或者记录请求日志,以及支持可撤销的操作.</code></pre><p><strong>5.解释器模式(Interpreter)</strong></p><pre><code>给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子. 使用场合:</code></pre><p><strong>6.迭代器模式(Iterator)</strong> </p><pre><code>提供一种方法顺序访问一个聚合对象中的各个元素,而又不需要暴露该对象的内部表示. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果你希望提供访问一个聚合对象的内容,但是又不想暴露他的内部表示的时候,可以使用迭代器模式来提供迭代器接口,从而让客户端只是通过迭代器的接口来访问聚合对象,而无须关心聚合对象的内部实现. </span><br><span class="line"><span class="number">2</span>.如果你希望有多种遍历方式可以访问聚合对象,可以使用</span><br><span class="line"><span class="number">3</span>.如果你希望为遍历不同的聚合对象提供一个统一的接口,可以使用....</span><br></pre></td></tr></table></figure><p><strong>7.中介模式(Mediator)</strong></p><pre><code>用一个中介对象类封装一系列对象的交互.中介者使得各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变他们之间的交互. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果一组对象之间的通信方式比较复杂,导致相互依赖,结构混乱,可以采用中介模式,把这些对象相互的交互管理起来,各个对象都只需要和中介者交互,从而是的各个对象松散耦合,结构也更清晰易懂. </span><br><span class="line"><span class="number">2</span>.如果一个对象引用很多的对象,并直接跟这些对象交互,导致难以复用该对象,可以采用中介者模式,把这个对象跟其他对象的交互封装到中介者对象里面,这个对象只需要和中介者对象交互就可了.</span><br></pre></td></tr></table></figure><p><strong>8.备忘录模式(Memento)</strong></p><pre><code>在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可将该对象恢复到原先保存的状态. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果必须要保存一个对象在某一个时刻的全部或者部分状态,方便以后需要的时候,可以把该对象恢复到先前的状态,可以使用备忘录模式. </span><br><span class="line"><span class="number">2</span>.如果需要保存一个对象的内部状态,但是如果用接口来让其他对象直接得到这些需要保存的状态,将会暴露对象的实现希捷并破坏对象的封装性,这是可以使用备忘录.</span><br></pre></td></tr></table></figure><p><strong>9.观察者模式(Observer)</strong></p><pre><code>定义对象间的一种一对多的依赖关系.当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.当一个抽象模型有两个方面,其中一个方面的操作依赖于另一个方面的状态变化,那么就可以选用观察者模式,将这两者封装成观察者和目标对象,当目标对象变化的时候,依赖于它的观察者对象也会发生相应的变化.这样就把抽象模型的这两个方面分离了使得,它们可以独立地改变和复用. </span><br><span class="line"><span class="number">2</span>.如果在更改一个对象的时候,需要同时连带改变其他对象,而且不知道究竟应该有多少对象需要被连带改变,这种情况可以选用观察者模式,被改的那一个对象很明显就相当于是目标对象,而需要连带修改的对歌其他对象,就作为多个观察着对象了. </span><br><span class="line"><span class="number">3</span>.当一个对象必须通知其他的对象,但是你又希望这个对象和其他被它通知的对象是松散耦合的,也就是说这个对象其实不详知道具体被通知的对象.这种情况可以选用观察者模式,这个对象就相当于是目标对象,而被它通知的对象就是观察者对象了.</span><br></pre></td></tr></table></figure><p><strong>10.状态模式(State)</strong></p><pre><code>允许一个对象在其内部状态改变是改变它的行为.对象看起来似乎修改了他的类. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果一个对象的行为取决于它的状态,而且它必须在运行时刻根据状态来改变它的行为,可以使用.来包状态和行为分离开.虽然分离了,但是状态和行为是有对应关系的,可以在运行期间,通过改变状态,就能够调用到该状态对应的状态处理对象上去从而改变对象的行为. </span><br><span class="line"><span class="number">2</span>.如果一个操作中含有庞大的多分枝语句,而且这些分支依赖于该对象的状态,可以使用</span><br><span class="line"><span class="number">3</span>.把各个分支的处理分散包装到单独的对象处理类中,这样,这些分支对应的对象就可以不依赖于其他对象而独立变化了.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建型模式&quot;&gt;&lt;a href=&quot;#创建型模式&quot; class=&quot;headerlink&quot; title=&quot;创建型模式&quot;&gt;&lt;/a&gt;创建型模式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;将对象的创建与使用分离。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://blogs.qiulig.website/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blogs.qiulig.website/2019/06/设计模式-观察者模式/</id>
    <published>2019-06-17T02:17:43.000Z</published>
    <updated>2019-06-17T02:34:03.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><pre><code>多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式。</code></pre><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>1. 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。2. 目标与观察者之间建立了一套触发机</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>1. 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。2. 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</code></pre><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'抽象主题'</span>（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'具体主题'</span>（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'抽象观察者'</span>（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'具体观察者'</span>（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。2. 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</span><br><span class="line"><span class="number">1</span>. Observable类</span><br><span class="line">    <span class="number">1</span>) Observable 类是抽象目标类，它有一个 Vector 向量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 <span class="number">3</span> 个方法。</span><br><span class="line">    <span class="number">2</span>)<span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> 方法：用于将新的观察者对象添加到向量中。</span></span><br><span class="line"><span class="function">    3)<span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> 方法：调用向量中的所有观察者对象的 update。方法，通知它们数据发生改变。通常越晚加入向量的观察者越先得到通知。</span></span><br><span class="line"><span class="function">    4)<span class="keyword">void</span> <span class="title">setChange</span><span class="params">()</span> 方法：用来设置一个 <span class="keyword">boolean</span> 类型的内部标志位，注明目标对象发生了变化。当它为真时，<span class="title">notifyObservers</span><span class="params">()</span> 才会通知观察者。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2. Observer 接口</span></span><br><span class="line"><span class="function">    Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o,Object arg)</span> 方法，进行相应的工作。</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Subject subject=<span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1=<span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2=<span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers=<span class="keyword">new</span> ArrayList&lt;Observer&gt;();   </span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体目标发生改变..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);       </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        &#125;      </span><br><span class="line"></span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者1作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者2作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://blogs.qiulig.website/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="http://blogs.qiulig.website/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
