<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0972e01a5f38f38e77d0154479c21150</icon>
  <subtitle>菜鸟要更加努力才能追上别人的步伐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blogs.qiulig.website/"/>
  <updated>2019-06-11T00:53:46.642Z</updated>
  <id>http://blogs.qiulig.website/</id>
  
  <author>
    <name>qiulig</name>
    <email>qiuling_long@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表反转</title>
    <link href="http://blogs.qiulig.website/2019/06/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    <id>http://blogs.qiulig.website/2019/06/链表反转/</id>
    <published>2019-06-10T13:04:46.000Z</published>
    <updated>2019-06-11T00:53:46.642Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>以链表 1-&gt;2-&gt;3-&gt;4  为例子：</p><ul><li>程序到达Node newHead = reverse(head.next);时进入递归</li><li>我们假设此时递归到了3结点，此时head=3结点，temp=3结点.next(实际上是4结点)<a id="more"></a></li><li>执行Node newHead = reverse(head.next);传入的head.next是4结点，返回的newHead是4结点。</li><li>接下来就是弹栈过程了<ul><li>程序继续执行 temp.next = head就相当于4-&gt;3</li><li>head.next = null 即把 3结点指向4结点的指针断掉。</li><li>返回新链表的头结点newHead</li></ul></li></ul><blockquote><p>注意：当retuen后，系统会恢复2结点压栈时的现场，此时的head=2结点；temp=2结点.next(3结点)，再进行上述的操作。最后完成整个链表的翻转。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode temp = head.next;</span><br><span class="line">    ListNode newHead = reverse(head.next);</span><br><span class="line">    temp.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h3><p>依旧是1-&gt;2-&gt;3-&gt;4</p><ul><li>准备两个空结点 pre用来保存先前结点、next用来做临时变量</li><li>在头结点node遍历的时候此时为1结点<ul><li>next = 1结点.next(2结点)</li><li>1结点.next=pre(null)</li><li>pre = 1结点</li><li>node = 2结点</li></ul></li><li>进行下一次循环node=2结点<ul><li>next = 2结点.next(3结点)</li><li>2结点.next=pre(1结点)=&gt;即完成2-&gt;1</li><li>pre = 2结点</li><li>node = 3结点</li></ul></li><li>进行循环…</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   ListNode next;</span><br><span class="line">   ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">       ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">       ListNode cur = node;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode next = cur.next;  <span class="comment">//将下一个节点记录</span></span><br><span class="line">           cur.next = pre;  <span class="comment">//当前节点指向上一个节点</span></span><br><span class="line">           pre = cur;   <span class="comment">//记录当前节点</span></span><br><span class="line">           cur = next; <span class="comment">//将下一个节点变成当前节点</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-递归&quot;&gt;&lt;a href=&quot;#1-递归&quot; class=&quot;headerlink&quot; title=&quot;1.递归&quot;&gt;&lt;/a&gt;1.递归&lt;/h3&gt;&lt;p&gt;以链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4  为例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序到达Node newHead = reverse(head.next);时进入递归&lt;/li&gt;
&lt;li&gt;我们假设此时递归到了3结点，此时head=3结点，temp=3结点.next(实际上是4结点)&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【203】移除链表元素</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-203移除链表元素/</id>
    <published>2019-06-10T12:35:37.000Z</published>
    <updated>2019-06-10T13:37:51.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>删除链表中等于给定值 <strong><em>val</em></strong> 的所有节点。<a id="more"></a></p><p><strong>示例:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, <strong><em>val</em></strong> = 6<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：</p><pre><code>如果当前链表值head.val不等于val,则新建一个节点放到ans后面如果相等，则跳到链表下一个。</code></pre><p>方法2：</p><pre><code>遇到相等则跳指针 要考虑好头节点跟val相等的情况。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：新建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">          ListNode ans = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">          ListNode res = ans;</span><br><span class="line">          <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(head.val==val)&#123;</span><br><span class="line">                  head = head.next;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  ans.next =<span class="keyword">new</span> ListNode(head.val) ;</span><br><span class="line">                  ans = ans.next;</span><br><span class="line">                  head = head.next;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>方法2：跳指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//如果头节点与val相同</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.val == val)</span><br><span class="line">            head = head.next;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;删除链表中等于给定值 &lt;strong&gt;&lt;em&gt;val&lt;/em&gt;&lt;/strong&gt; 的所有节点。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【120】三角形最小路径和</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-120-三角形最小路径和/</id>
    <published>2019-06-09T09:08:41.000Z</published>
    <updated>2019-06-10T07:33:23.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><a id="more"></a><p>例如，给定三角形：</p><p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划：</p><p> 每一层的值加上上一层的值中最小值，最后取最后一层的最小值就好了</p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">2</span>]                             [<span class="number">2</span>]</span><br><span class="line">&gt;    [<span class="number">3</span>,<span class="number">4</span>]         变成               [<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&gt;   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>]                        [<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>]</span><br><span class="line">&gt;  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]                      [<span class="number">15</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">16</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> len = triangle.get(triangle.size()-<span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="comment">//初始化第一层跟第二层</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>]+triangle.get(<span class="number">1</span>).get(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">0</span>] + triangle.get(<span class="number">1</span>).get(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//第一列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;= i ;j++)&#123;</span><br><span class="line">                <span class="comment">//最后一个数的dp,因为上一层比下一层少一个，所以只能最后一个数只能加上上一层的最后一个dp</span></span><br><span class="line">                <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j) + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j)+ Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三角形最后一层中的最小值就是最小路径</span></span><br><span class="line">        <span class="keyword">int</span> res = dp[len-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[len-<span class="number">1</span>][i] &lt; res)&#123;</span><br><span class="line">                res = dp[len-<span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/120.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【95】不同的二叉搜索树2</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-95-不同的二叉搜索树2/</id>
    <published>2019-06-09T07:16:05.000Z</published>
    <updated>2019-06-10T07:31:33.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出:<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释:<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>        <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span>        <span class="number">1</span></span><br><span class="line">&gt;  \      /      /      / \        \</span><br><span class="line">&gt;  <span class="number">3</span>     <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>        <span class="number">2</span></span><br><span class="line">&gt;  /    /        \                   \</span><br><span class="line">&gt;  <span class="number">2</span>   <span class="number">1</span>          <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1)当n = 1时，此时只有一个以1为根节点的二叉搜索树</p><p>(2) 当n &gt; 1时，当以 i 为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，依次递归遍历，分别放到left和right列表中，然后再先序遍历放入res结果中。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//n = 1 的情况，只有一个，就是根节点为1的二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                TreeNode node = <span class="keyword">new</span> TreeNode(start);</span><br><span class="line">                list.add(node);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以 i 为根节点，左子树为start~(i-1),右子树为(i+1)~n</span></span><br><span class="line">            List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                List&lt;TreeNode&gt; left = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                List&lt;TreeNode&gt; right = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (i != start) &#123;</span><br><span class="line">                    <span class="comment">//说明有左子树</span></span><br><span class="line">                    left = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != end) &#123;</span><br><span class="line">                    <span class="comment">//说明有右子树</span></span><br><span class="line">                    right = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//先序遍历存入res里面</span></span><br><span class="line">                <span class="keyword">if</span> (!left.isEmpty() &amp;&amp; !right.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode l : left) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (TreeNode r : right) &#123;</span><br><span class="line">                            TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                            root.left = l;</span><br><span class="line">                            root.right = r;</span><br><span class="line">                            res.add(root);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!left.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode l : left) &#123;</span><br><span class="line">                        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        root.left = l;</span><br><span class="line">                        res.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!right.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode r : right) &#123;</span><br><span class="line">                        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        root.right = r;</span><br><span class="line">                        res.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees=generate(start,i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归遍历右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees=generate(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//先序遍历存入以i为根节点的二叉搜索树</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left:leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right:rightTrees)&#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left=left;</span><br><span class="line">                    root.right=right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/95.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【96】不同二叉搜索树</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-96-%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-96-不同二叉搜索树/</id>
    <published>2019-06-08T15:53:51.000Z</published>
    <updated>2019-06-10T07:31:59.584Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>      <span class="number">3</span>     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">&gt;  \     /    /     / \     \</span><br><span class="line">&gt;  <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>     <span class="number">1</span>   <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">&gt;  /   /      \               \</span><br><span class="line">&gt;  <span class="number">2</span>  <span class="number">1</span>        <span class="number">2</span>               <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划：</p><p>(1)初始化</p><pre><code>n  = 1时，只含有1，1作为根节点，此时二叉搜索数个数为1；</code></pre><p>(2) 算法</p><pre><code>    （1）假设n个节点存在二叉排序树的个数是dp[i]，令f[i]为以i为根的二叉搜索树的个数，则                dp[n] = f[1] + f[2] + f[3] + f[4] + ... + f[n]     （2）当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则                f [i]  = dp[i-1] * dp[n-i]综合两个公式可以得到卡特兰数公式</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  dp[n] = dp[<span class="number">0</span>] * dp[n-<span class="number">1</span>] + dp[<span class="number">1</span>] * dp[n-<span class="number">2</span>]+...+dp[n-<span class="number">1</span>] * dp[<span class="number">0</span>]</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * C(<span class="number">2</span>n,n)</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * (<span class="number">4</span>*n-<span class="number">2</span>)/(n-<span class="number">1</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n个节点存在二叉树的个数</span></span><br><span class="line">        <span class="keyword">long</span> []dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//以i为根节点的二叉树个数</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]*(<span class="number">4</span>*i-<span class="number">2</span>)/(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/96.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="二叉树题" scheme="http://blogs.qiulig.website/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【70】爬楼梯</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-70-爬楼梯/</id>
    <published>2019-06-08T14:47:57.000Z</published>
    <updated>2019-06-10T07:28:59.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><a id="more"></a><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li><p>2 阶</p><p>示例 2：</p></li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><p>初始化：</p><pre><code>可知dp[0]  = 0;dp[1] = 1;dp[2] = 2;即跳0级有一种方法，一级有1种方法，2级有2种方法</code></pre><p>算法核心：</p><pre><code>dp[i] = dp[i-1] +dp[i-2] ,即爬i阶台阶的方法等于爬i-2阶台阶的方法加上爬i-1阶台阶的方法</code></pre><p>方法2：</p><pre><code>剑指offer第8题</code></pre><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n ;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;=n ;i++)&#123;</span><br><span class="line">            res = one + two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/70.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【64】最小路径和</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-64-最小路径和/</id>
    <published>2019-06-08T14:06:23.000Z</published>
    <updated>2019-06-10T07:28:29.186Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><a id="more"></a><p>示例:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果数组只有一个数，则路径最小即为该值，dp[0][0] = 0;</p><p> (1)动态规划初始化</p><pre><code>1)只有一行，则路径总和最小为 dp[0][i] = dp[0][i-1] + grid[0][i];2)只有一列，则路径总和最小为 dp[i][0] = dp[i-1][0] + grid[i][0];</code></pre><p>(2) 动态规划核心算法</p><p>  每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：</p><pre><code>dp[i][j] = grid[i][j] + min( dp[i-1][j] , dp[i][j-1]);</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划核心</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                dp[i][j] = grid[i][j]+(dp[i-<span class="number">1</span>][j]&lt;dp[i][j-<span class="number">1</span>]?dp[i-<span class="number">1</span>][j]:dp[i][j-<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/64.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;说明：每次只能向下或者向右移动一步。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【63】不同路径2</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-63-不同路径2/</id>
    <published>2019-06-08T13:38:57.000Z</published>
    <updated>2019-06-10T07:27:35.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><a id="more"></a><p>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果第一个格点 obstacleGrid[0][0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。</p><p>如果 obstacleGrid[0][0] 是 0，我们初始化这个值为 1 然后继续算法。<br>(1)动态规划初始化</p><pre><code>1)obstacleGrid[0][0] == 0,表示没障碍，路径只有一条；dp[0][0] = 1;2)遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[0][j] = dp[0][j-1]。             3)遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[i][0] = obstacleGrid[i-1][0]。</code></pre><p>(2) 动态规划核心算法</p><pre><code>从 obstacleGrid[1][1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 dp[i][j] = dp[i-1][j] + dp[i][j-1]。如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> col = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span> ? <span class="number">0</span> : dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>? <span class="number">0</span>:dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                    dp[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/63.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。&lt;/p&gt;
&lt;p&gt;说明：m 和 n 的值均不超过 100。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【62】不同的路径</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-62-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-62-不同的路径/</id>
    <published>2019-06-08T03:35:18.000Z</published>
    <updated>2019-06-10T07:25:47.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划</p><p>（1）初始化</p><pre><code>1) 从[0,0]走到[0,0]的路径，即没走，设dp[0][0] = 0;2) 如果m*n的n为1，即机器人在m*1走，只能有一条路径，即arr[i][0] = 1;3) 如果m*n的m为1，即机器人在1*n走，只能有一条路径，即arr[0][1] = 1;</code></pre><p>(2) 动态规划核心算法</p><pre><code>机器人每次只能向下或者向右移动一步。即机器人arr[i][j]的路径由arr[i-1][j]和arr[i][j-1]决定，即arr[i][j] = arr[i-1][j]+arr[i][j-1];</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j]+arr[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/62.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【53】最大子序和</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-53-最大子序和/</id>
    <published>2019-06-08T02:52:18.000Z</published>
    <updated>2019-06-10T07:17:31.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><blockquote><ol><li>定义一个函数f(n)，以第n个数为结束点的子数列的最大和，存在一个递推关系f(n) = max(f(n-1) + A[n], A[n]);</li><li>将这些最大和保存下来后，取最大的那个就是，最大子数组和。因为最大连续子数组 等价于 最大的以n个数为结束点的子数列</li></ol></blockquote><p>方法2：</p><blockquote><p>用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。</p><pre><code>(1)当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令    cur = 0.表示从下一个数开始累加。(2)当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最    大值即可。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        ans[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = ans[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//依次求出以第n个数为结束点的子序列最大和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            ans[i] = Math.max(ans[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="comment">//求出最大和</span></span><br><span class="line">            res = Math.max(res,ans[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            cur = cur + nums[i];</span><br><span class="line">            ans = Math.max(cur,ans);</span><br><span class="line">            cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/53_1.jpg" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/53_2.jpg" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【264】丑数2</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-264-%E4%B8%91%E6%95%B02/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-264-丑数2/</id>
    <published>2019-06-06T12:36:33.000Z</published>
    <updated>2019-06-10T07:36:03.325Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>编写一个程序，找出第  <code>n</code>  个丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code>  的<strong>正整数</strong>。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> n = 10<br><strong>输出:</strong> 12</p><a id="more"></a><p><strong>解释:</strong> <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> 是前 10 个丑数。</p><p><strong>说明:</strong></p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>剑指offer-【33】</p><p>丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an</p><p>所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2<em>a1, 2</em>a2, 2*a3 …..</p><p>包含3的有序丑数序列:3<em>a1, 3</em>a2, 3<em>a3 ….. 包含5的有序丑数序列:5</em>a1, 5<em>a2, 5</em>a3 …..</p><p>以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i] =Math.min(Math.min(arr[t2]*<span class="number">2</span>,arr[t3]*<span class="number">3</span>),arr[t5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr[t2]*<span class="number">2</span> == arr[i])&#123;</span><br><span class="line">                t2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[t3]*<span class="number">3</span> == arr[i])&#123;</span><br><span class="line">                t3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[t5]*<span class="number">5</span> == arr[i])&#123;</span><br><span class="line">                t5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/264.png" alt="丑数2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个程序，找出第  &lt;code&gt;n&lt;/code&gt;  个丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 &lt;code&gt;2, 3, 5&lt;/code&gt;  的&lt;strong&gt;正整数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; n = 10&lt;br&gt;&lt;strong&gt;输出:&lt;/strong&gt; 12&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【263】丑数</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-263-%E4%B8%91%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-263-丑数/</id>
    <published>2019-06-06T12:23:27.000Z</published>
    <updated>2019-06-10T07:35:27.034Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 6<br><strong>输出:</strong> true<br><strong>解释:</strong> 6 = 2 × 3</p><a id="more"></a><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 8<br><strong>输出:</strong> true<br><strong>解释:</strong> 8 = 2 × 2 × 2</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 14<br><strong>输出:</strong> false<br><strong>解释:</strong> <code>14</code> 不是丑数，因为它包含了另外一个质因数 <code>7</code>。</p><p><strong>说明：</strong></p><ol><li><code>1</code> 是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>丑数只能被2，3，5整除，所以丑数为2*i+3*j+5*k = num[i,j,k为任意整数]</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">3</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">5</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> num==<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/263.png" alt="丑数"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个程序判断给定的数是否为丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 &lt;code&gt;2, 3, 5&lt;/code&gt; 的&lt;strong&gt;正整数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 6&lt;br&gt;&lt;strong&gt;输出:&lt;/strong&gt; true&lt;br&gt;&lt;strong&gt;解释:&lt;/strong&gt; 6 = 2 × 3&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【23】合并K个排序链表</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-23%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-23合并K个排序链表/</id>
    <published>2019-06-06T11:21:49.000Z</published>
    <updated>2019-06-10T07:14:33.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><p><strong>输入:</strong><br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br><strong>输出:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：</p><pre><code>(1)利用priorityQueue的性质，每放一个数字进去就给你从小到大排好序了(2)队列的性质是先进先出，故依次poll出来就是从小到大的顺序，将该数值放到listNode里面即可。</code></pre><p>方法2：</p><pre><code>借用合并两个链表的代码，依次将list[]分成两部分，在分别合并，执行用时为6ms</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode ans = res;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//将所有节点的值放到一个queue里面从小到大排好序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; lists.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lists[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(lists[i].val);</span><br><span class="line">                lists[i] = lists[i].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次建立链表</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode(queue.poll());</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将一半的链表放到l1里面</span></span><br><span class="line">        <span class="keyword">int</span> mid = lists.length/<span class="number">2</span>;</span><br><span class="line">        ListNode[] l1 = <span class="keyword">new</span> ListNode[mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++)&#123;</span><br><span class="line">            l1[i] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将一半的链表放到l2里面</span></span><br><span class="line">        ListNode[] l2 = <span class="keyword">new</span> ListNode[lists.length-mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid,j=<span class="number">0</span>; i &lt; lists.length; i++,j++)&#123;</span><br><span class="line">            l2[j] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归实现多个链表的排序</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(mergeKLists(l1),mergeKLists(l2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方式实现两个链表排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            head.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            head.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/23.jpg" alt="合并K个排序的链表"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;合并 &lt;em&gt;k&lt;/em&gt; 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt;&lt;br&gt;[&lt;br&gt;  1-&amp;gt;4-&amp;gt;5,&lt;br&gt;  1-&amp;gt;3-&amp;gt;4,&lt;br&gt;  2-&amp;gt;6&lt;br&gt;]&lt;br&gt;&lt;strong&gt;输出:&lt;/strong&gt; 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
      <category term="困难" scheme="http://blogs.qiulig.website/tags/%E5%9B%B0%E9%9A%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【21】合并两个有序链表</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-21合并两个有序链表/</id>
    <published>2019-06-06T09:31:36.000Z</published>
    <updated>2019-06-10T07:09:35.971Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例：</strong></p><p><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1) 判断是否有空链表，如果有则直接返回另一个不为空有序链表</p><p>(2) 依次判断是否有对应链表大小，小的加入res链表，并移动</p><p>注：该题与剑指offer-[16]题一致，还可以用递归。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span> &amp;&amp;l2!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span> &amp;&amp; l1!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            ListNode ans = res;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//哪个小添加哪个</span></span><br><span class="line">                <span class="keyword">if</span>(l1.val&gt;l2.val)&#123;</span><br><span class="line">                    res.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将剩下的没便利完的加入</span></span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/21.png" alt="合并有序链表"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【19】删除链表的倒数第N个节点</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-19-删除链表的倒数第N个节点/</id>
    <published>2019-06-06T08:00:45.000Z</published>
    <updated>2019-06-10T07:06:58.826Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong><em>n</em> = 2</strong>.</p><p>当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p><p><strong>说明：</strong></p><p>给定的  <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>双指针</p><p>(1)第一个指针curNode先走n步</p><p>(2)然后第二个指针preNode再重头跟刚刚第一个指针curNode走,直到走到尾部【preNode走了(len-N)步,即下一个节点就是要删除的节点】</p><p>(3)此时的preNode的下一个即为倒数第N个节点，将其删除即可</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode preNode = head;</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        <span class="comment">//第一个指针先走n步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> preNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个指针同时走，走剩下的（Len-n）步，此时preNode的下一个就是要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (curNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preNode = preNode.next;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除倒数第N个节点</span></span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/19.jpg" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个链表，删除链表的倒数第 &lt;em&gt;n&lt;/em&gt; 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个链表: &lt;strong&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/strong&gt;, 和 &lt;strong&gt;&lt;em&gt;n&lt;/em&gt; = 2&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;当删除了倒数第二个节点后，链表变为 &lt;strong&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;5&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定的  &lt;em&gt;n&lt;/em&gt; 保证是有效的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你能尝试使用一趟扫描实现吗？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【434】字符串中的单词数</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-434-字符串中的单词数/</id>
    <published>2019-06-06T06:25:04.000Z</published>
    <updated>2019-06-10T07:36:32.006Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> “Hello, my name is John”<br><strong>输出:</strong> 5</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>每次出现非空字符，看看上一个是不是空格，如果是，发现一个新单词</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> lastIsBlank = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                lastIsBlank = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastIsBlank) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIsBlank = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/434.png" alt="字符串中的单词数"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。&lt;/p&gt;
&lt;p&gt;请注意，你可以假定字符串里不包括任何不可打印的字符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; “Hello, my name is John”&lt;br&gt;&lt;strong&gt;输出:&lt;/strong&gt; 5&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【13】罗马数字转整数</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-13-罗马数字转整数/</id>
    <published>2019-06-05T13:32:34.000Z</published>
    <updated>2019-06-10T07:01:11.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th><strong>字符</strong></th><th><strong>数值</strong></th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。<a id="more"></a></p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “III”<br><strong>输出:</strong> 3</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “IV”<br><strong>输出:</strong> 4</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “IX”<br><strong>输出:</strong> 9</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>通常情况下，<strong>罗马数字中小的数字在大的数字的右边</strong>。这句话很关键，意思是要变成罗马数字，必须先排列大的数</p><p>（1）res初始化为字符串的最后一个字符所代表的数字</p><p>（2）从字符串数组尾部开始遍历，</p><pre><code>1)如果下一个字符所代表的数字小于当前字符所代表的数字，则res减去下一个字符所代表的数字：如IV,下一个字符I所代表数字1&lt;当前字符所代表数字5，res = res-12)如果下一个字符所代表的数字大于当前字符所代表的数字，则res加上下一个字符所代表的数字如VI,下一个字符V 所代表数字5&gt;当前字符I所代表数字1,res = res+5</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'I'</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">int</span> res = map.get(s.charAt(s.length()-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//罗马数字中大的数字在小的数字的右边，用减法</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(s.charAt(i))&gt;map.get(s.charAt(i-<span class="number">1</span>)))&#123;</span><br><span class="line">                res -=map.get(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//罗马数字中小的数字在大的数字的右边，用加法</span></span><br><span class="line">                res +=map.get(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/13.png" alt="罗马数字转整数"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;罗马数字包含以下七种字符: &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;字符&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;数值&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例如， 罗马数字 2 写做 &lt;code&gt;II&lt;/code&gt; ，即为两个并列的 1。12 写做 &lt;code&gt;XII&lt;/code&gt; ，即为 &lt;code&gt;X&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。 27 写做 &lt;code&gt;XXVII&lt;/code&gt;, 即为 &lt;code&gt;XX&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="简单" scheme="http://blogs.qiulig.website/tags/%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【12】整数转罗马数字</title>
    <link href="http://blogs.qiulig.website/2019/06/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://blogs.qiulig.website/2019/06/leetcode-12-整数转罗马数字/</id>
    <published>2019-06-05T12:56:48.000Z</published>
    <updated>2019-06-10T06:59:56.797Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th style="text-align:center"><strong>字符</strong></th><th style="text-align:center"><strong>数值</strong></th></tr></thead><tbody><tr><td style="text-align:center">I</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">500</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><a id="more"></a><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 3<br><strong>输出:</strong> “III”</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 4<br><strong>输出:</strong> “IV”</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 9<br><strong>输出:</strong> “IX”</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> 58<br><strong>输出:</strong> “LVIII”<br><strong>解释:</strong> L = 50, V = 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> 1994<br><strong>输出:</strong> “MCMXCIV”<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>通常情况下，<strong>罗马数字中小的数字在大的数字的右边</strong>。这句话很关键，意思是要变成罗马数字，必须先排列大的数</p><p>（1）定义一个arr[],代表能用罗马数字代表的数</p><p>（2）定义一个str[],里面的字符串分别与数字arr[]里面的数字相对应，两个的联系即arr[i]  —–&gt;str[i]</p><p>（3）定义一个i,i从0开始，找到数组中第一个小于等于num的值，第一个罗马数字就是str[i],再依次循环知道num==0</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>   arr [] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>,<span class="number">100</span>,  <span class="number">90</span>, <span class="number">50</span>,  <span class="number">40</span>, <span class="number">10</span>,   <span class="number">9</span>,  <span class="number">5</span>,   <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        String str[] = &#123; <span class="string">"M"</span>,<span class="string">"CM"</span>, <span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//一般情况下罗马数字小的在大的右边</span></span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>&amp;&amp; i&lt;arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= arr[i])&#123;</span><br><span class="line">                num  = num-arr[i];</span><br><span class="line">                res.append(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/12.jpg" alt="整数转罗马数字"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;罗马数字包含以下七种字符： &lt;code&gt;I&lt;/code&gt;， &lt;code&gt;V&lt;/code&gt;， &lt;code&gt;X&lt;/code&gt;， &lt;code&gt;L&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，&lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;字符&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;数值&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;I&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;V&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;X&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;L&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;C&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;D&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;500&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;M&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例如， 罗马数字 2 写做 &lt;code&gt;II&lt;/code&gt; ，即为两个并列的 1。12 写做 &lt;code&gt;XII&lt;/code&gt; ，即为 &lt;code&gt;X&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。 27 写做 &lt;code&gt;XXVII&lt;/code&gt;, 即为 &lt;code&gt;XX&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt; + &lt;code&gt;II&lt;/code&gt; 。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="中等" scheme="http://blogs.qiulig.website/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://blogs.qiulig.website/2019/06/%E6%AD%BB%E9%94%81/"/>
    <id>http://blogs.qiulig.website/2019/06/死锁/</id>
    <published>2019-06-03T02:25:30.000Z</published>
    <updated>2019-06-03T03:14:02.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><pre><code>两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</code></pre><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>） <span class="string">'互斥条件'</span>： 一个资源每次只能被一个进程使用。</span><br><span class="line">（<span class="number">2</span>） <span class="string">'请求与保持条件'</span>： 一个进程因请求资源而阻塞时， 对已获得的资源保持不放。</span><br><span class="line">（<span class="number">3</span>） <span class="string">'不可剥夺条件'</span>:进程已获得的资源， 在末使用完之前， 不能强行剥夺。</span><br><span class="line">（<span class="number">4</span>） <span class="string">'环路等待条件'</span>:若干进程之间形成一种头尾相接的循环等待资源关系。</span><br><span class="line">    只要系统发生了死锁， 这些条件必然成立， 而只要上述条件之一不满足， 就不会发生死锁。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">'破坏互斥条件'</span></span><br><span class="line">     如果<span class="string">'允许系统资源都能共享使用'</span>， 则系统不会进入死锁状态。 但有些资源根本不能同时访问， 如打印机等临界资源只能互斥使用。 所以， </span><br><span class="line">    破坏互斥条件而预防死锁的方法不太可行， 而且在有的场合应该保护这种互斥性。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) <span class="string">'破坏不剥夺条件'</span></span><br><span class="line"></span><br><span class="line">    当一个已保持了某些不可剥夺资源的进程， <span class="string">'请求新的资源而得不到满足时，它必须释放已经保持的所有资源， 待以后需要时再重新申请。'</span> 这</span><br><span class="line">    意味着， 一个进程已占有的资源会被暂时释放， 或者说是被剥夺了，或从而破坏了不可剥夺条件。该策略实现起来比较复杂， 释放已获得</span><br><span class="line">    的资源可能造成前一阶段工作的失效， <span class="string">'反复地申请和释放资源会增加系统开销， 降低系统吞吐量'</span>。 这种方法常用于状态易于保存和恢复的资</span><br><span class="line">    源，如 CPU 的寄存器及内存资源， 一般不能用于打印机之类的资源。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) <span class="string">'破坏请求和保持条件'</span></span><br><span class="line"></span><br><span class="line">    釆用<span class="string">'预先静态分配方法'</span>， 即<span class="string">'进程在运行前一次申请完它所需要的全部资源'</span>， 在它的资源未满足前，不把它投入运行。 一旦投入运行后， 这</span><br><span class="line">    些资源就一直归它所有， 也不再提出其他资源请求， 这样就可以保证系统不会发生死锁。</span><br><span class="line">    这种方式实现简单， 但缺点也显而易见， 系统资源被严重浪费， 其中有些资源可能仅在运行初期或运行快结束时才使用， 甚至根本不使用。 </span><br><span class="line">    而且还会导致“饥饿” 现象， 当由于个别资源长期被其他进程占用时， 将致使等待该资源的进程迟迟不能开始运行。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) <span class="string">'破坏环路等待条件'</span></span><br><span class="line"></span><br><span class="line">    为了破坏循环等待条件， 可釆用<span class="string">'顺序资源分配法'</span>。 首先给系统中的资源编号，规定每个进程， 必须按编号递增的顺序请求资源， 同类资源</span><br><span class="line">    一次申请完。 也就是说， 只要进程提出申请分配资源 Ri， 则该进程在以后的资源申请中， 只能申请编号大于 Ri 的资源。</span><br><span class="line"></span><br><span class="line">    这种方法存在的问题是， 编号必须相对稳定， 这就<span class="string">'限制了新类型设备的增加'</span>；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的</span><br><span class="line">    顺序， 但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费； 此外， 这种按规定次序申请资源的方法， 也必</span><br><span class="line">    然会给用户的编程带来麻烦。</span><br></pre></td></tr></table></figure><h3 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h3><blockquote><p>我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。</p><p>为保证资金的安全，银行家规定：</p><pre><code>(1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客；(2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量；(3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款；(4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，</span><br><span class="line">&gt; (<span class="number">1</span>)如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。</span><br><span class="line">&gt; (<span class="number">2</span>)当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。</span><br><span class="line">&gt; (<span class="number">3</span>)若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="检测死锁-死锁定理"><a href="#检测死锁-死锁定理" class="headerlink" title="检测死锁(死锁定理)"></a>检测死锁(死锁定理)</h3><p>通常分析描述死锁，可以用资源分配图。关于资源分配图，要仅仅抓住两点：</p><ul><li>请求边</li><li>分配边</li></ul><p>关键在找：空闲资源。如果空闲资源可以满足某个进程，这个进程就可以解脱了，把它摘除资源分配图，再看剩下的资源分配图，策略相同。</p><p><strong>在资源分配图中，把分配的资源与进程连好，再看进程请求边。按照分配边分配好以后，剩余的资源就是空闲资源。此时再来分析进程Pi的请求边，如果空闲资源都能满足Pi的请求，也就意味着Pi可以从这个纠缠的图中得到解脱。删除Pi的所有相关的资源：已分配的+请求的。再递归处理剩下的资源分配图</strong>。</p><p>参看：<a href="https://blog.csdn.net/jgm20475/article/details/81297819" target="_blank" rel="noopener">https://blog.csdn.net/jgm20475/article/details/81297819</a></p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>1、资源剥夺法</p><pre><code>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</code></pre><p>2、撤销进程法</p><pre><code>强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</code></pre><p>3、进程回退法</p><pre><code>让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;死锁的概念&quot;&gt;&lt;a href=&quot;#死锁的概念&quot; class=&quot;headerlink&quot; title=&quot;死锁的概念&quot;&gt;&lt;/a&gt;死锁的概念&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;产生死锁的原因&quot;&gt;&lt;a href=&quot;#产生死锁的原因&quot; class=&quot;headerlink&quot; title=&quot;产生死锁的原因&quot;&gt;&lt;/a&gt;产生死锁的原因&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;） &lt;span class=&quot;string&quot;&gt;&#39;互斥条件&#39;&lt;/span&gt;： 一个资源每次只能被一个进程使用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;） &lt;span class=&quot;string&quot;&gt;&#39;请求与保持条件&#39;&lt;/span&gt;： 一个进程因请求资源而阻塞时， 对已获得的资源保持不放。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;） &lt;span class=&quot;string&quot;&gt;&#39;不可剥夺条件&#39;&lt;/span&gt;:进程已获得的资源， 在末使用完之前， 不能强行剥夺。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;） &lt;span class=&quot;string&quot;&gt;&#39;环路等待条件&#39;&lt;/span&gt;:若干进程之间形成一种头尾相接的循环等待资源关系。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    只要系统发生了死锁， 这些条件必然成立， 而只要上述条件之一不满足， 就不会发生死锁。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blogs.qiulig.website/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MYSQL" scheme="http://blogs.qiulig.website/tags/MYSQL/"/>
    
      <category term="多线程" scheme="http://blogs.qiulig.website/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="锁" scheme="http://blogs.qiulig.website/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>SQL-优化查询</title>
    <link href="http://blogs.qiulig.website/2019/06/SQL-%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/"/>
    <id>http://blogs.qiulig.website/2019/06/SQL-优化查询/</id>
    <published>2019-06-01T08:15:26.000Z</published>
    <updated>2019-06-01T08:49:41.872Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化查询的方法"><a href="#优化查询的方法" class="headerlink" title="优化查询的方法"></a>优化查询的方法</h1><h2 id="1-使用索引"><a href="#1-使用索引" class="headerlink" title="1.使用索引"></a>1.使用索引</h2><pre><code>尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。</code></pre><h2 id="2-优化SQL语句"><a href="#2-优化SQL语句" class="headerlink" title="2.优化SQL语句"></a>2.优化SQL语句</h2><h3 id="2-1-explain查看SQL语句执行效果"><a href="#2-1-explain查看SQL语句执行效果" class="headerlink" title="2.1 explain查看SQL语句执行效果"></a>2.1 explain查看SQL语句执行效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句，</span><br><span class="line"> 把关键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-任何地方都不要使用-select-from-t-，-用具体的字段列表代替“-”-，-不要返回用不到的任何字段。"><a href="#2-2-任何地方都不要使用-select-from-t-，-用具体的字段列表代替“-”-，-不要返回用不到的任何字段。" class="headerlink" title="2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*” ， 不要返回用不到的任何字段。"></a>2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*” ， 不要返回用不到的任何字段。</h3><h3 id="2-3-不在索引列做运算或者使用函数。"><a href="#2-3-不在索引列做运算或者使用函数。" class="headerlink" title="2.3 不在索引列做运算或者使用函数。"></a>2.3 不在索引列做运算或者使用函数。</h3><h3 id="2-4-查询尽可能使用-limit-减少返回的行数，-减少数据传输时间和带宽浪费。"><a href="#2-4-查询尽可能使用-limit-减少返回的行数，-减少数据传输时间和带宽浪费。" class="headerlink" title="2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。"></a>2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。</h3><h2 id="3-优化数据库对象"><a href="#3-优化数据库对象" class="headerlink" title="3.优化数据库对象"></a>3.优化数据库对象</h2><h3 id="3-1-优化表的数据类型"><a href="#3-1-优化表的数据类型" class="headerlink" title="3.1 优化表的数据类型"></a>3.1 优化表的数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="function">procedure <span class="title">analyse</span><span class="params">()</span>函数对表进行分析， 该函数可以对表中列的数据类型提出优化建议。 能小就用小。 </span></span><br><span class="line"><span class="function">表数据类型第一个原则是： 使用能正确的表示和存储数据的最短类型。 这样可以减少对磁盘空间、 内存、 cpu 缓存的使用。</span></span><br><span class="line"><span class="function">使用方法： 'select * from 表名 procedure <span class="title">analyse</span><span class="params">()</span></span>;<span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="3-2-对表进行拆分"><a href="#3-2-对表进行拆分" class="headerlink" title="3.2 对表进行拆分"></a>3.2 对表进行拆分</h3><pre><code>通过拆分表可以提高表的访问效率。  </code></pre><p><strong>1.垂直拆分</strong><br><code>把主键和一些列放在一个表中， 然后把主键和另外的列放在另一个表中。 如果一个表中某些列常用， 而另外一些不常用， 则可以采用垂直拆分。</code><br><strong>2.水平拆分</strong><br>        <code>根据一列或者多列数据的值把数据行放到二个独立的表中。</code></p><h3 id="3-3-使用中间表来提高查询速度"><a href="#3-3-使用中间表来提高查询速度" class="headerlink" title="3.3 使用中间表来提高查询速度"></a>3.3 使用中间表来提高查询速度</h3><pre><code>创建中间表， 表结构和源表结构完全相同， 转移要统计的数据到中间表， 然后在中间表上进行统计， 得出想要的结果。</code></pre><h2 id="4-硬件优化"><a href="#4-硬件优化" class="headerlink" title="4.硬件优化"></a>4.硬件优化</h2><h3 id="4-1-CPU-的优化"><a href="#4-1-CPU-的优化" class="headerlink" title="4.1 CPU 的优化"></a>4.1 CPU 的优化</h3><pre><code>选择多核和主频高的 CPU。  </code></pre><h3 id="4-2-内存的优化"><a href="#4-2-内存的优化" class="headerlink" title="4.2 内存的优化"></a>4.2 内存的优化</h3><pre><code>使用更大的内存。 将尽量多的内存分配给 MYSQL 做缓存。  </code></pre><h3 id="4-3-磁盘-I-O-的优化"><a href="#4-3-磁盘-I-O-的优化" class="headerlink" title="4.3 磁盘 I/O 的优化"></a>4.3 磁盘 I/O 的优化</h3><h4 id="4-3-1-使用磁盘阵列"><a href="#4-3-1-使用磁盘阵列" class="headerlink" title="4.3.1 使用磁盘阵列"></a>4.3.1 使用磁盘阵列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)RAID <span class="number">0</span> 没有数据冗余， 没有数据校验的磁盘陈列。 实现 RAID <span class="number">0</span>至少需要两块以上的硬盘， 它将两块以上的硬盘合并成一块， 数据连续地</span><br><span class="line">分割在每块盘上。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)RAID1 是将一个两块硬盘所构成 RAID 磁盘阵列， 其容量仅等于一块硬盘的容量， 因为另一块只是当作数据“镜像”。 </span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)RAID-<span class="number">0</span>+<span class="number">1</span> 磁盘阵列。 RAID <span class="number">0</span>+<span class="number">1</span>是 RAID <span class="number">0</span> 和 RAID <span class="number">1</span> 的组合形式。 它在提供与 RAID <span class="number">1</span> 一样的数据安全保障的同时,也提供了与 RAID <span class="number">0</span> </span><br><span class="line">近似的存储性能。</span><br></pre></td></tr></table></figure><h4 id="4-3-2-调整磁盘调度算法"><a href="#4-3-2-调整磁盘调度算法" class="headerlink" title="4.3.2 调整磁盘调度算法"></a>4.3.2 调整磁盘调度算法</h4><pre><code>选择合适的磁盘调度算法， 可以减少磁盘的寻道时间。</code></pre><h3 id="5-MYSQL自身的优化"><a href="#5-MYSQL自身的优化" class="headerlink" title="5.MYSQL自身的优化"></a>5.MYSQL自身的优化</h3><pre><code>对 MySQL 自身的优化主要是对其配置文件 my.cnf 中的各项参数进行优化调整。 如指定 MySQL 查询缓冲区的大小， 指定 MySQL 允许的最大连接进程数等。</code></pre><h2 id="6-应用优化"><a href="#6-应用优化" class="headerlink" title="6.应用优化"></a>6.应用优化</h2><h3 id="6-1-使用数据库连接池"><a href="#6-1-使用数据库连接池" class="headerlink" title="6.1 使用数据库连接池"></a>6.1 使用数据库连接池</h3><h3 id="6-2-使用查询缓存"><a href="#6-2-使用查询缓存" class="headerlink" title="6.2 使用查询缓存"></a>6.2 使用查询缓存</h3><pre><code>它的作用是存储 select 查询的文本及其相应结果。 如果随后收到一个相同的查询， 服务器会从查询缓存中直接得到查询结果。 查询缓存适用的对象是更新不频繁的表， 当表中数据更改后， 查询缓存中的相关条目就会被清空</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>(1) 选取最适合的字段</strong>：在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。还可以将字段设置为NOT NULL,在查询时就不用比较null值了</p><p><strong>(2) 使用连接（JOIN）来替代子查询</strong></p><p><strong>(3) 使用联合（UNION)来代替手动创建的临时表</strong>：它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。</p><p><strong>(4) 使用事务</strong>：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><p><strong>(5) 锁定表</strong>：事务会将数据库锁定，因此其他用户请求只能暂时等待直到事务结束，会造成响应延迟。我们可以通过锁定表的方法来获得更好的性能</p><p><strong>(6) 使用外键</strong>。锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p><p><strong>(7) 使用索引</strong>。索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><p><strong>(8) 优化的查询语句</strong>。</p><p><strong>(9) 分库分表</strong>：可以按照业务分库，分流数据库并发压力，使数据库表更加有条理性</p><p><strong>(10) 数据库引擎</strong>：一种是innodb、一种是myisam</p><p>myisam快，是因为他的数据存储结构、索引存储结构和innodb不一样的，mysiam的索引结构是在内存中存的。 当然，myisam也有弱点，那就是他是表级锁，而innodb是行级锁，所以，mysiam适用于一次插入，多次查询的表，或者是读写分离中的读库中的表，而对于修改插入删除操作比较频繁的表，就很不合适了</p><p><strong>(11) 读写分离</strong>：数据库并发大的情况下，最好的做法就是进行横向扩展，增加机器，以提升抗并发能力，而且还兼有数据备份功能</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;优化查询的方法&quot;&gt;&lt;a href=&quot;#优化查询的方法&quot; class=&quot;headerlink&quot; title=&quot;优化查询的方法&quot;&gt;&lt;/a&gt;优化查询的方法&lt;/h1&gt;&lt;h2 id=&quot;1-使用索引&quot;&gt;&lt;a href=&quot;#1-使用索引&quot; class=&quot;headerlink&quot; title=&quot;1.使用索引&quot;&gt;&lt;/a&gt;1.使用索引&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-优化SQL语句&quot;&gt;&lt;a href=&quot;#2-优化SQL语句&quot; class=&quot;headerlink&quot; title=&quot;2.优化SQL语句&quot;&gt;&lt;/a&gt;2.优化SQL语句&lt;/h2&gt;&lt;h3 id=&quot;2-1-explain查看SQL语句执行效果&quot;&gt;&lt;a href=&quot;#2-1-explain查看SQL语句执行效果&quot; class=&quot;headerlink&quot; title=&quot;2.1 explain查看SQL语句执行效果&quot;&gt;&lt;/a&gt;2.1 explain查看SQL语句执行效果&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 把关键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://blogs.qiulig.website/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MYSQL" scheme="http://blogs.qiulig.website/tags/MYSQL/"/>
    
  </entry>
  
</feed>
