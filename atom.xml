<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Long&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/0972e01a5f38f38e77d0154479c21150</icon>
  <subtitle>菜鸟要更加努力才能追上别人的步伐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blogs.qiulig.website/"/>
  <updated>2019-05-30T12:42:33.669Z</updated>
  <id>http://blogs.qiulig.website/</id>
  
  <author>
    <name>qiulig</name>
    <email>qiuling_long@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM_内存泄漏和内存溢出</title>
    <link href="http://blogs.qiulig.website/2019/05/JVMVM-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>http://blogs.qiulig.website/2019/05/JVMVM-内存泄漏和内存溢出/</id>
    <published>2019-05-30T11:54:41.000Z</published>
    <updated>2019-05-30T12:42:33.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><blockquote><p>一个不再被程序使用的对象或者变量还在内存中占有存储空间。</p><p>（1）堆中申请的空间没有被释放</p><p>（2）对象不在使用但还在内存中保留</p><a id="more"></a></blockquote><h6 id="内存泄漏的原因："><a href="#内存泄漏的原因：" class="headerlink" title="内存泄漏的原因："></a>内存泄漏的原因：</h6><blockquote><p>（1）静态集合类，如hashmap和vector，如果容器为静态，她们的生命周期与程序一致。</p><p>（2）各种连接，如数据库连接，IO连接</p><p>（3）监听器：通常一个应用中会用到多个监听器，但是在释放对象的同时往往没有相应的删除监听器</p><p>（4）变量不合理的作用域。一方面一个变量的定义作用范围大于其使用范围，很可能造成内存泄漏。另一方面如果没有及时把对象设置为null,很可能导致内存泄漏。</p><p>（5）单例模式：一直存在着一个对对象的引用，并且以一个静态变量的方式存储，因此它在JVM整个生命周期都存在。</p></blockquote><h6 id="内存泄漏解决方案："><a href="#内存泄漏解决方案：" class="headerlink" title="内存泄漏解决方案："></a>内存泄漏解决方案：</h6><blockquote><p>（1）避免在循环中创建对象</p><p>（2） 尽早释放无用的对象引用</p><p>（3）尽量少用静态变量</p><p>（4）使用字符串处理，避免使用String,应大量使用StringBuffer,因为每个String对象都得独立占用内存一块区域</p></blockquote><h2 id="内存溢出OOM"><a href="#内存溢出OOM" class="headerlink" title="内存溢出OOM"></a>内存溢出OOM</h2><h6 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h6><blockquote><p>程序运行过程中无法申请到足够的内存而导致的一种错误，除了程序计数器外，其他几个运行区都有OOM的可能。</p></blockquote><h6 id="内存溢出情况："><a href="#内存溢出情况：" class="headerlink" title="内存溢出情况："></a>内存溢出情况：</h6><blockquote><p>（1）虚拟机栈和本地方法栈溢出</p><pre><code>如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackOverflowError 异常。  如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError 异常。  </code></pre><p> （2）<strong>堆溢出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 一般的异常信息： java.lang.OutOfMemoryError:Java heap spaces</span><br><span class="line">&gt;  出现这种异常，一般手段是先通过内存映像分析工具(如 Eclipse Memory Analyzer)对 dump 出来的堆转存快照进行分析,</span><br><span class="line">&gt;  重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏还是内存溢出。</span><br><span class="line">&gt;     1.如果是内存泄漏， 可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。</span><br><span class="line">&gt;     2.如果不存在泄漏， 那就应该检查虚拟机的参数(-Xmx 与-Xms)的设置是否适当。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（3）<strong>方法区溢出</strong></p><pre><code>异常信息： java.lang.OutOfMemoryError:PermGen space。</code></pre><p>（4）<strong>运行时常量池溢出</strong></p><pre><code>异常信息： java.lang.OutOfMemoryError:PermGen space。  </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果要向运行时常量池中添加内容，最简单的做法就是使用 String.intern()这个Native 方法。</span><br><span class="line">&gt;     该方法的作用是:如果池中已经包含一个等于此 String 的字符串， 则返回代表池中这个字符串的 String 对象；</span><br><span class="line">&gt;     否则，将此 String 对象包含的字符串添加到常量池中， 并且返回此 String 对象的引用 。</span><br><span class="line">&gt; 由于常量池分配在方法区内，我们可以通过-XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小， 从而间接限制其中常量池的容量。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h6 id="内存溢出原因："><a href="#内存溢出原因：" class="headerlink" title="内存溢出原因："></a>内存溢出原因：</h6><blockquote><p>1.内存中加载的数据量过于庞大， 如一次从数据库取出过多数据；</p><p>2.集合类中有对对象的引用， 使用完后未清空， 使得 JVM 不能回收；<br>3.代码中存在死循环或循环产生过多重复的对象实体；<br>4.启动参数内存值设定的过小。</p></blockquote><h6 id="内存溢出解决方法："><a href="#内存溢出解决方法：" class="headerlink" title="内存溢出解决方法："></a>内存溢出解决方法：</h6><blockquote><p>(1) 修改 JVM 启动参数， 直接增加内存。 (-Xms， -Xmx 参数一定不要忘记加。一般要将-Xms 和-Xmx 选项设置为相同， 以避免在每次 GC 后调整堆的大小； 建  议堆的最大值设置为可用内存的最大值的 80%)。  </p><p>(2) 检查错误日志， 查看“OutOfMemory” 错误前是否有其它异常或错误。 </p><p>(3)对代码进行走查和分析， 找出可能发生内存溢出的位置</p><p>(4)  使用内存查看工具动态查看内存使用情况（Jconsole）。</p></blockquote><h2 id="减少gc次数的方法："><a href="#减少gc次数的方法：" class="headerlink" title="减少gc次数的方法："></a>减少gc次数的方法：</h2><blockquote><p><strong>（1）对象不用时最好显式置为 Null</strong></p><pre><code>一般而言,为 Null 的对象都会被作为垃圾处理,所以将不用的对象显式地设  为 Null,有利于 GC 收集器判定垃圾,从而提高了 GC 的效率。  </code></pre><p><strong>（2）尽量少用 System.gc()</strong>  </p><pre><code>此函数建议 JVM进行主 GC,虽然只是建议而非一定,但很多情况下它会触发  主 GC,从而增加主 GC 的频率,也即增加了间歇性停顿的次数。  </code></pre><p><strong>（3）尽量少用静态变量</strong>  </p><pre><code>静态变量属于全局变量,不会被 GC 回收,它们会一直占用内存。  </code></pre><p><strong>（4） 尽量使用 StringBuffer,而不用 String 来累加字符串。</strong><br>    由于 String 是固定长的字符串对象,累加 String 对象时,并非在一个 String  对象中扩增,而是重新创建新的 String 对象,如 Str5=Str1+Str2+Str3+Str4,这条  语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新  的 String 对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多  的垃圾。 避免这种情况可以改用 StringBuffer 来累加字符串,因 StringBuffer 是可变长的,它在原有基础上进行扩增,不会产生中间对象。<br><strong>（5）分散对象创建或删除的时间</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM 在面临这种情况时,只能进行主 GC,以回收内存或整合</span><br><span class="line">&gt; 内存碎片从而增加主 GC 的频率。集中删除对象,道理也是一样的。 它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大</span><br><span class="line">&gt; 增加了下一次创建新对象时强制主 GC 的机会。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（6） <strong>尽量少用 finalize 函数。 因为它会加大 GC 的工作量， 因此尽量少</strong>用finalize 方式回收资源。  </p><p><strong>（7） 如果需要使用经常用到的图片， 可以使用软引用类型， 它可以尽可能</strong></p><p><strong>（8）能用基本类型如 int,long,就不用 Integer,Long 对象</strong></p><pre><code>基本类型变量占用的内存资源比相应包装类对象占用的少得多,如果没有必要,最好使用基本变量。  </code></pre><p><strong>（9） 增大-Xmx 的值。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h2&gt;&lt;h6 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;概念：&lt;/h6&gt;&lt;blockquote&gt;
&lt;p&gt;一个不再被程序使用的对象或者变量还在内存中占有存储空间。&lt;/p&gt;
&lt;p&gt;（1）堆中申请的空间没有被释放&lt;/p&gt;
&lt;p&gt;（2）对象不在使用但还在内存中保留&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA虚拟机" scheme="http://blogs.qiulig.website/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://blogs.qiulig.website/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java_深拷贝和浅拷贝</title>
    <link href="http://blogs.qiulig.website/2019/05/Java-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://blogs.qiulig.website/2019/05/Java-深拷贝和浅拷贝/</id>
    <published>2019-05-30T09:08:44.000Z</published>
    <updated>2019-05-30T12:44:26.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>对基本数据类型进行了拷贝</p><p>对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。</p><h6 id="即"><a href="#即" class="headerlink" title="即"></a>即</h6><pre><code>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝</code></pre><a id="more"></a><h6 id="底层实现："><a href="#底层实现：" class="headerlink" title="底层实现："></a>底层实现：</h6><p>（1）对类实现Cloneable接口（implements Cloneable），并且重写clone</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;  String name;</span><br><span class="line">&gt;  String <span class="keyword">int</span> age;</span><br><span class="line">&gt;  Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line">&gt;  <span class="meta">@Override</span></span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;  <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（2）用clone()方法创建新的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;     A a = <span class="keyword">new</span> A();</span><br><span class="line">&gt;     A aclone = (A)a.clone();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>对基本数据类型进行了拷贝</p><p>对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量</p><h6 id="即-1"><a href="#即-1" class="headerlink" title="即"></a>即</h6><pre><code>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容</code></pre><h6 id="底层实现：-1"><a href="#底层实现：-1" class="headerlink" title="底层实现："></a>底层实现：</h6><ol><li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li><li><p>继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，<strong>再进行一次 clone()</strong>。对A而言就是深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;     String name;</span><br><span class="line">&gt;     String <span class="keyword">int</span> age;</span><br><span class="line">&gt;     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;     <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;        <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>一个对象内部只有基本数据类型，那用 clone() 方法获取到的就是这个对象的深拷贝，而如果其内部还有引用数据类型，那用 clone() 方法就是一次浅拷贝的操作。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对基本数据类型进行了拷贝&lt;/p&gt;
&lt;p&gt;对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。&lt;/p&gt;
&lt;h6 id=&quot;即&quot;&gt;&lt;a href=&quot;#即&quot; class=&quot;headerlink&quot; title=&quot;即&quot;&gt;&lt;/a&gt;即&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA基础" scheme="http://blogs.qiulig.website/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JAVA基础" scheme="http://blogs.qiulig.website/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【42】接雨水</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-42-接雨水/</id>
    <published>2019-05-30T07:31:57.000Z</published>
    <updated>2019-05-30T08:07:56.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/42.png" alt="图"></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>思路1：转化成每个位置留下水量的总和</p><pre><code>i位置上留下的水为[0 , (i-1)]的最大值max1,(i+1,length)位置上的max2的两者较小值-该位置的高度：min(max2-max1) - arr[i]。</code></pre><p>思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。</p><p>思路3：跟思路2一致，减掉了一个指针</p><p>思路4：左边最大值小于右边最大值，左指针右滑，左指针位置上能装的水就是左边最大值减去左指针指的值，若左指针指向的值大于左边大值，就不减，说明不能储水，更新左边最大值，当右边最大值小于左边最大值时，右指针左滑，做法跟前类似，直到左指针小于等于右指针跳出循环。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>思路1代码：转化成每个位置留下水量的总和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getWater1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; i; l++) &#123;</span><br><span class="line">                leftMax = Math.max(arr[l], leftMax);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = i + <span class="number">1</span>; r &lt; arr.length; r++) &#123;</span><br><span class="line">            rightMax = Math.max(arr[r], rightMax);</span><br><span class="line">            &#125;</span><br><span class="line">            value += Math.max(<span class="number">0</span>, Math.min(leftMax, rightMax) - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>思路2代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMaxs[<span class="number">0</span>] = arr[<span class="number">0</span>];<span class="comment">//左指针初始化为第一个数</span></span><br><span class="line">        <span class="comment">//求左边的max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            leftMaxs[i] = Math.max(leftMaxs[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] rightMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMaxs[n - <span class="number">1</span>] = arr[n + <span class="number">1</span>];<span class="comment">//右指针初始化为数组最后一个数</span></span><br><span class="line"><span class="comment">//求右边的max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightMaxs[i] = Math.max(rightMaxs[i + <span class="number">1</span>], arr[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            value += Math.max(<span class="number">0</span>, Math.min(leftMaxs[i - <span class="number">1</span>], rightMaxs[i - <span class="number">1</span>]) - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>思路3代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路3：减少一个指针</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> n = arr.length - <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span>[] rightMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">     rightMaxs[n - <span class="number">1</span>] = arr[n + <span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         rightMaxs[i] = Math.max(rightMaxs[i + <span class="number">1</span>], arr[i + <span class="number">2</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">         value += Math.max(<span class="number">0</span>, Math.min(leftMax, rightMaxs[i - <span class="number">1</span>]) - arr[i]);</span><br><span class="line">         leftMax = Math.max(leftMax, arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>思路4代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap4</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rightMax = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;<span class="comment">//从第二个查看是否能蓄水</span></span><br><span class="line">        <span class="keyword">int</span> r = arr.length - <span class="number">2</span>;<span class="comment">////从倒数第二个查看是否能蓄水</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt;= rightMax) &#123;</span><br><span class="line">                value += Math.max(<span class="number">0</span>, leftMax - arr[l]);</span><br><span class="line">                leftMax = Math.max(leftMax, arr[l++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value += Math.max(<span class="number">0</span>, rightMax - arr[r]);</span><br><span class="line">                rightMax = Math.max(rightMax, arr[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p>思路1提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_11.png" alt="接雨水"></p><p>思路2提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_12.png" alt="接雨水"></p><p>思路3提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_13.png" alt="接雨水"></p><p>思路4提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_14.png" alt="接雨水"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="滑动窗口法" scheme="http://blogs.qiulig.website/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【11】盛最多水的容器</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-11-盛最多水的容器/</id>
    <published>2019-05-30T07:20:14.000Z</published>
    <updated>2019-05-30T08:07:38.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定  <em>n</em>  个非负整数  <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画  <em>n</em>  条垂直线，垂直线  <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><a id="more"></a><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://github.com/qiulig/IMG/raw/master/11.png" alt="图"></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.  解题思路"></a>2.  解题思路</h3><p>这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。</p><p>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量  res  来持续存储到目前为止所获得的最大面积。 </p><p>在每一步中，我们会找出指针所指向的两条线段形成的区域，更新  res，并将指向较短线段的指针向较长线段那端移动一步。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            res = Math.max(res,(right-left)*Math.min(height[left],height[right]));</span><br><span class="line">            <span class="comment">//舍弃高度较小的</span></span><br><span class="line">            <span class="keyword">if</span> ((height[left] &gt; height[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/11_1.png" alt="盛最多水的容器"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定  &lt;em&gt;n&lt;/em&gt;  个非负整数  &lt;em&gt;a&lt;/em&gt;1，&lt;em&gt;a&lt;/em&gt;2，…，&lt;em&gt;a&lt;/em&gt;n，每个数代表坐标中的一个点 (&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;ai&lt;/em&gt;) 。在坐标内画  &lt;em&gt;n&lt;/em&gt;  条垂直线，垂直线  &lt;em&gt;i&lt;/em&gt; 的两个端点分别为 (&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;ai&lt;/em&gt;) 和 (&lt;em&gt;i&lt;/em&gt;, 0)。找出其中的两条线，使得它们与 &lt;em&gt;x&lt;/em&gt; 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="滑动窗口法" scheme="http://blogs.qiulig.website/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【10】正则表达式匹配</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-10-正则表达式匹配/</id>
    <published>2019-05-30T03:13:17.000Z</published>
    <updated>2019-05-30T08:24:14.633Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>)。实现支持  <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。<a id="more"></a></p><p>‘.’ 匹配任意单个字符。<br>‘*’ 匹配零个或多个前面的元素。</p><p>匹配应该覆盖<strong>整个</strong>字符串 (<code>s</code>) ，而不是部分字符串。</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li></ul><p><strong>示例 1:</strong></p><p><strong>输入:</strong><br>s = “aa”<br>p = “a”<br><strong>输出:</strong> false<br><strong>解释:</strong> “a” 无法匹配 “aa” 整个字符串。</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong><br>s = “aa”<br>p = “a<em>“<br><strong>输出:</strong> true<br><strong>解释:</strong> ‘</em>‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong><br>s = “ab”<br>p = “.<em>“<br><strong>输出:</strong> true<br><strong>解释:</strong> “.</em>“ 表示可匹配零个或多个(‘*’)任意字符(‘.’)。</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong><br>s = “aab”<br>p = “c<em>a</em>b”<br><strong>输出:</strong> true<br><strong>解释:</strong> ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong><br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br><strong>输出:</strong> false</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：</p><blockquote><p>跟剑指offer的52题一致</p><p>这道题的核心其实在于分析’<em>‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’</em>‘的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。</p><p><strong>情况1：Patttern第二个字符是’*’时</strong>：</p><p>1.第一个字符不匹配（’.’与任意字符视作匹配），那么’*’只能代表匹配0次</p><p>‘ba’与’a*ba’，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式</p><p>2.第一个字符匹配，那么’*’可能代表匹配0次，1次，多次，</p><p>(1)’aaa’与’a*aaa’: 匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；</p><p>(2)’aba’与’a*ba’:匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；</p><p>(3)’aaaba’与’a*ba’:匹配多次时，字符串往后移动一个字符，模式不变；</p><p><strong>情况2：Patttern第二个字符不是’*’时：</strong></p><p>(1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。</p><p>(2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。</p></blockquote><p>方法2：动态规划</p><blockquote><p>定义一个dp[][]数组，其中d[i][j]表示s[0,i]和p[0][j]是否匹配</p><p>dp初始化:dp[0][0] = true，代表str为空串，pattern为空串的情况</p><pre><code>求dp[0][j]即求str为空串，pattern是否匹配当遇到后一个为 * 时，且dp[0][i-1]为true则匹配(匹配前面字符0次)，标记dp[0][i+1] = true</code></pre><p>情况1：当前字母匹配，str和pattern都往后移动一位</p><pre><code>dp[i+1][j+1] = dp[i][j]</code></pre><p>情况2：后一个pattern是   *  ,前一个pattern跟str不匹配,str不变，pattern后移动两位</p><pre><code>dp[i+1][j+1] = dp[i+1][j-1]</code></pre><p>情况3：后一个pattern是 * ,前一个pattern跟str匹配</p><pre><code>(1)匹配0次，str不动，pattern后移2位        dp[i+1][j+1] = dp[i+1][j-1](2)匹配一次，str移动1位，pattern移动2位        dp[i+1][j+1] =dp[i][j-1](3)匹配多次，str移动1次，pattern不动        dp[i+1][j+1] = dp[i][j+1]</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> matchCore(str.toCharArray(), <span class="number">0</span>, pattern.toCharArray(), <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">       <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//pattern先到尾，匹配失败</span></span><br><span class="line">       <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;</span><br><span class="line">       <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位</span></span><br><span class="line">       <span class="comment">//   //如果当前pattern的下一个是*并且没有超出pattern的长度时</span></span><br><span class="line">       <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">           <span class="comment">// //如果当前字符str[index]和pattern[index]相等，或者当前pattern为‘.’</span></span><br><span class="line">           <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">               <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//模式后移2，视为x*匹配0个字符(当前pattern[index+1]='*'且str[index]!=pattern[index]）</span></span><br><span class="line">                       || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//视为模式匹配1个字符 (当前pattern[i+1]='*'且str[index]=pattern[index])</span></span><br><span class="line">                       || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配1个，再匹配str中的下一个（当前pattern[index]='.'）</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//当前字符str[index]和pattern[index]不相等&amp;&amp;当前pattern不为‘.’</span></span><br><span class="line">               <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">       <span class="comment">//pattern[index]='.'的情况，strindex和pattern都加1向下匹配</span></span><br><span class="line">       <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">           <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">           <span class="comment">//i= 0，j= 0表示str和pattern为空串，匹配成功标true</span></span><br><span class="line">           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//str为空串，pattern不为空串的情况</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">               <span class="comment">//前一个为true后一个为*，*匹配0个，则标记下一个为true</span></span><br><span class="line">               <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i - <span class="number">1</span>]) &#123;</span><br><span class="line">                   dp[<span class="number">0</span>][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">                   <span class="comment">//当前字母匹配，字符str和pattern都后移动一位</span></span><br><span class="line">                   <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span> || p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                       dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//后一个字符是*</span></span><br><span class="line">                   <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                       <span class="comment">//str与pattern不匹配</span></span><br><span class="line">                       <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j - <span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                           <span class="comment">//str不变，pattern后移动两位</span></span><br><span class="line">                           dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">//匹配0次，str不动，pattern后移2位，匹配一次，str移动一位，pattern移动2位，匹配多次，str移动1次，pattern不动</span></span><br><span class="line">                          dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j-<span class="number">1</span>] || dp[i][j - <span class="number">1</span>] || dp[i][j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/10_1.jpg" alt="单纯的匹配"></p><p><img src="https://github.com/qiulig/IMG/raw/master/10_2.jpg" alt="正则表达式匹配"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 (&lt;code&gt;s&lt;/code&gt;) 和一个字符模式 (&lt;code&gt;p&lt;/code&gt;)。实现支持  &lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;*&amp;#39;&lt;/code&gt; 的正则表达式匹配。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【234】回文链表</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-234-回文链表/</id>
    <published>2019-05-29T12:00:10.000Z</published>
    <updated>2019-05-29T12:32:07.324Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请判断一个链表是否为回文链表。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 1-&gt;2<br><strong>输出:</strong> false</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;2-&gt;1<br><strong>输出:</strong> true</p><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：将链表的数值依次入栈，然后弹栈跟listnode从头到尾比较</p><p>方法2：快慢指针弦找到中间点，再反转后面链表，再遍历比较</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            ListNode res = head;</span><br><span class="line">            <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (res!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.pop() == res.val)&#123;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode lat = head.next;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="comment">//快慢指针,pre一次一步，lat一次两步</span></span><br><span class="line">        <span class="keyword">while</span>(lat != <span class="keyword">null</span> &amp;&amp; lat.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            lat = lat.next.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转置后半链表</span></span><br><span class="line">        ListNode cur = pre.next;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode q = cur.next;</span><br><span class="line">            cur.next = p;</span><br><span class="line">            p = cur;</span><br><span class="line">            cur = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历比较</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val != head.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/234-1.jpg" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/234-2.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【9】回文数</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-9-回文数/</id>
    <published>2019-05-29T11:27:03.000Z</published>
    <updated>2019-05-29T11:46:21.854Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 121<br><strong>输出:</strong> true</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> -121<br><strong>输出:</strong> false<br><strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 10<br><strong>输出:</strong> false<br><strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：转换成字符串，将字符串反转进行比较是否相等</p><p>方法2：用一个stack存入数字从低位到高位的数；依次弹出（高位到低位弹出）跟每次数值取余的数进行对比</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        String res = x+<span class="string">""</span>;</span><br><span class="line">        String ans = <span class="keyword">new</span> StringBuilder(x+<span class="string">""</span>).reverse().toString();</span><br><span class="line">        <span class="keyword">if</span>(res.equals(ans))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            stack.push(x%<span class="number">10</span>);</span><br><span class="line">            x = x /<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (res&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.pop()==res%<span class="number">10</span>)&#123;</span><br><span class="line">                res = res/<span class="number">10</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/9-1.png" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/9-2.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【8】字符串转换成整数</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-8-字符串转换成整数/</id>
    <published>2019-05-29T03:30:30.000Z</published>
    <updated>2019-05-29T11:15:39.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。<a id="more"></a></p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “42”<br><strong>输出:</strong> 42</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “   -42”<br><strong>输出:</strong> -42<br><strong>解释:</strong> 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “4193 with words”<br><strong>输出:</strong> 4193<br><strong>解释:</strong> 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> “words and 987”<br><strong>输出:</strong> 0<br><strong>解释:</strong> 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> “-91283472332”<br><strong>输出:</strong> -2147483648<br><strong>解释:</strong> 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1)  用一个标志位flag记录字符串的正负号</p><p>(2)  依次进行叠加，如果遇到溢出，返回它的最大值或者最小值</p><p>最大溢出判断：</p><pre><code>res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//去掉前后空格</span></span><br><span class="line"></span><br><span class="line">        String str = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>||str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断只有符号的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">1</span>&amp;&amp;(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>||str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//为正数，flag设为1，负数设为 -1,并截取后面的字符串进行字符串转换成整数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>&amp;&amp; (str.charAt(<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">1</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">1</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>&amp;&amp;(str.charAt(<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">1</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">1</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((str.charAt(<span class="number">0</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">0</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">0</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字符串转换成整数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> flag,String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> pop = str.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//只需要判断上溢出情况，因为我们将符号单独拎出来了</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag==<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//上溢，输出最大值</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//下溢出，输出最小值</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = res*<span class="number">10</span> +pop;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//不是有效的字符[0-9]，直接退出</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/8.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;请你来实现一个 &lt;code&gt;atoi&lt;/code&gt; 函数，使其能将字符串转换成整数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【7】整数反转</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-7-整数反转/</id>
    <published>2019-05-28T13:08:00.000Z</published>
    <updated>2019-05-28T14:17:23.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 123<br><strong>输出:</strong> 321</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> -123<br><strong>输出:</strong> -321</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 120<br><strong>输出:</strong> 21</p><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>主要是注意溢出问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; （<span class="number">1</span>）当x&gt;<span class="number">0</span>时，溢出考虑上界</span><br><span class="line">&gt;     <span class="number">1</span>)如果 result 的值大于 Integer.MAX_VALUE / <span class="number">10</span> ，那么一定会溢出</span><br><span class="line">&gt;     <span class="number">2</span>)如果 result 的值等于 Integer.MAX_VALUE / <span class="number">10</span>，那么 pop 的值如果大于 Integer.MAX_VALUE % <span class="number">10</span> 也会溢出</span><br><span class="line">&gt; (<span class="number">2</span>) 当x&lt;<span class="number">0</span> 时，溢出考虑下界</span><br><span class="line">&gt;     <span class="number">1</span>)result 的值小于 Integer.MIN_VALUE / <span class="number">10</span> ，那么一定会溢出</span><br><span class="line">&gt;     <span class="number">2</span>)result 的值等于 Integer.MIN_VALUE / <span class="number">10</span>，那么 pop 的值如果小于于 Integer.MIN_VALUE % <span class="number">10</span> 也会溢出</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x%<span class="number">10</span>;</span><br><span class="line">        x = x/<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//考虑上界溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">//考虑下界溢出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; Integer.MIN_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res*<span class="number">10</span> +pop;<span class="comment">//得到最后一位</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/7.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>得到的最短的回文长度</title>
    <link href="http://blogs.qiulig.website/2019/05/%E5%9B%9E%E6%96%87/"/>
    <id>http://blogs.qiulig.website/2019/05/回文/</id>
    <published>2019-05-28T11:41:20.000Z</published>
    <updated>2019-05-28T12:34:58.008Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>京京和东东是好朋友。东东很喜欢回文。回文是指从前往后读和从后往前读是一样的词语。京京准备给东东一个惊喜，先取定一个字符串s，然后在后面附上0个或者更多个字母形成回文，京京希望这个回文越短越好。请帮助京京计算他能够得到的最短的回文长度。</p><a id="more"></a><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>输入包括一个字符串s，字符串s长度length(1 ≤ length ≤ 50)。</p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>输出一个整数，表示京京能够得到的最短的回文长度。</p><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>abab</p><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><p>5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>转化成求字符串中的最长回文子串的大小，结果即不是回文那部分逆序即可。</p><p>从左往右，</p><p>三个概念：回文半径数组pArr[]，回文右边界pr，取得回文右边界的轴中心i</p><p>1）没在回文右边界里边，暴力</p><p>2）i’在回文范围里，回文右边界不扩</p><p>3）i’在回文范围外，回文右边界不扩</p><p>4）i’压线，回文右边界扩</p><p>直到回文右边界第一次到达最后一个字符</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//manacher预处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">char</span>[] manacherString(String str) &#123;</span><br><span class="line"><span class="keyword">char</span>[] charArr = str.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != res.length; i++) &#123;</span><br><span class="line">res[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">'#'</span> : charArr[index++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">shortestEnd</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] charArr = manacherString(str);</span><br><span class="line"><span class="keyword">int</span>[] pArr = <span class="keyword">new</span> <span class="keyword">int</span>[charArr.length];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pR = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxContainsEnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != charArr.length; i++) &#123;</span><br><span class="line">pArr[i] = pR &gt; i ? Math.min(pArr[<span class="number">2</span> * index - i], pR - i) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])</span><br><span class="line">pArr[i]++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + pArr[i] &gt; pR) &#123;</span><br><span class="line">pR = i + pArr[i];</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右边界到达最后一个字符就结束，那个中心就是包含最后一个字符的最长的回文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pR == charArr.length) &#123;</span><br><span class="line">    <span class="comment">//得到那个中心</span></span><br><span class="line"></span><br><span class="line">maxContainsEnd = pArr[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原来的长度 + 扩充的长度（字符最大的半径[str.length+1-回文最大的半径maxContainEnd]）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str.length() + str.length() - maxContainsEnd + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sr.nextLine();</span><br><span class="line">        System.out.println(shortestEnd(s));      </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;京京和东东是好朋友。东东很喜欢回文。回文是指从前往后读和从后往前读是一样的词语。京京准备给东东一个惊喜，先取定一个字符串s，然后在后面附上0个或者更多个字母形成回文，京京希望这个回文越短越好。请帮助京京计算他能够得到的最短的回文长度。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="京东笔试题" scheme="http://blogs.qiulig.website/categories/%E4%BA%AC%E4%B8%9C%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
      <category term="manacher算法" scheme="http://blogs.qiulig.website/tags/manacher%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【5】最长回文子串</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-5-最长回文子串/</id>
    <published>2019-05-28T05:46:56.000Z</published>
    <updated>2019-05-28T12:38:07.493Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串  <code>s</code>，找到  <code>s</code>  中最长的回文子串。你可以假设 <code>s</code>  的最大长度为 1000。<a id="more"></a></p><p><strong>示例 1：</strong></p><p><strong>输入:</strong> “babad”<br><strong>输出:</strong> “bab”<br><strong>注意:</strong> “aba” 也是一个有效答案。</p><p><strong>示例 2：</strong></p><p><strong>输入:</strong> “cbbd”<br><strong>输出:</strong> “bb”</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><h5 id="方法1：暴力破解方法"><a href="#方法1：暴力破解方法" class="headerlink" title="方法1：暴力破解方法"></a>方法1：暴力破解方法</h5><h5 id="方法2：动态规划"><a href="#方法2：动态规划" class="headerlink" title="方法2：动态规划"></a>方法2：动态规划</h5><blockquote><p>新建一个dp[i][j]代表的意思是索引从i到j的子字符串是否是回文，假设s = cbbd,则可以dp对应坐标索引下的子字符串：</p><table><thead><tr><th></th><th>i = 0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>j = 0</td><td>c</td><td>cb</td><td>cbb</td><td>cbbd</td></tr><tr><td>1</td><td></td><td>b</td><td>bb</td><td>bbd</td></tr><tr><td>2</td><td></td><td></td><td>b</td><td>bd</td></tr><tr><td>3</td><td></td><td></td><td></td><td>d</td></tr></tbody></table><p>如果dp[i][j]所代表的字符串为回文，则将dp设为1.由上表可以总结出：</p><p>（1）当i = j 时，dp[j][i]  = 1</p><p>（2）i-j=1时,比如dp[1][2]为bb，表示两个相邻的字符，此时我们只要判断str[1]==str[2]就能得出dp[1][2]的结果</p><p>（3）i-j&gt;1时，我们来看dp[0][2]，首先还是要判断开头和结尾是否相等，也就是判断 str[0]==str[2]，假如此时str[0]=str[2]，我们还要再看剩下的子串是否回文， 我们可以直接从dp[j+1][i-1]来判断剩下的子串，把结果直接拿来用,判断是否是1（1表示回文）</p><p>即有公式</p><pre><code>dp[i][j] = (dp[i+1][j-1] &amp;&amp;s[i]=S[j]​) == true?1:0</code></pre><p>dp数组初始化如下：</p><pre><code>dp[i][i] = 1</code></pre><p>   dp[i][i+1] = ( S[i] == S[i+1] ?1:0;</p></blockquote><h5 id="方法3：中心扩展方法"><a href="#方法3：中心扩展方法" class="headerlink" title="方法3：中心扩展方法"></a>方法3：中心扩展方法</h5><blockquote><p>回文中心的两侧互为镜像。因此，回文可以从他的中心展开，并且只有2n-1个这样的中心(一个元素为中心的情况有n个，两个元素为中心的情况有n-1个)</p></blockquote><h5 id="方法4：manacher算法"><a href="#方法4：manacher算法" class="headerlink" title="方法4：manacher算法"></a>方法4：manacher算法</h5><blockquote><p>（1）预处理：回文的长度可奇可偶，故在每个字符的左右都加上一个特殊字符“#”,得到长度为奇数的字符串</p><p>（2）回文子串的半径：以中间的 ‘1’ 为中心的回文子串 “#2#2#1#2#2#” 的半径是6，而未添加#号的回文子串为 “22122”，长度是5，为半径减1。</p><p>（3）子串的起始位置：（字符串前面在加一个特殊字符”\$”,在字符末尾加另一个特殊字符”.”）中间位置减去半径再除以2。</p><p>（4）子串的终点位置：起点位置+半径-1</p><p>（5）马拉车核心</p><pre><code>p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;</code></pre><p>其中p[i]代表以i为中心的半径，id为能延伸到最右端的位置的那个回文子串的中心点位置，mx是回文串能延伸到的最右端的位置</p><p><img src="https://github.com/qiulig/IMG/raw/master/5_manecher1.png" alt="manecher"></p><p>1)mx - i &gt; p[j]，即以j为半径的回文在以id为半径的回文内(j跟i是对称的),其中 j = 2*id - i，因为 j 到 id 之间到距离等于 id 到 i 之间到距离，为 i - id，所以 j = id - (i - id) = 2*id - i.</p><p><img src="https://github.com/qiulig/IMG/raw/master/5_manecher2.png" alt="manecher"></p><p>2)mx - i &lt; p[j],即以j为中心的回文子串不一定完全包含于以id为中心的回文子串中，基于对称性可知，图中两个绿框所包围的部分是相同的，也就是说以i为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 p[i] = mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了，这就是后面紧跟到while循环的作用。</p><p>3)对于 mx &lt;= i 的情况，无法对 P[i]做更多的假设，只能P[i] = 1，然后再去匹配了。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>思路1：暴力破解方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       String temp = <span class="string">""</span>;</span><br><span class="line">       String res  =<span class="string">""</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;s.length();j++)&#123;</span><br><span class="line">               temp = temp+s.charAt(j);</span><br><span class="line">               <span class="comment">//re用来保存子字符串反转的结果</span></span><br><span class="line"></span><br><span class="line">               String re  = <span class="keyword">new</span> StringBuffer(temp).reverse().toString();</span><br><span class="line">               <span class="comment">//子字符串跟反转的字符串相等则为回文</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(temp.equals(re))&#123;</span><br><span class="line">                   res = res.length()&gt;temp.length()?res:temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = <span class="string">""</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：动态规划思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个行列均为字符串长度的二维数组，创建时默认初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++)&#123;</span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;<span class="comment">//如果是回文字符串</span></span><br><span class="line">              <span class="comment">//新得到的回文比之前的回文字符串要长，更新字符串长度，记录字符串</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; max)&#123;</span><br><span class="line">                        max = j - i + <span class="number">1</span>;</span><br><span class="line">                        res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3：中心扩展方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span>  String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i); <span class="comment">//奇数的回文，中心有一个字母，以该字母往外扩</span></span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);  <span class="comment">//偶数的回文，中心有两个字母，以这两个字母往外扩</span></span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：马拉车算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) </span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"> <span class="comment">//manacher预处理</span></span><br><span class="line">        <span class="comment">//起点加特殊字符$ </span></span><br><span class="line">        String t = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="comment">//每个字符左右都加特殊字符 #</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            t += s.charAt(i);</span><br><span class="line">            t += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点加特殊字符&amp;</span></span><br><span class="line">        t+=<span class="string">"&amp;"</span>;</span><br><span class="line"> <span class="comment">//马拉车算法实现</span></span><br><span class="line">        <span class="comment">//定义半径</span></span><br><span class="line">        <span class="keyword">int</span> []p = <span class="keyword">new</span> <span class="keyword">int</span>[t.length()];</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.length()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//mancher核心算法</span></span><br><span class="line">            p[i] = mx &gt; i ? Math.min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//半径往外扩</span></span><br><span class="line">            <span class="keyword">while</span> (t.charAt(i + p[i]) == t.charAt(i-p[i]))</span><br><span class="line">                ++p[i];</span><br><span class="line">            <span class="comment">//以i为中心的回文子串不一定完全包含于以id为中心的回文子串中</span></span><br><span class="line">            <span class="keyword">if</span> ((mx-i) &lt;  p[i]) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">                resLen = p[i];</span><br><span class="line">                resCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring((resCenter - resLen) / <span class="number">2</span>, (resCenter - resLen) / <span class="number">2</span> + resLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/5_2.png" alt="动态规划"></p><p><img src="https://github.com/qiulig/IMG/raw/master/5_3.png" alt="中心扩展"></p><p><img src="https://github.com/qiulig/IMG/raw/master/5_4.png" alt="马拉车算法"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串  &lt;code&gt;s&lt;/code&gt;，找到  &lt;code&gt;s&lt;/code&gt;  中最长的回文子串。你可以假设 &lt;code&gt;s&lt;/code&gt;  的最大长度为 1000。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
      <category term="动态规划" scheme="http://blogs.qiulig.website/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="manacher算法" scheme="http://blogs.qiulig.website/tags/manacher%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【4】寻找两个有序数组的中位数</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-4-寻找两个有序数组的中位数/</id>
    <published>2019-05-27T13:14:23.000Z</published>
    <updated>2019-05-27T14:01:46.551Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code>  和 <code>nums2</code>。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。<a id="more"></a></p><p><strong>示例 1:</strong></p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0</p><p><strong>示例 2:</strong></p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>排序输出中间值，但是复杂度不符合题意</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：复杂度不符合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = ArrayUtils.addAll(nums1, nums2);</span><br><span class="line">        Arrays.sort(ints);</span><br><span class="line">        <span class="keyword">if</span>(ints.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (ints[(ints.length+<span class="number">1</span>)/<span class="number">2</span>]+ints[(ints.length+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>d;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> ints[(ints.length-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：复杂度还是不符合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1Length = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2Length = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> totalLength = n1Length + n2Length;</span><br><span class="line">        <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArrayIndex = totalLength / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n1Index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2Index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> last1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (arrayIndex &lt;= maxArrayIndex) &#123;</span><br><span class="line">            last2 = last1;</span><br><span class="line">            <span class="keyword">if</span> (n1Index &gt;= n1Length) &#123;</span><br><span class="line">                last1 = nums2[n2Index++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n2Index &gt;= n2Length) &#123;</span><br><span class="line">                last1 = nums1[n1Index++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[n1Index] &lt;= nums2[n2Index]) &#123;</span><br><span class="line">                    last1 = nums1[n1Index++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    last1 = nums2[n2Index++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arrayIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (last1 + last2) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> last1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/4.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个大小为 m 和 n 的有序数组 &lt;code&gt;nums1&lt;/code&gt;  和 &lt;code&gt;nums2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p&gt;
&lt;p&gt;你可以假设 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt; 不会同时为空。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【3】无重复字符的最长子串</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-3-无重复字符的最长子串/</id>
    <published>2019-05-27T12:54:34.000Z</published>
    <updated>2019-05-29T05:56:41.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “abcabcbb”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;abc&quot;，所以其</code>长度为 3。</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “bbbbb”<br><strong>输出:</strong> 1<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;b&quot;</code>，所以其长度为 1。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “pwwkew”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;wke&quot;</code>，所以其长度为 3。<br>     请注意，你的答案必须是 <strong>子串</strong> 的长度，<code>&quot;pwke&quot;</code> 是一个<em>子序列，</em>不是子串。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>滑动窗口思想</p><pre><code>准备一个list用于滑动窗口，</code></pre><p>（1）当list里面没有该字符时，加入该字符，list.size()就是无重复字符发长度。依次跟MaxLength比较取最大</p><p>（2）当list里面存在该值时，移除list里面该字符出现的第一个索引所在位置之前的所有字符[因为要求最长字串，即连续，所以要移除之前全部的字符]</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MaxLength = <span class="number">0</span>;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(s.charAt(i)))&#123;</span><br><span class="line">                list.add(s.charAt(i));</span><br><span class="line">                MaxLength = Math.max(MaxLength,list.size());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(s.charAt(i));</span><br><span class="line">                <span class="keyword">int</span> index = list.indexOf(s.charAt(i)); <span class="comment">//返回指定元素的第一个匹配项的索引在此列表中</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    list.remove(index--); <span class="comment">// 移除该值以及该字符前面所有的字符</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/3.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="字符串题" scheme="http://blogs.qiulig.website/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【2】两数相加</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-2-两数相加/</id>
    <published>2019-05-27T12:33:46.000Z</published>
    <updated>2019-05-27T12:53:03.096Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给出两个 <strong>非空</strong>  的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<a id="more"></a></p><p><strong>示例：</strong></p><p><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出：</strong>7 -&gt; 0 -&gt; 8<br><strong>原因：</strong>342 + 465 = 807</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>（1）设置一个进位位flag,flag的值为(当前两链表值相加+flag)/10,链表存储的值为(当前两链表值相加+flag)%10，依次遍历直到两个链表都到达尾部</p><p>（2）如果结束了flag不为0，则将flag的值继续添加到结果链表的尾部。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            ListNode ress = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode res = ress;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span> ||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = l1!=<span class="keyword">null</span> ?l1.val:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> y = l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> value = x+y+flag;  </span><br><span class="line"></span><br><span class="line">                flag = value/<span class="number">10</span>;  <span class="comment">//等到进位位</span></span><br><span class="line"></span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(value%<span class="number">10</span>);</span><br><span class="line">                res = res.next;   </span><br><span class="line">                <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag&gt;<span class="number">0</span>)  <span class="comment">//如果到最后一个数相加还有进位位，则链表长度扩展一位</span></span><br><span class="line"></span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">            <span class="keyword">return</span> ress.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/2.png" alt="leetcode提交结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给出两个 &lt;strong&gt;非空&lt;/strong&gt;  的链表用来表示两个非负的整数。其中，它们各自的位数是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且它们的每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="链表题" scheme="http://blogs.qiulig.website/tags/%E9%93%BE%E8%A1%A8%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_【1】两数之和</title>
    <link href="http://blogs.qiulig.website/2019/05/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://blogs.qiulig.website/2019/05/leetcode-1-两数之和/</id>
    <published>2019-05-27T12:15:26.000Z</published>
    <updated>2019-05-27T12:53:37.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数数组  <code>nums</code> 和一个目标值  <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<a id="more"></a></p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9</p><p>所以返回 [<strong>0, 1</strong>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>依次遍历数组里面的数值</p><p>（1）用一个hashmap存储（target-nums[i],索引位置）</p><p>（2）如果下一次出现nums[i],说明找到了。直接将她的坐标跟之前存储的坐标存到结果。</p><p>如示例：</p><p>   i = 0 时， map存入（7,0）</p><p>   i= 1时，发现map.get(num[i]) = map.get(7)!=null, 存在，即找到了，直接将map.get(7) =0,i = 1,这两个值存到结果res里面返回。 </p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">            <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(nums[i])!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    res= <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(target-nums[i],i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-我的提交记录"><a href="#4-我的提交记录" class="headerlink" title="4.我的提交记录"></a>4.我的提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/1.png" alt="两数之和"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组  &lt;code&gt;nums&lt;/code&gt; 和一个目标值  &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出和为目标值的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://blogs.qiulig.website/categories/leetcode/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>volatile介绍</title>
    <link href="http://blogs.qiulig.website/2019/05/volatile%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blogs.qiulig.website/2019/05/volatile介绍/</id>
    <published>2019-05-23T01:23:17.000Z</published>
    <updated>2019-05-23T02:10:57.680Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="并发编程的三大概念："><a href="#并发编程的三大概念：" class="headerlink" title="并发编程的三大概念："></a>并发编程的三大概念：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (1)原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</span><br><span class="line">  (2)可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</span><br><span class="line">  (3)有序性：程序执行的顺序按照代码的先后顺序执行。</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a><a id="more"></a></h4><h4 id="volatile介绍："><a href="#volatile介绍：" class="headerlink" title="volatile介绍："></a>volatile介绍：</h4><blockquote><p>1.volatile是虚拟机提供的最轻量级的同步机制</p><pre><code>保证变量对所有线程的可见性但是不保证原子性，需要通过加锁保证原子性。特例：1)运算结果并不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值2)变量不需要与其他状态变量共同参与不变约束</code></pre><p>2.禁止指令重排</p><pre><code>指令重拍是指CPU采用了允许多条指令不按程序规定的顺序分开发送给各相应电路单元处理，也能得到正确的结果。</code></pre></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;并发编程的三大概念：&quot;&gt;&lt;a href=&quot;#并发编程的三大概念：&quot; class=&quot;headerlink&quot; title=&quot;并发编程的三大概念：&quot;&gt;&lt;/a&gt;并发编程的三大概念：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  (1)原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (2)可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (3)有序性：程序执行的顺序按照代码的先后顺序执行。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h4&gt;
    
    </summary>
    
      <category term="JAVA虚拟机" scheme="http://blogs.qiulig.website/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="线程" scheme="http://blogs.qiulig.website/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://blogs.qiulig.website/categories/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JVM" scheme="http://blogs.qiulig.website/tags/JVM/"/>
    
      <category term="线程" scheme="http://blogs.qiulig.website/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://blogs.qiulig.website/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer_【66】机器人的运动范围</title>
    <link href="http://blogs.qiulig.website/2019/05/66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>http://blogs.qiulig.website/2019/05/66-机器人的运动范围/</id>
    <published>2019-05-17T03:12:17.000Z</published>
    <updated>2019-05-20T11:03:58.353Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>本题使用的方法同样还是回溯法，另外还需要会计算给定整数上的各个位上数之和。</p><pre><code>(1)使用一个访问数组记录是否已经经过该格子。机器人从(0,0)开始移动，当它准备进入(i,j)的格子时，通过检查坐标的数位来判断机器人是否能够进入。(2)如果机器人能进入(i,j)的格子，接着在判断它是否能进入四个相邻的格子(i,j-1),(i,j+1),(i-1,j),(i+1,j)。</code></pre><p>因此，可以用回溯法来解决这一问题。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rows&lt;<span class="number">1</span>||cols&lt;<span class="number">1</span>||threshold&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">boolean</span> []visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</span><br><span class="line">        <span class="keyword">return</span> count(threshold,rows,cols,visit,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span>[] visit, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(threshold,rows,cols,visit,row,col))</span><br><span class="line">        &#123;</span><br><span class="line">            visit[row*cols+col]=<span class="keyword">true</span>;</span><br><span class="line">            res=<span class="number">1</span>+count(threshold,rows,cols,visit,row,col+<span class="number">1</span>)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row,col-<span class="number">1</span>)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row+<span class="number">1</span>,col)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row-<span class="number">1</span>,col);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[] visit, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">                     &amp;&amp; visit[row * cols + col] == <span class="keyword">false</span> &amp;&amp;getNum(col) + getNum(row) &lt;= threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取位数之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://blogs.qiulig.website/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="回溯法" scheme="http://blogs.qiulig.website/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer_【65】矩阵中的路径</title>
    <link href="http://blogs.qiulig.website/2019/05/65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://blogs.qiulig.website/2019/05/65-矩阵中的路径/</id>
    <published>2019-05-17T03:11:57.000Z</published>
    <updated>2019-05-20T08:04:15.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 * 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>回溯法</p><p>(1)在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。<br>　　由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。<br>　　需要判断这个矩阵中的每一个结点是否可以走一条路径，在走的过程中，设置一个和矩阵大小相同的整型数组flag表示是否已经访问，如果某个结点访问了，那么该结点的是否访问则为1。每次遍历一个结点的时候，递归的方式分别向左、向右、向上、向下。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(helper(matrix, rows, cols, i, j, str, <span class="number">0</span>, flag))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> k, <span class="keyword">int</span>[] flag)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = i * cols + j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols </span><br><span class="line">                || matrix[index] != str[k] || flag[index] == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// /下标不符合，index对应的值不为和字符数组中的不一致，或者该index已经被访问，这些情况只要有符合的就返回false</span></span><br><span class="line">            <span class="comment">// 只有上面的所有情况都不符合，也就是值相等，且没有访问过，下标不符合</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == str.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">if</span>(helper(matrix, rows, cols, i - <span class="number">1</span>, j, str, k + <span class="number">1</span>, flag)<span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        ||helper(matrix, rows, cols, i + <span class="number">1</span>, j, str, k + <span class="number">1</span>, flag)<span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">        ||helper(matrix, rows, cols, i, j - <span class="number">1</span>, str, k + <span class="number">1</span>, flag)<span class="comment">//上</span></span><br><span class="line"></span><br><span class="line">      ||helper(matrix, rows, cols, i , j + <span class="number">1</span>, str, k + <span class="number">1</span>, flag))<span class="comment">//下  </span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 * 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://blogs.qiulig.website/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
      <category term="回溯法" scheme="http://blogs.qiulig.website/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer_【64】滑动窗口的最大值</title>
    <link href="http://blogs.qiulig.website/2019/05/64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://blogs.qiulig.website/2019/05/64-滑动窗口的最大值/</id>
    <published>2019-05-16T03:11:35.000Z</published>
    <updated>2019-05-20T08:15:49.324Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。<a id="more"></a></p><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>{2,3,4,2,6,2,5,1} ，3</p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>{4,4,6,6,6,5}</p><h6 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h6><p> 存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}；</p><p> 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： </p><pre><code>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</code></pre></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>我们可以使用双向队列（Linklist），队列中只存放当前元素的下标，</p><pre><code>(1)设新来的元素为k，如果前面的元素比k小，直接把前面的删除（因为不可能成为后面窗口的最大值）(2)如果前面的元素比k大，判断是否还在窗口范围内，不在则移除</code></pre><h6 id="以数组-2-3-4-2-6-2-5-1-为例"><a href="#以数组-2-3-4-2-6-2-5-1-为例" class="headerlink" title="以数组{2,3,4,2,6,2,5,1}为例"></a>以数组{2,3,4,2,6,2,5,1}为例</h6><pre><code>数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。第五个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (num==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">if</span> (num.length&lt;size||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num.length; i++)&#123;</span><br><span class="line">     <span class="comment">//如果前面的数比插入的数小，直接把前面删除(因为不可能成为后面窗口的最大值)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()&amp;&amp;num[i]&gt;=num[queue.getLast()])</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        <span class="comment">//如果前面的元素比k大，判断是否还在窗口范围内，不在则移除</span></span><br><span class="line">        <span class="comment">//(i-(size-1))即滑动窗口最左侧的坐标索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()&amp;&amp;queue.getFirst()&lt;i-(size-<span class="number">1</span>))</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        <span class="comment">//加入队尾</span></span><br><span class="line"></span><br><span class="line">        queue.offerLast(i);</span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>&gt;=size)</span><br><span class="line">            arr.add(num[queue.getFirst()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://blogs.qiulig.website/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer_【63】数据流中的中位数</title>
    <link href="http://blogs.qiulig.website/2019/05/63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://blogs.qiulig.website/2019/05/63-数据流中的中位数/</id>
    <published>2019-05-16T03:11:09.000Z</published>
    <updated>2019-05-20T05:54:55.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用一个list存储插入的数，然后对其进行排序</p><p>(1) size == 0 , 返回 null;</p><p>(2) size是偶数 , 返回 数值排序之后中间两个数的平均值;</p><p>(3) size是奇数，返回 list.get(size/2);</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//添加操作</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">            list.add(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">if</span>(size!=<span class="number">0</span>)&#123;</span><br><span class="line">               </span><br><span class="line">                Collections.sort(list);</span><br><span class="line">                <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> (list.get(size/<span class="number">2</span>)+list.get(size/<span class="number">2</span>-<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> list.get(size/<span class="number">2</span>)*<span class="number">1.0</span>;                  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://blogs.qiulig.website/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组类型题" scheme="http://blogs.qiulig.website/tags/%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E9%A2%98/"/>
    
  </entry>
  
</feed>
