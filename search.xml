<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表题【翻转链表】【环形链表】【删除重复元素】【两数相加】【相交链表】</title>
      <link href="/2019/08/%E9%93%BE%E8%A1%A8%E9%A2%98%E3%80%90%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%91%E3%80%90%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E3%80%91%E3%80%90%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E3%80%91%E3%80%90%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E3%80%91%E3%80%90%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E3%80%91/"/>
      <url>/2019/08/%E9%93%BE%E8%A1%A8%E9%A2%98%E3%80%90%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%91%E3%80%90%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E3%80%91%E3%80%90%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E3%80%91%E3%80%90%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E3%80%91%E3%80%90%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-翻转链表"><a href="#1-翻转链表" class="headerlink" title="1.翻转链表"></a>1.翻转链表</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a><br>递归：</p><ul><li>在遍历链表时，将当前节点cur的next指向前一个元素，</li><li>由于节点没有引用上一个节点，故初始时设置前一个节点pre = null,</li><li>在更改引用之前，还需要另一个指针来存储下一个节点next = cur.next。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用时 :1 ms, 在所有 Java 提交中击败了85.90%的用户</span></span><br><span class="line"><span class="comment">// 内存消耗 :36.1 MB, 在所有 Java 提交中击败了55.82%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = cur.next;  <span class="comment">//将下一个节点记录</span></span><br><span class="line">        cur.next = pre;  <span class="comment">//当前节点指向上一个节点</span></span><br><span class="line">        pre = cur;   <span class="comment">//记录当前节点</span></span><br><span class="line">        cur = next; <span class="comment">//将下一个节点变成当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代：假设链表为 n1–&gt;n2–&gt;n3—n&gt;4–&gt;null,若某部分已经被翻转了  n1–&gt;n2–&gt;<code>n3&lt;--n4</code>，我们希望3指向2，所以有n3.next.next = n2,要注意n1的下一个必须指向null,故还有个head.next = null操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode res = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-翻转链表II"><a href="#2-翻转链表II" class="headerlink" title="2.翻转链表II"></a>2.翻转链表II</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a><br> 假设以 head – 1–2–3–4–中的1~4进行反转</p><blockquote><ul><li>先让头指针的next指向2，</li><li>再让1的next指向3，</li><li>最后将2的next指向1，</li><li><p>完成第一次交换，顺序变成header–2–1–3–4,</p><ul><li>然后进行相同的交换将结点3移动到结点2的前面，然后再将结点4移动到结点3的前面就完成了反转。</li><li><p>同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">&gt;        ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">&gt;        res.next = head;</span><br><span class="line">&gt;        ListNode pre = res;</span><br><span class="line">&gt;        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">&gt;            pre = pre.next;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        head = pre.next;</span><br><span class="line">&gt;        <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; n; i++)&#123;</span><br><span class="line">&gt;            ListNode nextnode = head.next;</span><br><span class="line">&gt;            head.next = nextnode.next;</span><br><span class="line">&gt;            nextnode.next = pre.next;</span><br><span class="line">&gt;            pre.next = nextnode;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        <span class="keyword">return</span> res.next;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><h3 id="3-环形链表"><a href="#3-环形链表" class="headerlink" title="3.环形链表"></a>3.环形链表</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a><br>方法1：HashSet,如果当前结点存在于哈希表中，说明有环，否则遍历完全，返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     Set&lt;ListNode&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">     <span class="keyword">while</span> (head !=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(res.contains(head))&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             res.add(head);</span><br><span class="line">         &#125;</span><br><span class="line">         head = head.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>方法2：快慢指针，快指针先于慢指针一步，如果有环，总有一个时刻快指针会追上慢指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了92.84%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :39.6 MB, 在所有 Java 提交中击败了47.88%的用户</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       ListNode fast = head.next;</span><br><span class="line">       ListNode slow = head;</span><br><span class="line">       <span class="keyword">while</span>(fast !=slow)&#123;</span><br><span class="line">           <span class="keyword">if</span>(fast==<span class="keyword">null</span> || fast.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-环形链表II"><a href="#4-环形链表II" class="headerlink" title="4.环形链表II"></a>4.环形链表II</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><ul><li><p>快慢指针：当fast和slow在环中相遇时，设头节点到入环结点的长度为x,入环结点到相遇点长度为y,相遇点到入环结点长度为z,则有(x+y)*2 = x+y+z+y,即x = z,把快指针设为头节点，慢指针还在相遇点，两个指针相遇之时就是入环点所在之处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.71%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :36.3 MB, 在所有 Java 提交中击败了5.03%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          ListNode fast = head;</span><br><span class="line">          ListNode slow = head;</span><br><span class="line">          <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              fast = fast.next.next;</span><br><span class="line">              slow = slow.next;</span><br><span class="line">              <span class="comment">//环内相遇</span></span><br><span class="line">              <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                  <span class="comment">//快指针重头走</span></span><br><span class="line">                  fast = head;</span><br><span class="line">                  <span class="comment">//快慢指针同时走，相等时即入环结点处</span></span><br><span class="line">                  <span class="keyword">while</span>(fast !=slow)&#123;</span><br><span class="line">                      fast = fast.next;</span><br><span class="line">                      slow = slow.next;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> fast;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//走到尾巴了，说明没有环</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-两数相加"><a href="#5-两数相加" class="headerlink" title="5.两数相加"></a>5.两数相加</h3><p>  &emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode ress = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode res = ress;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span> ||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = l1!=<span class="keyword">null</span> ?l1.val:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> value = x+y+flag;</span><br><span class="line">        flag = value/<span class="number">10</span>;</span><br><span class="line">        res.next = <span class="keyword">new</span> ListNode(value%<span class="number">10</span>);</span><br><span class="line">        res = res.next;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag&gt;<span class="number">0</span>)</span><br><span class="line">        res.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">    <span class="keyword">return</span> ress.next;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-两数相加II"><a href="#6-两数相加II" class="headerlink" title="6.两数相加II"></a>6.两数相加II</h3><p>  &emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii/submissions/</a></p><p>  思路1：使用翻转，进行计算，结果再次翻转即可</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">if</span>(l2 == <span class="keyword">null</span> &amp;&amp; l1!=<span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> l1;</span><br><span class="line">  ListNode head1 = reverseList(l1);</span><br><span class="line">  ListNode head2 = reverseList(l2);</span><br><span class="line">  ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">  ListNode ans = res;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (head1!=<span class="keyword">null</span> || head2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> x = head1 == <span class="keyword">null</span> ? <span class="number">0</span> : head1.val;</span><br><span class="line">      <span class="keyword">int</span> y = head2 ==<span class="keyword">null</span> ? <span class="number">0</span>:head2.val;</span><br><span class="line">      res.next = <span class="keyword">new</span> ListNode((x+y+count)%<span class="number">10</span>);</span><br><span class="line">      count = (x + y +count)/<span class="number">10</span>;</span><br><span class="line">      res = res.next;</span><br><span class="line">      <span class="keyword">if</span>(head1!=<span class="keyword">null</span>) head1 = head1.next;</span><br><span class="line">      <span class="keyword">if</span>(head2!=<span class="keyword">null</span>) head2 = head2.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count != <span class="number">0</span>)&#123;</span><br><span class="line">      res.next = <span class="keyword">new</span> ListNode(count);</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode root = reverseList(ans.next);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode nextnode = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nextnode;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   思路2： 不使用翻转，使用栈进行存储 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">      Stack&lt;Integer&gt; stack1=<span class="keyword">new</span> Stack();</span><br><span class="line">      Stack&lt;Integer&gt; stack2=<span class="keyword">new</span> Stack();</span><br><span class="line">      ListNode node1=l1;</span><br><span class="line">      <span class="comment">//将l1的值入栈</span></span><br><span class="line">      <span class="keyword">while</span>(node1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          stack1.push(node1.val);</span><br><span class="line">          node1=node1.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将l2的值入栈</span></span><br><span class="line">      ListNode node2=l2;</span><br><span class="line">      <span class="keyword">while</span>(node2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          stack2.push(node2.val);</span><br><span class="line">          node2=node2.next;</span><br><span class="line">      &#125;</span><br><span class="line">      ListNode head=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">//依次弹出</span></span><br><span class="line">      <span class="keyword">while</span>(!stack1.isEmpty()||!stack2.isEmpty()||flag!=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(!stack1.isEmpty())</span><br><span class="line">              value+=stack1.pop();</span><br><span class="line">          <span class="keyword">if</span>(!stack2.isEmpty())</span><br><span class="line">              value+=stack2.pop();</span><br><span class="line">          value+=flag;</span><br><span class="line">          ListNode node=<span class="keyword">new</span> ListNode(value%<span class="number">10</span>);</span><br><span class="line">          flag=value/<span class="number">10</span>;</span><br><span class="line">          <span class="comment">//计算的低位依次向后移动</span></span><br><span class="line">          node.next=head;</span><br><span class="line">          <span class="comment">//head存储上一次计算得到的值</span></span><br><span class="line">          head=node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="7-删除排序链表中的重复元素"><a href="#7-删除排序链表中的重复元素" class="headerlink" title="7.删除排序链表中的重复元素"></a>7.删除排序链表中的重复元素</h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       ListNode node = head;</span><br><span class="line">       <span class="keyword">while</span>(node!=<span class="keyword">null</span> &amp;&amp; node.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="comment">//如果相等则跳过这个数</span></span><br><span class="line">           <span class="keyword">if</span>(node.val == node.next.val)&#123;</span><br><span class="line">               node.next = node.next.next;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               node = node.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="8-删除排序链表中的重复元素II"><a href="#8-删除排序链表中的重复元素II" class="headerlink" title="8.删除排序链表中的重复元素II"></a>8.删除排序链表中的重复元素II</h3><p>&emsp;&emsp;<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//head的首部也是重复的数</span></span><br><span class="line">    <span class="keyword">if</span>(head.val==head.next.val)&#123;</span><br><span class="line">        <span class="comment">//node的首部为重复的数，此时head的首部也是重复的数</span></span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        <span class="comment">//如果node的首部一直跟head的相同，则一直向后移动，直到不是重复的数</span></span><br><span class="line">        <span class="keyword">while</span>( node != <span class="keyword">null</span> &amp;&amp; head.val == node.val )&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归node结点，此时node结点为删除了前面重复的数</span></span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//不相等就向下移动，递归删除后面重复的数</span></span><br><span class="line">        head.next = deleteDuplicates(head.next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-相交链表"><a href="#9-相交链表" class="headerlink" title="9.相交链表"></a>9.相交链表</h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a><br>关键：消除两个链表的长度差</p><ul><li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li><li>如果 pA 到了末尾，则 pA = headB 继续遍历</li><li>如果 pB 到了末尾，则 pB = headA 继续遍历</li><li><p>比较长的链表指针指向较短链表head时，长度差就消除了</p><p>如此，只需要将最短链表遍历两次即可找到位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">ListNode pA = headA, pB = headB;</span><br><span class="line"><span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">    pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">    pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法【区间调度】【集合覆盖】【背包问题】【旅行商问题】【哈夫曼构造价值树】</title>
      <link href="/2019/07/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2019/07/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><blockquote><p>&emsp;在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。<br>&emsp;贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略<strong>必须具备无后效性</strong>，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。<a id="more"></a></p></blockquote><h3 id="1-区间调度问题"><a href="#1-区间调度问题" class="headerlink" title="1.区间调度问题"></a>1.区间调度问题</h3><p> 假设有如下课程，希望尽可能多的将课程安排在一间教室里：<br>|课程|开始时间  |结束时间<br>|–|–|–|<br>| 美术 | 9AM  |10AM|<br>英语|9：30AM|10:30AM|<br>数学|10AM|11AM|<br>计算机|10：30AM|11:30AM|<br>音乐|11AM|12AM|<br>算法设计：</p><ul><li>1.选择结束最早的课，便是要在这教室上课的第一节课 </li><li>2.接下来，选择第一堂课结束后才开始的课，并且结束最早的课，这将是第二节在教室上的课。</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String subject[] = &#123;<span class="string">"英语"</span>,<span class="string">"数学"</span>,<span class="string">"计算机"</span>,<span class="string">"音乐"</span>,<span class="string">"美术"</span>&#125;;</span><br><span class="line">        Work[]  works = &#123;</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">1</span>,<span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">4</span>, <span class="number">7</span>),</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">6</span>, <span class="number">9</span>),</span><br><span class="line">                <span class="keyword">new</span> Work(<span class="number">8</span>, <span class="number">10</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> result = solution(works);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(Work[] works)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//works里面已经按end从小到大排序了</span></span><br><span class="line">        Arrays.sort(works);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前工作的结束时间</span></span><br><span class="line">        <span class="keyword">int</span> endTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;works.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(endTime&lt;works[i].getStart())&#123;</span><br><span class="line">                count++;</span><br><span class="line">                endTime = works[i].getEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//end 从小到大排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            Work work = (Work) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.end &gt; work.getEnd())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.end == work.getEnd())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同问题：2019届爱奇艺校招笔试题第三题_库特君的面条: &emsp;&emsp;<a href="https://blog.csdn.net/qq_17556191/article/details/95003363" target="_blank" rel="noopener">https://blog.csdn.net/qq_17556191/article/details/95003363</a></p><h3 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2.背包问题"></a>2.背包问题</h3><p>见：<a href="https://blog.csdn.net/qq_17556191/article/details/94764606" target="_blank" rel="noopener">https://blog.csdn.net/qq_17556191/article/details/94764606</a></p><h3 id="3-集合覆盖问题"><a href="#3-集合覆盖问题" class="headerlink" title="3.集合覆盖问题"></a>3.集合覆盖问题</h3><p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号。<br>|广播台|覆盖地区  |<br>|–|–|<br>| K1 |ID,NV,UT  |<br>K2|WA,ID,MT|<br>K3|OR,NV,CA|<br>K4|NV,UT|<br>K5|CA,AZ|<br>…|…|<br>算法设计：<br>(1) 选出一个广播台，即它覆盖了最多未覆盖的地区即便包含一些已覆盖的地区也没关系<br>(2) 重复第一步直到覆盖了全部的地区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_tanxin_jihefugai</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        broadcasts.put(<span class="string">"K1"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"ID"</span>,<span class="string">"NV"</span>,<span class="string">"UT"</span>&#125;)));</span><br><span class="line">        broadcasts.put(<span class="string">"K2"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"WA"</span>,<span class="string">"ID"</span>,<span class="string">"MT"</span>&#125;)));</span><br><span class="line">        broadcasts.put(<span class="string">"K3"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"OR"</span>,<span class="string">"NV"</span>,<span class="string">"CA"</span>&#125;)));</span><br><span class="line">        broadcasts.put(<span class="string">"K4"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"NV"</span>,<span class="string">"UT"</span>&#125;)));</span><br><span class="line">        broadcasts.put(<span class="string">"K5"</span>, <span class="keyword">new</span> HashSet(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"CA"</span>,<span class="string">"AZ"</span>&#125;)));</span><br><span class="line">        <span class="comment">//需要覆盖的全部地区</span></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"ID"</span>,<span class="string">"NV"</span>,<span class="string">"UT"</span>,<span class="string">"WA"</span>,<span class="string">"MT"</span>,<span class="string">"OR"</span>,<span class="string">"CA"</span>,<span class="string">"AZ"</span>&#125;));</span><br><span class="line">        <span class="comment">//所选择的广播台列表</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//(1) 选出一个广播台，即它覆盖了最多未覆盖的地区即便包含一些已覆盖的地区也没关系</span></span><br><span class="line">        <span class="comment">// (2) 重复第一步直到可以覆盖了全部的地区</span></span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String maxKey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(allAreas.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            maxKey = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//一轮轮选出（之前未覆盖的）数量最多的电台</span></span><br><span class="line">            <span class="keyword">for</span>(String key:broadcasts.keySet())&#123;</span><br><span class="line">                tempSet.clear();</span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                <span class="comment">//求出2个集合的交集，得到的交集的电台存在tempSet里面</span></span><br><span class="line">                tempSet.retainAll(allAreas);</span><br><span class="line">                <span class="comment">//如果该集合包含的地区数量比原本的集合多</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size()&gt;<span class="number">0</span> &amp;&amp; (maxKey == <span class="keyword">null</span> || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                    <span class="comment">//得到要存入的电台key</span></span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到未覆盖电台数的最大的那个电台</span></span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lists.add(maxKey);</span><br><span class="line">                <span class="comment">//将覆盖地区移除allAreas</span></span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"selects:"</span> + lists);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-旅行商问题"><a href="#4-旅行商问题" class="headerlink" title="4.旅行商问题"></a>4.旅行商问题</h3><p>&emsp;给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。<br>算法设计：<br>随机选一个城市开始，以寻找离该城市最近点作为下一个城市旅行城市，此后寻找离最后加入路线的城市最近的城市，直到最后。【类似于广度优先遍历】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旅行商问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String city[] = &#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"F"</span>,<span class="string">"G"</span>,<span class="string">"H"</span>,<span class="string">"I"</span>,<span class="string">"J"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> x[] = &#123;<span class="number">2066</span>,<span class="number">935</span>,<span class="number">1270</span>,<span class="number">1389</span>,<span class="number">984</span>,<span class="number">2253</span>,<span class="number">949</span>,<span class="number">87</span>,<span class="number">3094</span>,<span class="number">2706</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> y[] = &#123;<span class="number">2333</span>,<span class="number">1304</span>,<span class="number">200</span>,<span class="number">700</span>,<span class="number">2810</span>,<span class="number">478</span>,<span class="number">3025</span>,<span class="number">2483</span>,<span class="number">1883</span>,<span class="number">3130</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> distance[][] = Caldistance(x,y);</span><br><span class="line">        solve(distance,city);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[][] Caldistance(<span class="keyword">int</span> x[],<span class="keyword">int</span> y[])&#123;</span><br><span class="line">        <span class="keyword">double</span> [][] distance = <span class="keyword">new</span> <span class="keyword">double</span>[x.length][x.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;x.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;x.length;j++)&#123;</span><br><span class="line">                <span class="comment">//欧式距离</span></span><br><span class="line">                distance[i][j] = Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span>[][]distance,String []city)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录访问过的城市</span></span><br><span class="line">        <span class="keyword">int</span> visited[] = <span class="keyword">new</span> <span class="keyword">int</span>[distance.length];</span><br><span class="line">        <span class="comment">//记录依次访问的城市，得到最小的距离</span></span><br><span class="line">        String path[] = <span class="keyword">new</span> String[distance.length];</span><br><span class="line">        <span class="comment">//假设从第一个城市A开始</span></span><br><span class="line">        path[<span class="number">0</span>] = <span class="string">"A"</span>;</span><br><span class="line">        <span class="comment">//访问过的点记录为1</span></span><br><span class="line">        visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前正在访问的点</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一次设下一个城市为Index为1的B城市</span></span><br><span class="line">        <span class="keyword">int</span> nextCityIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//初始化最小的距离</span></span><br><span class="line">        <span class="keyword">double</span> mindistance = Double.MAX_VALUE;</span><br><span class="line">        <span class="comment">//记录以及访问过多少个城市了</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;city.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;city.length;i++)&#123;</span><br><span class="line">                <span class="comment">//如果该点没被访问</span></span><br><span class="line">                <span class="keyword">if</span>(visited[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//求出 从正在访问的点k到下一个点的最小距离，即为下一个要被访问的城市</span></span><br><span class="line">                    <span class="keyword">if</span>(distance[k][i]&lt;mindistance)&#123;</span><br><span class="line">                        mindistance  = distance[k][i];</span><br><span class="line">                        <span class="comment">//获取下一个要被访问的城市的下标索引</span></span><br><span class="line">                        nextCityIndex = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//依次访问的点的总路程</span></span><br><span class="line">            sum = sum + mindistance;</span><br><span class="line">            <span class="comment">//将得到的下一个要访问的城市加入到path中</span></span><br><span class="line">            path[count++] = city[nextCityIndex];</span><br><span class="line">            <span class="comment">//该点被访问，置为1</span></span><br><span class="line">            visited[nextCityIndex] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将访问的城市起点改成求得的下一个城市的点的坐标索引</span></span><br><span class="line">            k = nextCityIndex;</span><br><span class="line">            <span class="comment">//再次初始化</span></span><br><span class="line">            mindistance = Double.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得出依次访问的结果，输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;path.length;i++)&#123;</span><br><span class="line">            System.out.print(path[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-哈夫曼构造价值树"><a href="#5-哈夫曼构造价值树" class="headerlink" title="5.哈夫曼构造价值树"></a>5.哈夫曼构造价值树</h3><p>哈夫曼见： <a href="https://blog.csdn.net/likunkun__/article/details/80258515" target="_blank" rel="noopener">https://blog.csdn.net/likunkun__/article/details/80258515</a><br>相同题型：切金条： <a href="https://blog.csdn.net/qq_34115899/article/details/79723970" target="_blank" rel="noopener">https://blog.csdn.net/qq_34115899/article/details/79723970</a></p><p>参考：图解贪婪算法  <a href="https://blog.csdn.net/a8082649/article/details/82079779" target="_blank" rel="noopener">https://blog.csdn.net/a8082649/article/details/82079779</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【俄罗斯套娃信封问题】【堆积木】</title>
      <link href="/2019/07/%E3%80%90%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98%E3%80%91%E3%80%90%E5%A0%86%E7%A7%AF%E6%9C%A8%E3%80%91/"/>
      <url>/2019/07/%E3%80%90%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98%E3%80%91%E3%80%90%E5%A0%86%E7%A7%AF%E6%9C%A8%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a>俄罗斯套娃信封问题</h3><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/russian-doll-envelopes/</a></p><blockquote><p>&emsp;给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<a id="more"></a><br>&emsp;请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。<br><strong>说明:</strong><br>&emsp;不允许旋转信封。<br><strong>示例:<br>输入:</strong><br>&emsp; envelopes = [[5,4],[6,4],[6,7],[2,3]]<br><strong>输出:</strong><br>&emsp; 3<br><strong>解释:</strong> 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路1：动态规划<br>以envelopes =[[4,5],[4,6],[6,7],[2,3],[1,1]]为例；</p><ul><li><p>1.先将envelopes的长度进行从小到大排序，在长度相等的情况下，对它的宽度也进行从小到大排序得到 [1,1],[2,3],[4,5],[4,6],[4,7]</p><blockquote><p>Arrays.sort(envelopes, new Comparator&lt;int[]&gt;(){</p><p>&emsp;&emsp; public int compare(int[] o1,int [] o2){</p><p>&emsp;&emsp;&emsp;&emsp;//判断第一个元素是否相等</p><p>&emsp;&emsp;&emsp;&emsp; if (o1[0] == o2[0]) {</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o1[1] - o2[1];</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;} else {</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return o1[0] - o2[0];</p><p>&emsp;&emsp;&emsp;&emsp;}</p><p>&emsp;&emsp;&emsp; }</p><p>&emsp;&emsp;});</p></blockquote></li><li><p>2.因为f[i]表示第i个信封可以嵌套的最大信封数,结果要求最多有多少个信封，最多信封为嵌套信封加本身的信封，故将其每个位置初始化为1。</p></li><li><p>3.for语句嵌套，如果第i个信封的长度和宽度都大于第j个信封，则可以把它嵌套到i里面信封里面，所以此时第i个信封可以嵌套的最大信封数为f[i] = Math.max(f[i],f[j]+1);</p></li><li><p>4.最多的信封数即为f[]里面存在的最大的数。返回结果。</p></li></ul><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(envelopes==<span class="keyword">null</span>||envelopes.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//长度从小到大排序，在长度相等的情况下，高度从小到大排序</span></span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1,<span class="keyword">int</span> [] o2)</span></span>&#123;</span><br><span class="line">                <span class="comment">//判断第一个元素是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> n=envelopes.length;</span><br><span class="line">        <span class="comment">//f[i]表示第i个信封可以嵌套的最大信封数</span></span><br><span class="line">        <span class="comment">//5个信封的初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            f[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//第i个信封的长度和宽度都大于第j个信封，则可以把它嵌套到i里面信封里面</span></span><br><span class="line">                <span class="keyword">if</span>(envelopes[j][<span class="number">0</span>]&lt;envelopes[i][<span class="number">0</span>]&amp;&amp;envelopes[j][<span class="number">1</span>]&lt;envelopes[i][<span class="number">1</span>])&#123;</span><br><span class="line">                    f[i]=Math.max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res,f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：</p><ul><li>1.envelopes的长度进行从小到大排序，在长度相等的情况下，对它的宽度也进行从大到小排序得到 [1,1],[2,3],[4,6],[4,5],[4,7]，最后问题转换成求 1，3，6，5，7中的最大递增子序列</li><li>2.定义一个ends数组。ends[i]代表遍历到目前为止，所有长度为i+1的递增子序列的最小结尾数。初始化ends[0] = 1;即1 ，3，6，5，7遍历到1的时候，长度为1的递增子序列的最小结尾数就是1。</li><li><p>一次更新ends数组，for循环遍历1，3，6，5，7，从i=1遍历到尾部。在ends里面进行二分查找，查找此刻dots[i]在ends的哪个部分，如果是没更新到的地方则更新此时的ends[i];如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dots.length; i++) &#123;</span><br><span class="line">     l = <span class="number">0</span>;</span><br><span class="line">     r = right;</span><br><span class="line">     <span class="comment">//当要算以dots[i]结尾的最长递增子序列时，</span></span><br><span class="line">     <span class="comment">//二分查找去ends里面更新长度为i的最小结尾数</span></span><br><span class="line">     <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">         mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span> (dots[i].h &gt; ends[mid]) &#123;</span><br><span class="line">             l = mid + <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             r = mid - <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     right = Math.max(right, l);</span><br><span class="line">     <span class="comment">//更新最小结尾数</span></span><br><span class="line">     ends[l] = dots[i].h;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>第一次遍历: i = 1; l = r =mid = 0;&emsp;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dot[1].h = 3 &gt; ends[0] = 1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;l = 1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;right = 1;ends[1] = 3;<br>第二次遍历: i = 2; l=0,r = 1,mid = 0;<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dot[2].h = 6 &gt; ends[0] = 1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;l = 1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mid = 1,l =2<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;right = 2,end[2] = 6;<br>&emsp;&emsp;…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by qiulig on 2019/7/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_354</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行用时 :33 ms, 在所有 Java 提交中击败了87.11%的用户</span></span><br><span class="line">    <span class="comment">//内存消耗 :47.1 MB, 在所有 Java 提交中击败了80.68%的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] envelopes=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        System.out.print(maxEnvelopes(envelopes));</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dot</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Dot</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">                w = weight;</span><br><span class="line">                h = hight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//长度从小到大排序，在长度相等的情况下，高度从大到小排序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DotComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Dot</span>&gt; </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dot o1, Dot o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.w != o2.w) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.w - o2.w;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o2.h - o1.h;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] es)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (es == <span class="keyword">null</span> || es.length == <span class="number">0</span> || es[<span class="number">0</span>] == <span class="keyword">null</span> || es[<span class="number">0</span>].length != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Dot[] dots = <span class="keyword">new</span> Dot[es.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; es.length; i++) &#123;</span><br><span class="line">                dots[i] = <span class="keyword">new</span> Dot(es[i][<span class="number">0</span>], es[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//排序之后长度w： 1  2  4  4  6</span></span><br><span class="line">            <span class="comment">//    对应高度h： 1  3  6  5  7</span></span><br><span class="line">            <span class="comment">//最后问题转换成求 1  3  6  5  7中的最大递增子序列</span></span><br><span class="line">            Arrays.sort(dots, <span class="keyword">new</span> DotComparator());</span><br><span class="line">            <span class="comment">//ends[i]代表遍历到目前为止，所有长度为i+1的递增子序列的最小结尾数</span></span><br><span class="line">            <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[es.length];</span><br><span class="line">            <span class="comment">//代表第一个信封的长度为1的最小结尾数是dots[0].h</span></span><br><span class="line">            ends[<span class="number">0</span>] = dots[<span class="number">0</span>].h;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dots.length; i++) &#123;</span><br><span class="line">                l = <span class="number">0</span>;</span><br><span class="line">                r = right;</span><br><span class="line">                <span class="comment">//当要算以dots[i]结尾的最长递增子序列时，</span></span><br><span class="line">                <span class="comment">//二分查找去ends里面更新长度为i的最小结尾数</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dots[i].h &gt; ends[mid]) &#123;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                right = Math.max(right, l);</span><br><span class="line">                <span class="comment">//更新最小结尾数</span></span><br><span class="line">                ends[l] = dots[i].h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果信封可旋转，则我们可以把输入稍微定死，输入[w,h]定死了大的数的代表的是信封的长，小的数代表的是信封的宽，即如果输入w&lt;h，则把他们互换一下位置。</p><h3 id="搭积木"><a href="#搭积木" class="headerlink" title="搭积木"></a>搭积木</h3><p><a href="https://www.nowcoder.com/questionTerminal/55371b74b2f243e3820e57ee4c7b5504" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/55371b74b2f243e3820e57ee4c7b5504</a></p><blockquote><p>&emsp;小明有一袋子长方形的积木，如果一个积木A的长和宽都不大于另外一个积木B的长和宽，则积木A可以搭在积木B的上面。好奇的小明特别想知道这一袋子积木最多可以搭多少层，你能帮他想想办法吗？    定义每一个长方形的长L和宽W都为正整数，并且1 &lt;= W &lt;= L &lt;= INT_MAX, 袋子里面长方形的个数为N, 并且 1 &lt;= N &lt;= 1000000.    假如袋子里共有5个积木分别为 (2, 2), (2, 4), (3, 3), (2, 5), (4, 5), 则不难判断这些积木最多可以搭成4层, 因为(2, 2) &lt; (2, 4) &lt; (2, 5) &lt; (4, 5)。 </p></blockquote><blockquote><ul><li><p>同如上思路2，先将宽度进行排序，将问题转化成求长度的最大递增子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>package 拼多多;<br>import java.util.*;<br>public class Main_3{<br>    static class Rectangle{<br>        private int Weight; //宽度<br>        private int Len;  //长度<br>        public Rectangle(int x, int y){<br>            Weight = x;<br>            Len = y;<br>        }<br>    }<br>    public static void main(String[] args){<br>        Scanner sc = new Scanner(System.in);<br>        int n = sc.nextInt();<br>        ArrayList<rectangle> list = new ArrayList&lt;&gt;();<br>        for(int i = 0; i &lt; n; i++){<br>            int x = sc.nextInt();<br>            int y = sc.nextInt();<br>            Rectangle r = new Rectangle(x, y);<br>            list.add(r);<br>        }<br>        //排序，宽度从小到大，在宽度一样的情况下，长度从小到大<br>        Collections.sort(list, new Comparator<rectangle>(){<br>            @Override<br>            public int compare(Rectangle o1, Rectangle o2) {<br>                if(o1.Weight == o2.Weight)<br>                    return o1.Len - o2.Len;<br>                else<br>                    return o1.Weight -o2.Weight;<br>            }<br>        });<br>        //最后问题转换成求长度的最大递增子序列<br>        //用于代表遍历到目前为止，所有长度为i+1的递增子序列的最小结尾数<br>        int[] arr = new int[n];<br>        int max = 1;<br>        arr[0] = list.get(0).Len;<br>        for(int i = 1; i &lt; n; i++){<br>            if(list.get(i).Len &gt;= arr[max-1]){<br>                arr[max++] = list.get(i).Len;<br>            }else{<br>                int left = 0;<br>                int right = max -1;<br>                int L = list.get(i).Len;<br>                while(left &lt; right){<br>                    int mid = (left + right) &gt;&gt; 1;<br>                    if(arr[mid] == L){<br>                        left = mid;<br>                        break;<br>                    }else if(arr[mid] &gt; L){<br>                        right–;<br>                    }else<br>                        left++;<br>                }<br>                arr[left] = L;<br>            }<br>        }<br>        System.out.println(max);<br>    }<br>}</rectangle></rectangle></p><p><img src="https://img-blog.csdnimg.cn/20190730112202118.png" alt="在这里插入图片描述"></p><h3 id="拼多多学霸批的堆积木"><a href="#拼多多学霸批的堆积木" class="headerlink" title="拼多多学霸批的堆积木"></a>拼多多学霸批的堆积木</h3><blockquote><p>已知N个积木的长度，当堆积木的时候，要求每层积木的长度严格比其下方的积木小，而且每块积木只能承受自身重量的7倍，问可以堆多高的积木<br>给了个测试用例<br>输入：<br>10<br>1    2    3    4    5    6    7    8    9    10<br>1    1    1    1    1    1    1    1    1    10<br>输出：9</p><ul><li>个人思路觉得这题还是上面堆积木，俄罗斯套信封题一样，只是积木的长度 = 俄罗斯信封的长度，积木的重量*7 = 俄罗斯信封的高度。应该是这样子叭叭叭<del>~</del><del>~</del><del>~</del>~~~小菜鸟不知了。。。。。。。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构型模式之【代理模式】【享元模式】【桥接模式】【适配器模式】【外观模式】【组合模式】【装饰模式】</title>
      <link href="/2019/07/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
      <url>/2019/07/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><code>代理模式</code></h2><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问。</p></blockquote><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote><p>&emsp;（1）<strong>抽象角色</strong>(Subject)：通过接口或抽象类声明真实角色实现的业务方法。<br>&emsp;（2）<strong>代理角色</strong>（Proxy）：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。<br>&emsp;（3）<strong>真实角色</strong>(RealSubject)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p><a id="more"></a></blockquote><h3 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h3><blockquote><ul><li>（1）<strong>远程代理</strong>。为一个位于不同的地址空间的对象提供一个本地的代理对象。这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。这样可以隐藏一个对象存在于不同地址空间的事实，使得客户端可以访问在远程机器上的对象。</li><li><p>（2）<strong>虚拟代理</strong>。根据需要创建开销很大的对象。如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时</p><pre><code>才会被真正创建。</code></pre></li><li>（3）<strong>安全代理</strong>。用来控制真实对象访问时的权限。</li><li>（4）<strong>智能指引</strong>。当调用真实对象时，代理处理另外的一些事。</li></ul></blockquote><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>&emsp;&emsp;Spring 的AOP</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>   &emsp;&emsp;1.职责清晰：  真实角色就是实现实际的业务逻辑，不用关心其他非本职的事物<br>&emsp;&emsp;2.高扩展性：  真实角色可以随时更换或扩展，只需要实现接口就行，而代理不需要有任何变化</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>  &emsp;(1)由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。<br>    &emsp;(2)实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>&emsp;&ensp;由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Proxy proxy=<span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之前的预处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之后的后续处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>在实现阶段不需要关心代理谁，在运行阶段会动态生成一个代理类去代理指定的对象</p></blockquote><p><strong>默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用CGlib来生成代理</strong></p><h3 id="1-jdk动态代理：接口-InvocationHandler-目标对象"><a href="#1-jdk动态代理：接口-InvocationHandler-目标对象" class="headerlink" title="(1)jdk动态代理：接口+InvocationHandler+目标对象"></a>(1)jdk动态代理：<strong>接口+InvocationHandler+目标对象</strong></h3><blockquote><p>&emsp;主要用到java.lang.reflect中的两个类：<strong>‘Proxy和InvocationHandler’</strong><br>InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类代码，动态的将横切逻辑与业务逻辑编织在一起<br>     &emsp;&emsp;1.定义业务逻辑接口<br>    &emsp;&emsp;2.实现业务逻辑接口创建业务实现类<br>     &emsp;&emsp;3.实现（implements）InvacationHandler代理接口，创建代理类<br>     &emsp;&emsp;4.创建业务类和代理类对象，通过代理类对象.bind(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。<br><strong>缺点</strong>：要求目标类必须实现对应方法非接口，它<strong>只能为接口创建代理</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvocationHandler + invoke()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理类的实例</span></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="comment">// 将被代理者的实例传进动态代理类的构造函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖InvocationHandler接口中的invoke()方法</span></span><br><span class="line"><span class="comment">     * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构</span></span><br><span class="line"><span class="comment">     * 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到</span></span><br><span class="line"><span class="comment">     * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊</span></span><br><span class="line"><span class="comment">     * 代码切入的扩展点了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * before ：doSomething();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object result = method.invoke(<span class="keyword">this</span>.obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * after : doSomething();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-cglib动态代理：接口或类-MethodInterceptor-目标对象"><a href="#2-cglib动态代理：接口或类-MethodInterceptor-目标对象" class="headerlink" title="(2)cglib动态代理：接口或类+MethodInterceptor+目标对象"></a>(2)cglib动态代理：<strong>接口或类+MethodInterceptor+目标对象</strong></h3><blockquote><p>主要用到java.lang.reflect中的两个类:’MethodInterceptor和CglibProcy’<br>    &emsp;1.定义业务类，无需实现接口（也可以实现）<br>     &emsp;2.实现MethodInterceptor方法代理接口，创建代理类<br>     &emsp;3.创建业务类和代理类对象，通过代理类对象.getInstance(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。<br>特点：<code>能代理类和接口，但是不能代理final类</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MethodIntercepter + intercept()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Proxy instance = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getInstance</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        sayBefore();</span><br><span class="line">        Object result = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">        sayAfter();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"before..."</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayAfter</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"after..."</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a><code>享元模式</code></h2><blockquote><p>&emsp;运用<strong>共享技术</strong>有效地支持<strong>大量细粒度对象的复用</strong>。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。<!--more--></p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><p>&emsp;在享元模式中引入了享元工厂类FlyweightFactory，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。<br>&emsp;<strong>享元工厂类：FlyweightFactory<br>&emsp;享元类：ConcreteFlyweight<br>&emsp;享元对象：Flyweight</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个HashMap用于存储享元对象，实现享元池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap flyweights = newHashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果对象存在，则直接从享元池获取</span></span><br><span class="line">        <span class="keyword">if</span>(flyweights.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>(Flyweight)flyweights.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Flyweight fw = newConcreteFlyweight();</span><br><span class="line">            flyweights.put(key,fw);</span><br><span class="line">            <span class="keyword">return</span> fw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><blockquote><p>&emsp;&emsp;当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。</p></blockquote><p>&emsp;<strong>1.String中的享元模式</strong></p><blockquote><p> &emsp;&emsp;Java中将String类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。</p></blockquote><p>&emsp;<strong>2.Integer中的享元模式</strong></p><blockquote><p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code>之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象</p></blockquote><p>&emsp; <strong>3.Long中的享元模式</strong></p><blockquote><p>与Integer原理类似</p></blockquote><p>&emsp;<strong>4.Apache Commons Pool2中的享元模式（对象池）</strong></p><blockquote><p>将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用，从而在一定程度上减少频繁创建对象所造成的开销。用于充当保存对象的“容器”的对象，被称为“对象池”</p></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a><code>桥接模式</code></h2><blockquote><p>&emsp;将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p></blockquote><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="string">'实现化'</span>（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</span><br><span class="line">- <span class="string">'具体实现化'</span>（Concrete Implementor）角色：给出实现化角色接口的具体实现。</span><br><span class="line">- <span class="string">'抽象化'</span>（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</span><br><span class="line">- <span class="string">'扩展抽象化'</span>（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</span><br></pre></td></tr></table></figure><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><blockquote><ul><li>(1) 由于抽象与实现分离，所以扩展能力强；</li><li><p>(2) 可动态的切换实现</p><p>&emsp;&emsp;&ensp;由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。</p></li><li>(3) 实现细节对客户端透明，可以对用户隐藏实现细节。</li></ul></blockquote><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><blockquote><ul><li>(1) 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</li><li>(2) 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。</li></ul></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><ul><li>(1)当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>(2)当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li><li>(3)当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li></ul></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Implementor imple=<span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs=<span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体实现化(Concrete Implementor)角色被访问"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Implementor imple;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.imple=imple;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(imple);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"扩展抽象化(Refined Abstraction)角色被访问"</span> );</span><br><span class="line">       imple.OperationImpl();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><code>适配器模式</code></h2><blockquote><p>&emsp;<code>将一个类的接口转换成客户希望的另外一个接口</code>。Adapter模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式分为<code>类结构型模式</code>和<code>对象结构型模式</code>两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p></blockquote><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>&emsp;对类适配器来说，更换适配器的实现过程比较复杂。</p><h3 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h3><ol><li><strong>目标（Target）接口</strong>：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li><strong>适配者（Adaptee）类</strong>：它是被访问和适配的现存组件库中的组件接口。</li><li><strong>适配器（Adapter）类</strong>：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ol><h3 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h3><p>适配器模式（Adapter）通常适用于以下场景。</p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>&emsp;<a href="https://blog.csdn.net/wwwdc1012/article/details/82780560" target="_blank" rel="noopener">https://blog.csdn.net/wwwdc1012/article/details/82780560</a></p><h4 id="1-spring-AOP中的适配器模式"><a href="#1-spring-AOP中的适配器模式" class="headerlink" title="(1)spring AOP中的适配器模式"></a>(1)spring AOP中的适配器模式</h4><blockquote><ul><li>在Spring的Aop中，使用的 Advice（通知） 来增强被代理类的功能。</li><li>Advice的类型有：MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice</li><li>在每个类型 Advice 都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptorSpring</li><li>需要将每个 Advice 都封装成对应的拦截器类型，返回给容器，所以需要<strong>使用适配器模式对 Advice 进行转换</strong></li></ul></blockquote><h4 id="2-spring-JPA中的适配器模式"><a href="#2-spring-JPA中的适配器模式" class="headerlink" title="(2)spring JPA中的适配器模式"></a>(2)spring JPA中的适配器模式</h4><blockquote><ul><li>在Spring的ORM包中，对于JPA的支持也是采用了适配器模式，首先定义了一个接口的 JpaVendorAdapter，然后不同的持久层框架都实现此接口。<ul><li>jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，因此最好在这里设置；</li><li>目前Spring提供 HibernateJpaVendorAdapter、OpenJpaVendorAdapter、EclipseLinkJpaVendorAdapter、TopLinkJpaVendorAdapter 四个实现。</li></ul></li><li>其中最重要的属性是 database，用来指定使用的数据库类型，从而能根据数据库类型来决定比如如何将数据库特定异常转换为Spring的一致性异常，目前支持如下数据库<ul><li>DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、SQL_SERVER、SYBASE</li></ul></li></ul></blockquote><h4 id="3-spring-MVC中的适配器模式"><a href="#3-spring-MVC中的适配器模式" class="headerlink" title="(3)spring MVC中的适配器模式"></a>(3)spring MVC中的适配器模式</h4><blockquote><p>Spring MVC中的适配器模式主要用于执行目标 Controller 中的请求处理方法。在Spring MVC中，<strong>DispatcherServlet 作为用户，HandlerAdapter 作为期望接口</strong>，具体的适配器实现类用于对目标类进行适配，<strong>Controller 作为需要适配的类。</strong></p></blockquote><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a><code>外观模式</code></h2><blockquote><p>&emsp;&emsp;<strong>为多个子系统提供一个统一的接口</strong>，而使这些子系统更加容易被访问的模式。降低系统的耦合度。<br>&emsp;&emsp;迪米特法则的典型应用，但是增加新的子系统可能需要修改外观类或客户端的源代码，<strong>违背了“开闭原则”</strong>。</p></blockquote><!--more--><h3 id="组成-3"><a href="#组成-3" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'外观'</span>（Facade）角色：为多个子系统对外提供一个共同的接口。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'子系统'</span>（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'客户'</span>（Client）角色：通过一个外观角色访问各个子系统的功能。</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><ul><li>(1) 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以<strong>简化子系统之间的依赖关系</strong>。</li><li>(2) 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>(3) 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而<strong>提高子系统的独立性和可移植性</strong>。</li></ul></blockquote><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Facade f=<span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1=<span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2=<span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3=<span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统01的method1()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统02的method2()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统03的method3()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a><code>组合模式</code></h2><blockquote><p>&emsp;有时又叫作<strong>部分-整体模式</strong>，将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p></blockquote><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ol><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这<strong>简化了客户端代码</strong>；</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，<strong>满足“开闭原则”；</strong></li></ol><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p> &emsp; 1.设计较复杂，客户端需要花更多时间理清类之间的层次关系；</p><p>  &emsp; 2.不容易限制容器中的构件；</p><p>  &emsp; 3.不容易用继承的方法来增加构件的新功能；</p><h3 id="组成-4"><a href="#组成-4" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'抽象构件'</span>（Component）角色：它的主要作用是为树叶构件和树枝构件<span class="string">'声明公共接口，并实现它们的默认行为'</span>。在透明式的组合模式中抽象</span><br><span class="line">    构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'树叶构件'</span>（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于<span class="string">'实现抽象构件角色中声明的公共接口'</span>。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'树枝构件'</span>（Composite）角色：是组合中的分支节点对象，它有子节点。它<span class="string">'实现了抽象构件角色中声明的接口'</span>，它的主要作用是存储和管理</span><br><span class="line">    子部件，通常包含 Add()、Remove()、GetChild() 等方法。</span><br></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="emsp-1-透明式"><a href="#emsp-1-透明式" class="headerlink" title="&emsp; (1) 透明式"></a>&emsp; (1) 透明式</h4><blockquote><p>&emsp; <strong>抽象构件声明了所有子类中的全部方法</strong>，包括add,remove等，使树叶和树枝具备完全一致的行为接口。所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。<br>&emsp;<strong>缺点</strong>：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会<strong>带来一些安全性问题</strong>。</p></blockquote><h4 id="emsp-2-安全式"><a href="#emsp-2-安全式" class="headerlink" title="&emsp;(2) 安全式"></a>&emsp;(2) 安全式</h4><blockquote><p>&emsp;<strong>抽象构件不去声明add、remove方法</strong>，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题。<br>&emsp; <strong>缺点</strong>：由于不够透明，树叶和树枝不具备相同的接口，客户端的调用需要做相应的判断<strong>带来不便。</strong></p></blockquote><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>  &emsp; 1.在需要表示一个对象整体与部分的层次结构的场合。</p><p>  &emsp; 2.要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。<br>&emsp;&emsp;Java  AWT/Swing中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component c0=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component c1=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">"1"</span>); </span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">"2"</span>); </span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">"3"</span>);          </span><br><span class="line">        c0.add(leaf1); </span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2); </span><br><span class="line">        c1.add(leaf3);          </span><br><span class="line">        c0.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123; &#125;           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123; &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"树叶"</span>+name+<span class="string">"：被访问！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children=<span class="keyword">new</span> ArrayList&lt;Component&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a><code>装饰模式</code></h2><p>&emsp;指在不改变现有对象结构的情况下，<strong>动态地给该对象增加一些职责</strong>（即增加其额外功能）的模式，它属于对象结构型模式。<br>&emsp;就增加功能来说，装饰模式比生成子类更为灵活。</p><!--more--><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><ul><li>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。</li><li>如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。</li></ul><h3 id="组成-5"><a href="#组成-5" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-   <span class="string">'抽象构件'</span>（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</span><br><span class="line">-   <span class="string">'具体构件'</span>（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</span><br><span class="line">-   <span class="string">'抽象装饰'</span>（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</span><br><span class="line">-   <span class="string">'具体装饰'</span>（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</span><br></pre></td></tr></table></figure><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>当需要给一个<strong>现有类添加附加职责</strong>，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li><li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用<strong>继承关系很难实现</strong>，而采用装饰模式却很好实现。</li><li>当对象的<strong>功能要求可以动态地添加，也可以再动态地撤销时</strong>。</li></ul><h3 id="实际中的应用"><a href="#实际中的应用" class="headerlink" title="实际中的应用"></a>实际中的应用</h3><blockquote><p> Java I/O 标准库的设计。例如，</p><ul><li>(1) InputStream 的子类 FilterInputStream，</li><li>(2) OutputStream 的子类 FilterOutputStream，</li><li>(3) Reader 的子类BufferedReader 以及 FilterReader，</li><li>(4) Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</li></ul></blockquote><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component p=<span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        Component d=<span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建具体构件角色"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用具体构件角色的方法operation()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component=component;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为具体构件角色增加额外的功能addedFunction()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019届华为秋招笔试题【数字反转相加】【消除重复数字】【仿LISP运算】</title>
      <link href="/2019/07/2019%E5%B1%8A%E5%8D%8E%E4%B8%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC%E7%9B%B8%E5%8A%A0%E3%80%91%E3%80%90%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E3%80%91%E3%80%90%E4%BB%BFLISP%E8%BF%90%E7%AE%97%E3%80%91/"/>
      <url>/2019/07/2019%E5%B1%8A%E5%8D%8E%E4%B8%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC%E7%9B%B8%E5%8A%A0%E3%80%91%E3%80%90%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E3%80%91%E3%80%90%E4%BB%BFLISP%E8%BF%90%E7%AE%97%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数字反转相加"><a href="#数字反转相加" class="headerlink" title="数字反转相加"></a><code>数字反转相加</code></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请您写一个 reversoAdd函数，该函数根据输入的两个正整数a和b, 字按照高位在右边的方式反转后求和。<br>例如，reverseAdd(123, 456) == 321 + 654 = 975</p><a id="more"></a><p><strong>输入描述:</strong><br>函数原型: int reverseAdd (int a, int b);<br><strong>输入:</strong><br>输入的a, b参数均为有效取值范围[1, 70000]区间上的正整数。100和200反转后的值为1和2 (前导0被忽略)<br><strong>输出描述:</strong><br> <strong>输出:</strong><br>通过函数返回值输出结果。<br>若输入的a或b参数超出了取值范围(小于1或者大于70000)，则应输出-1:否则应按照要求输出数字反转后的和。<br>注意:最终交付的函数代码中不要向控制台打印输出任何信息。<br><strong>输入样例:</strong><br>123, 456<br><strong>输出样例:</strong><br>975</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>想法就是把它变成String类型，再利用String类型的reverse()函数进行反转，再将其变成Integer类型进行运算</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> b = sr.nextInt();</span><br><span class="line">        reverseAdd(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">reverseAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((a&lt;=<span class="number">1</span> &amp;&amp; a&gt;=<span class="number">70000</span>) || (b&lt;=<span class="number">1</span> &amp;&amp; b&gt;=<span class="number">70000</span>))</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           String  str1 =<span class="keyword">new</span> StringBuilder(a +<span class="string">""</span>).reverse().toString();</span><br><span class="line">           String str2 =<span class="keyword">new</span> StringBuilder( b +<span class="string">""</span>).reverse().toString();</span><br><span class="line">           <span class="keyword">return</span> Integer.parseInt(str1) +Integer.parseInt(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消除重复数字"><a href="#消除重复数字" class="headerlink" title="消除重复数字"></a><code>消除重复数字</code></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个正整数，给出消除重复数字以后最大的整数<br><strong>输入描述:</strong><br>正整数，注意考虑长整数<br><strong>输出描述:</strong><br>消除重复数字以后的最大整数输入样例:423234输出样例:432</p></blockquote><h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：（垃圾选手第一式，复杂度高）</p><blockquote><ul><li>用list1存放出现一次的数字，用list2存放重复的数字。然后将他们放到优先队列自动排序，因为优先队列从小到大排序的，所以重写它的比较方法new Comparator()…,最后再依次将他们按顺序加到res里面</li></ul></blockquote><p>方法2：</p><blockquote><ul><li>桶排序思想，因为数字无疑就是0-9，所以创建一个长度为10的数组，将每个数字依次入桶。桶中不为空代表这个常整数有该值，然后将桶内的数依次拼凑成最大的数。count[0] ~count[9]依次存放0-9</li><li>设置一个list存放一共出现了几个不同的数了，当list.size == 10,代表所有数字都出现过了，后面再怎么出现的数都是重复的。可以提前终止while语句。</li></ul></blockquote><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">long</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放出现一次的数</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存放重复的数</span></span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (<span class="keyword">int</span>)a % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (!list1.contains(temp) &amp;&amp; !list2.contains(temp)) &#123;</span><br><span class="line">                list1.add(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list1.remove(Integer.valueOf(temp));</span><br><span class="line">                list2.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            a = a / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现Comparator,将优先队列从大到小排列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2-o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list1.size();i++)&#123;</span><br><span class="line">            queue.add(list1.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list2.size();i++)&#123;</span><br><span class="line">            queue.add(list2.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span> + queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//利用桶计数方法，判断哪个值出现过</span></span><br><span class="line">        <span class="keyword">int</span> count[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//用来计数，如果前面出现了0-9的所有数，则提前结束循环</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (a!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp =(<span class="keyword">int</span>) a%<span class="number">10</span>;</span><br><span class="line">            count[temp]++;</span><br><span class="line">            <span class="comment">//list里面存放没出现的值</span></span><br><span class="line">            <span class="keyword">if</span>(!list.contains(temp))&#123;</span><br><span class="line">                list.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否提前结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a = a / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果的生成</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = count.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                res = res*<span class="number">10</span> + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="仿LISP运算"><a href="#仿LISP运算" class="headerlink" title="仿LISP运算"></a><code>仿LISP运算</code></h2><h3 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp;LISP语言唯一的语法就是括号要配对。<br>&emsp;形如 (OP P1 P2 …)，括号内元素由单个空格分割。<br>&emsp;其中第一个元素OP为操作符，后续元素均为其参数，参数个数取决于操作符类型<br>&emsp;注意：参数 P1, P2 也有可能是另外一个嵌套的 (OP P1 P2 …)<br>&emsp;当前OP类型为add/sub/mul/div(全小写)，分别代表整数的加减乘除法。简单起见，所以OP参数个数为2<br><strong>举例</strong><br>&emsp;&emsp;输入：(mul 3 -7)输出：-21<br>&emsp;&emsp;输入：(add 1 2) 输出：3<br>&emsp;&emsp;输入：(sub (mul 2 4) (div 9 3)) 输出 ：5<br>&emsp;&emsp;输入：(div 1 0) 输出：error<br><strong>输入描述</strong>：<br>&emsp;&emsp;合法C字符串，字符串长度不超过512，用例保证了无语法错误<br><strong>输出描述</strong>：<br>&emsp;&emsp;合法C字符串，字符包括’0’-‘9’及负号’-‘或者’error’</p></blockquote><h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>按照题意模拟语法运算规则</p></blockquote><h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sr.nextLine();</span><br><span class="line">        solution(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; operStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> paramOne = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> paramTwo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> chas = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(chas == <span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="comment">//截取符号位</span></span><br><span class="line">                operStack.push(str.substring(i+<span class="number">1</span>,i+<span class="number">4</span>));</span><br><span class="line">                <span class="comment">//这里为空格的索引位置</span></span><br><span class="line">                i = i + <span class="number">4</span>;</span><br><span class="line">                <span class="comment">//符号位后第一个数字的索引坐标</span></span><br><span class="line">                mark = i+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(chas == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mark &lt; i)&#123;</span><br><span class="line">                    <span class="comment">//所有数字的截取</span></span><br><span class="line">                    numStack.push(Integer.valueOf(str.substring(mark,i)));</span><br><span class="line">                    i++;</span><br><span class="line">                    mark = i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//得到一次（）的对应，就进行一次计算</span></span><br><span class="line">                paramOne = numStack.pop();</span><br><span class="line">                paramTwo = numStack.pop();</span><br><span class="line">                calc(numStack,operStack,paramOne,paramTwo);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//空格位将数字进行区分</span></span><br><span class="line">                <span class="keyword">if</span>(chas == <span class="string">' '</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mark &lt; i )&#123;</span><br><span class="line">                        numStack.push(Integer.valueOf(str.substring(mark,i)));</span><br><span class="line">                        <span class="comment">//下一个数字的索引为空格后面一位，故mark = i+1;</span></span><br><span class="line">                        mark = i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果还有没计算完的，就进行再次计算</span></span><br><span class="line">        <span class="keyword">while</span> (!operStack.isEmpty())&#123;</span><br><span class="line">            paramTwo = numStack.pop();</span><br><span class="line">            paramOne = numStack.pop();</span><br><span class="line">            calc(numStack,operStack,paramOne,paramTwo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(Stack&lt;Integer&gt; numStack, Stack&lt;String&gt; operStack, <span class="keyword">int</span> paramOne, <span class="keyword">int</span> paramTwo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(operStack.pop())&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                numStack.push(paramOne + paramTwo);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sub"</span>:</span><br><span class="line">                numStack.push(paramOne - paramTwo);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"mul"</span>:</span><br><span class="line">                numStack.push(paramOne * paramTwo);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"div"</span>:</span><br><span class="line">                <span class="keyword">if</span>(paramTwo == <span class="number">0</span>)</span><br><span class="line">                    System.out.println(<span class="string">"error"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    numStack.push(paramOne / paramTwo);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目及代码整理自牛客技术资料<br>如有错误请指出！！</p>]]></content>
      
      
      <categories>
          
          <category> 笔试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019届百度秋招笔试题【混战世界】【字符串计数】</title>
      <link href="/2019/07/2019%E5%B1%8A%E7%99%BE%E5%BA%A6%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E6%B7%B7%E6%88%98%E4%B8%96%E7%95%8C%E3%80%91%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E6%95%B0%E3%80%91/"/>
      <url>/2019/07/2019%E5%B1%8A%E7%99%BE%E5%BA%A6%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E6%B7%B7%E6%88%98%E4%B8%96%E7%95%8C%E3%80%91%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E6%95%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="混战世界"><a href="#混战世界" class="headerlink" title="混战世界"></a><code>混战世界</code></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp;战乱年代。整个世界各个军阀的英团泄战，你是P7军团的战略参谋，你手下n(保证为3的倍数)个士兵，第i个土兵的物理攻击数值为Ai，魔法攻击数值为Bi，你需要将这些士兵三等分为三个连，<a id="more"></a></p><ul><li>第一个连需要去物理空间参加物理对抗战争，战斗力估值W1为士兵的物理攻击数值之和:</li><li>第二个连需要去魔法空间参加魔法对抗战争，战斗力估值W2为士兵的魔法攻击数值之和:</li><li>第三个连需要去虚幻空间参加物理魔法装备的综合对抗战争，战斗力估值W3为所有士兵的物理攻击数值、魔法攻击数值之和除以2。</li></ul><p>你希望W1+W2+W3最大。这样才最有可能胜利。<br><strong>输入描述:</strong><br>&emsp;第一行一个整数n，保证为3的倍数。(3≤n≤1000）<br>&emsp; 第二行n个整数， 第i个数表示Ai。<br>&emsp; 第三行n个整数，第i个数表示Bi。(I≤Ai，  Di≤1000)<br><strong>输出描述:</strong><br>&emsp;一个小数，表示最大数之和,保留两位小数(四舍五入)。<br><strong>输入样例:</strong><br>&emsp;6<br>&emsp;1   7   3   4   5   9<br>&emsp;2   3   9   4   3   3<br>输出样例:<br>&emsp;35.00</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>设一个人的物理值为A,魔法值为B.<br>派去一连可得A的贡献，二连可得B, 三连可得(A+B)/2。</p><ul><li>去一连与去三连相比差了(A-B)/2.去二连比去三连也差(A-B)/2。这样，可以根据每个人的A-B数值进行排序，</li><li>由题意可知，A越大越适合去1连，B越大越适合去2连，故（A-B）/2中，较大者1连，较小者去2连，中间的去3连。</li></ul></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int a[] = &#123;1,7,3,4,5,9&#125;;</span></span><br><span class="line"><span class="comment">//        int b[] = &#123;2,3,9,4,3,3&#125;;</span></span><br><span class="line"><span class="comment">//        System.out.println(String.format("%.2f",solution(a,b)));</span></span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> b[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          a[i] = sr.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          b[i] = sr.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        solution(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[])</span></span>&#123;</span><br><span class="line">        Diff []list= <span class="keyword">new</span> Diff[A.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            list[i] = <span class="keyword">new</span> Diff(i,A[i] - B[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//里面的list已经从小到大排序了</span></span><br><span class="line">        Arrays.sort(list);</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//取值,较小的去2连，中间的去三连，较大的去1连</span></span><br><span class="line">        <span class="keyword">int</span> Avglen = list.length/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">            <span class="comment">//（A-B）较小者去2连</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>&lt;=i &amp;&amp; i&lt;Avglen )&#123;</span><br><span class="line">                res += B[list[i].index];</span><br><span class="line">                <span class="comment">//（A-B）中间者去3连,这里注意要乘个1.0,避免除以2会强转为int型</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= Avglen &amp;&amp; i&lt; <span class="number">2</span> *Avglen )&#123;</span><br><span class="line">                res += ((A[list[i].index] + B[list[i].index])*<span class="number">1.0</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//(A-B)较大者去1连</span></span><br><span class="line">                res += A[list[i].index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.00"</span>);</span><br><span class="line">        System.out.println(df.format(res));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于存储索引坐标以及（Ai-Bi）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Diff</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Diff</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照（A-B）/2 进行排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">          Diff diff = (Diff) o;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">this</span>.value &gt; diff.value)</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.value == diff.value)</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190725102038741.png" alt="在这里插入图片描述"></p><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><blockquote><p>java里面保留数值的位数(四舍五人)<br>方法1：<br>  &emsp; &emsp;System.out.println(String.format(“%.2f”,num));<br> 方法2：<br>  &emsp; &emsp;DecimalFormat df = new DecimalFormat(“#.00”);<br> &emsp;  &emsp;System.out.println(df.format(num));</p></blockquote><h2 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a><code>字符串计数</code></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp; 给定一个仅由小写字母组成且长度不超过10^6的字符串，将首字符移到末尾并记录所得的字符串，不断重复该操作，虽然记录了无限个字符串，但其中不同字符串的数目却是有限的，那么一共记录了多少个不同的字符串？<br> &emsp;<strong>样例输入</strong><br>&emsp;&emsp; abab<br>&emsp;<strong>样例输出</strong><br>&emsp;&emsp; 2<br>&emsp;<strong>样例解释</strong><br>&emsp;&emsp; 记录了abab和baba这2个不同的字符串。</p></blockquote><h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：对字符串不断进行重组，对不同的字符串进行入队，最后返回队列的大小即为不同的字符串个数</p></blockquote><blockquote><p>方法2：利用kmp算法的next数组，可以求出字符串的最小循环周期T，这就是答案</p></blockquote><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sr.nextLine();</span><br><span class="line">        System.out.println(solution(str));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.trim().equals(<span class="string">""</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String temp = str;</span><br><span class="line">            list.add(str);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">                <span class="comment">//首字符移到末尾并记录所得的字符串，</span></span><br><span class="line">                temp = temp.substring(<span class="number">1</span>,temp.length())+temp.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//如果list里面没有该字符串则加入list</span></span><br><span class="line">                <span class="keyword">if</span>(!list.contains(temp))&#123;</span><br><span class="line">                    list.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>请检查是否存在数组越界等非法访问情况<br>case通过率为50.00%<br><br><br>不知道哪里错了。哭泣</p></blockquote><p>方法2：KMP算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sr.nextLine();</span><br><span class="line">        System.out.println(kmp(str));</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">int</span> [] next = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len )&#123;</span><br><span class="line">            <span class="keyword">if</span>(k== -<span class="number">1</span> || str.charAt(k) == str.charAt(j))&#123;</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀，这里next[len]表示len-1之前的模式串，即为str时,有k的相同的前缀和后缀</span></span><br><span class="line">        <span class="comment">//所以循环周期T为 总长度-相同前缀数</span></span><br><span class="line">        <span class="keyword">int</span> res = len % (len - next[len]);</span><br><span class="line">        <span class="keyword">if</span>(res != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> len-next[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019072510251487.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 笔试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> kmp算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019届爱奇艺秋招笔试题【局长的食物】【清雨的自助餐】【库特君的面条】</title>
      <link href="/2019/07/2019%E5%B1%8A%E7%88%B1%E5%A5%87%E8%89%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E5%B1%80%E9%95%BF%E7%9A%84%E9%A3%9F%E7%89%A9%E3%80%91%E3%80%90%E6%B8%85%E9%9B%A8%E7%9A%84%E8%87%AA%E5%8A%A9%E9%A4%90%E3%80%91%E3%80%90%E5%BA%93%E7%89%B9%E5%90%9B%E7%9A%84%E9%9D%A2%E6%9D%A1%E3%80%91/"/>
      <url>/2019/07/2019%E5%B1%8A%E7%88%B1%E5%A5%87%E8%89%BA%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E5%B1%80%E9%95%BF%E7%9A%84%E9%A3%9F%E7%89%A9%E3%80%91%E3%80%90%E6%B8%85%E9%9B%A8%E7%9A%84%E8%87%AA%E5%8A%A9%E9%A4%90%E3%80%91%E3%80%90%E5%BA%93%E7%89%B9%E5%90%9B%E7%9A%84%E9%9D%A2%E6%9D%A1%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="局长的食物"><a href="#局长的食物" class="headerlink" title="局长的食物"></a><code>局长的食物</code></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp; 每天局长会吃一份食物，或者买一份食物（即每天只能进行吃或买其中的一种动作），这样过了M天现在局长想知道M天后第p种食物的份数排名（从大到小，相同算并列，例如3 3 2，则排名为1 1 3）N,M,P&lt;=100,Ai&lt;=1000。<a id="more"></a><br><strong>输入描述</strong>：<br>&emsp;第一行N M P<br>&emsp;第二行N个数Ai<br>&emsp;接下来M行，每行Ai或者Bi分别表示买一份食物i，吃一份食物i<br><strong>输出</strong><br>&emsp;一个答案<br><strong>输入样例:</strong><br>&emsp;3 4 2 5 3 1 B 1 A 2 A 2 A 3<br><strong>输出样例</strong>：<br>&emsp;1</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：<br>&emsp;&emsp;&emsp;模拟吃东西的过程：关键在于吃一份食物还是买一份食物数据的存储方式，本次的数据存储方式为 List&lt;List&lt; String &gt; &gt;,注意后面的Integer.parseInt的转型。更好的方法是用对象存储<br>方法2：<br>&emsp;&emsp;&emsp; 用class存储数据</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1: 用List&lt;List&lt; String &gt; &gt;存储数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> M  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> P  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            a[i] = sr.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            List&lt;String&gt; temp= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            temp.add(sr.next());</span><br><span class="line">            temp.add(sr.next());</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(solution(list,P,a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">solution</span><span class="params">(List&lt;List&lt;String&gt;&gt; list, <span class="keyword">int</span> p, <span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="comment">// 买一份食物</span></span><br><span class="line">            <span class="keyword">if</span>(list.get(i).get(<span class="number">0</span>).equals( <span class="string">"A"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> index = Integer.parseInt(list.get(i).get(<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">                a[index] ++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//吃一份食物</span></span><br><span class="line">                <span class="keyword">int</span> index = Integer.parseInt(list.get(i).get(<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">                a[index] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第p种食物的份数排名</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p-<span class="number">1</span>]&lt;a[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190725105531311.png" alt="在这里插入图片描述"><br>方法2：用对象存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> <span class="keyword">import</span> java.util.List;</span><br><span class="line"> <span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> M  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> P  = sr.nextInt();</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            a[i] = sr.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Category&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> Category(sr.next(),sr.nextInt()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(solution(lists,P,a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">solution</span><span class="params">(List&lt;Category&gt; lists, <span class="keyword">int</span> p, <span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;lists.size();i++)&#123;</span><br><span class="line">            <span class="comment">//买一份食物</span></span><br><span class="line">            <span class="keyword">if</span>(lists.get(i).x.equals(<span class="string">"A"</span>))&#123;</span><br><span class="line">                a[lists.get(i).getIndex()-<span class="number">1</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//吃一份食物</span></span><br><span class="line">                a[lists.get(i).getIndex()-<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第p种食物的份数排名</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p-<span class="number">1</span>]&lt;a[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//存储 [A 2] 等数据</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Category</span></span>&#123;</span><br><span class="line">    String x;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Category</span><span class="params">(String x, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190725105625850.png" alt="在这里插入图片描述"></p><h2 id="清雨的自助餐"><a href="#清雨的自助餐" class="headerlink" title="清雨的自助餐"></a><code>清雨的自助餐</code></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>&emsp; 清雨又在吃自助餐了。<br>&emsp;排在清雨面前的有N种食物，排成一排，清雨可以选择其中的若干种食物，但是不能连续选择相邻的食物。因为清雨很挑食，当所有食物都不合口味时，他可以一种都不选，即一个都不选也算为一种方法。<br>请问他有多少种选择食物的方法呢？<br><strong>输入</strong><br>&emsp;一个整数n（1 &lt;= n &lt;= 90）<br><strong>输出</strong><br>&emsp;一个正整数表示答案<br><strong>样例输入</strong><br>&emsp;3<br><strong>样例输出</strong><br>&emsp;5</p></blockquote><h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><blockquote><p>动态规划问题：dp[i]表示有(i+1)种食物的时候有多少种选择的方法</p><ul><li>初始化<ul><li>dp[0]  = 2，表示有1种食物，可以选择吃或者不吃2种方法</li><li>dp[1] = 3,表示有两种食物，可以选择不吃，吃第一种，吃第二种 3种方法</li></ul></li><li>动态规划状态转移矩阵<ul><li>如果选这个食物(第i+1种食物)，则选择为dp[i-2]种选法，若不选择这个食物,则方法数为dp[i-1]{因为相邻而不能选}即</li><li>dp[i] = dp[i-2] + dp[i-1]; </li></ul></li></ul></blockquote><p>注：该题也可以用斐波那契数列的应用，只是初始值变了，具体参看剑指offer_【7】斐波那契数组:<a href="https://blog.csdn.net/qq_17556191/article/details/94436130" target="_blank" rel="noopener">https://blog.csdn.net/qq_17556191/article/details/94436130</a></p><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sr.nextInt();</span><br><span class="line">        System.out.println(solution(N));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> dp[] = <span class="keyword">new</span> <span class="keyword">long</span>[num];</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//只有一种食物，可以选择 吃 或者不吃2种方法</span></span><br><span class="line">            dp[<span class="number">1</span>] = <span class="number">3</span>;  <span class="comment">//有2种食物，选择 不吃 ，吃第一种食物，吃第二种食物。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num; i++) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[num - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/2019072510531954.png" alt="在这里插入图片描述"></p><h2 id="库特君的面条"><a href="#库特君的面条" class="headerlink" title="库特君的面条"></a><code>库特君的面条</code></h2><h3 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>题目描述：<br>库特君在吃面条！<br>&emsp;他将面条放在了数轴上，每根面条对应数轴上的两个点a和b，他想知道在任意两根面条不重叠(端点可以重叠）的情况下最多能选出多少根面条。<br>1 &lt;= n &lt;= 100<br>-999 &lt;= a<br><strong>输入描述：</strong><br>&emsp;&emsp;第一行为一个整数N<br>&emsp;&emsp;接下来，N行每行N个整数a和b<br><strong>输出描述：</strong><br>&emsp;&emsp;一个数的答案<br><strong>输出样例</strong>：<br>&emsp;&emsp;3   6  3  1  3  2  5<br><strong>输出样例：</strong><br>&emsp;&emsp;2</p></blockquote><h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>贪心算法的区间调度问题</p><ul><li>贪心策略：在不与已选区域重叠的前提下，优先选择右端点最小的区间，所以按照区间右端点排序后，依次检查，不重叠就选择，并更新已选区域的最右端，方便判断重叠。</li></ul><p>算法设计：</p><ul><li>如果被检查的活动i的开始时间小于最近选择的活动j的结束时间，则不选择活动i,否则选择活动i<ul><li>1.选择最早结束的面条，便是最开始要选择的没有重叠的第一根面条</li><li>2.选择第一根面条结束后[右端点值]才开始的第二根面条[该面条的左端点大于等于第一根面条的右端点]，并且此时右端点结束最早的面条，这将是要选择的第二根面条。</li><li>3.更新右端点值，重复以上。</li></ul></li></ul></blockquote><h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//贪心算法的区间调度问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sr.nextInt();</span><br><span class="line">        List&lt;Work&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = sr.nextInt();</span><br><span class="line">            <span class="keyword">int</span> x2 = sr.nextInt();</span><br><span class="line">            <span class="comment">//题目说了x1&lt;x2,但是给出的样例出现了问题，故用个if语句</span></span><br><span class="line">            <span class="keyword">if</span>(x1&lt;x2)</span><br><span class="line">                lists.add(<span class="keyword">new</span> Work(x1,x2));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lists.add(<span class="keyword">new</span> Work(x2,x1));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(solution(lists));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//解决方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(List&lt;Work&gt; works)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//works里面已经按end从小到大排序了，这时在将start进行排序，找到第一个要进行的工作</span></span><br><span class="line">        Collections.sort(works);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前工作的结束时间</span></span><br><span class="line">        <span class="keyword">int</span> endTime = works.get(<span class="number">0</span>).getEnd();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;works.size();i++)&#123;</span><br><span class="line">            <span class="comment">// 第二根面条的开始时间大于第一个面条的结束时间</span></span><br><span class="line">            <span class="keyword">if</span>(endTime&lt;=works.get(i).getStart())&#123;</span><br><span class="line">                <span class="comment">//这个面条可选，没有覆盖之前的面条</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//更新右端点</span></span><br><span class="line">                endTime = works.get(i).getEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//end 从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Work work = (Work) o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.end &gt; work.getEnd())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.end == work.getEnd())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190725103625192.png" alt="在这里插入图片描述"><br>题目整理自牛客技术篇<br>个人想法，如有错误请指出！！</p>]]></content>
      
      
      <categories>
          
          <category> 笔试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019届vivo秋招笔试题【字符串排序】【链表奇数位正序偶数位逆序】【最长回文子串】</title>
      <link href="/2019/07/2019%E5%B1%8Avivo%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E3%80%91%E3%80%90%E9%93%BE%E8%A1%A8%E5%A5%87%E6%95%B0%E4%BD%8D%E6%AD%A3%E5%BA%8F%E5%81%B6%E6%95%B0%E4%BD%8D%E9%80%86%E5%BA%8F%E3%80%91%E3%80%90%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E3%80%91/"/>
      <url>/2019/07/2019%E5%B1%8Avivo%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E9%A2%98%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E3%80%91%E3%80%90%E9%93%BE%E8%A1%A8%E5%A5%87%E6%95%B0%E4%BD%8D%E6%AD%A3%E5%BA%8F%E5%81%B6%E6%95%B0%E4%BD%8D%E9%80%86%E5%BA%8F%E3%80%91%E3%80%90%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a><code>字符串排序</code></h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><p>请对组字符串进行排序，字符串由大小写字母和数字组成，需要满足以下比较规则</p><ul><li>1、长度不同时，长度较短在排前面</li><li>2、长度相同时，按照字典顺序排列（AaBb-Zz, 0-9顺序)，即大写字母在小写字母前，数字排在字母后，要求时间复杂度为O(nlogn)。<a id="more"></a></li></ul><p>比如:<br> abc Abc 123 1bc CBD abed a<br>排序后结果为:<br>a  1  Abc abc  CBD 1bc 123 abcd</p><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>ASCII码：0-9（对应数值48-59）；A-Z（对应数值65-90）；a-z（对应数值97-122）；<br>排序为（AaBb-Zz, 0-9顺序),不符合常规字典排序，故这里我重新定义了ASCII码，因为A和a的ascii码相差32，这里定义A的ascii码为32，依次排序为<br>| 字符 | 重新定义的ASCII码 | 字符 | 重新定义的ASCII码 | 字符 | 重新定义的ASCII码 |<br>| — | — | — | — | — | — |<br>| A | 32 | L | 54 | v | 75 |<br>| a | 33 | l | 55 | W | 76 |<br>| B | 34 | M | 56 | w | 77 |<br>| b | 35 | m | 57 | X | 78 |<br>| C | 36 | N | 58 | x | 79 |<br>| c | 37 | n | 59 | Y | 80 |<br>| D | 38 | O | 60 | y | 81 |<br>| d | 39 | o | 61 | Z | 82 |<br>| E | 40 | P | 62 | z | 83 |<br>| e | 41 | p | 63 | 0 | 84 |<br>| F | 42 | Q | 64 | 1 | 85 |<br>| f | 43 | q | 65 | 2 | 86 |<br>| G | 44 | R | 66 | 3 | 87 |<br>| g | 45 | r | 67 | 4 | 88 |<br>| H | 46 | S | 68 | 5 | 89 |<br>| h | 47 | s | 69 | 6 | 90 |<br>| I | 48 | T | 70 | 7 | 91 |<br>| i | 49 | t | 71 | 8 | 92 |<br>| J | 50 | U | 72 | 9 | 93 |<br>| j | 51 | u | 73 |  |  |<br>| K | 52 | V | 74 |  |  |<br>| k | 53 |  |  |  |  |<br>故可以根据原来的ascii推出现在定义的ASCII码：</p><ul><li>(1) 假设字符为 A-Z,则有 ascii = (str1.charAt(i) - ‘A’) * 2 + 32;</li><li>(2) 假设字符为 a-z,则有 ascii = (str1.charAt(i) - ‘a’) * 2 + 33;</li><li>(3) 假设字符为 0-9,则有 ascii = str1.charAt(i) + 36;</li></ul><blockquote><p>(1) 用TreeSet存储字符串，因为TreeMap会自动给其排序<br>(2) 重写Compare方法，将其长度按照从小到大排序</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[]arr = &#123;<span class="string">"abc"</span>,<span class="string">"Abc"</span>,<span class="string">"123"</span>,<span class="string">"1"</span>,<span class="string">"1bc"</span>,<span class="string">"CBD"</span>,<span class="string">"abcd"</span>,<span class="string">"a"</span>&#125;;</span><br><span class="line">        Set strSet = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                String str1 = (String) o1;</span><br><span class="line">                String str2 = (String) o2;</span><br><span class="line">                <span class="keyword">int</span> temp = str1.length()-str2.length();</span><br><span class="line">                <span class="comment">//如果两个数组的长度相等则直接按字典序排列,但是这个字典序不是常规的[0-9 A-Z a-z ]</span></span><br><span class="line">                <span class="comment">//而是[AaBb-Zz 0-9]类型，故不能直接用str1.compareTo(str2)方法，要重新计算他的ascii码</span></span><br><span class="line">                <span class="comment">//如果两个数组的长度相等则直接按字典序排列</span></span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span>  t1=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span>  t2=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.length();i++)&#123;</span><br><span class="line">                        <span class="keyword">char</span> c1=str1.charAt(i);</span><br><span class="line">                        <span class="keyword">char</span> c2=str2.charAt(i);</span><br><span class="line">                        <span class="comment">//第一个字符串的新的ascii码计算</span></span><br><span class="line">                        <span class="comment">//A-Z范围，计算重新定义的ascii码 </span></span><br><span class="line">                        <span class="keyword">if</span>(c1&gt;=<span class="string">'A'</span>&amp;&amp;c1&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">                            t1 = (c1-<span class="string">'A'</span>) * <span class="number">2</span> + <span class="number">32</span>;</span><br><span class="line">                        <span class="comment">//a-z范围，计算重新定义的ascii码 </span></span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c1&gt;=<span class="string">'a'</span>&amp;&amp;c1&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">                            t1 = (c1-<span class="string">'a'</span>) * <span class="number">2</span> + <span class="number">33</span>;</span><br><span class="line">                        <span class="comment">//0-9范围，计算重新定义的ascii码 </span></span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c1&gt;=<span class="string">'0'</span>&amp;&amp;c1&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                            t1 = c1 + <span class="number">36</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//第二个字符串新的ascii计算</span></span><br><span class="line">                        <span class="keyword">if</span>(c2&gt;=<span class="string">'A'</span>&amp;&amp;c2&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">                            t2 = (c2 -<span class="string">'A'</span>) * <span class="number">2</span> + <span class="number">32</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c2&gt;=<span class="string">'a'</span>&amp;&amp;c2&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">                            t2 = (c2-<span class="string">'a'</span>) * <span class="number">2</span> + <span class="number">33</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c2&gt;=<span class="string">'0'</span>&amp;&amp;c2&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                            t2=c2 + <span class="number">36</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(t1!=t2)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> t1-t2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">// 字符串长度不等，直接返回长度较小的，从小到大的字符串排序</span></span><br><span class="line">                    <span class="keyword">return</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  return temp == 0 ?str1.compareTo(str2) : temp ;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            strSet.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Iterator it = strSet.iterator(); it.hasNext();)&#123;</span><br><span class="line">            System.out.print(it.next()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表奇数位正序偶数位逆序"><a href="#链表奇数位正序偶数位逆序" class="headerlink" title="链表奇数位正序偶数位逆序"></a><code>链表奇数位正序偶数位逆序</code></h2><h3 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>设C={a1, b1, a2, b2…an, bn}为线性表，采用带头结点的hc单链表存放，设计一个算法，将其拆分为两个线性表，使得奇数位保持正序，偶数位转化为逆序。即:<br>A = {a1，a2….an}, B= {bn….b2,b1)</p></blockquote><h3 id="2-解题思路-1"><a href="#2-解题思路-1" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><ul><li>用odd和head存放奇数位数值，head用于指针的移动和将数值的添加到链表尾部，odd代表以-1为节点的奇数位链表</li><li>用even和tail存放偶数位数值，tail用于指针的移动和将数值的添加到链表尾部，even代表以-1为节点的偶数位链表</li><li>odd.next即代表奇数位的线性表数值链起来的链表</li><li>even.next要进行链表反转，最后存到evenRes里面即代表偶数位的线性表数值链起来的链表</li></ul></blockquote><h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奇数位正序，偶数位逆序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next ;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(ListNode temp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//奇数（正序输出）</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode odd = head;</span><br><span class="line">        <span class="comment">//偶数（需要逆序输出）</span></span><br><span class="line">        ListNode tail = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode even = tail;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//奇数位head</span></span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> !=<span class="number">0</span>)&#123;</span><br><span class="line">                head.next = temp;</span><br><span class="line">                <span class="comment">//指针移动</span></span><br><span class="line">                temp  = temp.next;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//偶数位逆序</span></span><br><span class="line">                tail.next = temp;</span><br><span class="line">                <span class="comment">//指针移动</span></span><br><span class="line">                temp = temp.next;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个怎么说捏</span></span><br><span class="line">        <span class="comment">//假设是0--1--2--3</span></span><br><span class="line">        <span class="comment">//遍历到这的时候为  odd : -1 -- 0 -- 2 -- 3   even ： -1 -- 1 -- 3 ，所以要截断</span></span><br><span class="line">        <span class="comment">//反正 tail 或者 head 都会包含链表的最后一个值，有一个是不需要的。</span></span><br><span class="line">        tail.next =<span class="keyword">null</span>;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表反转</span></span><br><span class="line">        ListNode evenRes = reverseList(even.next);</span><br><span class="line">        System.out.print(<span class="string">"奇数位的排序为："</span>);</span><br><span class="line">        printRes(odd.next);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">"偶数位的排序为："</span>);</span><br><span class="line">        printRes(evenRes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表反转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = node;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next; <span class="comment">//记录下一个节点</span></span><br><span class="line">            cur.next = pre;  <span class="comment">//当前节点指向上一个节点</span></span><br><span class="line">            pre = cur;  <span class="comment">//记录当前节点</span></span><br><span class="line">            cur = next;  <span class="comment">//将下一个节点变成当前节点 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印结果</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRes</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(node.val+<span class="string">" "</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><code>最长回文子串</code></h2><h3 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>定义前后两端完全一致的字符串为对称字符串，如“abba”,”caddac”,编写程序，输出字符串”abcdefiiaaovivoovivcaideumncca”的最长对称子字符串。</p></blockquote><h3 id="2-解题思路-2"><a href="#2-解题思路-2" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>同leetcode_【5】最长回文子串：<a href="https://blog.csdn.net/qq_17556191/article/details/94620675" target="_blank" rel="noopener">https://blog.csdn.net/qq_17556191/article/details/94620675</a><br>题解：<br><a href="https://qiulig.github.io/%2F2019%2F05%2Fleetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F" target="_blank" rel="noopener">https://qiulig.github.io/%2F2019%2F05%2Fleetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</a><br>以下用动态规划重写：dp[i][j]代表的意思是索引从i到j的子字符串是否是回文，假设s = cbbd,则可以dp对应坐标索引下的子字符串：</p><blockquote><table><thead><tr><th></th><th>i = 0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>j = 0</td><td>c</td><td>cb</td><td>cbb</td><td>cbbd</td></tr><tr><td>1</td><td></td><td>b</td><td>bb</td><td>bbd</td></tr><tr><td>2</td><td></td><td></td><td>b</td><td>bd</td></tr><tr><td>3</td><td></td><td></td><td></td><td>d</td></tr><tr><td>1.动态规划初始化</td><td></td><td></td><td></td><td></td></tr><tr><td>- 对角线dp[i][i]:代表当前字符str.charAt(i),故初始化为true</td><td></td><td></td><td></td><td></td></tr><tr><td>- 相邻的两个字符初始化，两个字符相等就可以了。str.charAt(i) == str.charAt(j)</td><td></td><td></td><td></td></tr></tbody></table></blockquote><p>2.动态规划状态转移矩阵</p><blockquote><ul><li><p>假设要求dp[0][2]，首先还是要判断开头和结尾是否相等，也就是判断 str.charAt(0)==str.charAt(2)，假如此时str.charAt(0)==str.charAt(2)，我们还要再看剩下的子串是否回文， 我们可以直接从dp[i+1][j-1]来判断剩下的子串，把结果直接拿来用,判断是否是true（true表示回文）</p><p>即有公式</p><p>   dp[i][j] = dp[i+1][j-1] &amp;&amp;str.charAt(0)==str.charAt(2) ?true:false</p></li></ul></blockquote><h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"abcdefiiaaovivoovivcaideumncca"</span>;</span><br><span class="line">        solution(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> arr[] = str.toCharArray();</span><br><span class="line">        <span class="comment">//dp[i][j]代表i~j的字符串的回文长度</span></span><br><span class="line">        <span class="keyword">boolean</span> [][]dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[str.length()][str.length()];</span><br><span class="line">        <span class="comment">//初始化对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化相邻的两个字符是否为回文</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=arr.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = str.charAt(i) == str.charAt(i+<span class="number">1</span>)?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">2</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                    <span class="comment">//两端的数相等以及中间的数是回文</span></span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; str.charAt(i) == str.charAt(j) ? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] == <span class="keyword">true</span> &amp;&amp; j - i + <span class="number">1</span>&gt;max)&#123;</span><br><span class="line">                    max = j-i+<span class="number">1</span>;</span><br><span class="line">                    res = str.substring(i,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(max);</span></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理自牛客资料技术篇</p><p>个人想法，如有错误请指出！！</p>]]></content>
      
      
      <categories>
          
          <category> 笔试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】_leetcode刷题的各种股票问题</title>
      <link href="/2019/07/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91-leetcode%E5%88%B7%E9%A2%98%E7%9A%84%E5%90%84%E7%A7%8D%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91-leetcode%E5%88%B7%E9%A2%98%E7%9A%84%E5%90%84%E7%A7%8D%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-leetcode-121-买卖股票的最佳时机"><a href="#1-leetcode-121-买卖股票的最佳时机" class="headerlink" title="1.leetcode_121.买卖股票的最佳时机"></a>1.leetcode_121.买卖股票的最佳时机</h3><blockquote><p>&emsp; 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多<strong>只允许完成一笔交易</strong>（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><a id="more"></a><p>注意你不能在买入股票前卖出股票。<br>示例 1:<br> &emsp; <strong>输入:</strong><br>  &emsp;  &emsp; [7,1,5,3,6,4]<br> &emsp; <strong>输出:</strong><br>  &emsp;  &emsp;  5<br> &emsp;  &emsp; 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:<br> &emsp; <strong>输入:</strong><br>  &emsp;  &emsp; [7,6,4,3,1]<br> &emsp; <strong>输出:</strong><br>  &emsp;  &emsp;  0<br> &emsp;  &emsp; 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><h6 id="方法1"><a href="#方法1" class="headerlink" title="方法1:"></a>方法1:</h6><p> <img src="https://img-blog.csdnimg.cn/20190709165453991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="方法2：动态规划"><a href="#方法2：动态规划" class="headerlink" title="方法2：动态规划"></a>方法2：动态规划</h6><blockquote><p> dp[i][0]代表第i+1天没有持股票，dp[i][1]代表第i+1天持有股票</p><ul><li><p>初始化：</p><ul><li><p>dp[0][0] = 0;    &emsp;&emsp;&emsp;&ensp;&ensp; 第一天没有持股，这时候相当于没有买入，故为0</p><p> dp[0][1] = -prices[0];&emsp; 第一天持股，相当于买入，这时候为-pricrs[0]</p></li><li>状态转移方程：</li><li><p>没有持股 =max(昨天没有持股今天维持现状 , 昨天持股，今天卖出）</p><p>&emsp;  &emsp; &emsp; &emsp;<code>dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);</code>  </p></li><li><p>持股 = max(昨天持股今天维持现状，（之前没有交易，今天买入)）【因为只能完成一笔交易，故今天买入，则前面就相当于一直没有进行交易为利润为0】</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;<code>dp[i][1] = Math.max(dp[i-1][1], -1 * prices[i])</code></p></li></ul></li></ul></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p> 方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(minPrice&gt;prices[i])&#123;</span><br><span class="line">              minPrice = prices[i];</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxProfit&lt;prices[i] - minPrice)&#123;</span><br><span class="line">              maxProfit = prices[i] - minPrice;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxProfit;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> 方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">         dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求第(i+1)天持股或者不持股的最大收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">             dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">             dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], -<span class="number">1</span> * prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展1"><a href="#拓展1" class="headerlink" title="拓展1"></a>拓展1</h4><pre><code>以上题目中的“只允许完成一笔交易” 变成 “可以完成无数比交易”</code></pre><p> 同：leetcode-122:买卖股票的最佳时机 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/submissions/</a><br> 动态规划：</p><blockquote><p> dp[i][0]代表第i+1天没有持股票，dp[i][1]代表第i+1天持有股票</p><ul><li>初始化：<ul><li>dp[0][0] = 0; &emsp;&emsp; &emsp;  &emsp;            第一天没有持股，这时候相当于没有买入，故为0</li><li>dp[0][1] = -prices[0]; &emsp;  第一天持股，相当于买入，这时候为-prices[0]</li></ul></li></ul></blockquote><blockquote><ul><li><p>状态转移方程：</p><ul><li><p>没有持股 =max(昨天没有持股今天维持现状 , 昨天持股，今天卖出）</p><p>&emsp;&emsp;&emsp;<code>dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);</code>   //</p></li><li><p>持股 = max(昨天持股今天维持现状，（昨天没有持股，今天买入))【相对于之前，这里改变了】</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp; `dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]) ` </code></pre></li></ul></li></ul></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//求第(i+1)天持股或者不持股的最大收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="拓展2："><a href="#拓展2：" class="headerlink" title="拓展2："></a>拓展2：</h4><pre><code>在拓展1的基础上[可以完成无数比交易]，每次 sell 之后要等一天才能继续交易。</code></pre><p>同：leetcode-309:最佳买卖股票时机含冷冻期 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a><br> 动态规划：</p><blockquote><p> dp[i][0]代表第i+1天没有持股票，dp[i][1]代表第i+1天持有股票</p><ul><li>初始化：<ul><li>dp[0][0] = 0;   &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; //第1天没有持股，这时候相当于没有买入，故为0</li><li>dp[1][0] =Math.max(0,prices[1]-prices[0]); //第2天没有持股，这时候max(第一天没持股，第一天持股第二天卖出)</li><li>dp[0][1] = -prices[0];&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &ensp; //第1天持股维持，相当于买入，这时候为-prices[0]</li><li>dp[1][1] = Math.max(-prices[0],-prices[1]);//第2天持股，这时候max(第一天持股维持，第一天没持股第二天买入)</li></ul></li></ul></blockquote><blockquote><ul><li><p>状态转移方程：</p><ul><li><p>没有持股 =max(昨天没有持股今天维持现状 , (昨天持股，今天卖出))</p><p>&emsp;&emsp;&emsp; <code>dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);</code></p></li><li><p>持股 = max(昨天持股今天维持现状，（前天没有持股，今天买入))即：第i天要买的时候，要从前天的状态进行判断</p><p>&emsp;&emsp;&emsp;<code>dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);</code></p></li></ul></li></ul></blockquote><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit4</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(prices.length == <span class="number">0</span> ||prices.length == <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">      <span class="comment">//初始化</span></span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      dp[<span class="number">1</span>][<span class="number">0</span>] =Math.max(<span class="number">0</span>,prices[<span class="number">1</span>]-prices[<span class="number">0</span>]);</span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">      dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>],-prices[<span class="number">1</span>]);</span><br><span class="line">      <span class="comment">//动态规划</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">               dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">          dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">      <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="拓展3："><a href="#拓展3：" class="headerlink" title="拓展3："></a>拓展3：</h5><pre><code>每次买入交易要支付手续费。</code></pre><p> leetcode-714:买卖股票的最佳时机含手续费 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a><br>动态规划</p><blockquote><p> dp[i][0]代表第i+1天没有持股票，dp[i][1]代表第i+1天持有股票</p><ul><li><p>初始化：</p><ul><li><p>dp[0][0] = 0;      &emsp; &emsp; &emsp; &emsp;      第一天没有持股，这时候相当于没有买入，故为0</p><p> dp[0][1] = -prices[0] - fee; &emsp; 第一天持股，相当于买入，这时候为-prices[0] - fee ,本次以买入作为交易的开始，每次买入就扣除手续费，卖出的时候就不扣除手续费了。</p></li></ul></li></ul></blockquote><blockquote><ul><li><p>状态转移方程：</p><ul><li><p>没有持股 =max(昨天没有持股今天维持现状 , 昨天持股，今天卖出）【买入扣除手续费，卖出就不扣除了，因为买卖都完成才扣一次手续费】</p><p>&emsp; &emsp; <code>dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] + prices[i]);</code></p></li><li><p>持股 = max(昨天持股今天维持现状，（昨天没有持股，今天买入))</p><p>&emsp; &emsp; <code>dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i] - fee);</code></p></li></ul></li></ul></blockquote><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit5</span><span class="params">(<span class="keyword">int</span>[] prices,<span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]-fee;</span><br><span class="line">       <span class="comment">//求第(i+1)天持股或者不持股的最大收益</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">         dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">       <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="拓展4："><a href="#拓展4：" class="headerlink" title="拓展4："></a>拓展4：</h5><pre><code>以上题目中的“只允许完成一笔交易” 变成 “只允许完成2笔交易”</code></pre><p> 同： <a href="https://www.nowcoder.com/questionTerminal/3e8c66829a7949d887334edaa5952c28" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/3e8c66829a7949d887334edaa5952c28</a><br> 已调试通过<br> 同： leetcode-123. 买卖股票的最佳时机 III :<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/submissions/</a><br>动态规划</p><blockquote><p> dp[i][k][0]代表第i+1天交易k次并且没有持股票，dp[i][k][1]代表第i+1天交易k次并且持有股票</p><ul><li><p>初始化：</p><ul><li>dp[0][1][0] = 0; &emsp; &emsp;&emsp;&ensp;//第一天，交易次数为1，没持股，相当于就没买入</li><li>dp[0][1][1] = -prices[0];  //第一天，交易次数为1，持股，相当于买入股票</li><li>dp[0][2][0] = 0;   &emsp;&emsp;&emsp;&ensp;//第一天,交易次数为2，没持股，相当于买入卖出买入卖出，没有盈利</li><li>dp[0][2][1] = -prices[0];  //第一天，交易次数为2，持股，相当于买入再卖出（交易1次）再买入</li><li>状态转移方程：</li><li><p>第(i+1)天交易数为2，没持股 = max(前一天交易数为2没持股维持，前一天交易数为2持股今天卖出)</p><pre><code>&amp;emsp;&amp;emsp; &amp;emsp;`dp[i][2][0] = Math.max(dp[i-1][2][0],dp[i-1][2][1] + prices[i]);`</code></pre></li><li><p>第(i+1)天交易数为2，持股 = 前一天交易数为2持股维持，<strong>前一天交易数为1</strong>没持股今天买入[买入之前必须卖出，故之前交易数应该为1而不是为2]</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp;`dp[i][2][1] = Math.max(dp[i-1][2][1],dp[i-1][1][0] - prices[i]);`</code></pre></li><li><p>第(i+1)天交易数为1，没持股 = max(前一天交易数为1没持股维持，<strong>前一天交易数为1</strong>持股今天卖出)[卖出之前必须买入，故交易数为1而不是0]</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp;` dp[i][1][0] = Math.max(dp[i-1][1][0],dp[i-1][1][1] + prices[i]);`</code></pre></li><li><p>第(i+1)天交易数为1，持股 = max(前一天交易数为1持股维持，(没交易，今天买入))</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp; ` dp[i][1][1] = Math.max(dp[i-1][1][1],-1 * prices[i]);`</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="keyword">import</span> java.util.*;</span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">&gt;          <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">&gt;              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;        <span class="comment">//dp[i][k][0]代表第(i+1)天交易次数为k,没持股</span></span><br><span class="line">&gt;        <span class="keyword">int</span> dp[][][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">&gt;        <span class="comment">//初始化</span></span><br><span class="line">&gt;        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">&gt;        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">&gt;        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;   </span><br><span class="line">&gt;        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">&gt;            <span class="comment">//动态规划</span></span><br><span class="line">&gt;        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">&gt;            dp[i][<span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">&gt;            dp[i][<span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">&gt;            dp[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">&gt;            dp[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>],-<span class="number">1</span> * prices[i]);</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><h4 id="拓展5："><a href="#拓展5：" class="headerlink" title="拓展5："></a>拓展5：</h4><pre><code>以上题目中的“只允许完成一笔交易” 变成 “只允许完成k笔交易”</code></pre><p>leetcode-188: 买卖股票的最佳时机IV：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a><br>动态规划：</p><blockquote><p> dp[i][k][0]代表第i+1天交易k次并且没有持股票，dp[i][k][1]代表第i+1天交易k次并且持有股票</p><ul><li>初始化：<ul><li>dp[0][i][0] = 0;   【i为交易成交的笔数】即第一天,持续的买入卖出买入卖出，没收益</li><li>dp[0][i][1] = -prices[0]; 【i为交易成交的笔数】即第一天,持续的买入卖出买入，收益为买入的-prices[0]</li></ul></li></ul></blockquote><blockquote><ul><li><p>状态转移方程：</p><ul><li><p>第(i+1)天交易数为j，没持股 = max(前一天交易数为j没持股维持，前一天交易数为j持股今天卖出)</p><pre><code>&amp;emsp;&amp;emsp; &amp;emsp;`  dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);`</code></pre><ul><li><p>第(i+1)天交易数为j，持股 = max(前一天交易数为j持股维持，前一天交易数为j没持股今天买入)</p><pre><code>&amp;emsp;&amp;emsp;&amp;emsp; `dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i]);`</code></pre></li></ul></li></ul></li></ul></blockquote><p>答案超出内存限制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[][][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//第一天,买入卖出买入卖出，没收益</span></span><br><span class="line">           dp[<span class="number">0</span>][i][<span class="number">1</span>] = -prices[<span class="number">0</span>]; </span><br><span class="line">       &#125;</span><br><span class="line">         <span class="comment">//求第(i+1)天持股或者不持股的最大收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k;j &gt;= <span class="number">1</span>;j --) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>], dp[i-<span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][j][<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大利益肯定是那天没有持股时的利益</span></span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时间再想想，觉得思路应该是对的，但是这些题应该有更优的解法，动态规划时间复杂度还是有点高的。<br> 整理自：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/</a></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建型模式之【单例模式】【工厂模式】【原型模式】【建造者模式】</title>
      <link href="/2019/07/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
      <url>/2019/07/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E3%80%90%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%91%E3%80%90%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>    单例模式包括<br>    &emsp;（1）私有的构造方法<br>      &emsp;（2）含有一个该类的静态私有对象private static<br>     &emsp;（3）提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</p></blockquote><a id="more"></a><h3 id="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"><a href="#懒汉模式：全局的单例在第一次使用时构建（延迟初始化）" class="headerlink" title="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"></a>懒汉模式：全局的单例在第一次使用时构建（延迟初始化）</h3><p>&emsp;<strong>优点：</strong><br>        &emsp;&emsp;避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法。<br>     &emsp;<strong>缺点</strong>：<br>             &emsp; &emsp;懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉模式：全局的单例实例在类装载时构建"><a href="#饿汉模式：全局的单例实例在类装载时构建" class="headerlink" title="饿汉模式：全局的单例实例在类装载时构建"></a>饿汉模式：全局的单例实例在类装载时构建</h3><pre><code>&amp;emsp;&amp;emsp;1.线程安全   &amp;emsp;&amp;emsp;2.在类加载的同时已经创建好一个静态对象，调用时反应速度快  </code></pre><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><blockquote><p>资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h3><p>&emsp;&emsp;数据库连接池，多线程连接池。Windows应用管理器</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><ul><li>1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，<strong>确保所有的对象都访问一个实例</strong> </li><li>2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。  </li><li>3.<strong>提供了对唯一实例的受控访问</strong>。  </li><li>4.由于在系统内存中只存在一个对象，因此可以<strong>节约系统资源</strong>，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。  </li><li>5.允许可变数目的实例。  </li><li>6.<strong>避免对共享资源的多重占用。</strong></li></ul></blockquote><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>单例模式可能<strong>导致内存泄漏（OOM）</strong></p><ul><li>&emsp;1.<strong>不适用于变化的对象</strong>，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。  <ul><li>&emsp;2.由于单利模式中没有抽象层，因此单例类的<strong>扩展有很大的困难</strong>。  </li><li>&emsp;3.单例类的职责过重，在一定程度上<strong>违背了“单一职责原则”</strong>。  </li></ul></li><li>&emsp;4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li></ul></blockquote><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>&emsp;&emsp;定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的<strong>实例化延迟</strong>到其子类。<br>&emsp;&emsp;<strong>提供一个创建对象实例的功能，而无须关心其具体实现</strong>。被创建实例的类型可以是接口、抽象类，也可以是具体的类。工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。<!--more--></p><p><img src="https://img-blog.csdnimg.cn/20190717103842500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-简单工厂方法"><a href="#1-简单工厂方法" class="headerlink" title="1.简单工厂方法"></a>1.简单工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISample <span class="title">creator</span><span class="params">(<span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (which==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleA();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (which==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实例时</span></span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">1</span>);</span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="2-抽象工厂"><a href="#2-抽象工厂" class="headerlink" title="2.抽象工厂"></a>2.抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample <span class="title">creator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实现接口的实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleA</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2A</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//创建工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BombFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleB</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><blockquote><p>&emsp;1、可以一定程度上<strong>解耦</strong>，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。<br>&emsp;2、可以一定程度<strong>增加扩展性</strong>，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。<br>&emsp;3、可以一定程度<strong>增加代码的封装性、可读性</strong>。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。  </p><!--more--></blockquote><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>&emsp;&emsp;每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上<strong>增加了系统的复杂度，同时也增加了系统具体类的依赖</strong>。</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>&emsp;1、<strong>日志记录器</strong>：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </p><p>&emsp;2、<strong>数据库访问</strong>，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </p><p>&emsp;3、<strong>设计一个连接服务器的框架</strong>，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p></blockquote><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>&emsp;&ensp;创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是<strong>从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节</strong>。<!--more--></p><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1.浅拷贝"></a>1.浅拷贝</h3><blockquote><ul><li>对类实现Cloneable接口（implements Cloneable），并且重写clone</li><li>对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象.</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Realizetype()&#123;</span><br><span class="line">    System.out.println(<span class="string">"具体原型创建成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2.深拷贝"></a>2.深拷贝</h3><blockquote><ul><li>对其中的引用类型的成员变量进行实现Cloneable接口，重写clone，就变成深拷贝了</li><li>对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">     String name;</span><br><span class="line"></span><br><span class="line">     String <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><blockquote><p>&emsp;1.如果创建新的对象比较复杂时，可以利用<strong>原型模式简化对象的创建过程</strong>。<br>&emsp;2.使用原型模式创建对象比直接 new 一个对象在<strong>性能</strong>上要好的多，因为 Object 类的 clone 方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p><strong>在需要重复地创建相似对象时可以考虑使用原型模式</strong>。</p><p>&emsp;&emsp;比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。</p></blockquote><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>&emsp;&emsp;将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示</p><!--more--><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol><li><strong>产品角色</strong>（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。</li><li><strong>抽象建造者</strong>（Builder）：它是一个包含创建产品各个子部件的抽象方法的<strong>接口</strong>，通常还包含一个返回复杂产品的方法 getResult()。</li><li><strong>具体建造者</strong>(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li><strong>指挥者</strong>（Director）：构建一个使用builder接口的对象。它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>&emsp;&emsp;主要用于创建一些复杂的对象，这些对象内部间的建造顺序是稳定的，但对象内部的构建通常面临着复杂的变化。</p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>&emsp;（1）使得建造代码与表示代码分离，由于建造者隐藏了产品如何组装，所以若需要改变一个产品内部表示，只需要在定义一个具体的建造者就可以了。</p><p>&emsp;（2） 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</p><p>&emsp;（3）<strong>增加新的具体建造者无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统扩展方便，符合 <strong>“开闭原则”</strong></p><p>&emsp;（4）<strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的涉及的题</title>
      <link href="/2019/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B6%89%E5%8F%8A%E7%9A%84%E9%A2%98/"/>
      <url>/2019/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B6%89%E5%8F%8A%E7%9A%84%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line">       TreeNode(<span class="keyword">int</span> x) &#123; </span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-二叉树的最大深度"><a href="#1-二叉树的最大深度" class="headerlink" title="1.二叉树的最大深度"></a>1.二叉树的最大深度</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left =  maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-二叉树的最小深度"><a href="#2-二叉树的最小深度" class="headerlink" title="2.二叉树的最小深度"></a>2.二叉树的最小深度</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((root.left == <span class="keyword">null</span>) &amp;&amp; (root.right == <span class="keyword">null</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> minDepth = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">           minDepth = Math.min(minDepth, minDepth(root.left));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           minDepth = Math.min(minDepth, minDepth(root.right));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> minDepth + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="3-求完全二叉树中节点的个数"><a href="#3-求完全二叉树中节点的个数" class="headerlink" title="3..求完全二叉树中节点的个数"></a>3..求完全二叉树中节点的个数</h2><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">int</span> left = countNodes(root.left);</span><br><span class="line">       <span class="keyword">int</span> right = countNodes(root.right);</span><br><span class="line">       <span class="keyword">return</span> left+right +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4. 平衡二叉树"></a>4. 平衡二叉树</h2><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(getDepth(root.left)-getDepth(root.right))&lt;=<span class="number">1</span>)&#123;      </span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp;isBalanced(root.right);   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-二叉树的完全性检验"><a href="#5-二叉树的完全性检验" class="headerlink" title="5.二叉树的完全性检验"></a>5.二叉树的完全性检验</h2><p><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//加入根节点</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">boolean</span> hasNoChild = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (hasNoChild) &#123;</span><br><span class="line">                <span class="comment">//上一层中左子树不为空，右子树为空，如果遍历到左子树，这时候左子树有孩子，则代表上一层不完全填满</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span> || node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;  <span class="comment">//左右子树不为空</span></span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123; <span class="comment">//左子树不为空,右子树为空</span></span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                    hasNoChild = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;<span class="comment">//左子树为空，右子树不为空</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//左右子树都为空</span></span><br><span class="line">                    hasNoChild = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-相同的树"><a href="#6-相同的树" class="headerlink" title="6.相同的树"></a>6.相同的树</h2><p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> ||q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val !=q.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-对称二叉树"><a href="#7-对称二叉树" class="headerlink" title="7.对称二叉树"></a>7.对称二叉树</h2><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Symmetric</span><span class="params">(TreeNode leftroot,TreeNode rightroot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> &amp;&amp; rightroot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> || rightroot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot.val != rightroot.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(leftroot.left,rightroot.right) &amp;&amp; Symmetric(leftroot.right,rightroot.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node1 = queue.poll();</span><br><span class="line">            TreeNode node2 = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> &amp;&amp; node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> || node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">if</span>(node1.val!=node2.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            queue.add(node1.left);</span><br><span class="line">            queue.add(node2.right);</span><br><span class="line">            queue.add(node1.right);</span><br><span class="line">            queue.add(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-翻转二叉树"><a href="#8-翻转二叉树" class="headerlink" title="8.翻转二叉树"></a>8.翻转二叉树</h2><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-二叉搜索树的最近公共祖先"><a href="#9-二叉搜索树的最近公共祖先" class="headerlink" title="9.二叉搜索树的最近公共祖先"></a>9.二叉搜索树的最近公共祖先</h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//都在右子树</span></span><br><span class="line">        <span class="keyword">if</span>(p.val &gt;root.val &amp;&amp; q.val &gt;root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val&lt;root.val &amp;&amp; q.val &lt;root.val)&#123; <span class="comment">//都在左子树</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//一个在左子树，一个在右子树</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-二叉树的最近公共祖先"><a href="#10-二叉树的最近公共祖先" class="headerlink" title="10.二叉树的最近公共祖先"></a>10.二叉树的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span> || root==p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">return</span> left==<span class="keyword">null</span> ? right : right == <span class="keyword">null</span>?left:root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-最深叶节点的最近公共祖先"><a href="#11-最深叶节点的最近公共祖先" class="headerlink" title="11.最深叶节点的最近公共祖先"></a>11.最深叶节点的最近公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="comment">//如果左右子树深度相同，表示获取到了最深叶子节点的最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//如果左右子树不等高，高度小的那个子树节点的叶子节点的深度肯定不是最深的（因为比高度大的子树深度小）。</span></span><br><span class="line">        <span class="comment">//所以，最深叶子节点肯定在深度较大的子树当中，采用深度优先搜索，每次只要继续往深度更大的子树进行递归即可。</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> lcaDeepestLeaves(root.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lcaDeepestLeaves(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-节点与其祖先中间的最大差值"><a href="#12-节点与其祖先中间的最大差值" class="headerlink" title="12.节点与其祖先中间的最大差值"></a>12.节点与其祖先中间的最大差值</h2><p><a href="https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> AncestorDiff(root,root.val,root.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每条从根节点到叶子节点的路径中的最大值和最小值，并求出差值更新全局变量</span></span><br><span class="line">    <span class="comment">//一口气遍历到叶子节点，遍历的时候动态保存当前路径的最大节点值和最小节点值</span></span><br><span class="line">    <span class="comment">//每当遍历一次叶子节点，将保存好的最大值与最小值之间的差与全局变量 maxvalue 比较，并且取较大值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">AncestorDiff</span><span class="params">(TreeNode root, <span class="keyword">int</span> max_value, <span class="keyword">int</span> min_value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> max_value-min_value;</span><br><span class="line">        max_value = root.val &gt; max_value ? root.val : max_value;</span><br><span class="line">        min_value = root.val &lt; min_value ? root.val : min_value;</span><br><span class="line">        <span class="keyword">return</span> Math.max(AncestorDiff(root.left,max_value,min_value),AncestorDiff(root.right,max_value,min_value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-从前序与中序遍历序列构造二叉树"><a href="#13-从前序与中序遍历序列构造二叉树" class="headerlink" title="13.从前序与中序遍历序列构造二叉树"></a>13.从前序与中序遍历序列构造二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//前序的第一个数即为树的根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序中的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">                <span class="comment">//pre[1,i+1] 和in[0,i]构成左子树的遍历</span></span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                <span class="comment">//pre[i+1,len-1]和in[i+1,len-1]构成右子树的遍历</span></span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-从中序与后序遍历序列构造二叉树"><a href="#14-从中序与后序遍历序列构造二叉树" class="headerlink" title="14.从中序与后序遍历序列构造二叉树"></a>14.从中序与后序遍历序列构造二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.length == <span class="number">0</span>||postorder.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//后序的最后一个为根结点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="comment">//找到中序中的根节点位置</span></span><br><span class="line">                <span class="keyword">if</span>(inorder[i] == postorder[postorder.length-<span class="number">1</span>])&#123;</span><br><span class="line">                  <span class="comment">//in[0,i]和pos[0,i-1]构成左子树的遍历</span></span><br><span class="line">                    root.left = buildTree(Arrays.copyOfRange(inorder,<span class="number">0</span>,i),Arrays.copyOfRange(postorder,<span class="number">0</span>,i));</span><br><span class="line">                     <span class="comment">//in[i+1,len-1]和pos[i,len-2]构成左子树的遍历</span></span><br><span class="line">                    root.right = buildTree(Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length),Arrays.copyOfRange(postorder,i,postorder.length-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-把二叉树转换成累加树"><a href="#15-把二叉树转换成累加树" class="headerlink" title="15.把二叉树转换成累加树"></a>15.把二叉树转换成累加树</h2><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历结果为从小到大，要变成累加树，则中序遍历反过来相加变成节点值即可。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//遍历右子树</span></span><br><span class="line">           convertBST(root.right);</span><br><span class="line">           <span class="comment">//改变值，依次累加即可</span></span><br><span class="line">           root.val = root.val+num;</span><br><span class="line">           <span class="comment">//存储上一层的值</span></span><br><span class="line">           num = root.val;</span><br><span class="line">           <span class="comment">//遍历左子树</span></span><br><span class="line">           convertBST(root.left);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-不同的二叉搜索树"><a href="#16-不同的二叉搜索树" class="headerlink" title="16.不同的二叉搜索树"></a>16.不同的二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br>动态规划</p><ul><li><p>初始化</p><p>假设n个节点存在二叉搜索树的个数是dp（n）,令f(i) 为以i为根的二叉搜索树的个数，则有</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;  <code>dp(n) = f(1) + f(2) + f(3) +... + f(n)</code></p><p>当i为根节点时，其左子树的个数为(i - 1),右子树的个数为（n-i）,则</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;  <code>f(i) = dp(i-1) *dp(n-i)</code></p><p>结合两个式子可以得到卡特兰数：</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp; <code>dp(n) = dp(0) *dp(n-1) +dp(1) *dp(n-2) +... +dp(n-1)</code>*dp(0)</p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;&emsp; &emsp; &ensp; <code>= dp(n-1) * C(2n,n)</code></p><p>&emsp;&emsp; &emsp; &emsp; &emsp; &emsp;&emsp; &emsp; &ensp; <code>= dp(n-1) * (4*n-2)/(n-1)</code></p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n个节点存在二叉树的个数</span></span><br><span class="line">        <span class="keyword">long</span> []dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//以i为根节点的二叉树个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//以0为根节点的</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]*(<span class="number">4</span>*i-<span class="number">2</span>)/(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-不同的二叉搜索树-II"><a href="#17-不同的二叉搜索树-II" class="headerlink" title="17.不同的二叉搜索树 II"></a>17.不同的二叉搜索树 II</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees=generate(start,i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归遍历右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees=generate(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//先序遍历存入以i为根节点的二叉搜索树</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left:leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right:rightTrees)&#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left=left;</span><br><span class="line">                    root.right=right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-在二叉树中增加一行"><a href="#18-在二叉树中增加一行" class="headerlink" title="18.在二叉树中增加一行"></a>18.在二叉树中增加一行</h2><p><a href="https://leetcode-cn.com/problems/add-one-row-to-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-one-row-to-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">           TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">           <span class="comment">//如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</span></span><br><span class="line">            <span class="keyword">if</span>(d == <span class="number">1</span>)&#123;</span><br><span class="line">                node.left = root;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d == <span class="number">0</span>)&#123;</span><br><span class="line">                node.right = root;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; d&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                root.left = addOneRow(root.left ,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">                root.right = addOneRow(root.right,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-验证一棵树是不是二叉搜索树"><a href="#19-验证一棵树是不是二叉搜索树" class="headerlink" title="19.验证一棵树是不是二叉搜索树"></a>19.验证一棵树是不是二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据二叉搜索树的中序遍历为从小到大的思路写的</span></span><br><span class="line"><span class="comment">//修改一下二叉搜索树的非递归写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">double</span> inorder = - Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt;= inorder)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root.val;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的【前序遍历】【中序遍历】【后序遍历】【层遍历】【BFS】【DFS】</title>
      <link href="/2019/07/%E6%A0%91%E7%9A%84%E3%80%90%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%B1%82%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90BFS%E3%80%91%E3%80%90DFS%E3%80%91/"/>
      <url>/2019/07/%E6%A0%91%E7%9A%84%E3%80%90%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%B1%82%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90BFS%E3%80%91%E3%80%90DFS%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="二叉树的数据结构"><a href="#二叉树的数据结构" class="headerlink" title="二叉树的数据结构"></a>二叉树的数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line">       TreeNode(<span class="keyword">int</span> x) &#123; </span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-二叉树的前序遍历"><a href="#1-二叉树的前序遍历" class="headerlink" title="1.二叉树的前序遍历"></a>1.二叉树的前序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.62%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.1 MB, 在所有 Java 提交中击败了40.72%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**依次将每层的结点入栈，入栈顺序是右--左，方便弹出时出栈为左---右**/</span></span><br><span class="line">     <span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了6.05%的用户</span></span><br><span class="line">    <span class="comment">//内存消耗 :35 MB, 在所有 Java 提交中击败了40.72%的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">//入栈下一层的右节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入栈下一层的左节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加入根节点</span></span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-二叉树的中序遍历"><a href="#2-二叉树的中序遍历" class="headerlink" title="2.二叉树的中序遍历"></a>2.二叉树的中序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.55%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :34.7 MB, 在所有 Java 提交中击败39.5的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">              inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了55.11%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.1 MB, 在所有 Java 提交中击败了39.36%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            TreeNode cur = root;</span><br><span class="line">            <span class="keyword">while</span> (cur!=<span class="keyword">null</span> ||!stack.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//循环直到找到最左子树</span></span><br><span class="line">                <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(cur);</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                ans.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="3-二叉树的后序遍历"><a href="#3-二叉树的后序遍历" class="headerlink" title="3. 二叉树的后序遍历"></a>3. 二叉树的后序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :1 ms, 在所有 Java 提交中击败了99.71%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.6 MB, 在所有 Java 提交中击败了36.80%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(root.left !=<span class="keyword">null</span>)</span><br><span class="line">            postorderTraversal(root.left);</span><br><span class="line">         <span class="keyword">if</span>(root.right !=<span class="keyword">null</span>)</span><br><span class="line">            postorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了61.53%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :35.8 MB, 在所有 Java 提交中击败了35.50%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里先加入根结点</span></span><br><span class="line">    stack.addLast(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      TreeNode node = stack.pollLast();</span><br><span class="line">      <span class="comment">//在res的头部添加，依次添加的为 根，然后再添加为 右--根，再添加为左--右--根</span></span><br><span class="line">      res.addFirst(node.val);  </span><br><span class="line">      <span class="comment">//在stack中依次加入左--右，方便下次先弹出右子树，再弹出左子树</span></span><br><span class="line">      <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.addLast(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.addLast(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-二叉树的层序遍历"><a href="#4-二叉树的层序遍历" class="headerlink" title="4.二叉树的层序遍历"></a>4.二叉树的层序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了90.77%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :37 MB, 在所有 Java 提交中击败了43.02%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() == level)</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        ans.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了58.74%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :36.7 MB, 在所有 Java 提交中击败了43.83%的用户</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//用于存一层的结果</span></span><br><span class="line">           ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="comment">//这一层的结点个数</span></span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count;i++)&#123;</span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               <span class="comment">//存入下一层的左右子树</span></span><br><span class="line">               <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               <span class="comment">//添加当前层的值到tmp    </span></span><br><span class="line">               tmp.add(node.val);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将一层的结果存到结果集中</span></span><br><span class="line">           res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-二叉树的深度优先遍历"><a href="#5-二叉树的深度优先遍历" class="headerlink" title="5.二叉树的深度优先遍历"></a>5.二叉树的深度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ans.add(root.val);</span><br><span class="line">               DFS(root.left);</span><br><span class="line">               DFS(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">//先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-二叉树的广度优先遍历"><a href="#6-二叉树的广度优先遍历" class="headerlink" title="6.二叉树的广度优先遍历"></a>6.二叉树的广度优先遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> res;</span><br><span class="line">         Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">         queue.add(root);</span><br><span class="line">         <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">             TreeNode node = queue.poll();</span><br><span class="line">             <span class="comment">////先往queue中压入左节点，再压右节点。</span></span><br><span class="line">             <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.left);</span><br><span class="line">             <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.right);</span><br><span class="line">             res.add(node.val);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="N叉树的数据结构"><a href="#N叉树的数据结构" class="headerlink" title="N叉树的数据结构"></a>N叉树的数据结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-N叉树的前序遍历"><a href="#1-N叉树的前序遍历" class="headerlink" title="1. N叉树的前序遍历"></a>1. N叉树的前序遍历</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了88.62%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :52.2 MB, 在所有 Java 提交中击败了78.78%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加根</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">//递归孩子结点</span></span><br><span class="line">        <span class="keyword">for</span>(Node node:root.children)&#123;</span><br><span class="line">            preorder(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :8 ms, 在所有 Java 提交中击败了28.21%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :54.5 MB, 在所有 Java 提交中击败了64.22%的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Stack&lt;Node&gt; stack= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Node node = stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.children.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//stack从右到左入栈，以达到弹出先弹左子树再弹右子树</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = node.children.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    stack.add(node.children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-N叉树的中序遍历"><a href="#2-N叉树的中序遍历" class="headerlink" title="2. N叉树的中序遍历"></a>2. N叉树的中序遍历</h2><p> &emsp;&emsp;&emsp;&emsp;没找到相关题，略过~~~</p><h2 id="3-N叉树的后序遍历"><a href="#3-N叉树的后序遍历" class="headerlink" title="3. N叉树的后序遍历"></a>3. N叉树的后序遍历</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了90.67%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :58.9 MB, 在所有 Java 提交中击败了25.73%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(Node node : root.children)&#123;</span><br><span class="line">            postorder(node);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Node node = stack.pollLast();</span><br><span class="line">           <span class="comment">//在res的头部添加，依次添加的为 根，然后再添加为 右--根，再添加为左--右--根</span></span><br><span class="line">            res.addFirst(node.val);</span><br><span class="line">            <span class="comment">//判断是否有孩子结点</span></span><br><span class="line">            <span class="keyword">if</span>(node.children.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//从左到右依次入栈，方便后面先取出右子树</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;node.children.size();i++)&#123;</span><br><span class="line">                    stack.addLast(node.children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-N叉树的层序遍历"><a href="#4-N叉树的层序遍历" class="headerlink" title="4. N叉树的层序遍历"></a>4. N叉树的层序遍历</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了98.57%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :58.8 MB, 在所有 Java 提交中击败了40.01%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == level)</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        res.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.children.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Node node : root.children)</span><br><span class="line">                 helper(node,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :7 ms, 在所有 Java 提交中击败了64.89的用户</span></span><br><span class="line">    <span class="comment">//内存消耗 :52.6 MB, 在所有 Java 提交中击败了79.34%的用户</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//用于存上一层的结果</span></span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//这一层的结点个数</span></span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                <span class="comment">//添加当前层的值到tmp    </span></span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">//存入下一层的孩子</span></span><br><span class="line">                <span class="keyword">if</span>(node.children.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;node.children.size();j++)&#123;</span><br><span class="line">                        queue.add(node.children.get(j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将一层的结果存到结果集中</span></span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法-【全排列】【组合总和】【n皇后】【子集】</title>
      <link href="/2019/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E3%80%90%E5%85%A8%E6%8E%92%E5%88%97%E3%80%91%E3%80%90%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E3%80%91%E3%80%90n%E7%9A%87%E5%90%8E%E3%80%91%E3%80%90%E5%AD%90%E9%9B%86%E3%80%91/"/>
      <url>/2019/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E3%80%90%E5%85%A8%E6%8E%92%E5%88%97%E3%80%91%E3%80%90%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E3%80%91%E3%80%90n%E7%9A%87%E5%90%8E%E3%80%91%E3%80%90%E5%AD%90%E9%9B%86%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>&emsp;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。即从一条路往前走，能进则进，不能进则退回来，换一条路再试。<a id="more"></a></p><h2 id="如何使用回溯算法"><a href="#如何使用回溯算法" class="headerlink" title="如何使用回溯算法"></a>如何使用回溯算法</h2><p>&emsp;回溯我认为也就是一种递归，有以下四个参数，当然不一定是我所举例的类型，要看题目而定<br>&emsp;&emsp;(1)一个全局变量集合保存所有满足条件的答案，举例：List&lt;List<integer>&gt; res<br>&emsp;&emsp;(2)一个集合保存一个满足条件的答案，举例：List<integer> tmpList<br>核心：根据各个题情况变换<br><!--more--><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//add进去的值根据题意变换</span></span><br><span class="line">              tmplist.add(i);</span><br><span class="line">              <span class="comment">//递归,这里根据题意变换回溯，这仅仅是个例子</span></span><br><span class="line">              backtrack( k - <span class="number">1</span>, n, i+<span class="number">1</span>,tmplist, result);</span><br><span class="line">              <span class="comment">//将这个集合清空，方便下一个满足条件的答案</span></span><br><span class="line">              tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></integer></integer></p><h2 id="leetcode-【46】全排列-I"><a href="#leetcode-【46】全排列-I" class="headerlink" title="leetcode_【46】全排列 I"></a>leetcode_【46】全排列 I</h2><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p><blockquote><p><strong>题目描述：</strong><br>   &emsp;给定一个没有重复数字的序列，返回其所有可能的全排列。<br><strong>输入：</strong><br>&emsp;&emsp;[1,2,3]<br><strong>输出：</strong><br>&emsp;&emsp;[<br> &emsp;&emsp; [1,2,3],<br> &emsp;&emsp; [1,3,2],<br> &emsp;&emsp; [2,1,3],<br> &emsp;&emsp; [2,3,1],<br>&emsp;&emsp;  [3,1,2],<br> &emsp;&emsp; [3,2,1]<br>&emsp;&emsp; ]</p></blockquote><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>&emsp; 回溯算法：</p><blockquote><ul><li>将第j个数字与第 j , j +1 , j + 2 ,…, len(nums) - 1个数字分别交换，得到 len(nums) - j 种情况；</li><li>在每种情况下递归，将第j+1处数字与第j+1,j+2,…,len(nums) - 1处数字分别交换；<ul><li>每个递归跳出后，要将交换过的元素还原，这样才能实现第一条所说的内容。<ul><li>直到j == len(nums) - 1，代表此种交换组合下已经交换完毕，记录答案。</li></ul></li></ul></li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p> 第一版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//执行用时 :41 ms, 在所有 Java 提交中击败了5.01%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :44.4 MB, 在所有 Java 提交中击败了5.03%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        permute(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,ArrayList&lt;Integer&gt; tempList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//start为左边界值，要跟右边界的数进行交换</span></span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(tempList))&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//将第j个数字与第 j , j +1 , j + 2 ,..., len(nums) - 1个数字分别交换</span></span><br><span class="line">            swap(nums,start,i);</span><br><span class="line">            tempList.add(nums[start]);</span><br><span class="line">            backTrace(nums,start+<span class="number">1</span>,tempList,res);</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 每个递归跳出后，要将交换过的元素还原</span></span><br><span class="line">            swap(nums,start,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">        nums[start] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二版：leetcode官网解答</p><blockquote><p>这里有一个回溯函数，使用第一个整数的索引作为参数 backtrack(first)。</p><ul><li>如果第一个整数有索引 n，意味着当前排列已完成。</li><li>遍历索引 first 到索引 n - 1 的所有整数。<ul><li>在排列中放置第 i 个整数， 即 swap(nums[first], nums[i]).</li><li>继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).</li><li>现在回溯，即通过 swap(nums[first], nums[i]) 还原.</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了87.64%的用户</span></span><br><span class="line"> <span class="comment">//内存消耗 :38.5 MB, 在所有 Java 提交中击败了67.89%的用户</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n,ArrayList&lt;Integer&gt; nums, List&lt;List&lt;Integer&gt;&gt; output, <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一个整数有索引 n，意味着当前排列已完成。</span></span><br><span class="line">        <span class="keyword">if</span> (first == n)</span><br><span class="line">            output.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(nums));</span><br><span class="line">        <span class="comment">// 遍历索引 first 到索引 n - 1 的所有整数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//在排列中放置第 i 个整数</span></span><br><span class="line">            Collections.swap(nums, first, i);</span><br><span class="line">            <span class="comment">//  继续生成从第 i 个整数开始的所有排列</span></span><br><span class="line">             backtrack(n, nums, output, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            Collections.swap(nums, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert nums into list since the output is a list of lists</span></span><br><span class="line">        ArrayList&lt;Integer&gt; nums_lst = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            nums_lst.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        backtrack(n, nums_lst, output, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【47】全排列-II"><a href="#leetcode-【47】全排列-II" class="headerlink" title="leetcode_【47】全排列 II"></a>leetcode_【47】全排列 II</h2><p> <a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii/</a></p><blockquote><p><strong>题目描述：</strong><br>&emsp;给定一个可能包含重复数字的序列，返回其所有可能的不重复全排列。<br><strong>输入：</strong><br>&emsp;&emsp;[1,1,2]<br><strong>输出：</strong><br>&emsp;&emsp;[<br> &emsp;&emsp; [1,1,2],<br> &emsp;&emsp; [1,2,1],<br> &emsp;&emsp; [2,1,1],<br> &emsp;&emsp; ]</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>第一版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//执行用时 :742 ms, 在所有 Java 提交中击败了8.80%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :45.7 MB, 在所有 Java 提交中击败了44.99%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span>  List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start,ArrayList&lt;Integer&gt; tempList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//start为边界值</span></span><br><span class="line">            <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">                <span class="comment">//加了这一句</span></span><br><span class="line">                <span class="keyword">if</span>(!res.contains(tempList))&#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">                swap(nums,start,i);</span><br><span class="line">                tempList.add(nums[start]);</span><br><span class="line">                backTrace(nums,start+<span class="number">1</span>,tempList,res);</span><br><span class="line">                tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">                swap(nums,start,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优化的第二版:leetcode官网解答<br><img src="https://img-blog.csdnimg.cn/20190722151516219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722151537389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190722151548299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190722151600826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NTU2MTkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :6 ms, 在所有 Java 提交中击败了63.63%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :42.8 MB, 在所有 Java 提交中击败了76.28%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findPermuteUnique</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> depth, Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                <span class="comment">// 修改 2：因为排序以后重复的数一定不会出现在开始，故 i &gt; 0</span></span><br><span class="line">                <span class="comment">// 和之前的数相等，并且之前的数还未使用过，只有出现这种情况，才会出现相同分支</span></span><br><span class="line">                <span class="comment">// 这种情况跳过即可</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                stack.add(nums[i]);</span><br><span class="line">                findPermuteUnique(nums, depth + <span class="number">1</span>, stack);</span><br><span class="line">                stack.pop();</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改 1：首先排序，之后才有可能发现重复分支</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        findPermuteUnique(nums, <span class="number">0</span>, <span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permuteUnique = solution.permuteUnique(nums);</span><br><span class="line">        System.out.println(permuteUnique);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【77】组合"><a href="#leetcode-【77】组合" class="headerlink" title="leetcode_【77】组合"></a>leetcode_【77】组合</h2><p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations/</a></p><blockquote><p>&emsp;给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>    示例:<br>    输入:<br>    &emsp;&emsp;n = 4, k = 2<br>    输出:<br>   &emsp;&ensp; [<br>  &emsp;&emsp;  [2,4],<br>   &emsp;&emsp; [3,4],<br>   &emsp;&emsp; [2,3],<br>   &emsp;&emsp; [1,2],<br>   &emsp;&emsp; [1,3],<br> &emsp;&emsp;   [1,4],<br> &emsp;&ensp;   ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//执行用时 :40 ms, 在所有 Java 提交中击败了52.77%的用户</span></span><br><span class="line">&gt; <span class="comment">//内存消耗 :52.5 MB, 在所有 Java 提交中击败了26.41%的用户</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">&gt;         List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;         backtrack(k,n,<span class="number">1</span>,<span class="keyword">new</span> ArrayList(),res);</span><br><span class="line">&gt;         <span class="keyword">return</span> res;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n,<span class="keyword">int</span> start,List&lt;Integer&gt; tmplist,List&lt;List&lt;Integer&gt;&gt; result)</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">&gt;             result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">&gt;         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">&gt;             <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">&gt;                 tmplist.add(i);</span><br><span class="line">&gt;                 <span class="comment">//递归，这里回溯 从 i+1  ~ n 中 k-1 个数的组合，直到k == 0就可将这次结果存到res里面</span></span><br><span class="line">&gt;                 backtrack( k - <span class="number">1</span>, n, i+<span class="number">1</span>,tmplist, result);</span><br><span class="line">&gt;                 tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="leetcode-【39】组合总和-I"><a href="#leetcode-【39】组合总和-I" class="headerlink" title="leetcode_【39】组合总和 I"></a>leetcode_【39】组合总和 I</h2><p>&emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum/</a></p><blockquote><p>&emsp;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以&gt;使数字和为 target 的组合。<br>&emsp;candidates 中的<strong>数字可以无限制重复被选取。</strong><br><strong>说明：</strong><br>&emsp; (1)所有数字（包括 target）都是正整数。<br>&emsp;(2)解集不能包含重复的组合。<br>       <strong><strong>示例 1:<br>       输入:</strong></strong><br>      &emsp;&emsp; candidates = [2,3,6,7], target = 7,<br>       <strong>所求解集为:</strong><br>      &emsp;&emsp; [<br>     &emsp;&emsp;  [7],<br>      &emsp;&emsp; [2,2,3]<br>      &emsp;&emsp; ]<br>       <strong>示例 2:<br>       输入:</strong><br>       &emsp;&emsp;candidates = [2,3,5], target = 8,<br>       <strong>所求解集为:</strong><br>       &emsp;&emsp;[<br>         &emsp;&emsp;[2,2,2,2],<br>        &emsp;&emsp; [2,3,3],<br>        &emsp;&emsp; [3,5]<br>       &emsp;&emsp;]</p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :7 ms, 在所有 Java 提交中击败了81.11%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :39.1 MB, 在所有 Java 提交中击败了87.66%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">          <span class="comment">//存放结果</span></span><br><span class="line">          List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="comment">//排序</span></span><br><span class="line">          Arrays.sort(candidates);</span><br><span class="line">          <span class="comment">//从第一个数开始递归</span></span><br><span class="line">          calculate(candidates,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,ArrayList&lt;Integer&gt; tmpList,List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存入结果集</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123;</span><br><span class="line">                <span class="comment">//加入</span></span><br><span class="line">                tmpList.add(candidates[i]);</span><br><span class="line">                <span class="comment">//递归,candidates 中的数字可以使用无数次，故start还是从 i 开始</span></span><br><span class="line">                calculate( candidates, target - candidates[i], i, tmpList,result);</span><br><span class="line">                <span class="comment">//清空所得到的一次结果的list</span></span><br><span class="line">                tmpList.remove(tmpList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【40】组合总和-II"><a href="#leetcode-【40】组合总和-II" class="headerlink" title="leetcode_【40】组合总和 II"></a>leetcode_【40】组合总和 II</h2><p>&emsp;&emsp;&emsp;<a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii/</a></p><blockquote><p>&emsp;&emsp;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>&emsp;<strong>candidates 中的数字可以只能使用一次。</strong><br><strong>说明：</strong><br>&emsp; (1)所有数字（包括 target）都是正整数。<br>&emsp;(2)解集不能包含重复的组合。<br><strong>输入:</strong><br>&emsp;&emsp;candidates = [10,1,2,7,6,1,5], target = 8，<br><strong>所求解集为:</strong><br>       &emsp;&ensp; [<br>      &emsp;&emsp;  [1, 7],<br>       &emsp;&emsp; [1, 2, 5],<br>       &emsp;&emsp; [2, 6],<br>      &emsp;&emsp;  [1, 1, 6]<br>      &emsp;&ensp;  ]<br>        <strong>示例 2:<br>        输入:</strong><br>        &emsp;&emsp; candidates = [2,5,2,1,2], target = 5,<br>        <strong>所求解集为:</strong><br>       &emsp;&ensp; [<br>          &emsp;&emsp;[1,2,2],<br>         &emsp;&emsp; [5]<br>       &emsp;&ensp; ]       </p></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//执行用时 :30 ms, 在所有 Java 提交中击败了22.59%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :45 MB, 在所有 Java 提交中击败了27.34%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="comment">//从下标为0，目标为target的开始回溯</span></span><br><span class="line">        backTrace(candidates,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//解集不能包含重复的组合。 </span></span><br><span class="line">            Collections.sort(tmpList);</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(tmpList))&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123;</span><br><span class="line">                tmpList.add(candidates[i]);</span><br><span class="line">                <span class="comment">//回溯,因为candidates 中的数字可以只能使用一次，所以这里start变成了i+1</span></span><br><span class="line">                backTrace(candidates, target - candidates[i], i + <span class="number">1</span>, tmpList, res);</span><br><span class="line">                tmpList.remove(tmpList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【216】组合总和III"><a href="#leetcode-【216】组合总和III" class="headerlink" title="leetcode_【216】组合总和III"></a>leetcode_【216】组合总和III</h2><p>  <a href="https://leetcode-cn.com/problems/combination-sum-iii/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iii/submissions/</a></p><blockquote><p>&emsp;&emsp;找出所有相加之和为 n 的 k 个数的组合。组合中<strong>只允许含有 1 - 9 的正整数</strong>，并且每种组合中不存在重复的数字。<br> <strong>说明：</strong><br>        &emsp;所有数字都是正整数。<br>       &emsp; 解集不能包含重复的组合。<br>        <strong>示例 1:<br>        输入:</strong><br>        &emsp;&emsp; k = 3, n = 7<br>        <strong>输出:</strong><br>        &emsp;&emsp; [[1,2,4]]<br>        <strong>示例 2:<br>        输入:</strong><br>        &emsp;&emsp;k = 3, n = 9<br>        <strong>输出:</strong><br>        &emsp;&emsp; [[1,2,6], [1,3,5], [2,3,4]]</p></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//执行用时 :5 ms, 在所有 Java 提交中击败了8.96%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :34.1 MB, 在所有 Java 提交中击败了28.88%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrace(k,n,<span class="number">1</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target,<span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == k &amp;&amp; target == <span class="number">0</span>)&#123;</span><br><span class="line">            Collections.sort(tmpList);</span><br><span class="line">            <span class="keyword">if</span>(!res.contains(tmpList))</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">// 组合数中只包含1-9的数，故i&lt;=9</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= <span class="number">9</span> ;i++)&#123;</span><br><span class="line">                tmpList.add(i);</span><br><span class="line">                backTrace(k-<span class="number">1</span>,target - i,i+<span class="number">1</span>,tmpList,res);</span><br><span class="line">                tmpList.remove(tmpList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【377】组合总和-IV"><a href="#leetcode-【377】组合总和-IV" class="headerlink" title="leetcode_【377】组合总和 IV"></a>leetcode_【377】组合总和 IV</h2><blockquote><p>&emsp;给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。<br>        示例:<br>       &emsp;&emsp; nums = [1, 2, 3]<br>        &emsp;&emsp;target = 4<br>        所有可能的组合为：<br>      &emsp;&emsp;  (1, 1, 1, 1)<br>      &emsp;&emsp;  (1, 1, 2)<br>       &emsp;&emsp; (1, 2, 1)<br>       &emsp;&emsp; (1, 3)<br>       &emsp;&emsp; (2, 1, 1)<br>       &emsp;&emsp; (2, 2)<br>       &emsp;&emsp; (3, 1)<br>        请注意，顺序不同的序列被视作不同的组合。<br>        因此输出为 7。</p></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>   回溯超出内存限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrace(nums,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmpList));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length &amp;&amp; target &gt;= nums[i];i++)&#123;</span><br><span class="line">                tmpList.add(nums[i]);</span><br><span class="line">                backTrace(nums,target - nums[i],i,tmpList,res);</span><br><span class="line">                tmpList.remove(tmpList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划：dp[i] 代表组成i 能有多少种组合数，即dp[1] = 2代表 和为1的组合个数为2</p><blockquote><ul><li>初始化<ul><li><code>dp[0] = 1</code>;即组成和为0的组合数为1，即都nums里面的数都不取</li></ul></li><li><p>状态转移方程：</p><ul><li><p><code>dp[i]=dp[ i - nums[0] ]+dp[ i - nums[1] ]+dp[ i - nums[2] ] + ...</code></p><p>举个例子 : 比如nums=[1,3,4],target=7;dp[7]=dp[6]+dp[4]+dp[3]</p></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :5 ms, 在所有 Java 提交中击败了68.54%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :34.3 MB, 在所有 Java 提交中击败了39.00%的用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">combinationSum6</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - nums[j] &gt;= <span class="number">0</span> )&#123;</span><br><span class="line">                dp[i] += dp[i-nums[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【51】N皇后-I"><a href="#leetcode-【51】N皇后-I" class="headerlink" title="leetcode_【51】N皇后 I"></a>leetcode_【51】N皇后 I</h2><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens/</a></p><blockquote><p>&emsp; n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>  &emsp;  给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>  &emsp;  每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br>        <strong>示例:<br>        输入:</strong><br>        &emsp;  4<br>        <strong>输出:</strong><br>       &emsp; &ensp;   [<br>       &emsp; &emsp;  [“.Q..”,  // 解法 1<br>        &emsp; &emsp; “…Q”,<br>       &emsp; &emsp;  “Q…”,<br>       &emsp; &emsp;  “..Q.” ],<br>        &emsp; &ensp; [ “..Q.”,  // 解法 2<br>        &emsp; &emsp; “Q…”,<br>      &emsp; &emsp;   “…Q”,<br>       &emsp; &emsp;  “.Q..”]<br>       &emsp; &ensp;  ]<br>        <strong>解释:</strong> 4 皇后问题存在两个不同的解法。</p></blockquote><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><blockquote><ul><li>回溯函数 <code>backtrack(row = 0)</code>.<ul><li>从第一个 <code>row = 0</code> 开始.</li><li>循环列并且试图在每个 <code>column</code> 中放置皇后.<ul><li>如果方格 <code>(row, column)</code> 不在攻击范围内<ul><li>在 <code>(row, column)</code> 方格上放置皇后</li><li>排除对应行，列和两个对角线的位置。</li><li>If 所有的行被考虑过，<code>row == NunOfQueen</code><ul><li>意味着我们找到了一个解</li></ul></li><li>else<ul><li>继续考虑接下来的皇后放置 backtrack(row + 1).</li></ul></li><li>回溯：将在 (row, column) 方格的皇后移除.</li></ul></li></ul></li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.Arrays.回溯;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">//执行用时 :9 ms, 在所有 Java 提交中击败了53.89%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :39.3 MB, 在所有 Java 提交中击败了84.75%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_51</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//用于存储行</span></span><br><span class="line">        List&lt;Integer&gt; col = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储正对角线</span></span><br><span class="line">        List&lt;Integer&gt; z_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储负对角线</span></span><br><span class="line">        List&lt;Integer&gt; f_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//从第一个row = 0开始</span></span><br><span class="line">        backtrack(<span class="number">0</span>, n, res, <span class="keyword">new</span> ArrayList&lt;String&gt;(), col, z_diagonal, f_diagonal);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> NumOfQueen, List&lt;List&lt;String&gt;&gt; res, ArrayList&lt;String&gt; tmplist, List&lt;Integer&gt; col, List&lt;Integer&gt; z_diagonal, List&lt;Integer&gt; f_diagonal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//到达了最后一行</span></span><br><span class="line">        <span class="keyword">if</span> (row == NumOfQueen) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; NumOfQueen; column++) &#123;</span><br><span class="line">            <span class="comment">//如果不在攻击范围内（不在同一行或者同一列 &amp;&amp; 负对角线和相等 &amp;&amp;  正对角线差相等）</span></span><br><span class="line">            <span class="keyword">if</span> (!col.contains(column) &amp;&amp; !f_diagonal.contains(row + column) &amp;&amp; !z_diagonal.contains(row - column)) &#123;</span><br><span class="line">                col.add(column);</span><br><span class="line">                f_diagonal.add(row + column);</span><br><span class="line">                z_diagonal.add(row - column);</span><br><span class="line">                <span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[NumOfQueen];</span><br><span class="line">                Arrays.fill(s, <span class="string">'.'</span>);</span><br><span class="line">                <span class="comment">//这一行的j位置放皇后</span></span><br><span class="line">                s[column] = <span class="string">'Q'</span>;</span><br><span class="line">                tmplist.add(<span class="keyword">new</span> String(s));</span><br><span class="line">                <span class="comment">//回溯算法</span></span><br><span class="line">                backtrack(row+<span class="number">1</span>,NumOfQueen,res,tmplist,col,z_diagonal,f_diagonal);</span><br><span class="line">                tmplist.remove(tmplist.size() - <span class="number">1</span>);</span><br><span class="line">                col.remove(Integer.valueOf(column));</span><br><span class="line">                f_diagonal.remove(Integer.valueOf(row + column));</span><br><span class="line">                z_diagonal.remove(Integer.valueOf(row - column));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【52】N皇后-II"><a href="#leetcode-【52】N皇后-II" class="headerlink" title="leetcode_【52】N皇后 II"></a>leetcode_【52】N皇后 II</h2><p><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens-ii/</a></p><blockquote><p>&emsp; n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>  &emsp;  给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>  &emsp;  每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br>        <strong>示例:<br>        输入:</strong><br>        &emsp;  4<br>        <strong>输出:</strong><br>       &emsp; 2<br>        <strong>解释</strong>：4皇后存在两种不同的解法<br>       &emsp; &ensp;   [<br>       &emsp; &emsp;  [“.Q..”,  // 解法 1<br>        &emsp; &emsp; “…Q”,<br>       &emsp; &emsp;  “Q…”,<br>       &emsp; &emsp;  “..Q.” ],<br>        &emsp; &ensp; [ “..Q.”,  // 解法 2<br>        &emsp; &emsp; “Q…”,<br>      &emsp; &emsp;   “…Q”,<br>       &emsp; &emsp;  “.Q..”]<br>       &emsp; &ensp;  ]</p></blockquote><p>   如leetcode_【51】代码返回res.size();</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时</span></span><br><span class="line"> :<span class="number">29</span> ms, 在所有 Java 提交中击败了<span class="number">5.45</span>%的用户</span><br><span class="line"><span class="comment">//内存消耗 :34.8 MB, 在所有 Java 提交中击败了41.25%的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用于存储行</span></span><br><span class="line">        List&lt;Integer&gt; col = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储正对角线</span></span><br><span class="line">        List&lt;Integer&gt; z_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储负对角线</span></span><br><span class="line">        List&lt;Integer&gt; f_diagonal = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储结果</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//从第一个row = 0开始</span></span><br><span class="line">        backtrack(<span class="number">0</span>, n, res, <span class="keyword">new</span> ArrayList&lt;String&gt;(), col, z_diagonal, f_diagonal);</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> NumOfQueen, List&lt;List&lt;String&gt;&gt; res, ArrayList&lt;String&gt; tmplist, List&lt;Integer&gt; col, List&lt;Integer&gt; z_diagonal, List&lt;Integer&gt; f_diagonal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//到达了最后一行</span></span><br><span class="line">        <span class="keyword">if</span> (row == NumOfQueen) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第0列开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; NumOfQueen; column++) &#123;</span><br><span class="line">            <span class="comment">//如果不在攻击范围内（不在同一行或者同一列 &amp;&amp; 负对角线和相等 &amp;&amp;  正对角线差相等）</span></span><br><span class="line">            <span class="keyword">if</span> (!col.contains(column) &amp;&amp; !f_diagonal.contains(row + column) &amp;&amp; !z_diagonal.contains(row - column)) &#123;</span><br><span class="line">                col.add(column);</span><br><span class="line">                f_diagonal.add(row + column);</span><br><span class="line">                z_diagonal.add(row - column);</span><br><span class="line">                <span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[NumOfQueen];</span><br><span class="line">                Arrays.fill(s, <span class="string">'.'</span>);</span><br><span class="line">                <span class="comment">//这一行的j位置放皇后</span></span><br><span class="line">                s[column] = <span class="string">'Q'</span>;</span><br><span class="line">                tmplist.add(<span class="keyword">new</span> String(s));</span><br><span class="line">                <span class="comment">//回溯算法</span></span><br><span class="line">                backtrack(row+<span class="number">1</span>,NumOfQueen,res,tmplist,col,z_diagonal,f_diagonal);</span><br><span class="line">                tmplist.remove(tmplist.size() - <span class="number">1</span>);</span><br><span class="line">                col.remove(Integer.valueOf(column));</span><br><span class="line">                f_diagonal.remove(Integer.valueOf(row + column));</span><br><span class="line">                z_diagonal.remove(Integer.valueOf(row - column));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【78】子集I"><a href="#leetcode-【78】子集I" class="headerlink" title="leetcode_【78】子集I"></a>leetcode_【78】子集I</h2><p>   <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/</a></p><blockquote><p>&emsp;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>        &emsp;说明：解集不能包含重复的子集。<br>        &emsp;示例:<br>        输入:<br>        &emsp;&emsp;nums = [1,2,3]<br>        输出:<br>       &emsp;&ensp; [<br>      &emsp;&emsp;  [3],<br>       &emsp;&emsp;  [1],<br>         &emsp;&emsp; [2],<br>         &emsp;&emsp; [1,2,3],<br>         &emsp;&emsp; [1,3],<br>         &emsp;&emsp; [2,3],<br>         &emsp;&emsp; [1,2],<br>         &emsp;&emsp; []<br>      &emsp;&ensp;  ]</p></blockquote><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :2 ms, 在所有 Java 提交中击败了87.86%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :37 MB, 在所有 Java 提交中击败了44.12%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmplist, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            tmplist.add(nums[i]);</span><br><span class="line">            backTrace(nums,i+<span class="number">1</span>,tmplist,res);</span><br><span class="line">            tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="leetcode-【90】子集-II"><a href="#leetcode-【90】子集-II" class="headerlink" title="leetcode_【90】子集 II"></a>leetcode_【90】子集 II</h2><p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets-ii/</a></p><blockquote><p>   给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>        说明：解集不能包含重复的子集。<br>        示例:<br>        输入:<br>        &emsp; [1,2,2]<br>        输出:<br>       &emsp; &ensp;  [<br>       &emsp; &emsp;  [2],<br>         &emsp; &emsp; [1],<br>        &emsp; &emsp; [1,2,2],<br>        &emsp; &emsp; [2,2],<br>         &emsp; &emsp; [1,2],<br>        &emsp; &emsp; []<br>        &emsp; &ensp; ]</p></blockquote><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时 :3 ms, 在所有 Java 提交中击败了87.52%的用户</span></span><br><span class="line"><span class="comment">//内存消耗 :38.5 MB, 在所有 Java 提交中击败了47.42%的用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrace(nums,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; tmplist, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmplist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//和上一个数字相等则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmplist.add(nums[i]);</span><br><span class="line">                backTrace(nums,i+<span class="number">1</span>,tmplist,res);</span><br><span class="line">                tmplist.remove(tmplist.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【102】二叉树的层次遍历</title>
      <link href="/2019/06/leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
      <url>/2019/06/leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。<a id="more"></a></p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">3</span></span><br><span class="line">&gt;     / \</span><br><span class="line">&gt;    <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">&gt;       / \</span><br><span class="line">&gt;      <span class="number">15</span>  <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>同【剑指offer - 60】</p><p>BFS广度优先搜索的扩展题</p><p>迭代思想：</p><p>我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。</p><p>第 0 层只包含根节点 root ，算法实现如下：</p><pre><code>(1)初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。(2)当队列非空的时候：    1) 在输出结果 levels 中插入一个空列表，开始当前层的算法。    2)计算当前层有多少个元素：等于队列的长度。    3)将这些元素从队列中弹出，并加入 levels 当前层的空列表中。    4)将他们的孩子节点作为下一层压入队列中。    5)进入下一层 level++。</code></pre><p>递归思想：<br>    最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下：<br>    (1)输出列表称为 ans，当前最高层数就是列表的长度 len(ans)。比较访问节点所在的层次 level 和当前最高层次 len(ans) 的大小，如果前者更大就向 ans 添加一个空列表。<br>    (2)将当前节点插入到对应层的列表 ans[level] 中。<br>    (3)递归非空的孩子节点：helper(node.left , level + 1)。helper(node.right, level + 1)。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span> ms, 在所有 Java 提交中击败了<span class="number">55.91</span>%的用户</span><br><span class="line"></span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">36.5</span> MB, 在所有 Java 提交中击败了<span class="number">44.59</span>%的用户</span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//用于记录所有结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//用于保存当前层的节点数</span></span><br><span class="line">           ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="comment">//当前层包含的节点个数</span></span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count;i++)&#123;</span><br><span class="line">              <span class="comment">//删除并返回queue中的头元素，删掉根（上一层结点元素）</span></span><br><span class="line">               TreeNode node = queue.poll();</span><br><span class="line">               <span class="comment">//加入左子树</span></span><br><span class="line">               <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               <span class="comment">//加入右子树</span></span><br><span class="line">               <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               <span class="comment">//加入当前层的节点</span></span><br><span class="line">               tmp.add(node.val);</span><br><span class="line">           &#125;</span><br><span class="line">           lists.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line">    <span class="number">2</span> ms, 在所有 Java 提交中击败了<span class="number">92.32</span>%的用户</span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">37.1</span> MB, 在所有 Java 提交中击败了<span class="number">42.97</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        helper(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans.size() == level)</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        ans.get(level).add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/102.png" alt="leetcode提交结果-迭代"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 广度优先遍历 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【108】将有序数组转换成二叉搜索树</title>
      <link href="/2019/06/leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2019/06/leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。<a id="more"></a></p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;           <span class="number">0</span></span><br><span class="line">&gt;          / \</span><br><span class="line">&gt;        -<span class="number">3</span>   <span class="number">9</span></span><br><span class="line">&gt;        /   /</span><br><span class="line">&gt;      -<span class="number">10</span>  <span class="number">5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>将一个排序array转化为平衡二叉搜索树：<br>平衡二叉树：对于每个根节点，左右子树高度差 &lt;= 1；<br>二叉搜索树：对于每个节点，其左子树值&lt;此节点值，右子树&gt;此节点值。<br>要满足以上两个特点，我们自然想到以array中点值作为根节点值，并递归重建，这样就可以同时保证以上两个条件。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">3</span> ms, 在所有 Java 提交中击败了<span class="number">8.50</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">40.2</span> MB, 在所有 Java 提交中击败了<span class="number">29.40</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将最中间的数作为根节点</span></span><br><span class="line">        TreeNode root =<span class="keyword">new</span> TreeNode( nums[nums.length/<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//以中间的树为分界，左边归属于左子树，右边归属于右子树</span></span><br><span class="line">        root.left = sortedArrayToBST(Arrays.copyOfRange(nums,<span class="number">0</span>,nums.length/<span class="number">2</span>));</span><br><span class="line">        root.right = sortedArrayToBST(Arrays.copyOfRange(nums,nums.length/<span class="number">2</span>+<span class="number">1</span>,nums.length));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时为2ms的范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右等分建立左右子树，中间节点作为子树根节点，递归该过程</span></span><br><span class="line">        <span class="keyword">return</span> nums == <span class="keyword">null</span> ? <span class="keyword">null</span> : buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">        root.left = buildTree(nums, left, mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        root.right = buildTree(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/108.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 简单 </tag>
            
            <tag> 深度优先遍历 </tag>
            
            <tag> 广度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【106】从中序与后序遍历序列构造二叉树</title>
      <link href="/2019/06/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/06/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。<a id="more"></a></p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;       <span class="number">3</span></span><br><span class="line">&gt;      /  \</span><br><span class="line">&gt;     <span class="number">9</span>    <span class="number">20</span></span><br><span class="line">&gt;    /  \</span><br><span class="line">&gt;   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>中序<code>9,3,15,20,7</code>,后序 <code>9,15,7,20,3</code></p><p>有如下特征：</p><ol><li>后序中最后一位<code>1</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>root</code>；</li><li>中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li><li>后序中结点分布应该是：<code>[左子树结点，右子树结点，根结点]</code>；</li><li>根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；</li><li>如果我们要后序遍历生成二叉树的话，下一层递归应该是：<ul><li>左子树：<code>root.left = buildTree(中序左子树范围，后序左子树范围);</code>；</li><li>右子树：<code>root.right = buildTree(中序右子树范围，后序左子树范围，);</code>。</li></ul></li><li>每一层递归都要返回当前根结点<code>root</code>；</li></ol></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">42</span> ms, 在所有 Java 提交中击败了<span class="number">15.47</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">78.1</span> MB, 在所有 Java 提交中击败了<span class="number">5.17</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.length == <span class="number">0</span>||postorder.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//根节点为后序遍历的最后一个节点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">              <span class="comment">//找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点</span></span><br><span class="line">                <span class="keyword">if</span>(inorder[i] == postorder[postorder.length-<span class="number">1</span>])&#123;</span><br><span class="line">               <span class="comment">//递归构建左子树，此时,中序缩小为[0,i),后序的范围缩小为[0,i]</span></span><br><span class="line">                    root.left = buildTree(Arrays.copyOfRange(inorder,<span class="number">0</span>,i),Arrays.copyOfRange(postorder,<span class="number">0</span>,i));</span><br><span class="line">              <span class="comment">//递归构建右子树,中序缩小为[i+1,len),后序的范围缩小为[i,len-1),</span></span><br><span class="line">                    root.right = buildTree(Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length),Arrays.copyOfRange(postorder,i,postorder.length-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/106.png" alt="重构二叉树"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 深度优先遍历 </tag>
            
            <tag> 广度优先遍历 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【105】从前序与中序遍历序列构造二叉树</title>
      <link href="/2019/06/leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/06/leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>根据一棵树的前序遍历与中序遍历构造二叉树。<a id="more"></a></p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">3</span></span><br><span class="line">&gt;     / \</span><br><span class="line">&gt;    <span class="number">9</span>   <span class="number">20</span></span><br><span class="line">&gt;       /  \</span><br><span class="line">&gt;      <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>同【剑指offer_4】</p><p>前序<code>3,9,20,15,7</code>  ，中序<code>9,3,15,20,7</code>；</p><p>有如下特征：</p><ol><li>前序中左起第一位<code>3</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>root</code>；</li><li>中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li><li>前序中结点分布应该是：<code>[根结点，左子树结点，右子树结点]</code>；</li><li>根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；</li><li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul><li>左子树：<code>root.left = buildTree(前序左子树范围，中序左子树范围);</code>；</li><li>右子树：<code>root.right = buildTree(前序右子树范围，中序右子树范围);</code>。</li></ul></li><li>每一层递归都要返回当前根结点<code>root</code>；</li></ol></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">43</span> ms, 在所有 Java 提交中击败了<span class="number">15.42</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">76.5</span> MB, 在所有 Java 提交中击败了<span class="number">6.76</span>%的用户</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="comment">//找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点  </span></span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">             <span class="comment">//递归构建左子树，此时前序的范围缩小为[1,i],中序缩小为[0,i)     </span></span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">             <span class="comment">//递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len)   </span></span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行用时32ms的范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length != inorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildHelper(preorder, inorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildHelper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preL &gt; preR) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preL]);</span><br><span class="line">        <span class="keyword">int</span> rootIdx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = inL; i &lt;= inR; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == preorder[preL]) &#123;</span><br><span class="line">                rootIdx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rootIdx == -<span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        root.left = buildHelper(preorder, inorder, preL + <span class="number">1</span>, rootIdx - inL + preL, inL, rootIdx - <span class="number">1</span>);</span><br><span class="line">        root.right = buildHelper(preorder, inorder, rootIdx - inL + preL + <span class="number">1</span>, preR, rootIdx + <span class="number">1</span>, inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/105.png" alt="重构二叉树"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 广度优先遍历 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【101】对称二叉树</title>
      <link href="/2019/06/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/06/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，检查它是否是镜像对称的。<a id="more"></a></p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;       <span class="number">1</span></span><br><span class="line">&gt;    /     \</span><br><span class="line">&gt;   <span class="number">2</span>       <span class="number">2</span></span><br><span class="line">&gt;  /  \    /  \</span><br><span class="line">&gt; <span class="number">3</span>   <span class="number">4</span>   <span class="number">4</span>   <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">1</span></span><br><span class="line">&gt;     /  \</span><br><span class="line">&gt;    <span class="number">2</span>    <span class="number">2</span></span><br><span class="line">&gt;     \    \</span><br><span class="line">&gt;      <span class="number">3</span>    <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：递归</p><blockquote><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p><p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p><p>如果同时满足下面的条件，两个树互为镜像：</p><p>(1)它们的两个根结点具有相同的值。<br>(2)每个树的右子树都与另一个树的左子树镜像对称。</p><p>递归过程：</p><ul><li>判断两个指针当前节点值是否相等</li><li>判断 A 的右子树与 B 的左子树是否对称</li><li>判断 A 的左子树与 B 的右子树是否对称</li></ul></blockquote><p>方法2：迭代</p><blockquote><p>类似于广度优先遍历BFS，用一个队列queue存储左右节点。其中队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。</p><p>(1) 最初，队列中包含的是 root 以及 root。每次提取两个结点并比较它们的值。</p><p>(2)当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p><p>(3)然后，将两个结点的左右子结点按相反的顺序插入队列中。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">     <span class="number">2</span> ms, 在所有 Java 提交中击败了<span class="number">84.89</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line">    <span class="number">35.5</span> MB, 在所有 Java 提交中击败了<span class="number">80.63</span>%的用户</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Symmetric</span><span class="params">(TreeNode leftroot,TreeNode rightroot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> &amp;&amp; rightroot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot==<span class="keyword">null</span> || rightroot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftroot.val != rightroot.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetric(leftroot.left,rightroot.right) &amp;&amp; Symmetric(leftroot.right,rightroot.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 执行用时 :</span><br><span class="line">    <span class="number">3</span> ms, 在所有 Java 提交中击败了<span class="number">28.02</span>%的用户</span><br><span class="line"> 内存消耗 :</span><br><span class="line"></span><br><span class="line">    <span class="number">35.7</span> MB, 在所有 Java 提交中击败了<span class="number">80.01</span>%的用户</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node1 = queue.poll();</span><br><span class="line">            TreeNode node2 = queue.poll();</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> &amp;&amp; node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(node1==<span class="keyword">null</span> || node2==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">if</span>(node1.val!=node2.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            queue.add(node1.left);</span><br><span class="line">            queue.add(node2.right);</span><br><span class="line">            queue.add(node1.right);</span><br><span class="line">            queue.add(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/101.png" alt="对称二叉树-递归"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 简单 </tag>
            
            <tag> 深度优先遍历 </tag>
            
            <tag> 广度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【100】相同的树</title>
      <link href="/2019/06/leetcode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
      <url>/2019/06/leetcode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; 示例 <span class="number">1</span>:</span><br><span class="line">&gt; 输入:   <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">&gt;       /  \       /  \</span><br><span class="line">&gt;      <span class="number">2</span>    <span class="number">3</span>     <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt; 输出: <span class="keyword">true</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; 示例 <span class="number">2</span>:</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入:    <span class="number">1</span>      <span class="number">1</span></span><br><span class="line">&gt;         /       \</span><br><span class="line">&gt;        <span class="number">2</span>         <span class="number">2</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">1</span>,<span class="number">2</span>],     [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 输出: <span class="keyword">false</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; 示例 <span class="number">3</span>:</span><br><span class="line">&gt; 输入:      <span class="number">1</span>        <span class="number">1</span></span><br><span class="line">&gt;          /  \     /  \</span><br><span class="line">&gt;         <span class="number">2</span>    <span class="number">1</span>   <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 输出：<span class="keyword">false</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>最简单的策略是使用递归。检查p和q节点是否不是空，它们的值是否相等。如果所有检查都正常，则递归地为子节点执行相同操作。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line">    <span class="number">1</span> ms, 在所有 Java 提交中击败了<span class="number">86.63</span>%的用户</span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">34.2</span> MB, 在所有 Java 提交中击败了<span class="number">85.19</span>%的用户</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> ||q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val !=q.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4. 提交结果"></a>4. 提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/100.png" alt="相同的树"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 简单 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【104】二叉树的最大深度</title>
      <link href="/2019/06/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2019/06/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><blockquote><p>给定一个二叉树，找出其最大深度。<a id="more"></a></p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;      <span class="number">3</span></span><br><span class="line">&gt;     /  \</span><br><span class="line">&gt;    <span class="number">9</span>   <span class="number">20</span></span><br><span class="line">&gt;       /  \</span><br><span class="line">&gt;      <span class="number">15</span>  <span class="number">7</span></span><br><span class="line">&gt; 返回它的最大深度 <span class="number">3</span> 。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>同 【剑指offer38题】</p><p>递归实现</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :</span><br><span class="line">    <span class="number">1</span> ms, 在所有 Java 提交中击败了<span class="number">98.19</span>%的用户</span><br><span class="line">内存消耗 :</span><br><span class="line">    <span class="number">37.5</span> MB, 在所有 Java 提交中击败了<span class="number">45.48</span>%的用户</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> left_height =  maxDepth(root.left);</span><br><span class="line">             <span class="keyword">int</span> right_height = maxDepth(root.right);</span><br><span class="line">             <span class="keyword">return</span> Math.max(left_height,right_height)+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/104.png" alt="二叉树的最大深度"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 简单 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先遍历和广度优先遍历</title>
      <link href="/2019/06/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2019/06/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h2><blockquote><p> 假设给定图G的初态是所有顶点均未曾访问过。在G中任选一顶点v为初始出发点(源点)，则深度优先遍历可定义如下：<a id="more"></a></p><p>(1)首先访问出发点v，并将其标记为已访问过；</p><p>(2)然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和源点v有路径相通的顶点(亦称为从源点可达的顶点)均已被访问为止。</p><p>(3)若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点作为新的源点重复上述过程，直至图中所有顶点均已被访问为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;           A</span><br><span class="line">&gt;         /    \</span><br><span class="line">&gt;        B      C</span><br><span class="line">&gt;      /  \    /  </span><br><span class="line">&gt;     E    F  G</span><br><span class="line">&gt;         /</span><br><span class="line">&gt;        I</span><br><span class="line">&gt; 深度遍历结果为： A--B--E--F--I--C--G(假设先走子节点的的左侧)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>遍历过程如下：</p><blockquote><p><strong>先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。</strong></p><p>(1)首先将A节点压入栈中，stack（A）;</p><p>(2)将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)；</p><p>(3)将B节点弹出，同时将B的子节点F，E压入栈中，此时E在栈的顶部，stack（E,F,C）；</p><p>(4)将E节点弹出，没有子节点压入,此时E在栈的顶部，stack（F，C）；</p><p>(5)将F节点弹出，同时将F的子节点I压入，stack（I,C）；</p><p>(6)将I节点弹出，没有子节点压入,此时C在栈的顶部，stack（C）；</p><p>(7)将C节点弹出，同时将C的子节点G压入栈中，stack(G)；</p><p>(8)将C节点弹出，没有子节点压入，stack为空；</p><p>最终遍历完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   class TreeNode &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        int val;</span></span><br><span class="line"><span class="comment">//        TreeNode left;</span></span><br><span class="line"><span class="comment">//        TreeNode right;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">//            this.val = val;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">//先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ans.add(root.val);</span><br><span class="line">               DFS(root.left);</span><br><span class="line">               DFS(root.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h2><blockquote><p>广度优先遍历从某个顶点出发，首先访问这个顶点，然后找出这个结点的所有未被访问的邻接点，访问完后再访问这些结点中第一个邻接点的所有结点，重复此方法，直到所有结点都被访问完为止。</p><p><strong>1、</strong>从图中某个顶点V0出发，并访问此顶点；</p><p><strong>2、</strong>从V0出发，访问V0的各个未曾访问的邻接点W1，W2，…,Wk;然后,依次从W1,W2,…,Wk出发访问各自未被访问的邻接点；</p><p><strong>3、</strong>重复步骤2，直到全部顶点都被访问为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;           A</span><br><span class="line">&gt;         /   \</span><br><span class="line">&gt;        B     C</span><br><span class="line">&gt;      /  \    /</span><br><span class="line">&gt;     E    F  G</span><br><span class="line">&gt;    /</span><br><span class="line">&gt;   I</span><br><span class="line">&gt; 深度遍历结果为： A--B--C--E--F--G--I(假设先走子节点的的左侧)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>遍历过程如下：</p><blockquote><p><strong>先往队列中插入左节点，再插右节点，这样出队就是先左节点后右节点了。</strong></p><p>(1)首先将A节点插入队列中，队列queue（A）;</p><p>(2)将A节点弹出，同时将A节点的左、右节点B、C依次插入队列，queue（B，C）；</p><p>(3)将B节点弹出，同时将B节点的左、右节点E、F依次插入队列，queue（C, E, F）；</p><p>(4将C节点弹出，同时将C节点的左节点G依次插入队列，queue（E , F , G）；</p><p>(5)将E节点弹出，同时将E节点的左节点I依次插入队列，queue（F , G , I）；</p><p>(6)将F节点弹出，F没有子节点插入，queue（G,I）；</p><p>(7)将G节点弹出，G没有子节点插入，queue（I）；</p><p>(8)将I节点弹出，I没有子节点插入，queue为空；</p><p>最终遍历完成。</p></blockquote><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class TreeNode &#123;</span></span><br><span class="line"><span class="comment">// int val;</span></span><br><span class="line"><span class="comment">// TreeNode left;</span></span><br><span class="line"><span class="comment">// TreeNode right;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">// this.val = val;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">BFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> res;</span><br><span class="line">         Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">         queue.add(root);</span><br><span class="line">         <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">             TreeNode node = queue.poll();</span><br><span class="line">             <span class="comment">////先往queue中压入左节点，再压右节点。</span></span><br><span class="line">             <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.left);</span><br><span class="line">             <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                 queue.add(node.right);</span><br><span class="line">             res.add(node.val);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 深度优先遍历 </tag>
            
            <tag> 广度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【623】在二叉树中增加一行</title>
      <link href="/2019/06/leetcode-623-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/"/>
      <url>/2019/06/leetcode-623-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。<a id="more"></a></p><p>添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。</p><p>将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。</p><p>如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt; 示例 <span class="number">1</span>:</span><br><span class="line">&gt; </span><br><span class="line">&gt; 输入:</span><br><span class="line">&gt;  二叉树如下所示:</span><br><span class="line">&gt;           <span class="number">4</span></span><br><span class="line">&gt;        /     \</span><br><span class="line">&gt;       <span class="number">2</span>       <span class="number">6</span></span><br><span class="line">&gt;      / \     /</span><br><span class="line">&gt;     <span class="number">3</span>   <span class="number">1</span>   <span class="number">5</span></span><br><span class="line">&gt; v = <span class="number">1</span></span><br><span class="line">&gt; d = <span class="number">2</span></span><br><span class="line">&gt; 输出:</span><br><span class="line">&gt;          <span class="number">4</span></span><br><span class="line">&gt;         /  \</span><br><span class="line">&gt;        <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">&gt;       / \</span><br><span class="line">&gt;      <span class="number">2</span>   <span class="number">6</span></span><br><span class="line">&gt;     / \  /</span><br><span class="line">&gt;    <span class="number">3</span>  <span class="number">1</span>  <span class="number">5</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; 示例 <span class="number">2</span>:</span><br><span class="line">&gt; 输入:</span><br><span class="line">&gt;  二叉树如下所示:</span><br><span class="line">&gt;       <span class="number">4</span></span><br><span class="line">&gt;      /</span><br><span class="line">&gt;     <span class="number">2</span></span><br><span class="line">&gt;    / \</span><br><span class="line">&gt;   <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">&gt; v = <span class="number">1</span></span><br><span class="line">&gt; d = <span class="number">3</span></span><br><span class="line">&gt; 输出:</span><br><span class="line">&gt;        <span class="number">4</span></span><br><span class="line">&gt;       /</span><br><span class="line">&gt;      <span class="number">2</span></span><br><span class="line">&gt;     / \</span><br><span class="line">&gt;    <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">&gt;   / \</span><br><span class="line">&gt;  <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">       TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">       <span class="comment">//d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</span></span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">1</span>)&#123;</span><br><span class="line">            node.left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">0</span>)&#123;</span><br><span class="line">            node.right = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; d&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            root.left = addOneRow(root.left ,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            root.right = addOneRow(root.right,v, d &gt; <span class="number">2</span> ? d - <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">addOneRow</span><span class="params">(TreeNode root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</span></span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">1</span>)&#123;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            node.left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        TreeNode temp;</span><br><span class="line">        <span class="comment">//计算层数，到达前一层结束</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(depth == d-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                temp = queue.remove();</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode parent;</span><br><span class="line">        <span class="comment">//分别插入</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            parent = queue.remove();</span><br><span class="line">            <span class="comment">//将v插到左子树</span></span><br><span class="line">            temp = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            temp.left = parent.left;</span><br><span class="line">            parent.left = temp;</span><br><span class="line">            <span class="comment">//将v插到右子树</span></span><br><span class="line">            temp = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            temp.right = parent.right;</span><br><span class="line">            parent.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/623.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【94】二叉树的中序遍历</title>
      <link href="/2019/06/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2019/06/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个二叉树，返回它的中序遍历。<a id="more"></a></p><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;        <span class="number">1</span></span><br><span class="line">&gt;         \</span><br><span class="line">&gt;          <span class="number">2</span></span><br><span class="line">&gt;         /</span><br><span class="line">&gt;        <span class="number">3</span></span><br><span class="line">&gt; 输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">&gt; 进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>思路1：使用递归</p><pre><code>中序遍历的 左子树--&gt; 跟--&gt; 右子树</code></pre><p>思路2：迭代</p><pre><code>用一个指针模拟访问过程，先遍历到root的最左节点，</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;              <span class="number">1</span></span><br><span class="line">&gt;            /    \</span><br><span class="line">&gt;           <span class="number">2</span>      <span class="number">3</span></span><br><span class="line">&gt;         /  \    / </span><br><span class="line">&gt;        <span class="number">4</span>    <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">&gt; (<span class="number">1</span>)第一次循环，栈stack里面放入root的左子树：分别放入<span class="number">1</span>--<span class="number">2</span>--<span class="number">4</span>为root的树，然后ans里面存入stack.pop(),即<span class="number">4</span>，cur = cur.right = <span class="keyword">null</span></span><br><span class="line">&gt; (<span class="number">2</span>)stack内有<span class="number">2</span>个TreeNode,进入第二次循环，ans.add(cur.val) = <span class="number">2</span>;cur = cur.right = <span class="number">5</span>;</span><br><span class="line">&gt; (<span class="number">3</span>)stack里面还有一个以<span class="number">1</span>为root的TreeNode,进入第三次循环，stack加入以<span class="number">5</span>为root的TreeNode,ans加入<span class="number">5</span>，cur = <span class="keyword">null</span>,</span><br><span class="line">&gt; (<span class="number">4</span>)stack里面还有一个以<span class="number">1</span>为root的TreeNode,进入第四次循环，ans加入<span class="number">1</span>，cur = cur.right = <span class="number">3</span></span><br><span class="line">&gt; (<span class="number">5</span>)cur!=<span class="keyword">null</span>,进入第四次循环,stack加入<span class="number">3</span>和<span class="number">6</span>为root的树，ans加入<span class="number">6</span>，cur = <span class="keyword">null</span></span><br><span class="line">&gt; (<span class="number">6</span>) stack里面还有一个以<span class="number">3</span>为root的TreeNode,进入第五次循环，ans加入<span class="number">3</span>，cur = <span class="keyword">null</span>,stack为空，结束循环</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">              inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">          List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">          TreeNode cur = root;</span><br><span class="line">          <span class="keyword">while</span> (cur!=<span class="keyword">null</span> ||!stack.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  stack.push(cur);</span><br><span class="line">                  cur = cur.left;</span><br><span class="line">              &#125;</span><br><span class="line">              cur = stack.pop();</span><br><span class="line">              ans.add(cur.val);</span><br><span class="line">              cur = cur.right;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/94.jpg" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【717】1比特和2比特字符</title>
      <link href="/2019/06/leetcode-717-1%E6%AF%94%E7%89%B9%E5%92%8C2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/"/>
      <url>/2019/06/leetcode-717-1%E6%AF%94%E7%89%B9%E5%92%8C2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。<a id="more"></a></p></blockquote><blockquote><p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p></blockquote><blockquote><p>示例 1:</p><p>输入: </p><p>bits = [1, 0, 0] 输出: True 解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</p><p>示例 2:</p><p>输入: bits = [1, 1, 1, 0] 输出: False 解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>从倒数第二个开始计算1的个数，直到遇到0结束，如果此时得到的1的个数是奇数个，代表最后一个0是2比特中的0，如果是偶数个，代表最后一个0是1比特中的0.</p><p>如：</p><p>111110<strong>11111</strong>0 ： 得到的count = 5，则最后一个0是2比特中的0,返回false</p><p>111110<strong>1111</strong>0 ： 得到的count = 4，则最后一个0是1比特中的0，返回true</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = bits.length -<span class="number">2</span> ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(bits[i]==<span class="number">1</span>) count++;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = count % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span>  ret==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/717.png" alt="提交记录"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题-【01背包】【完全背包】【多重背包】【多限定条件背包】</title>
      <link href="/2019/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2019/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><blockquote><p> 给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p></blockquote><a id="more"></a><p>可参考<a href="https://www.cnblogs.com/-guz/p/9866118.html" target="_blank" rel="noopener">https://www.cnblogs.com/-guz/p/9866118.html</a></p><h3 id="1-0-1背包问题-求最大的价值，不要求恰好装满这个包"><a href="#1-0-1背包问题-求最大的价值，不要求恰好装满这个包" class="headerlink" title="1.  0-1背包问题[求最大的价值，不要求恰好装满这个包]"></a>1.  0-1背包问题[求最大的价值，不要求恰好装满这个包]</h3><blockquote><p>我们有n种物品，物品i的重量为weight[i]，价格为value[i]。我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为total。如果限定<strong>每种物品只能选择0个或1个</strong>，求背包里面能放的最大价格。</p></blockquote><p>   dp[i][v]代表“将前i件物品放入容量为v的背包中得到的最大价值。</p><blockquote><p>情况1：第i件不放进去，转化成前i-1件物品放入容量为v的背包中的价值的情况，此时所得价值</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>dp[i-1][v]</code></p><p>情况2：第i件放进去，要是容量只能为v,则可以转化成将前<code>i-1</code>件物品放入<code>v-weight[i]</code>的背包里，此时加入第i件的重量恰好是v重量的背包，所得价值</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>dp[i-1][v-weight[i]] + c[i]</code>，</p><p>由此得到状态转移方程：注：dp[i][v]表示重量不超过v公斤的最大价值</p><p>&emsp; <code>dp[i][v] = Math.max(dp[i-1][v],dp[i-1][v-w[i]]+c[i])</code></p></blockquote><blockquote><p>时间和空间复杂度都为<code>O(Num*total)=O(N*N)</code>,可以将其压缩成空间为<code>O(total) = O(N)</code></p></blockquote><blockquote><ul><li>情况1：第i件不放进去，所得价值<code>dp[v]</code></li><li>情况2：第i件放进去，所得价值<code>dp[v-weight[i]]+c[i]</code></li></ul><p>由此得到状态转移方程：dp[v]表示重量不超过v公斤的最大价值<br>       &emsp;  &emsp;  &emsp;<code>dp[v] = Math.max(dp[v],dp[v-w[i]]+c[i])</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;     <span class="comment">//weight表示每件物品的重量，value代表每件物品的价值，total 表示容量，Num表示物品数量，设 dp[v]表示重量不超过v公斤的最大价值</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ZeroOnePackage</span><span class="params">(<span class="keyword">int</span> []weight,<span class="keyword">int</span> []value,<span class="keyword">int</span> []dp,<span class="keyword">int</span> Num,<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Num;i++)&#123;</span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">int</span> v = total;v&gt;=weight[i];v--)&#123; <span class="comment">//注意是逆序</span></span><br><span class="line">&gt;                 dp[v] = Math.max(dp[v-weight[i]]+value[i],dp[v]);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> dp[total];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>关于为什么是逆序：<a href="https://www.jb51.net/article/126072.htm" target="_blank" rel="noopener">https://www.jb51.net/article/126072.htm</a></p><ul><li>如果只用一个数组dp[0…V]，要保证每次主循环中我们要以v = V…0的顺序推dp[v],才能保证推dp[v]时dp[v-weight[i]]保存的状态是dp[i-1][v-weight[i]]的值，</li><li>因为如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-weight[i]]推出了而不是f[i-1][v-weight[i]]</li></ul></blockquote><h3 id="2-0-1背包问题-要求恰好装满这个包，此时的最大价值"><a href="#2-0-1背包问题-要求恰好装满这个包，此时的最大价值" class="headerlink" title="2. 0-1背包问题[要求恰好装满这个包，此时的最大价值]"></a>2. 0-1背包问题[要求恰好装满这个包，此时的最大价值]</h3><blockquote><p>&emsp;与以上不同初始化时除了f[0]为0其它f[1..V]均设为-∞，可以这样理解，可以这样理解：初始化的dp数组事实上就是在没有任何物品可以放入背包时的合法状态。</p><p>&emsp;如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。</p><p>&emsp;如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ZeroOnePackage</span><span class="params">(<span class="keyword">int</span> []weight,<span class="keyword">int</span> []value,<span class="keyword">int</span> Num,<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">&gt;        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[total+<span class="number">1</span>];</span><br><span class="line">&gt;        <span class="comment">//初始化dp数组</span></span><br><span class="line">&gt;        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;dp.length;i++)</span><br><span class="line">&gt;            dp[i] = Integer.MIN_VALUE; </span><br><span class="line">&gt;        <span class="comment">//动态规划背包问题</span></span><br><span class="line">&gt;       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Num;i++)&#123;</span><br><span class="line">&gt;           <span class="keyword">for</span>(<span class="keyword">int</span> v = total;v&gt;=weight[i];v--)&#123; <span class="comment">//注意是逆序</span></span><br><span class="line">&gt;               dp[v] = Math.max(dp[v-weight[i]]+value[i],dp[v]);</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;       <span class="keyword">return</span> dp[total];</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2. 完全背包问题"></a>2. 完全背包问题</h3><p>有Num种物品和一个容量为total的背包，每种物品都有无限件可用。第i种物品的体重量是weight[i]，价值是value[i]。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</p><blockquote><p>&emsp;情况1：第i件不放进去，所得价值  <code>dp[i-1][v]</code></p><p>&emsp;情况2：第i件放进去，所得价值  <code>dp[i-1][v-weight[i]]+c[i]</code></p><p>由此得到状态转移方程：，dp[i][v]表示前i个背包装入重量不超过v公斤的最大价值</p><p> <code>dp[i][v] = Math.max(dp[i-1][v],dp[i-1][v-n*w[i]]+n*c[i]){0&lt;n*value[i]&lt;total}</code></p></blockquote><blockquote><p>时间和空间复杂度都为<code>O(Num*total)=O(N*N)</code>,可以将其压缩成空间为<code>O(total) = O(N)</code></p></blockquote><blockquote><ul><li>情况1：第i件不放进去，所得价值<code>dp[v]</code></li><li>情况2：第i件放进去，所得价值<code>dp[v-weight[i]]+c[i]</code></li></ul><p>由此得到状态转移方程：f[v]表示重量不超过v公斤的最大价值<br>    <code>dp[v] = Math.max(dp[v],dp[v-n*w[i]] + n*c[i])   {0&lt;n*value[i]&lt;total}</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//weight表示每件物品的重量，value代表每件物品的价值，total 表示容量，Num表示物品数量，设 f[v]表示重量不超过v公斤的最大价值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ZeroMorePackage</span><span class="params">(<span class="keyword">int</span> []weight,<span class="keyword">int</span> []value,<span class="keyword">int</span> []dp,<span class="keyword">int</span> Num,<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Num;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v = weight[i];v&lt;=total;v++)&#123; <span class="comment">//注意是++</span></span><br><span class="line">                dp[v] = Math.max(dp[v-weight[i]]+value[i],dp[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[total];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-多重背包问题"><a href="#4-多重背包问题" class="headerlink" title="4.多重背包问题"></a>4.多重背包问题</h3><p>有Num种物品和一个容量为total的背包。第i种物品最多有eachNum[i]件可用，每件体积是weight[i]，价值是value[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量total，且价值总和最大。</p><blockquote><ul><li>情况1：第i件不放进去，所得价值<code>dp[v]</code></li><li>情况2：第i件放进去，所得价值<code>dp[v-weight[i]] + c[i]</code></li></ul><p>由此得到状态转移方程：dp[v]表示装入重量不超过v公斤的最大价值<br>&emsp;&emsp;<code>dp[v] = Math.max(dp[v] , dp[v-n*w[i]] + n*c[i])</code> {0 &lt; k &lt; eachNum[i]，0&lt;k*value[i]&lt;total}，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多重背包问题</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MorePackage</span><span class="params">(<span class="keyword">int</span> []weight,<span class="keyword">int</span> []value,<span class="keyword">int</span> []dp,<span class="keyword">int</span> Num,<span class="keyword">int</span> total,<span class="keyword">int</span> eachNum[])</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Num;i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> v = total; v &gt;= <span class="number">0</span>; v--) &#123; <span class="comment">//注意是逆序</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= eachNum[i]; k++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (v - k * weight[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       dp[v] = Math.max(dp[v - k * weight[i]] + k * value[i], dp[v]);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[total];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="5-多限定条件的背包问题"><a href="#5-多限定条件的背包问题" class="headerlink" title="5.多限定条件的背包问题"></a>5.多限定条件的背包问题</h3><blockquote><p>&emsp;&emsp; 航天飞机的体积有限,当然如果载过重的物品,燃料会浪费很多钱,每件食品都有各自的体积、质量以及所含卡路里,在告诉你体积和质量的最大值的情况下,请输出能达到的食品方案所含卡路里的最大值,当然每个食品只能使用一次.<br>  <strong>输入格式</strong><br>  &emsp;&emsp;第一行 两个数 体积最大值(&lt;400)和质量最大值(&lt;400)<br>  &emsp;&emsp;第二行 一个数 食品总数N(&lt;50).<br>  &emsp;&emsp;第三行－第3+N行,每行三个数 体积(&lt;400) 质量(&lt;400) 所含卡路里(&lt;500)<br>  <strong>输出格式</strong><br> &emsp;&emsp; 一个数,所能达到的最大卡路里(int范围内)<br>  <strong>样例输入</strong><br> &emsp;&emsp; 320&emsp; 350<br>  &emsp;&emsp; 4<br> &emsp;&emsp;160&emsp; 40 &emsp;120<br>&emsp;&emsp;  80 &emsp;110&emsp; 240<br> &emsp;&emsp; 220&emsp;70 &emsp; 310<br> &emsp;&emsp; 40 &emsp;400&emsp; 220<br>  <strong>样例输出</strong><br> &emsp;&emsp; 550</p></blockquote><blockquote><p>dp[i][j][k]代表“前i件物品，此刻体积为j,质量为k时，可得到的最大卡路里值。</p><p>第i件不放进去，转化成前i-1件物品此刻体积为j,质量为k时，可得到的最大卡路里值，此时所得卡路里</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>dp[i-1][j][k]</code></p><p>第i件放进去，要是体积只能为j,质量只能为k,则可以转化成将前<code>i-1</code>件物品放入体积为<code>j-vol[i]</code>，质量为<code>k-qua[i]</code>的背包里，此时加入第i件的体积恰好是j,质量恰好是k的背包，所得卡路里为</p><p>&emsp;&emsp; &emsp;&emsp;<code>dp[i-1][j-vol[i]][k-qua[i]]+ calorie[i]</code></p><p>由此得到状态转移方程：</p><p>&emsp;&emsp;&emsp;<code>dp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j-vol[i]][k-qua[i]]+ calorie[i]);</code></p></blockquote><blockquote><p>可以将其压缩成空间为<code>O(total) = O(N*N)</code></p><ul><li>情况1：第i件不放进去，所得价值<code>dp[j][k]</code></li><li>情况2：第i件放进去，所得价值<code>dp[j-vol[i]][k-qua[i]]+ calorie[i]</code></li></ul><p>由此得到状态转移方程：<br>    &emsp;&emsp;&emsp; &emsp;&emsp;  <code>dp[j][k] = Math.max(dp[j][k],dp[j-vol[i]][k-qua[i]]+ calorie[i]);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">solution</span><span class="params">(<span class="keyword">int</span> Num,<span class="keyword">int</span> Volume,<span class="keyword">int</span> Quality,<span class="keyword">int</span> vol[],<span class="keyword">int</span> qua[],<span class="keyword">int</span> calorie[])</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span> [Volume+<span class="number">1</span>][Quality+<span class="number">1</span>];</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Num;i++)&#123;  <span class="comment">//食品数量</span></span><br><span class="line">&gt;             <span class="keyword">for</span>(<span class="keyword">int</span> j = Volume;j&gt;=vol[i];j--)&#123;  <span class="comment">//体积</span></span><br><span class="line">&gt;                 <span class="keyword">for</span>(<span class="keyword">int</span> k = Quality;k &gt;= qua[i];k--)&#123; <span class="comment">//质量</span></span><br><span class="line">&gt;                     dp[j][k] = Math.max(dp[j][k],dp[j-vol[i]][k-qua[i]]+ calorie[i]);</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> dp[Volume][Quality];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;         Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">&gt;         <span class="keyword">int</span> Volume  = sr.nextInt();</span><br><span class="line">&gt;         <span class="keyword">int</span> Quality = sr.nextInt();</span><br><span class="line">&gt;         <span class="keyword">int</span> Num = sr.nextInt();</span><br><span class="line">&gt;         <span class="keyword">int</span> vol[] = <span class="keyword">new</span> <span class="keyword">int</span>[Num];</span><br><span class="line">&gt;         <span class="keyword">int</span> qua[] = <span class="keyword">new</span> <span class="keyword">int</span>[Num];</span><br><span class="line">&gt;         <span class="keyword">int</span> calorie[] = <span class="keyword">new</span> <span class="keyword">int</span>[Num];</span><br><span class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Num;i++)&#123;</span><br><span class="line">&gt;             vol[i] = sr.nextInt();</span><br><span class="line">&gt;             qua[i] = sr.nextInt();</span><br><span class="line">&gt;             calorie[i] = sr.nextInt();</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         System.out.println(solution(Num,Volume,Quality,vol,qua,calorie));</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【55】跳跃游戏</title>
      <link href="/2019/06/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/06/leetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。<a id="more"></a></p><p>示例 1:</p><p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。<br>示例 2:</p><p>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><pre><code>从左到右依次判断索引坐标i是否能跳到，当遍历到数组末尾时，当dp[nums.length-1]==true时说明能跳到这个位置。即可以跳到最后一个位置。</code></pre><p>方法2: 贪心算法</p><pre><code>从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意味着可以从第一个位置跳到最后的位置。</code></pre><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(nums==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> []dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">      dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">              <span class="comment">//如果之前j节点可达，并且从此节点可以跳到i</span></span><br><span class="line">              <span class="keyword">if</span>(dp[j] &amp;&amp; nums[j]+j&gt;=i)&#123;</span><br><span class="line">                  dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：贪心算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJump2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastPos = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= lastPos) &#123;</span><br><span class="line">                lastPos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastPos == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p>方法1：动态规划</p><p>![leetcode提交结果]</p><p>(<a href="https://github.com/qiulig/IMG/raw/master/55-1.jpg" target="_blank" rel="noopener">https://github.com/qiulig/IMG/raw/master/55-1.jpg</a>)</p><p>方法2：贪心算法</p><p>![leetcode提交结果]</p><p>(<a href="https://github.com/qiulig/IMG/raw/master/55-2.jpg" target="_blank" rel="noopener">https://github.com/qiulig/IMG/raw/master/55-2.jpg</a>)</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-82.删除排序链表中的重复元素2</title>
      <link href="/2019/06/leetcode-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/"/>
      <url>/2019/06/leetcode-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。<a id="more"></a></p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br>示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>剑指offer-56题</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head.val==head.next.val)&#123;</span><br><span class="line">                ListNode node = head.next;</span><br><span class="line">                <span class="keyword">while</span>( node != <span class="keyword">null</span> &amp;&amp; head.val == node.val )&#123;</span><br><span class="line">                   node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> deleteDuplicates(node);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head.next = deleteDuplicates(head.next);</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-83.删除排序链表中的重复元素</title>
      <link href="/2019/06/leetcode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>/2019/06/leetcode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><a id="more"></a><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode res = head;</span><br><span class="line">       <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span> &amp;&amp; head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val == head.next.val)&#123;</span><br><span class="line">                head.next = head.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/83.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-各种模式应用场景</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><pre><code>将对象的创建与使用分离。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。</code></pre><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-  单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</span><br><span class="line"></span><br><span class="line">-  原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</span><br><span class="line"></span><br><span class="line">-  工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</span><br><span class="line"></span><br><span class="line">-  抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</span><br><span class="line"></span><br><span class="line">-  建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</span><br><span class="line"></span><br><span class="line">以上 <span class="number">5</span> 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式，</span><br></pre></td></tr></table></figure><p>1.<strong>单例（Singleton）模式</strong></p><pre><code>某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</span><br><span class="line"><span class="number">2</span>.当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</span><br><span class="line"><span class="number">3</span>.当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</span><br></pre></td></tr></table></figure><p>2.<strong>原型（Prototype）模式</strong></p><pre><code>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果一个系统想要独立于它想要使用的对象时,可以使用原型模式,让系统只面向接口编程,在系统需要新的对象的时候,可以通过克隆原型来得到.  </span><br><span class="line"><span class="number">2</span>.如果需要实例化的类是在运行时刻动态指定时,可以使用原型模式,通过克隆原型来得到需要的实例.</span><br></pre></td></tr></table></figure><p>3.<strong>工厂方法（FactoryMethod）模式</strong></p><pre><code>定义一个用于创建产品的接口，由子类决定生产什么产品。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.客户类不关心使用哪个具体类,只关心该接口所提供的功能.  </span><br><span class="line"><span class="number">2</span>.创建过程比较复杂,例如需要初始化其他关联的资源类,读取配置文件等.  </span><br><span class="line"><span class="number">3</span>.接口有很多具体实现或者抽象类有很多具体子类时,  </span><br><span class="line"><span class="number">4</span>.不希望给客户程序暴露过多的此类的内部结构,隐藏这些细节可以降低耦合度.      </span><br><span class="line"><span class="number">5</span>.优化性能,比如缓存大对象或者初始化比较耗时的对象.</span><br></pre></td></tr></table></figure><p>4.<strong>抽象工厂（AbstractFactory）模式</strong></p><pre><code>提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果希望一个系统独立于它的产品的创建,组合和表示的时候,换句话说,希望一个系统只是知道产品的接口,而不关心实现的时候.  </span><br><span class="line"><span class="number">2</span>.如果一个系统要由多个产品系列中的一个来配置的时候.换句话说,就是可以,就是可以动态地切换产品族的时候.  </span><br><span class="line"><span class="number">3</span>.如果强调一系列相关产品的接口,以便联合使用他们的时候</span><br></pre></td></tr></table></figure><p>5.<strong>建造者（Builder）模式</strong></p><pre><code>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果创建对象的算法,应该独立于该对象的组成部分以及它们的装配方式时  </span><br><span class="line"><span class="number">2</span>.如果同一个构建过程有着不同的表示时</span><br></pre></td></tr></table></figure><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><pre><code>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-   适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</span><br><span class="line">-   桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</span><br><span class="line">-   组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</span><br><span class="line">-   装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</span><br><span class="line">-   外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</span><br><span class="line">-   享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</span><br><span class="line">-   代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</span><br><span class="line">    以上 <span class="number">7</span> 种结构型模式，除了 适配器模式 分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式</span><br></pre></td></tr></table></figure><p><strong>1.适配器模式(Adapter)</strong></p><pre><code>将一个类的接口转换成客户希望的另外一个接口.适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果先要使用一个已经存在的类,但是它的接口不符合你的需求,这种情况可以使用适配器模式,来把已有的实现转换成你需要的接口.</span><br><span class="line"><span class="number">2</span>.如果你想创建一个可以复用的类,这个类可能和一些不兼容的类一起工作,这中情况可以使用适配器模式,到时候需要什么就适配什么. </span><br><span class="line"><span class="number">3</span>.如果你想使用一些已经窜在的子类,但不对每一个子类都进行适配,这中情况可以使用适配器模式,直接适配这些子类的父类就可以了.</span><br></pre></td></tr></table></figure><p><strong>2.桥接模式(Bridge)</strong></p><pre><code>将抽象部分与它的实现部分分离,使他们可以独立变化. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果你不希望在抽象部分和实现部分采用固定的绑定关系,可以采用桥接模式. </span><br><span class="line"><span class="number">2</span>.如果出现抽象部分和实现部分都能够扩展的情况,可以采用桥接模式,让抽象部分和实现部分独立地变化. </span><br><span class="line"><span class="number">3</span>.如果希望实现部分的修改不会对客户产生影响,可以采用桥接模式. </span><br><span class="line"><span class="number">4</span>.如果采用继承的实现方案,会导致产生很多子类,对于这种情况,可以考虑采用桥接模式.</span><br></pre></td></tr></table></figure><p><strong>3.组合模式(Composite)</strong></p><pre><code>将对象组合成属性结构以表示&quot;部分-整体&quot;的层次结构,组合模式使用的用户对单个对象和组合对象的使用具有一致性. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果你想表示对象的部分-整体层次结构,可以使用..把整体和部分的操作统一起来,使得层次结构实现更简单,从外部来使用,这个层次结构也容易. </span><br><span class="line"><span class="number">2</span>.如果希望同意地使用组合结构中的所有对象,可以选用,这正是组合模式提供的主要功能.</span><br></pre></td></tr></table></figure><p><strong>4.装饰器模式(Decorator Method)</strong></p><p> 动态的给一个对象增加一些额外的职责,就增加功能来说,装饰模式生成子类更为灵活. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果需要爱不影响其他对象的情况下,以动态,透明的方式给对象添加职责,可以使用装饰模式. </span><br><span class="line"><span class="number">2</span>.如果不适合使用子类来进行扩展的时候,可以考虑使用装饰模式.</span><br></pre></td></tr></table></figure><p><strong>5.外观模式(Facade)</strong></p><pre><code>为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层的接口,这个接口使得这一子系统更加同容易使用.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果希望为一个复杂的子系统提供一个简单接口的时候,可以考虑使用外观模式.使用外观对象来实现大部分客户需要的功能,从而简化客户的使用. </span><br><span class="line"><span class="number">2</span>.如果想要让客户程序和抽象类的实现部分松散耦合,可以考虑使用外观模式,使用外观对象来将这个子系统与他的客户分离开来,从而提高子系统的独立性和可移植性. </span><br><span class="line"><span class="number">3</span>.如果构建多层节后的系统,可以考虑使用外观模式使用外观模式对象作为每层的入口,这样可以简化层间调用,也可以松散出层次之间的依赖关系.</span><br></pre></td></tr></table></figure><p><strong>6.享元模式(Flyweight)</strong></p><pre><code>运用共享技术有效地支持大量细粒度的对象. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果一个应用程序使用了大量的细粒度对象,可以使用享元模式来减少对象的数量. </span><br><span class="line"><span class="number">2</span>.如果犹豫使用大量的对象,造成很大的存储开销,可以使用享元模式来减少对象数量,并节约内存. </span><br><span class="line"><span class="number">3</span>.如果对象的大多数状态都可以转变成外部状态,比如通过计算得到,或者从外部传入等,可以使用享元模式来实现内部状态和外部状态的分离.</span><br><span class="line"><span class="number">4</span>.如果不考虑对象的外部状态,可以用相对较少的共享对象取代很多组合对象,可以使用享元模式来共享对象.然后组合对象来使用这些共享对象.</span><br></pre></td></tr></table></figure><p><strong>7.代理模式(Proxy)</strong></p><pre><code>为其他对象提供一种代理以控制对这个对象的访问.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.需要为一个对象在不同的地址空间提供局部代表的时候,可以使用远程代理. </span><br><span class="line"><span class="number">2</span>.需要按照需要创建开销很大的对象的时候,可以使用虚代理. </span><br><span class="line"><span class="number">3</span>.需要控制对原始对象的访问的时候,可以使用保护代理. </span><br><span class="line"><span class="number">4</span>.需要在访问你对象执行一些附加操作的时候,可以使用智能指引代理.</span><br></pre></td></tr></table></figure><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><pre><code>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。  行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。  </code></pre><p>行为型模式是 设计模式中最为庞大的一类，它包含以下 11 种模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-   模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</span><br><span class="line">-   策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</span><br><span class="line">-   命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</span><br><span class="line">-   职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</span><br><span class="line">-   状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</span><br><span class="line">-   观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</span><br><span class="line">-   中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</span><br><span class="line">-   迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</span><br><span class="line">-   访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</span><br><span class="line">-   备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</span><br><span class="line">-   解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</span><br></pre></td></tr></table></figure><p><strong>1.策略模式(Strategy)</strong></p><pre><code>定义一系列的算法,把它们一个个封装起来,并且使他们可以相互替换.本模式使得算法可独立于使用它的客户而变化. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.出现有许多相关的类,仅仅是行为有差别的情况下,可以使用策略模式来使用多个行为中的一个来配置一个类的方法,实现算法动态切换 </span><br><span class="line"><span class="number">2</span>.出现同一算法,有很多不同实现的情况下,可以使用策略模式来把这些<span class="string">"不同的实现"</span>实现成为一个算法的类层次. </span><br><span class="line"><span class="number">3</span>.需要封装算法中,有与算法相关数据的情况下,可以使用策略模式来避免暴露这些跟算法相关的数据结构. </span><br><span class="line"><span class="number">4</span>.出现抽象一个定义了很多行为的类,并且是通过多个<span class="keyword">if</span>-<span class="keyword">else</span>语句来选择这些行为的情况下,可以使用策略模式来替换这些条件语句.</span><br></pre></td></tr></table></figure><p><strong>2.模版方法模式(TemplateMethod)</strong></p><pre><code>定义在一个操作中的算法框架,把一些步骤推迟到子类去实现.模版方法模式让子类不需要改变算法的结构而重新定义特定的算法步骤 </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</span><br></pre></td></tr></table></figure><p><strong>3.职责链模式(Chain Of Responsibility)</strong></p><pre><code>使多个对象都有机会处理请求,,从而避免请求的发送者和接收者之间耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果有多个对象可以处理同一个请求,但是具体由哪个对象来处理该请求,是运行时刻动态确定的. </span><br><span class="line"><span class="number">2</span>.如果你想在不明确指定接收者的情况下,向多个对象中的其中一个提交请求的话,可以使用职责链模式. </span><br><span class="line"><span class="number">3</span>.如果想要动态指定处理一个请求的对象结合,可以使用职责链模式.</span><br></pre></td></tr></table></figure><p><strong>4.命令模式(Command)</strong></p><pre><code>将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化,对请求排队或者记录请求日志,以及支持可撤销的操作.</code></pre><p><strong>5.解释器模式(Interpreter)</strong></p><pre><code>给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子. 使用场合:</code></pre><p><strong>6.迭代器模式(Iterator)</strong> </p><pre><code>提供一种方法顺序访问一个聚合对象中的各个元素,而又不需要暴露该对象的内部表示. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果你希望提供访问一个聚合对象的内容,但是又不想暴露他的内部表示的时候,可以使用迭代器模式来提供迭代器接口,从而让客户端只是通过迭代器的接口来访问聚合对象,而无须关心聚合对象的内部实现. </span><br><span class="line"><span class="number">2</span>.如果你希望有多种遍历方式可以访问聚合对象,可以使用</span><br><span class="line"><span class="number">3</span>.如果你希望为遍历不同的聚合对象提供一个统一的接口,可以使用....</span><br></pre></td></tr></table></figure><p><strong>7.中介模式(Mediator)</strong></p><pre><code>用一个中介对象类封装一系列对象的交互.中介者使得各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变他们之间的交互. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果一组对象之间的通信方式比较复杂,导致相互依赖,结构混乱,可以采用中介模式,把这些对象相互的交互管理起来,各个对象都只需要和中介者交互,从而是的各个对象松散耦合,结构也更清晰易懂. </span><br><span class="line"><span class="number">2</span>.如果一个对象引用很多的对象,并直接跟这些对象交互,导致难以复用该对象,可以采用中介者模式,把这个对象跟其他对象的交互封装到中介者对象里面,这个对象只需要和中介者对象交互就可了.</span><br></pre></td></tr></table></figure><p><strong>8.备忘录模式(Memento)</strong></p><pre><code>在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可将该对象恢复到原先保存的状态. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果必须要保存一个对象在某一个时刻的全部或者部分状态,方便以后需要的时候,可以把该对象恢复到先前的状态,可以使用备忘录模式. </span><br><span class="line"><span class="number">2</span>.如果需要保存一个对象的内部状态,但是如果用接口来让其他对象直接得到这些需要保存的状态,将会暴露对象的实现希捷并破坏对象的封装性,这是可以使用备忘录.</span><br></pre></td></tr></table></figure><p><strong>9.观察者模式(Observer)</strong></p><pre><code>定义对象间的一种一对多的依赖关系.当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.当一个抽象模型有两个方面,其中一个方面的操作依赖于另一个方面的状态变化,那么就可以选用观察者模式,将这两者封装成观察者和目标对象,当目标对象变化的时候,依赖于它的观察者对象也会发生相应的变化.这样就把抽象模型的这两个方面分离了使得,它们可以独立地改变和复用. </span><br><span class="line"><span class="number">2</span>.如果在更改一个对象的时候,需要同时连带改变其他对象,而且不知道究竟应该有多少对象需要被连带改变,这种情况可以选用观察者模式,被改的那一个对象很明显就相当于是目标对象,而需要连带修改的对歌其他对象,就作为多个观察着对象了. </span><br><span class="line"><span class="number">3</span>.当一个对象必须通知其他的对象,但是你又希望这个对象和其他被它通知的对象是松散耦合的,也就是说这个对象其实不详知道具体被通知的对象.这种情况可以选用观察者模式,这个对象就相当于是目标对象,而被它通知的对象就是观察者对象了.</span><br></pre></td></tr></table></figure><p><strong>10.状态模式(State)</strong></p><pre><code>允许一个对象在其内部状态改变是改变它的行为.对象看起来似乎修改了他的类. </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果一个对象的行为取决于它的状态,而且它必须在运行时刻根据状态来改变它的行为,可以使用.来包状态和行为分离开.虽然分离了,但是状态和行为是有对应关系的,可以在运行期间,通过改变状态,就能够调用到该状态对应的状态处理对象上去从而改变对象的行为. </span><br><span class="line"><span class="number">2</span>.如果一个操作中含有庞大的多分枝语句,而且这些分支依赖于该对象的状态,可以使用</span><br><span class="line"><span class="number">3</span>.把各个分支的处理分散包装到单独的对象处理类中,这样,这些分支对应的对象就可以不依赖于其他对象而独立变化了.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><pre><code>多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式。</code></pre><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>1. 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。2. 目标与观察者之间建立了一套触发机</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>1. 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。2. 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</code></pre><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'抽象主题'</span>（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'具体主题'</span>（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'抽象观察者'</span>（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'具体观察者'</span>（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。2. 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</span><br><span class="line"><span class="number">1</span>. Observable类</span><br><span class="line">    <span class="number">1</span>) Observable 类是抽象目标类，它有一个 Vector 向量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 <span class="number">3</span> 个方法。</span><br><span class="line">    <span class="number">2</span>)<span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> 方法：用于将新的观察者对象添加到向量中。</span></span><br><span class="line"><span class="function">    3)<span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> 方法：调用向量中的所有观察者对象的 update。方法，通知它们数据发生改变。通常越晚加入向量的观察者越先得到通知。</span></span><br><span class="line"><span class="function">    4)<span class="keyword">void</span> <span class="title">setChange</span><span class="params">()</span> 方法：用来设置一个 <span class="keyword">boolean</span> 类型的内部标志位，注明目标对象发生了变化。当它为真时，<span class="title">notifyObservers</span><span class="params">()</span> 才会通知观察者。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2. Observer 接口</span></span><br><span class="line"><span class="function">    Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o,Object arg)</span> 方法，进行相应的工作。</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Subject subject=<span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1=<span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2=<span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers=<span class="keyword">new</span> ArrayList&lt;Observer&gt;();   </span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体目标发生改变..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);       </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        &#125;      </span><br><span class="line"></span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者1作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体观察者2作出反应！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><pre><code>对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</code></pre><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>1. 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。2. 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。3. 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。4. 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。5. 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。2. 策略模式造成很多的策略类。</code></pre><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'抽象策略'</span>（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'具体策略'</span>（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'策略上下文'</span>（Context）类：持有一个策略类的引用，最终给客户端调用。</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</span><br><span class="line">具体使用：Java SE 的容器布局管理，每个容器都存在多种布局供用户选择</span><br><span class="line">         线程池的拒绝策略RejectedExecutionHandler：AbortPolicy/DiscardPolicy/DiscardOldestPolicy/CallerRunsPolicy</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Context c=<span class="keyword">new</span> Context();</span><br><span class="line">        Strategy s=<span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        s=<span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">        c.setStrategy(s);</span><br><span class="line">        c.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象策略类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span>;    <span class="comment">//策略方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体策略A的策略方法被访问！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体策略类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"具体策略B的策略方法被访问！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Strategy <span class="title">getStrategy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy=strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        strategy.strategyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-模板方法模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><pre><code>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</code></pre><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 它<span class="string">'封装了不变部分，扩展可变部分'</span>。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 它在父类中提取了公共的部分代码，<span class="string">'便于代码复用'</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. <span class="string">'部分方法是由子类实现'</span>的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.对每个不同的实现都需要定义一个子类，这会导致类的个数增加，<span class="string">'系统更加庞大'</span>，设计也更加抽象。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</span><br></pre></td></tr></table></figure><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="string">'抽象类'</span>（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</span><br><span class="line"></span><br><span class="line">    ① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</span><br><span class="line"></span><br><span class="line">    ② 基本方法：是整个算法中的一个步骤，包含以下几种类型。</span><br><span class="line"></span><br><span class="line">         抽象方法：在抽象类中申明，由具体子类实现。</span><br><span class="line"></span><br><span class="line">         具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</span><br><span class="line"></span><br><span class="line">         钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) <span class="string">'具体子类'</span>（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodPattern</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AbstractClass tm=<span class="keyword">new</span> ConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> <span class="comment">//模板方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();          </span><br><span class="line">         abstractMethod2();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> <span class="comment">//具体方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抽象类中的具体方法被调用..."</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>; <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>; <span class="comment">//抽象方法2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抽象方法1的实现被调用..."</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抽象方法2的实现被调用..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-组合模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><pre><code>有时又叫作部分-整体模式，将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</code></pre><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>1. 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>1.设计较复杂，客户端需要花更多时间理清类之间的层次关系；2.不容易限制容器中的构件；3.不容易用继承的方法来增加构件的新功能；</code></pre><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'抽象构件'</span>（Component）角色：它的主要作用是为树叶构件和树枝构件<span class="string">'声明公共接口，并实现它们的默认行为'</span>。在透明式的组合模式中抽象</span><br><span class="line">    构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'树叶构件'</span>（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于<span class="string">'实现抽象构件角色中声明的公共接口'</span>。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'树枝构件'</span>（Composite）角色：是组合中的分支节点对象，它有子节点。它<span class="string">'实现了抽象构件角色中声明的接口'</span>，它的主要作用是存储和管理</span><br><span class="line">    子部件，通常包含 Add()、Remove()、GetChild() 等方法。</span><br></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1-透明式"><a href="#1-透明式" class="headerlink" title="(1) 透明式"></a>(1) 透明式</h4><pre><code>抽象构件声明了所有子类中的全部方法，包括add,remove等，使树叶和树枝具备完全一致的行为接口。所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。缺点：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。</code></pre><h4 id="2-安全式"><a href="#2-安全式" class="headerlink" title="(2) 安全式"></a>(2) 安全式</h4><pre><code>抽象构件不去声明add、remove方法，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题。缺点：由于不够透明，树叶和树枝不具备相同的接口，客户端的调用需要做相应的判断带来不便。</code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1.在需要表示一个对象整体与部分的层次结构的场合。2.要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。Java  AWT/Swing中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component c0=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component c1=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">"1"</span>); </span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">"2"</span>); </span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">"3"</span>);          </span><br><span class="line">        c0.add(leaf1); </span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2); </span><br><span class="line">        c1.add(leaf3);          </span><br><span class="line">        c0.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123; &#125;           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123; &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"树叶"</span>+name+<span class="string">"：被访问！"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children=<span class="keyword">new</span> ArrayList&lt;Component&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-外观模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><pre><code>为多个子系统提供一个统一的接口，而使这些子系统更加容易被访问的模式。降低系统的耦合度。迪米特法则的典型应用，但是增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</code></pre><a id="more"></a><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="string">'外观'</span>（Facade）角色：为多个子系统对外提供一个共同的接口。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'子系统'</span>（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</span><br><span class="line"></span><br><span class="line">-  <span class="string">'客户'</span>（Client）角色：通过一个外观角色访问各个子系统的功能。</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>(1) 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。(2) 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。(3) 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Facade f=<span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1=<span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2=<span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3=<span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统01的method1()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统02的method2()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统03的method3()被调用！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-装饰模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><pre><code>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。就增加功能来说，装饰模式比生成子类更为灵活。</code></pre><a id="more"></a><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><pre><code>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。</code></pre><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-   <span class="string">'抽象构件'</span>（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</span><br><span class="line">-   <span class="string">'具体构件'</span>（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</span><br><span class="line">-   <span class="string">'抽象装饰'</span>（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</span><br><span class="line">-   <span class="string">'具体装饰'</span>（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   当需要给一个<span class="string">'现有类添加附加职责'</span>，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</span><br><span class="line">-   当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用<span class="string">'继承关系很难实现'</span>，而采用装饰模式却很好实现。</span><br><span class="line">-   当对象的<span class="string">'功能要求可以动态地添加，也可以再动态地撤销时'</span>。</span><br></pre></td></tr></table></figure><ul><li></li><li></li></ul><h3 id="实际中的应用"><a href="#实际中的应用" class="headerlink" title="实际中的应用"></a>实际中的应用</h3><pre><code> Java I/O 标准库的设计。例如，      (1) InputStream 的子类 FilterInputStream，      (2) OutputStream 的子类 FilterOutputStream，      (3) Reader 的子类BufferedReader 以及 FilterReader，      (4) Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component p=<span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        Component d=<span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建具体构件角色"</span>);       </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用具体构件角色的方法operation()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component=component;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为具体构件角色增加额外的功能addedFunction()"</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-桥接模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><pre><code>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</code></pre><a id="more"></a><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="string">'实现化'</span>（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</span><br><span class="line">- <span class="string">'具体实现化'</span>（Concrete Implementor）角色：给出实现化角色接口的具体实现。</span><br><span class="line">- <span class="string">'抽象化'</span>（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</span><br><span class="line">- <span class="string">'扩展抽象化'</span>（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>(1) 由于抽象与实现分离，所以扩展能力强；(2) 可动态的切换实现     由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。(3) 实现细节对客户端透明，可以对用户隐藏实现细节。</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>(1) 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 (2) 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。</code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>(1)当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。(2)当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。(3)当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Implementor imple=<span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs=<span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体实现化(Concrete Implementor)角色被访问"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Implementor imple;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.imple=imple;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(imple);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"扩展抽象化(Refined Abstraction)角色被访问"</span> );</span><br><span class="line">       imple.OperationImpl();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配器模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。<a id="more"></a>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>对类适配器来说，更换适配器的实现过程比较复杂。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ol><h3 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h3><p>适配器模式（Adapter）通常适用于以下场景。</p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p><a href="https://blog.csdn.net/wwwdc1012/article/details/82780560" target="_blank" rel="noopener">https://blog.csdn.net/wwwdc1012/article/details/82780560</a></p><h4 id="1-spring-AOP中的适配器模式"><a href="#1-spring-AOP中的适配器模式" class="headerlink" title="(1)spring AOP中的适配器模式"></a>(1)spring AOP中的适配器模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在Spring的Aop中，使用的 Advice（通知） 来增强被代理类的功能。</span><br><span class="line"></span><br><span class="line">Advice的类型有：MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice</span><br><span class="line"></span><br><span class="line">在每个类型 Advice 都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptorSpring</span><br><span class="line">需要将每个 Advice 都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对 Advice 进行转换</span><br></pre></td></tr></table></figure><h4 id="2-spring-JPA中的适配器模式"><a href="#2-spring-JPA中的适配器模式" class="headerlink" title="(2)spring JPA中的适配器模式"></a>(2)spring JPA中的适配器模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在Spring的ORM包中，对于JPA的支持也是采用了适配器模式，首先定义了一个接口的 JpaVendorAdapter，然后不同的持久层框架都实现此接口。</span><br><span class="line"></span><br><span class="line">jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，</span><br><span class="line">因此最好在这里设置；目前Spring提供 HibernateJpaVendorAdapter、OpenJpaVendorAdapter、EclipseLinkJpaVendorAdapter、</span><br><span class="line">TopLinkJpaVendorAdapter 四个实现。其中最重要的属性是 database，用来指定使用的数据库类型，从而能根据数据库类型来决定比如如何将数</span><br><span class="line">据库特定异常转换为Spring的一致性异常，目前支持如下数据库（DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、</span><br><span class="line">SQL_SERVER、SYBASE）</span><br></pre></td></tr></table></figure><h4 id="3-spring-MVC中的适配器模式"><a href="#3-spring-MVC中的适配器模式" class="headerlink" title="(3)spring MVC中的适配器模式"></a>(3)spring MVC中的适配器模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring MVC中的适配器模式主要用于执行目标 Controller 中的请求处理方法。在Spring MVC中，DispatcherServlet 作为用户，</span><br><span class="line">HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-代理模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><pre><code>为其他对象提供一种代理以控制对这个对象的访问。</code></pre><a id="more"></a><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>（1）抽象角色(Subject)：通过接口或抽象类声明真实角色实现的业务方法。</p><p>（2）代理角色（Proxy）：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p><p>（3）真实角色(RealSubject)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p><h3 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h3><pre><code>（1）远程代理。为一个位于不同的地址空间的对象提供一个本地的代理对象。这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远    程代理又叫做大使(Ambassador)。这样可以隐藏一个对象存在于不同地址空间的事实，使得客户端可以访问在远程机器上的对象。（2）虚拟代理。根据需要创建开销很大的对象。如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时    才会被真正创建。（3）安全代理。用来控制真实对象访问时的权限。（4）智能指引。当调用真实对象时，代理处理另外的一些事。</code></pre><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><pre><code>Spring 的AOP</code></pre><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>职责清晰：  真实角色就是实现实际的业务逻辑，不用关心其他非本职的事物高扩展性：  真实角色可以随时更换或扩展，只需要实现接口就行，而代理不需要有任何变化</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>(1)由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。  (2)实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</code></pre><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><pre><code>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Proxy proxy=<span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之前的预处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之后的后续处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><pre><code>在实现阶段不需要关心代理谁，在运行阶段会动态生成一个代理类去代理指定的对象</code></pre><p><strong>默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用CGlib来生成代理</strong></p><h3 id="1-jdk动态代理：接口-InvocationHandler-目标对象"><a href="#1-jdk动态代理：接口-InvocationHandler-目标对象" class="headerlink" title="(1)jdk动态代理：接口+InvocationHandler+目标对象"></a>(1)jdk动态代理：<strong>接口+InvocationHandler+目标对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主要用到java.lang.reflect中的两个类：<span class="string">'Proxy和InvocationHandler'</span></span><br><span class="line">InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类代码，动态的将横切逻辑与业务逻辑编织在一起</span><br><span class="line">     <span class="number">1</span>.定义业务逻辑接口</span><br><span class="line">     <span class="number">2</span>.实现业务逻辑接口创建业务实现类</span><br><span class="line">     <span class="number">3</span>.实现（implements）InvacationHandler代理接口，创建代理类</span><br><span class="line">     <span class="number">4</span>.创建业务类和代理类对象，通过代理类对象.bind(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。</span><br><span class="line">缺点：要求目标类必须实现对应方法非接口，它只能为接口创建代理</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvocationHandler + invoke()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被代理类的实例</span></span><br><span class="line">    Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将被代理者的实例传进动态代理类的构造函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖InvocationHandler接口中的invoke()方法</span></span><br><span class="line"><span class="comment">     * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构</span></span><br><span class="line"><span class="comment">     * 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到</span></span><br><span class="line"><span class="comment">     * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊</span></span><br><span class="line"><span class="comment">     * 代码切入的扩展点了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * before ：doSomething();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object result = method.invoke(<span class="keyword">this</span>.obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * after : doSomething();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-cglib动态代理：接口或类-MethodInterceptor-目标对象"><a href="#2-cglib动态代理：接口或类-MethodInterceptor-目标对象" class="headerlink" title="(2)cglib动态代理：接口或类+MethodInterceptor+目标对象"></a>(2)cglib动态代理：<strong>接口或类+MethodInterceptor+目标对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主要用到java.lang.reflect中的两个类:<span class="string">'MethodInterceptor和CglibProcy'</span></span><br><span class="line">    <span class="number">1</span>.定义业务类，无需实现接口（也可以实现）</span><br><span class="line">    <span class="number">2</span>.实现MethodInterceptor方法代理接口，创建代理类</span><br><span class="line">    <span class="number">3</span>.创建业务类和代理类对象，通过代理类对象.getInstance(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。</span><br><span class="line">特点：能代理类和接口，但是不能代理<span class="keyword">final</span>类</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MethodIntercepter + intercept()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Proxy instance = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getInstance</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        sayBefore();</span><br><span class="line">        Object result = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">        sayAfter();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayBefore</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"before..."</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayAfter</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"after..."</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-建造者模式</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><pre><code>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示</code></pre><a id="more"></a><h3 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h3><ol><li><strong>产品角色</strong>（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。</li><li><strong>抽象建造者</strong>（Builder）：它是一个包含创建产品各个子部件的抽象方法的<strong>接口</strong>，通常还包含一个返回复杂产品的方法 getResult()。</li><li><strong>具体建造者</strong>(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li><strong>指挥者</strong>（Director）：构建一个使用builder接口的对象。它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>主要用于创建一些复杂的对象，这些对象内部间的建造顺序是稳定的，但对象内部的构建通常面临着复杂的变化。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>（1）使得建造代码与表示代码分离，由于建造者隐藏了产品如何组装，所以若需要改变一个产品内部表示，只需要在定义一个具体的建造者就可以了。</p><p>（2） 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</p><p>（3）<strong>增加新的具体建造者无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统扩展方便，符合 <strong>“开闭原则”</strong></p><p>（4）<strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="排序算法一览表"><a href="#排序算法一览表" class="headerlink" title="排序算法一览表"></a>排序算法一览表</h3><p><img src="https://github.com/qiulig/IMG/raw/master/排序算法.jpg" alt="排序算法一览表"></p><a id="more"></a><h2 id="1-冒泡排序-稳定"><a href="#1-冒泡排序-稳定" class="headerlink" title="1.冒泡排序[稳定]"></a>1.冒泡排序[稳定]</h2><blockquote><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] Bubblesort(<span class="keyword">int</span> []arr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;<span class="comment">//外层控制排序的趟数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;<span class="comment">//内层循环控制每趟排序多少次</span></span><br><span class="line">            <span class="comment">//前一个数比后一个数大，交换位置</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-选择排序-不稳定"><a href="#2-选择排序-不稳定" class="headerlink" title="2.选择排序[不稳定]"></a>2.选择排序[不稳定]</h2><blockquote><p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span> []arr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">      <span class="keyword">int</span> minIndex =i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[j]&lt; arr[minIndex])&#123;</span><br><span class="line">              minIndex = j;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">int</span> temp =arr[i];</span><br><span class="line">    arr[i] =arr[minIndex];</span><br><span class="line">    arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-插入排序-稳定"><a href="#3-插入排序-稳定" class="headerlink" title="3.插入排序[稳定]"></a>3.插入排序[稳定]</h2><blockquote><p>每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span> []arr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">           <span class="comment">//后一个数小于前一个数则交换</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-归并排序-稳定"><a href="#4-归并排序-稳定" class="headerlink" title="4.归并排序[稳定]"></a>4.归并排序[稳定]</h2><blockquote><p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>如　设有数列{6，202，100，301，38，8，1}</p><p>初始状态：6 , 202 , 100 , 301 , 38 , 8 , 1</p><p>第一次归并后：{6,202} , {100,301}, {8,38}, {1} ，比较次数：3；</p><p>第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；</p><p>第三次归并后：{1,6,8,38,100,202,301},比较次数：4；</p><p>总的比较次数为：3+4+4=11；</p><p>逆序数为14；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid  = (low+high)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(arr,low,mid);</span><br><span class="line">        mergeSort(arr,mid+<span class="number">1</span>,high);</span><br><span class="line">        <span class="comment">//两路归并</span></span><br><span class="line">        merge(arr,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];<span class="comment">//汇总两个有序区的临时区域</span></span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">//左边序列起始索引</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右边序列起始索引</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;  <span class="comment">//临时区域的索引</span></span><br><span class="line">    <span class="comment">//把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;= high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;arr[j])&#123;</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若左边序列还有剩余，则将其全部拷贝进tmp[]中</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        tmp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若右边序列还有剩余，则将其全部拷贝进tmp[]中</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)&#123;</span><br><span class="line">        tmp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将排序后的元素，全部都整合到数组中。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>;t &lt; tmp.length ;t++)</span><br><span class="line">        arr[t+low] = tmp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-计数排序-稳定-–升级为桶排序"><a href="#5-计数排序-稳定-–升级为桶排序" class="headerlink" title="5.计数排序[稳定]–升级为桶排序"></a>5.计数排序[稳定]–升级为桶排序</h2><blockquote><p>工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//桶数</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = max + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;bucketNum;i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        bucketArr.get(arr[i]).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;bucketArr.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bucketArr.get(i).isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(Integer a:bucketArr.get(i))</span><br><span class="line">                System.out.print(a+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-基数排序-稳定"><a href="#6-基数排序-稳定" class="headerlink" title="6.基数排序[稳定]"></a>6.基数排序[稳定]</h2><blockquote><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p>准备10个桶，按照个位将数放入桶中，在倒出来，再按照十位数放入桶中再倒出来…..</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Redixsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span><span class="comment">//d表示最大的数有多少位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;  <span class="comment">//表示位数对应的数</span></span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> [][]bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][len];<span class="comment">//排序桶，用于保存每次排序后的结果，这样位排序结果相同的数字放在同一个桶里</span></span><br><span class="line">    <span class="keyword">int</span> []order = <span class="keyword">new</span> <span class="keyword">int</span>[len]; <span class="comment">// 用于保存每个桶里面有多少个数字</span></span><br><span class="line">    <span class="keyword">while</span>(n&lt; Math.pow(<span class="number">10</span>,d))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;<span class="comment">//将数组array里的每个数字放在相应的桶里</span></span><br><span class="line">            <span class="keyword">int</span> digit = (arr[i]/n)%<span class="number">10</span>;  <span class="comment">//求位上的数</span></span><br><span class="line">            bucket[digit][order[digit]] = arr[i];</span><br><span class="line">            order[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个循环生成的桶里的数据覆盖到原数组中，用于保存这一位的排序结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//桶里有数据</span></span><br><span class="line">            <span class="keyword">if</span>(order[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;order[i];j++)&#123;</span><br><span class="line">                    arr[k] = bucket[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//桶里计数器计0，用于下一次排序</span></span><br><span class="line">            order[i] =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n =n*<span class="number">10</span>;</span><br><span class="line">        k = <span class="number">0</span>; <span class="comment">//将k置0，用于下一轮保存位排序结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-快速排序-不稳定"><a href="#7-快速排序-不稳定" class="headerlink" title="7.快速排序[不稳定]"></a>7.快速排序[不稳定]</h2><blockquote><p>选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</p><p>简单记忆为：</p><p>“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(low &lt; high)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">int</span> position = partition(arr, low, high);</span><br><span class="line"> quicksort(arr, low, position - <span class="number">1</span>);</span><br><span class="line"> quicksort(arr, position + <span class="number">1</span>, high);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置基准值</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="comment">//从右到左，直到找到一个小于key的值</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= key) --high;</span><br><span class="line">        <span class="comment">//将该值填入前的坑</span></span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="comment">//从左到右，直到找到一个大于key的值</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= key) ++low;</span><br><span class="line">        <span class="comment">//将该值填入前一个坑</span></span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将基准值填入最后一个坑</span></span><br><span class="line">    arr[low] = key;</span><br><span class="line">    <span class="comment">//最后一个坑划分了左边小于该值，右边大于该值</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-希尔排序-不稳定-–插入排序的优化"><a href="#8-希尔排序-不稳定-–插入排序的优化" class="headerlink" title="8.希尔排序[不稳定]–插入排序的优化"></a>8.希尔排序[不稳定]–插入排序的优化</h2><blockquote><p>现在有一个array,希尔排序就是设定一个增量incrementNum (0&lt;incrementNum&lt;array.length)</p><p>(1)先从array[0]开始，以incrementNum为增量的进行直接插入排序，直到数组末尾，然后从array[1]开始重复：以incrementNum为增量的进行直接插入排序; 然后从array[1]开始重复……一直到array[n]。</p><p>然后取一个小于上一步增量的新的增量（比如设置为incrementNum/2）,对前一个步骤的结果array进行遍历，直接插入排序….</p><p>再取小于上一步增量的新的增量，重复进行：遍历，直接插入排序，直到新的增量小于1之后再退出循环</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> incrementNums = arr.length/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(incrementNums&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="comment">//进行插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =i+incrementNums;j&lt;arr.length;j+=incrementNums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[j-incrementNums])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] =arr[j-incrementNums];</span><br><span class="line">                    arr[j-incrementNums] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置新的增量</span></span><br><span class="line">        incrementNums =incrementNums/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-堆排序-不稳定"><a href="#9-堆排序-不稳定" class="headerlink" title="9.堆排序[不稳定]"></a>9.堆排序[不稳定]</h2><p><img src="https://github.com/qiulig/IMG/raw/master/堆排序.png" alt="堆知识"></p><blockquote><ol><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol><li><p>创建一个堆 H[0……n-1]；</p></li><li><p>把堆首（最大值）和堆尾互换；</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p></li><li><p>重复步骤 2，直到堆的尺寸为 1。</p></li></ol></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="comment">//叶子节点为（n/2+1~n,每个叶子本身就是一个大根堆）,故需要遍历的非叶子结点数位len/2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span> ; i&gt;=<span class="number">0</span>;i-- )&#123;</span><br><span class="line">        <span class="comment">//从第一个非叶子结点从下往上，从右至左调整，构造大根堆</span></span><br><span class="line">        <span class="comment">// i为最后一个根节点，n为数组最后一个元素的下标</span></span><br><span class="line">        HeapAdjust(arr,i,len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//最后一个元素跟第一个元素交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = tmp;</span><br><span class="line">        HeapAdjust(arr,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大根堆的构建</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得左孩子</span></span><br><span class="line">    <span class="keyword">int</span> leftchild = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightchild = <span class="number">2</span>* parent + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(leftchild&lt;length &amp;&amp; arr[leftchild]&gt;arr[largest])&#123;</span><br><span class="line">        largest= leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rightchild&lt;length &amp;&amp; arr[rightchild]&gt;arr[largest])&#123;</span><br><span class="line">        largest = rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(parent != largest)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[parent];</span><br><span class="line">        arr[parent] = arr[largest];</span><br><span class="line">        arr[largest]= temp;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        HeapAdjust(arr,largest,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【237】删除链表的节点</title>
      <link href="/2019/06/leetcode-237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2019/06/leetcode-237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。<a id="more"></a></p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p>示例 1:</p><p>输入: head = [4,5,1,9], node = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], node = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>这题的输入只给出了要删除的点所在的位置node,即如果链表node为 2–&gt;3–&gt;4–&gt;1,则只删除2节点，即</p><pre><code>将node后面的向前移动覆盖即可</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">         node.val = node.next.val;</span><br><span class="line">         node.next = node.next.next;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/237.png" alt="删除链表结点"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【24】两两交换链表中的节点</title>
      <link href="/2019/06/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2019/06/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：将链表中的数放到stack里面，每当stack里面有两个值，就pop弹出，将弹出的值放到新的链表后面。</p><p>方法2：递归</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">     ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">     ListNode ans = res;</span><br><span class="line">     <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         stack.push(head.val);</span><br><span class="line">         head = head.next;</span><br><span class="line">         <span class="keyword">if</span>(stack.size()==<span class="number">2</span>)&#123;</span><br><span class="line">             <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                 res.next = <span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">                 res = res.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">         res.next = <span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">         res = res.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans.next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">swapPairs2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode next = head.next;</span><br><span class="line">       head.next = swapPairs(next.next);</span><br><span class="line">       next.next = head;</span><br><span class="line">       <span class="keyword">return</span> next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/24_1.png" alt="两两交换链表中的节点方法1"></p><p><img src="https://github.com/qiulig/IMG/raw/master/24_2.png" alt="两两交换链表中的节点方法2"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表反转</title>
      <link href="/2019/06/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/06/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>以链表 1-&gt;2-&gt;3-&gt;4  为例子：</p><ul><li>程序到达Node newHead = reverse(head.next);时进入递归</li><li>我们假设此时递归到了3结点，此时head=3结点，temp=3结点.next(实际上是4结点)<a id="more"></a></li><li>执行Node newHead = reverse(head.next);传入的head.next是4结点，返回的newHead是4结点。</li><li>接下来就是弹栈过程了<ul><li>程序继续执行 temp.next = head就相当于4-&gt;3</li><li>head.next = null 即把 3结点指向4结点的指针断掉。</li><li>返回新链表的头结点newHead</li></ul></li></ul><blockquote><p>注意：当retuen后，系统会恢复2结点压栈时的现场，此时的head=2结点；temp=2结点.next(3结点)，再进行上述的操作。最后完成整个链表的翻转。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode temp = head.next;</span><br><span class="line">    ListNode newHead = reverse(head.next);</span><br><span class="line">    temp.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h3><p>依旧是1-&gt;2-&gt;3-&gt;4</p><ul><li>准备两个空结点 pre用来保存先前结点、next用来做临时变量</li><li>在头结点node遍历的时候此时为1结点<ul><li>next = 1结点.next(2结点)</li><li>1结点.next=pre(null)</li><li>pre = 1结点</li><li>node = 2结点</li></ul></li><li>进行下一次循环node=2结点<ul><li>next = 2结点.next(3结点)</li><li>2结点.next=pre(1结点)=&gt;即完成2-&gt;1</li><li>pre = 2结点</li><li>node = 3结点</li></ul></li><li>进行循环…</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   ListNode next;</span><br><span class="line">   ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">       ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">       ListNode cur = node;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode next = cur.next;  <span class="comment">//将下一个节点记录</span></span><br><span class="line">           cur.next = pre;  <span class="comment">//当前节点指向上一个节点</span></span><br><span class="line">           pre = cur;   <span class="comment">//记录当前节点</span></span><br><span class="line">           cur = next; <span class="comment">//将下一个节点变成当前节点</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【203】移除链表元素</title>
      <link href="/2019/06/leetcode-203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2019/06/leetcode-203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>删除链表中等于给定值 <strong><em>val</em></strong> 的所有节点。<a id="more"></a></p><p><strong>示例:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, <strong><em>val</em></strong> = 6<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：</p><pre><code>如果当前链表值head.val不等于val,则新建一个节点放到ans后面如果相等，则跳到链表下一个。</code></pre><p>方法2：</p><pre><code>遇到相等则跳指针 要考虑好头节点跟val相等的情况。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：新建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">          ListNode ans = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">          ListNode res = ans;</span><br><span class="line">          <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(head.val==val)&#123;</span><br><span class="line">                  head = head.next;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  ans.next =<span class="keyword">new</span> ListNode(head.val) ;</span><br><span class="line">                  ans = ans.next;</span><br><span class="line">                  head = head.next;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>方法2：跳指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//如果头节点与val相同</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.val == val)</span><br><span class="line">            head = head.next;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【120】三角形最小路径和</title>
      <link href="/2019/06/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2019/06/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><a id="more"></a><p>例如，给定三角形：</p><p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划：</p><p> 每一层的值加上上一层的值中最小值，最后取最后一层的最小值就好了</p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">2</span>]                             [<span class="number">2</span>]</span><br><span class="line">&gt;    [<span class="number">3</span>,<span class="number">4</span>]         变成               [<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&gt;   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>]                        [<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>]</span><br><span class="line">&gt;  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]                      [<span class="number">15</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">16</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> len = triangle.get(triangle.size()-<span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="comment">//初始化第一层跟第二层</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>]+triangle.get(<span class="number">1</span>).get(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">0</span>] + triangle.get(<span class="number">1</span>).get(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//第一列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;= i ;j++)&#123;</span><br><span class="line">                <span class="comment">//最后一个数的dp,因为上一层比下一层少一个，所以只能最后一个数只能加上上一层的最后一个dp</span></span><br><span class="line">                <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j) + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j)+ Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三角形最后一层中的最小值就是最小路径</span></span><br><span class="line">        <span class="keyword">int</span> res = dp[len-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[len-<span class="number">1</span>][i] &lt; res)&#123;</span><br><span class="line">                res = dp[len-<span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/120.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【95】不同的二叉搜索树2</title>
      <link href="/2019/06/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/"/>
      <url>/2019/06/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出:<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释:<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>        <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span>        <span class="number">1</span></span><br><span class="line">&gt;  \      /      /      / \        \</span><br><span class="line">&gt;  <span class="number">3</span>     <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>        <span class="number">2</span></span><br><span class="line">&gt;  /    /        \                   \</span><br><span class="line">&gt;  <span class="number">2</span>   <span class="number">1</span>          <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1)当n = 1时，此时只有一个以1为根节点的二叉搜索树</p><p>(2) 当n &gt; 1时，当以 i 为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，依次递归遍历，分别放到left和right列表中，然后再先序遍历放入res结果中。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//n = 1 的情况，只有一个，就是根节点为1的二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                TreeNode node = <span class="keyword">new</span> TreeNode(start);</span><br><span class="line">                list.add(node);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以 i 为根节点，左子树为start~(i-1),右子树为(i+1)~n</span></span><br><span class="line">            List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                List&lt;TreeNode&gt; left = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                List&lt;TreeNode&gt; right = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (i != start) &#123;</span><br><span class="line">                    <span class="comment">//说明有左子树</span></span><br><span class="line">                    left = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != end) &#123;</span><br><span class="line">                    <span class="comment">//说明有右子树</span></span><br><span class="line">                    right = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//先序遍历存入res里面</span></span><br><span class="line">                <span class="keyword">if</span> (!left.isEmpty() &amp;&amp; !right.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode l : left) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (TreeNode r : right) &#123;</span><br><span class="line">                            TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                            root.left = l;</span><br><span class="line">                            root.right = r;</span><br><span class="line">                            res.add(root);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!left.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode l : left) &#123;</span><br><span class="line">                        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        root.left = l;</span><br><span class="line">                        res.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!right.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode r : right) &#123;</span><br><span class="line">                        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        root.right = r;</span><br><span class="line">                        res.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees=generate(start,i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归遍历右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees=generate(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//先序遍历存入以i为根节点的二叉搜索树</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left:leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right:rightTrees)&#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left=left;</span><br><span class="line">                    root.right=right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/95.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【96】不同二叉搜索树</title>
      <link href="/2019/06/leetcode-96-%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2019/06/leetcode-96-%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>      <span class="number">3</span>     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">&gt;  \     /    /     / \     \</span><br><span class="line">&gt;  <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>     <span class="number">1</span>   <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">&gt;  /   /      \               \</span><br><span class="line">&gt;  <span class="number">2</span>  <span class="number">1</span>        <span class="number">2</span>               <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划：</p><p>(1)初始化</p><pre><code>n  = 1时，只含有1，1作为根节点，此时二叉搜索数个数为1；</code></pre><p>(2) 算法</p><pre><code>    （1）假设n个节点存在二叉排序树的个数是dp[i]，令f[i]为以i为根的二叉搜索树的个数，则                dp[n] = f[1] + f[2] + f[3] + f[4] + ... + f[n]     （2）当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则                f [i]  = dp[i-1] * dp[n-i]综合两个公式可以得到卡特兰数公式</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  dp[n] = dp[<span class="number">0</span>] * dp[n-<span class="number">1</span>] + dp[<span class="number">1</span>] * dp[n-<span class="number">2</span>]+...+dp[n-<span class="number">1</span>] * dp[<span class="number">0</span>]</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * C(<span class="number">2</span>n,n)</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * (<span class="number">4</span>*n-<span class="number">2</span>)/(n-<span class="number">1</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n个节点存在二叉树的个数</span></span><br><span class="line">        <span class="keyword">long</span> []dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//以i为根节点的二叉树个数</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]*(<span class="number">4</span>*i-<span class="number">2</span>)/(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/96.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【70】爬楼梯</title>
      <link href="/2019/06/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2019/06/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><a id="more"></a><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li><p>2 阶</p><p>示例 2：</p></li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><p>初始化：</p><pre><code>可知dp[0]  = 0;dp[1] = 1;dp[2] = 2;即跳0级有一种方法，一级有1种方法，2级有2种方法</code></pre><p>算法核心：</p><pre><code>dp[i] = dp[i-1] +dp[i-2] ,即爬i阶台阶的方法等于爬i-2阶台阶的方法加上爬i-1阶台阶的方法</code></pre><p>方法2：</p><pre><code>剑指offer第8题</code></pre><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n ;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;=n ;i++)&#123;</span><br><span class="line">            res = one + two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/70.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【64】最小路径和</title>
      <link href="/2019/06/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2019/06/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><a id="more"></a><p>示例:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果数组只有一个数，则路径最小即为该值，dp[0][0] = 0;</p><p> (1)动态规划初始化</p><pre><code>1)只有一行，则路径总和最小为 dp[0][i] = dp[0][i-1] + grid[0][i];2)只有一列，则路径总和最小为 dp[i][0] = dp[i-1][0] + grid[i][0];</code></pre><p>(2) 动态规划核心算法</p><p>  每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：</p><pre><code>dp[i][j] = grid[i][j] + min( dp[i-1][j] , dp[i][j-1]);</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划核心</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                dp[i][j] = grid[i][j]+(dp[i-<span class="number">1</span>][j]&lt;dp[i][j-<span class="number">1</span>]?dp[i-<span class="number">1</span>][j]:dp[i][j-<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/64.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【63】不同路径2</title>
      <link href="/2019/06/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/"/>
      <url>/2019/06/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><a id="more"></a><p>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果第一个格点 obstacleGrid[0][0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。</p><p>如果 obstacleGrid[0][0] 是 0，我们初始化这个值为 1 然后继续算法。<br>(1)动态规划初始化</p><pre><code>1)obstacleGrid[0][0] == 0,表示没障碍，路径只有一条；dp[0][0] = 1;2)遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[0][j] = dp[0][j-1]。             3)遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[i][0] = obstacleGrid[i-1][0]。</code></pre><p>(2) 动态规划核心算法</p><pre><code>从 obstacleGrid[1][1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 dp[i][j] = dp[i-1][j] + dp[i][j-1]。如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> col = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span> ? <span class="number">0</span> : dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>? <span class="number">0</span>:dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                    dp[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/63.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【62】不同的路径</title>
      <link href="/2019/06/leetcode-62-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/06/leetcode-62-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划</p><p>（1）初始化</p><pre><code>1) 从[0,0]走到[0,0]的路径，即没走，设dp[0][0] = 0;2) 如果m*n的n为1，即机器人在m*1走，只能有一条路径，即arr[i][0] = 1;3) 如果m*n的m为1，即机器人在1*n走，只能有一条路径，即arr[0][1] = 1;</code></pre><p>(2) 动态规划核心算法</p><pre><code>机器人每次只能向下或者向右移动一步。即机器人arr[i][j]的路径由arr[i-1][j]和arr[i][j-1]决定，即arr[i][j] = arr[i-1][j]+arr[i][j-1];</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j]+arr[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/62.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【53】最大子序和</title>
      <link href="/2019/06/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
      <url>/2019/06/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><blockquote><ol><li>定义一个函数f(n)，以第n个数为结束点的子数列的最大和，存在一个递推关系f(n) = max(f(n-1) + A[n], A[n]);</li><li>将这些最大和保存下来后，取最大的那个就是，最大子数组和。因为最大连续子数组 等价于 最大的以n个数为结束点的子数列</li></ol></blockquote><p>方法2：</p><blockquote><p>用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。</p><pre><code>(1)当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令    cur = 0.表示从下一个数开始累加。(2)当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最    大值即可。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        ans[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = ans[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//依次求出以第n个数为结束点的子序列最大和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            ans[i] = Math.max(ans[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="comment">//求出最大和</span></span><br><span class="line">            res = Math.max(res,ans[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            cur = cur + nums[i];</span><br><span class="line">            ans = Math.max(cur,ans);</span><br><span class="line">            cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/53_1.jpg" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/53_2.jpg" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【264】丑数2</title>
      <link href="/2019/06/leetcode-264-%E4%B8%91%E6%95%B02/"/>
      <url>/2019/06/leetcode-264-%E4%B8%91%E6%95%B02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>编写一个程序，找出第  <code>n</code>  个丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code>  的<strong>正整数</strong>。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> n = 10<br><strong>输出:</strong> 12</p><a id="more"></a><p><strong>解释:</strong> <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> 是前 10 个丑数。</p><p><strong>说明:</strong></p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>剑指offer-【33】</p><p>丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an</p><p>所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2<em>a1, 2</em>a2, 2*a3 …..</p><p>包含3的有序丑数序列:3<em>a1, 3</em>a2, 3<em>a3 ….. 包含5的有序丑数序列:5</em>a1, 5<em>a2, 5</em>a3 …..</p><p>以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i] =Math.min(Math.min(arr[t2]*<span class="number">2</span>,arr[t3]*<span class="number">3</span>),arr[t5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr[t2]*<span class="number">2</span> == arr[i])&#123;</span><br><span class="line">                t2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[t3]*<span class="number">3</span> == arr[i])&#123;</span><br><span class="line">                t3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[t5]*<span class="number">5</span> == arr[i])&#123;</span><br><span class="line">                t5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/264.png" alt="丑数2"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【263】丑数</title>
      <link href="/2019/06/leetcode-263-%E4%B8%91%E6%95%B0/"/>
      <url>/2019/06/leetcode-263-%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 6<br><strong>输出:</strong> true<br><strong>解释:</strong> 6 = 2 × 3</p><a id="more"></a><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 8<br><strong>输出:</strong> true<br><strong>解释:</strong> 8 = 2 × 2 × 2</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 14<br><strong>输出:</strong> false<br><strong>解释:</strong> <code>14</code> 不是丑数，因为它包含了另外一个质因数 <code>7</code>。</p><p><strong>说明：</strong></p><ol><li><code>1</code> 是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>丑数只能被2，3，5整除，所以丑数为2*i+3*j+5*k = num[i,j,k为任意整数]</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">3</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">5</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> num==<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/263.png" alt="丑数"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【23】合并K个排序链表</title>
      <link href="/2019/06/leetcode-23%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/06/leetcode-23%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><p><strong>输入:</strong><br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br><strong>输出:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：</p><pre><code>(1)利用priorityQueue的性质，每放一个数字进去就给你从小到大排好序了(2)队列的性质是先进先出，故依次poll出来就是从小到大的顺序，将该数值放到listNode里面即可。</code></pre><p>方法2：</p><pre><code>借用合并两个链表的代码，依次将list[]分成两部分，在分别合并，执行用时为6ms</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode ans = res;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//将所有节点的值放到一个queue里面从小到大排好序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; lists.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lists[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(lists[i].val);</span><br><span class="line">                lists[i] = lists[i].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次建立链表</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode(queue.poll());</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将一半的链表放到l1里面</span></span><br><span class="line">        <span class="keyword">int</span> mid = lists.length/<span class="number">2</span>;</span><br><span class="line">        ListNode[] l1 = <span class="keyword">new</span> ListNode[mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++)&#123;</span><br><span class="line">            l1[i] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将一半的链表放到l2里面</span></span><br><span class="line">        ListNode[] l2 = <span class="keyword">new</span> ListNode[lists.length-mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid,j=<span class="number">0</span>; i &lt; lists.length; i++,j++)&#123;</span><br><span class="line">            l2[j] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归实现多个链表的排序</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(mergeKLists(l1),mergeKLists(l2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方式实现两个链表排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            head.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            head.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/23.jpg" alt="合并K个排序的链表"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 困难 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【21】合并两个有序链表</title>
      <link href="/2019/06/leetcode-21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/06/leetcode-21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例：</strong></p><p><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1) 判断是否有空链表，如果有则直接返回另一个不为空有序链表</p><p>(2) 依次判断是否有对应链表大小，小的加入res链表，并移动</p><p>注：该题与剑指offer-[16]题一致，还可以用递归。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span> &amp;&amp;l2!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span> &amp;&amp; l1!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            ListNode ans = res;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//哪个小添加哪个</span></span><br><span class="line">                <span class="keyword">if</span>(l1.val&gt;l2.val)&#123;</span><br><span class="line">                    res.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将剩下的没便利完的加入</span></span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/21.png" alt="合并有序链表"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【19】删除链表的倒数第N个节点</title>
      <link href="/2019/06/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2019/06/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong><em>n</em> = 2</strong>.</p><p>当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p><p><strong>说明：</strong></p><p>给定的  <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>双指针</p><p>(1)第一个指针curNode先走n步</p><p>(2)然后第二个指针preNode再重头跟刚刚第一个指针curNode走,直到走到尾部【preNode走了(len-N)步,即下一个节点就是要删除的节点】</p><p>(3)此时的preNode的下一个即为倒数第N个节点，将其删除即可</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode preNode = head;</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        <span class="comment">//第一个指针先走n步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> preNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个指针同时走，走剩下的（Len-n）步，此时preNode的下一个就是要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (curNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preNode = preNode.next;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除倒数第N个节点</span></span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/19.jpg" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【434】字符串中的单词数</title>
      <link href="/2019/06/leetcode-434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
      <url>/2019/06/leetcode-434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> “Hello, my name is John”<br><strong>输出:</strong> 5</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>每次出现非空字符，看看上一个是不是空格，如果是，发现一个新单词</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> lastIsBlank = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                lastIsBlank = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastIsBlank) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIsBlank = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/434.png" alt="字符串中的单词数"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【13】罗马数字转整数</title>
      <link href="/2019/06/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2019/06/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th><strong>字符</strong></th><th><strong>数值</strong></th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。<a id="more"></a></p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “III”<br><strong>输出:</strong> 3</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “IV”<br><strong>输出:</strong> 4</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “IX”<br><strong>输出:</strong> 9</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>通常情况下，<strong>罗马数字中小的数字在大的数字的右边</strong>。这句话很关键，意思是要变成罗马数字，必须先排列大的数</p><p>（1）res初始化为字符串的最后一个字符所代表的数字</p><p>（2）从字符串数组尾部开始遍历，</p><pre><code>1)如果下一个字符所代表的数字小于当前字符所代表的数字，则res减去下一个字符所代表的数字：如IV,下一个字符I所代表数字1&lt;当前字符所代表数字5，res = res-12)如果下一个字符所代表的数字大于当前字符所代表的数字，则res加上下一个字符所代表的数字如VI,下一个字符V 所代表数字5&gt;当前字符I所代表数字1,res = res+5</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'I'</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">int</span> res = map.get(s.charAt(s.length()-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//罗马数字中大的数字在小的数字的右边，用减法</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(s.charAt(i))&gt;map.get(s.charAt(i-<span class="number">1</span>)))&#123;</span><br><span class="line">                res -=map.get(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//罗马数字中小的数字在大的数字的右边，用加法</span></span><br><span class="line">                res +=map.get(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/13.png" alt="罗马数字转整数"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【12】整数转罗马数字</title>
      <link href="/2019/06/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
      <url>/2019/06/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th style="text-align:center"><strong>字符</strong></th><th style="text-align:center"><strong>数值</strong></th></tr></thead><tbody><tr><td style="text-align:center">I</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">500</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><a id="more"></a><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 3<br><strong>输出:</strong> “III”</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 4<br><strong>输出:</strong> “IV”</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 9<br><strong>输出:</strong> “IX”</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> 58<br><strong>输出:</strong> “LVIII”<br><strong>解释:</strong> L = 50, V = 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> 1994<br><strong>输出:</strong> “MCMXCIV”<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>通常情况下，<strong>罗马数字中小的数字在大的数字的右边</strong>。这句话很关键，意思是要变成罗马数字，必须先排列大的数</p><p>（1）定义一个arr[],代表能用罗马数字代表的数</p><p>（2）定义一个str[],里面的字符串分别与数字arr[]里面的数字相对应，两个的联系即arr[i]  —–&gt;str[i]</p><p>（3）定义一个i,i从0开始，找到数组中第一个小于等于num的值，第一个罗马数字就是str[i],再依次循环知道num==0</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>   arr [] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>,<span class="number">100</span>,  <span class="number">90</span>, <span class="number">50</span>,  <span class="number">40</span>, <span class="number">10</span>,   <span class="number">9</span>,  <span class="number">5</span>,   <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        String str[] = &#123; <span class="string">"M"</span>,<span class="string">"CM"</span>, <span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//一般情况下罗马数字小的在大的右边</span></span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>&amp;&amp; i&lt;arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= arr[i])&#123;</span><br><span class="line">                num  = num-arr[i];</span><br><span class="line">                res.append(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/12.jpg" alt="整数转罗马数字"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="/2019/06/%E6%AD%BB%E9%94%81/"/>
      <url>/2019/06/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><pre><code>两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</code></pre><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>） <span class="string">'互斥条件'</span>： 一个资源每次只能被一个进程使用。</span><br><span class="line">（<span class="number">2</span>） <span class="string">'请求与保持条件'</span>： 一个进程因请求资源而阻塞时， 对已获得的资源保持不放。</span><br><span class="line">（<span class="number">3</span>） <span class="string">'不可剥夺条件'</span>:进程已获得的资源， 在末使用完之前， 不能强行剥夺。</span><br><span class="line">（<span class="number">4</span>） <span class="string">'环路等待条件'</span>:若干进程之间形成一种头尾相接的循环等待资源关系。</span><br><span class="line">    只要系统发生了死锁， 这些条件必然成立， 而只要上述条件之一不满足， 就不会发生死锁。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">'破坏互斥条件'</span></span><br><span class="line">     如果<span class="string">'允许系统资源都能共享使用'</span>， 则系统不会进入死锁状态。 但有些资源根本不能同时访问， 如打印机等临界资源只能互斥使用。 所以， </span><br><span class="line">    破坏互斥条件而预防死锁的方法不太可行， 而且在有的场合应该保护这种互斥性。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) <span class="string">'破坏不剥夺条件'</span></span><br><span class="line"></span><br><span class="line">    当一个已保持了某些不可剥夺资源的进程， <span class="string">'请求新的资源而得不到满足时，它必须释放已经保持的所有资源， 待以后需要时再重新申请。'</span> 这</span><br><span class="line">    意味着， 一个进程已占有的资源会被暂时释放， 或者说是被剥夺了，或从而破坏了不可剥夺条件。该策略实现起来比较复杂， 释放已获得</span><br><span class="line">    的资源可能造成前一阶段工作的失效， <span class="string">'反复地申请和释放资源会增加系统开销， 降低系统吞吐量'</span>。 这种方法常用于状态易于保存和恢复的资</span><br><span class="line">    源，如 CPU 的寄存器及内存资源， 一般不能用于打印机之类的资源。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) <span class="string">'破坏请求和保持条件'</span></span><br><span class="line"></span><br><span class="line">    釆用<span class="string">'预先静态分配方法'</span>， 即<span class="string">'进程在运行前一次申请完它所需要的全部资源'</span>， 在它的资源未满足前，不把它投入运行。 一旦投入运行后， 这</span><br><span class="line">    些资源就一直归它所有， 也不再提出其他资源请求， 这样就可以保证系统不会发生死锁。</span><br><span class="line">    这种方式实现简单， 但缺点也显而易见， 系统资源被严重浪费， 其中有些资源可能仅在运行初期或运行快结束时才使用， 甚至根本不使用。 </span><br><span class="line">    而且还会导致“饥饿” 现象， 当由于个别资源长期被其他进程占用时， 将致使等待该资源的进程迟迟不能开始运行。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) <span class="string">'破坏环路等待条件'</span></span><br><span class="line"></span><br><span class="line">    为了破坏循环等待条件， 可釆用<span class="string">'顺序资源分配法'</span>。 首先给系统中的资源编号，规定每个进程， 必须按编号递增的顺序请求资源， 同类资源</span><br><span class="line">    一次申请完。 也就是说， 只要进程提出申请分配资源 Ri， 则该进程在以后的资源申请中， 只能申请编号大于 Ri 的资源。</span><br><span class="line"></span><br><span class="line">    这种方法存在的问题是， 编号必须相对稳定， 这就<span class="string">'限制了新类型设备的增加'</span>；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的</span><br><span class="line">    顺序， 但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费； 此外， 这种按规定次序申请资源的方法， 也必</span><br><span class="line">    然会给用户的编程带来麻烦。</span><br></pre></td></tr></table></figure><h3 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h3><blockquote><p>我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。</p><p>为保证资金的安全，银行家规定：</p><pre><code>(1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客；(2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量；(3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款；(4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，</span><br><span class="line">&gt; (<span class="number">1</span>)如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。</span><br><span class="line">&gt; (<span class="number">2</span>)当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。</span><br><span class="line">&gt; (<span class="number">3</span>)若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="检测死锁-死锁定理"><a href="#检测死锁-死锁定理" class="headerlink" title="检测死锁(死锁定理)"></a>检测死锁(死锁定理)</h3><p>通常分析描述死锁，可以用资源分配图。关于资源分配图，要仅仅抓住两点：</p><ul><li>请求边</li><li>分配边</li></ul><p>关键在找：空闲资源。如果空闲资源可以满足某个进程，这个进程就可以解脱了，把它摘除资源分配图，再看剩下的资源分配图，策略相同。</p><p><strong>在资源分配图中，把分配的资源与进程连好，再看进程请求边。按照分配边分配好以后，剩余的资源就是空闲资源。此时再来分析进程Pi的请求边，如果空闲资源都能满足Pi的请求，也就意味着Pi可以从这个纠缠的图中得到解脱。删除Pi的所有相关的资源：已分配的+请求的。再递归处理剩下的资源分配图</strong>。</p><p>参看：<a href="https://blog.csdn.net/jgm20475/article/details/81297819" target="_blank" rel="noopener">https://blog.csdn.net/jgm20475/article/details/81297819</a></p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>1、资源剥夺法</p><pre><code>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</code></pre><p>2、撤销进程法</p><pre><code>强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</code></pre><p>3、进程回退法</p><pre><code>让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL-优化查询</title>
      <link href="/2019/06/SQL-%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/06/SQL-%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化查询的方法"><a href="#优化查询的方法" class="headerlink" title="优化查询的方法"></a>优化查询的方法</h1><h2 id="1-使用索引"><a href="#1-使用索引" class="headerlink" title="1.使用索引"></a>1.使用索引</h2><pre><code>尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。</code></pre><h2 id="2-优化SQL语句"><a href="#2-优化SQL语句" class="headerlink" title="2.优化SQL语句"></a>2.优化SQL语句</h2><h3 id="2-1-explain查看SQL语句执行效果"><a href="#2-1-explain查看SQL语句执行效果" class="headerlink" title="2.1 explain查看SQL语句执行效果"></a>2.1 explain查看SQL语句执行效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句，</span><br><span class="line"> 把关键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-任何地方都不要使用-select-from-t-，-用具体的字段列表代替“-”-，-不要返回用不到的任何字段。"><a href="#2-2-任何地方都不要使用-select-from-t-，-用具体的字段列表代替“-”-，-不要返回用不到的任何字段。" class="headerlink" title="2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*” ， 不要返回用不到的任何字段。"></a>2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*” ， 不要返回用不到的任何字段。</h3><h3 id="2-3-不在索引列做运算或者使用函数。"><a href="#2-3-不在索引列做运算或者使用函数。" class="headerlink" title="2.3 不在索引列做运算或者使用函数。"></a>2.3 不在索引列做运算或者使用函数。</h3><h3 id="2-4-查询尽可能使用-limit-减少返回的行数，-减少数据传输时间和带宽浪费。"><a href="#2-4-查询尽可能使用-limit-减少返回的行数，-减少数据传输时间和带宽浪费。" class="headerlink" title="2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。"></a>2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。</h3><h2 id="3-优化数据库对象"><a href="#3-优化数据库对象" class="headerlink" title="3.优化数据库对象"></a>3.优化数据库对象</h2><h3 id="3-1-优化表的数据类型"><a href="#3-1-优化表的数据类型" class="headerlink" title="3.1 优化表的数据类型"></a>3.1 优化表的数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="function">procedure <span class="title">analyse</span><span class="params">()</span>函数对表进行分析， 该函数可以对表中列的数据类型提出优化建议。 能小就用小。 </span></span><br><span class="line"><span class="function">表数据类型第一个原则是： 使用能正确的表示和存储数据的最短类型。 这样可以减少对磁盘空间、 内存、 cpu 缓存的使用。</span></span><br><span class="line"><span class="function">使用方法： 'select * from 表名 procedure <span class="title">analyse</span><span class="params">()</span></span>;<span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="3-2-对表进行拆分"><a href="#3-2-对表进行拆分" class="headerlink" title="3.2 对表进行拆分"></a>3.2 对表进行拆分</h3><pre><code>通过拆分表可以提高表的访问效率。  </code></pre><p><strong>1.垂直拆分</strong><br><code>把主键和一些列放在一个表中， 然后把主键和另外的列放在另一个表中。 如果一个表中某些列常用， 而另外一些不常用， 则可以采用垂直拆分。</code><br><strong>2.水平拆分</strong><br>        <code>根据一列或者多列数据的值把数据行放到二个独立的表中。</code></p><h3 id="3-3-使用中间表来提高查询速度"><a href="#3-3-使用中间表来提高查询速度" class="headerlink" title="3.3 使用中间表来提高查询速度"></a>3.3 使用中间表来提高查询速度</h3><pre><code>创建中间表， 表结构和源表结构完全相同， 转移要统计的数据到中间表， 然后在中间表上进行统计， 得出想要的结果。</code></pre><h2 id="4-硬件优化"><a href="#4-硬件优化" class="headerlink" title="4.硬件优化"></a>4.硬件优化</h2><h3 id="4-1-CPU-的优化"><a href="#4-1-CPU-的优化" class="headerlink" title="4.1 CPU 的优化"></a>4.1 CPU 的优化</h3><pre><code>选择多核和主频高的 CPU。  </code></pre><h3 id="4-2-内存的优化"><a href="#4-2-内存的优化" class="headerlink" title="4.2 内存的优化"></a>4.2 内存的优化</h3><pre><code>使用更大的内存。 将尽量多的内存分配给 MYSQL 做缓存。  </code></pre><h3 id="4-3-磁盘-I-O-的优化"><a href="#4-3-磁盘-I-O-的优化" class="headerlink" title="4.3 磁盘 I/O 的优化"></a>4.3 磁盘 I/O 的优化</h3><h4 id="4-3-1-使用磁盘阵列"><a href="#4-3-1-使用磁盘阵列" class="headerlink" title="4.3.1 使用磁盘阵列"></a>4.3.1 使用磁盘阵列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)RAID <span class="number">0</span> 没有数据冗余， 没有数据校验的磁盘陈列。 实现 RAID <span class="number">0</span>至少需要两块以上的硬盘， 它将两块以上的硬盘合并成一块， 数据连续地</span><br><span class="line">分割在每块盘上。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)RAID1 是将一个两块硬盘所构成 RAID 磁盘阵列， 其容量仅等于一块硬盘的容量， 因为另一块只是当作数据“镜像”。 </span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)RAID-<span class="number">0</span>+<span class="number">1</span> 磁盘阵列。 RAID <span class="number">0</span>+<span class="number">1</span>是 RAID <span class="number">0</span> 和 RAID <span class="number">1</span> 的组合形式。 它在提供与 RAID <span class="number">1</span> 一样的数据安全保障的同时,也提供了与 RAID <span class="number">0</span> </span><br><span class="line">近似的存储性能。</span><br></pre></td></tr></table></figure><h4 id="4-3-2-调整磁盘调度算法"><a href="#4-3-2-调整磁盘调度算法" class="headerlink" title="4.3.2 调整磁盘调度算法"></a>4.3.2 调整磁盘调度算法</h4><pre><code>选择合适的磁盘调度算法， 可以减少磁盘的寻道时间。</code></pre><h3 id="5-MYSQL自身的优化"><a href="#5-MYSQL自身的优化" class="headerlink" title="5.MYSQL自身的优化"></a>5.MYSQL自身的优化</h3><pre><code>对 MySQL 自身的优化主要是对其配置文件 my.cnf 中的各项参数进行优化调整。 如指定 MySQL 查询缓冲区的大小， 指定 MySQL 允许的最大连接进程数等。</code></pre><h2 id="6-应用优化"><a href="#6-应用优化" class="headerlink" title="6.应用优化"></a>6.应用优化</h2><h3 id="6-1-使用数据库连接池"><a href="#6-1-使用数据库连接池" class="headerlink" title="6.1 使用数据库连接池"></a>6.1 使用数据库连接池</h3><h3 id="6-2-使用查询缓存"><a href="#6-2-使用查询缓存" class="headerlink" title="6.2 使用查询缓存"></a>6.2 使用查询缓存</h3><pre><code>它的作用是存储 select 查询的文本及其相应结果。 如果随后收到一个相同的查询， 服务器会从查询缓存中直接得到查询结果。 查询缓存适用的对象是更新不频繁的表， 当表中数据更改后， 查询缓存中的相关条目就会被清空</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>(1) 选取最适合的字段</strong>：在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。还可以将字段设置为NOT NULL,在查询时就不用比较null值了</p><p><strong>(2) 使用连接（JOIN）来替代子查询</strong></p><p><strong>(3) 使用联合（UNION)来代替手动创建的临时表</strong>：它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。</p><p><strong>(4) 使用事务</strong>：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><p><strong>(5) 锁定表</strong>：事务会将数据库锁定，因此其他用户请求只能暂时等待直到事务结束，会造成响应延迟。我们可以通过锁定表的方法来获得更好的性能</p><p><strong>(6) 使用外键</strong>。锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p><p><strong>(7) 使用索引</strong>。索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><p><strong>(8) 优化的查询语句</strong>。</p><p><strong>(9) 分库分表</strong>：可以按照业务分库，分流数据库并发压力，使数据库表更加有条理性</p><p><strong>(10) 数据库引擎</strong>：一种是innodb、一种是myisam</p><p>myisam快，是因为他的数据存储结构、索引存储结构和innodb不一样的，mysiam的索引结构是在内存中存的。 当然，myisam也有弱点，那就是他是表级锁，而innodb是行级锁，所以，mysiam适用于一次插入，多次查询的表，或者是读写分离中的读库中的表，而对于修改插入删除操作比较频繁的表，就很不合适了</p><p><strong>(11) 读写分离</strong>：数据库并发大的情况下，最好的做法就是进行横向扩展，增加机器，以提升抗并发能力，而且还兼有数据备份功能</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-六大原则</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>六原则一法则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s( Single-Resposibility Principle ): 单一职责原则。</span><br><span class="line">o( Open-Closed principle ): 开放封闭原则。</span><br><span class="line">l( Liskov-Substituion Principle ): 里氏替换原则。</span><br><span class="line">d( Dependecy-Inversion Principle ): 依赖倒置原则。</span><br><span class="line">i( Interface-Segregation Principle ): 接口隔离原则。</span><br><span class="line"> 合成/聚合复用。</span><br><span class="line"> 迪米特法则（最少知道）&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-单一职责"><a href="#1-单一职责" class="headerlink" title="(1)单一职责"></a>(1)单一职责</h2><blockquote><p><strong><em>一个类的功能要单一， 一个类只负责一个职责。 一个类只做它该做的事情(高内聚)</em></strong>。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的的破坏</p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>如果只让一个类完成它该做的事,而不涉及与它无关的领域就是践行了高内聚的原则</code></pre><h2 id="2-开放-封闭"><a href="#2-开放-封闭" class="headerlink" title="(2)开放-封闭"></a>(2)开放-封闭</h2><p> 软件实体(类、模块、函数等) <code></code>对修改关闭。 对扩展开放`</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'有新的需求或变化时， 可以对现有代码进行扩展， 以适应新的情况。'</span></span><br><span class="line"><span class="string">'对修改封闭， 意味着类一旦设计完成， 就可以独立其工作， 而不要对类尽任何修改。'</span></span><br><span class="line"> 在开发阶段， 我们都知道， 如果对一个功能进行扩展， 如果只是一味地对方法进行修改， 可能会造成一些问题， 诸如可能会引入新的 bug，</span><br><span class="line"> 或者增加代码的复杂度， 对代码结构造成破坏、 冗余， 还需要重新进行全面的测试。 那么该怎么解决这些问题？ 很简单，这就需要系统能</span><br><span class="line"> 够支持扩展， 只有扩展性良好的系统， 才能在不进行修改已有实现代码的基础上， 引进新的功能。</span><br></pre></td></tr></table></figure><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><pre><code>可维护性，可扩展性，可复用，灵活性好</code></pre><h2 id="3-里氏替换"><a href="#3-里氏替换" class="headerlink" title="(3)里氏替换"></a>(3)里氏替换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何使用基类的地方， 都能够使用子类替换， 而且在替换子类 后， 系统能够正常工作。</span><br></pre></td></tr></table></figure><pre><code> 子类一定是增加父类的能力而不是减少父类的能力，  因为子类比父类的能力更多， 把能力多的对象当成能力少的对象来用当然没有任何问题。一个 软件实体如果使用的是一个基类， 那么当把这个基类替换成继承该基类的子类， 程序的行为不会发生任何变化。软件实体察觉不出基类对象和子类对象的区别。</code></pre><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><pre><code>1. 提高代码的重用性，子类拥有父类的方法和属性；  2. 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；  </code></pre><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><pre><code>1. 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；  2. 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成     非常糟糕的结果，要重构大量的代码。  </code></pre><h2 id="4-接口隔离"><a href="#4-接口隔离" class="headerlink" title="(4)接口隔离"></a>(4)接口隔离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'使用多个专门的接口比使用单一的总接口要好。一个类对另外一个类的依赖性应当是建立在最小的接口上的。'</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将接口粒度最小化，将功能划分到每一个不能再分的子角色， 为每一个子角色创建接口通过这样，才不会让接口的实现类实现一些不必要的功能。 </span><br><span class="line">建立单一的接口， 不要建立臃肿的庞大的接口， 也就是说接口的方法尽量少。接口要小而专， 绝不能大而全。 臃肿的接口是对接口的污染,</span><br><span class="line">既然接口表示能力,那么一个接口只应该描述一种能力， 接口也应该是高度内聚的。</span><br></pre></td></tr></table></figure><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><pre><code>实现模块间的松耦合</code></pre><h2 id="5-依赖倒置"><a href="#5-依赖倒置" class="headerlink" title="(5)依赖倒置"></a>(5)依赖倒置</h2><figure class="highlight plain"><figcaption><span>而不是依赖于具体， 也就是我们经常听到的“要面向接口编程” 。``` </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们的类要依赖于抽象， 而不是依赖于具体， 也就是我们经常听到的“要面向接口编程” 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    该原则说得具体一些就是声明方法的参数类型、 方法的返回类型、 变量的引用类型时， <span class="string">'尽可能使用抽象类型而不用具体类型，'</span> 因为抽象</span><br><span class="line">类型可以被它的任何一个子类型所替代</span><br><span class="line">（<span class="number">1</span>）高层模块不应该依赖低层模块，两个都应该依赖抽象</span><br><span class="line">（<span class="number">2</span>）抽象不应该依赖细节，细节应该依赖抽象</span><br></pre></td></tr></table></figure><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><pre><code>通过抽象（抽象类或接口） 使各个类或模块的实现彼此独立， 不相互影响， 实现模块间的松耦合。 减少类间的耦合性。</code></pre><h2 id="6-合成-聚合复用"><a href="#6-合成-聚合复用" class="headerlink" title="(6)合成/聚合复用"></a>(6)合成/聚合复用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。'</span></span><br></pre></td></tr></table></figure><p>   在面向对象设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生改变，则子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了合成/聚合复用原则，也就是在实际开发设计中，尽量使用合成/聚合，不要使用类继承.一般而言，如果一个角色得到了更多的责任，那么可以使用合成/聚合关系将新的责任委派到合适的对象。当然，这种复用也有缺点。</p><pre><code>最主要的缺点就是通过这种复用建造的系统会有较多的对象需要管理。</code></pre><h2 id="迪米特法则-最少知道法则"><a href="#迪米特法则-最少知道法则" class="headerlink" title="迪米特法则(最少知道法则)"></a>迪米特法则(最少知道法则)</h2><pre><code>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类要调用另一个类的某种方法，可以通过第三方转发这个调用</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在类的结构设计上，每个类都应当尽量降低成员的访问权限</span><br></pre></td></tr></table></figure><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><pre><code>类间解耦，降低耦合度，只有弱耦合之后，类的复用性才可以提高</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中的【IO】、【NIO】、【AIO】</title>
      <link href="/2019/06/JAVA%E4%B8%AD%E7%9A%84NIO-BIO/"/>
      <url>/2019/06/JAVA%E4%B8%AD%E7%9A%84NIO-BIO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h2><table><thead><tr><th><strong>IO</strong></th><th><strong>NIO</strong></th></tr></thead><tbody><tr><td>面向流</td><td>面向缓冲</td></tr><tr><td>阻塞IO</td><td>非阻塞IO</td></tr><tr><td>无</td><td>选择器</td></tr></tbody></table><blockquote><p><strong>1.面向流与面向缓冲</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Java IO 面向流意味着每次从流中读一个或多个字节， 直至读取所有字节，它们没有被缓存在任何地方。 此外， 它不能前后</span><br><span class="line">&gt; 移动流中的数据。</span><br><span class="line">&gt;     Java NIO 中把数据读取到一个缓冲区中， 需要时可在缓冲区中前后移动。 这就增加了处理过程中的灵活性。而且， 需确保当</span><br><span class="line">&gt; 更多的数据读入缓冲区时， 不要覆盖缓冲区里尚未处理的数据。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><a id="more"></a><p><strong>2.阻塞与非阻塞 IO</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Java IO 的各种流是阻塞的。 这意味着， 当一个线程调用 read() 或 write() 时， 该线程被阻塞， 直到有一些数据被读取,</span><br><span class="line">&gt; 或数据完全写入。 <span class="string">'该线程在此期间不能再干任何事情了'</span>。</span><br><span class="line">&gt;     Java NIO 的非阻塞模式， 使一个线程从某通道发送请求读取数据， 但是它仅能得到目前可用的数据， 如果<span class="string">'目前没有数据可用时，</span></span><br><span class="line"><span class="string">&gt; 就什么都不会获取， 而不是保持线程阻塞， 所以直至数据变的可以读取之前， 该线程可以继续做其他的事情。'</span> 非阻塞写也是如此。 一</span><br><span class="line">&gt; 个线程请求写入一些数据到某通道， 但不需要等待它完全写入， 这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用</span><br><span class="line">&gt; 于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel)。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>3.选择器（Selector）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Java NIO 的选择器允许一个单独的线程来监视多个输入通道， 你可以注册多个通道使用一个选择器， 然后使用一个单独的线程</span><br><span class="line">&gt; 来“选择”通道： 这些通道里已经有可以处理的输入， 或者选择已准备写入的通道。 为了将 Channel和Selector 配合使用,必须将</span><br><span class="line">&gt; channel 注册到 selector 上， 通过SelectableChannel.register()方法来实现。 这种选择机制，使得一个单独的线程很容易来</span><br><span class="line">&gt; 管理多个通道。 <span class="string">'只要 Channel 向 Selector 注册了某种特定的事件，Selector 就会监听这些事件是否会发生，一旦发生某个</span></span><br><span class="line"><span class="string">&gt; 便会通知对应的 Channel。 使用选择器， 借助单一线程， 就可对数量庞大的活动 I/O 通道实施监控和维护'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="IO同步阻塞"><a href="#IO同步阻塞" class="headerlink" title="IO同步阻塞"></a>IO同步阻塞</h2><h3 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="(1)阻塞IO"></a>(1)阻塞IO</h3><blockquote><p> 最传统的一种IO模型，即在<strong>读写数据过程中会发生阻塞现象</strong>。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解绑block状态。典型的阻塞IO模型的例子为：data = socket.read()；如果数据没有就绪，就会一直阻塞在read方法。</p></blockquote><h3 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="(2)非阻塞IO"></a>(2)非阻塞IO</h3><blockquote><p> 当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个Error时，它就知道数据还没准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次受到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就是说<strong>非阻塞IO模型不会交出CPU，而会一直占用CPU</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">&gt;   data = socket.read();</span><br><span class="line">&gt;   <span class="keyword">if</span>(data != error)&#123;</span><br><span class="line">&gt;     处理数据</span><br><span class="line">&gt;     <span class="keyword">break</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-多路复用IO-同步非阻塞NIO"><a href="#3-多路复用IO-同步非阻塞NIO" class="headerlink" title="(3)多路复用IO[同步非阻塞NIO]"></a>(3)多路复用IO[同步非阻塞NIO]</h3><blockquote><p>在多路复用IO模型中(实际上就说NIO)，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。通过一个线程就可以管理多个socket，只有在真正有socket读写事件进行时，才会使用IO资源进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。</p></blockquote><h3 id="4-信号驱动IO"><a href="#4-信号驱动IO" class="headerlink" title="(4)信号驱动IO"></a>(4)信号驱动IO</h3><blockquote><p>在信号驱动IO模型中，<strong>当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数</strong>，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p></blockquote><h3 id="5-异步IO-异步非阻塞AIO"><a href="#5-异步IO-异步非阻塞AIO" class="headerlink" title="(5)异步IO[异步非阻塞AIO]"></a>(5)异步IO[异步非阻塞AIO]</h3><p>应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。</p><p>在异步IO模型中，<strong>当用户线程发起read操作之后，立刻就可以开始去做其它的事</strong>。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求一个成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，<strong>当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了</strong>。也就是说用户线程完全不需要实际的整个IO操作是如何进行的。只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p><h2 id="NIO同步非阻塞"><a href="#NIO同步非阻塞" class="headerlink" title="NIO同步非阻塞"></a>NIO同步非阻塞</h2><p><img src="https://github.com/qiulig/IMG/raw/master/NIO.png" alt="NIO图解"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h5 id="1-缓冲区-buffer"><a href="#1-缓冲区-buffer" class="headerlink" title="1.缓冲区(buffer)"></a>1.缓冲区(buffer)</h5><pre><code>缓冲区实际上是一个容器对象， 其实就是一个数组， &apos;在 NIO 库中,所有数据都是用缓冲区处理的。&apos;在读取数据时， 它是直接读到缓冲区中的； 在写入数据时， 它也是写入到缓冲区中的； 任何时候访问 NIO 中的数据， 都是将它放到缓冲区中。 在 NIO 中， 所有的缓冲区类型都继承于抽象类 Buffer， 最常用的就是 ByteBuffer。  </code></pre><h5 id="2-通道-channel"><a href="#2-通道-channel" class="headerlink" title="2.通道(channel)"></a>2.通道(channel)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'通道是一个对象， 通过它可以读取和写入数据'</span>， 所有数据都通过 Buffer 对象来处理。 我们永远不会将字节直接写入通道中，相反是将数据写入</span><br><span class="line"></span><br><span class="line">包含一个或者多个字节的缓冲区。 同样不会直接从通道中读取字节， 而是将数据从通道读入缓冲区， 再从缓冲区获取这个字节。 而流只是在一个</span><br><span class="line"></span><br><span class="line">方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类， 比如 InputStream 只能进行读取操作， OutputStream 只能进行写操</span><br><span class="line"></span><br><span class="line">作)， 而<span class="string">'通道是双向的， 可以用于读、 写或者同时用于读写'</span>。</span><br></pre></td></tr></table></figure><h5 id="3-选择器（selector）"><a href="#3-选择器（selector）" class="headerlink" title="3.选择器（selector）"></a>3.选择器（selector）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Selector 的作用就是用来轮询每个注册的 Channel，一旦发现 Channel 有注册的事件发生， 便获取事件然后进行处理。'</span> </span><br><span class="line">用单线程处理一个 Selector， 然后通过 Selector.select()方法来获取到达事件， 在获取了到达事件之后， 就可以逐个地对这些事件进行</span><br><span class="line">响应处理。</span><br><span class="line">    <span class="string">'服务端和客户端各自维护一个管理通道的对象， 我们称之为 selector， 该对象能检测一个或多个通道（channel） 上的事件。'</span> </span><br><span class="line">我们以服务端为例， 如果服务端的 selector 上注册了读事件， 某时刻客户端给服务端送了一些数据， 阻塞 I/O这时会调用 read()方法阻</span><br><span class="line">塞地读取数据， 而 NIO 的服务端会在 selector 中添加一个读事件。 服务端的处理线程会轮询地访问 selector， 如果访问selector 时</span><br><span class="line">发现有感兴趣的事件到达， 则处理这些事件， 如果没有感兴趣的事件到达， 则处理线程会一直阻塞直到感兴趣的事件到达为止。</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的<strong>实例化延迟</strong>到其子类。</p><p><strong>提供一个创建对象实例的功能，而无须关心其具体实现</strong>。被创建实例的类型可以是接口、抽象类，也可以是具体的类。工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。<a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/设计模式之工厂模式.png" alt="工厂模式结构图"></p><h3 id="1-简单工厂方法"><a href="#1-简单工厂方法" class="headerlink" title="1.简单工厂方法"></a>1.简单工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISample <span class="title">creator</span><span class="params">(<span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (which==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleA();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (which==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实例时</span></span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">1</span>);</span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="2-抽象工厂"><a href="#2-抽象工厂" class="headerlink" title="2.抽象工厂"></a>2.抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample <span class="title">creator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实现接口的实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleA</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2A</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//创建工厂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BombFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleB</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1、可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。</p><p>2、可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。<br>3、可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。  </p><!--more--></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上<strong>增加了系统的复杂度，同时也增加了系统具体类的依赖</strong>。</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </p><p>2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </p><p>3、设计一个连接服务器的框架，需要三个议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节。<a id="more"></a></p><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1.浅拷贝"></a>1.浅拷贝</h3><pre><code>对类实现Cloneable接口（implements Cloneable），并且重写clone对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型创建成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2.深拷贝"></a>2.深拷贝</h3><pre><code>对其中的引用类型的成员变量进行实现Cloneable接口，重写clone，就变成深拷贝了对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">     String name;</span><br><span class="line"></span><br><span class="line">     String <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1.如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程。</p><p>2.使用原型模式创建对象比直接 new 一个对象在性能上要好的多，因为 Object 类的 clone 方法是一个本地方法，它直接操作内存中的二进制流，特别  是复制大对象时，性能的差别非常明显。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p><strong>在需要重复地创建相似对象时可以考虑使用原型模式</strong>。</p><p>比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数  很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-享元模式</title>
      <link href="/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>运用<strong>共享技术</strong>有效地支持<strong>大量细粒度对象的复用</strong>。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。<a id="more"></a></p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="https://github.com/qiulig/IMG/raw/master/设计模式之享元模式.jpg" alt="享元模式结构图"></p><p>在享元模式中引入了享元工厂类FlyweightFactory，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><p>享元工厂类：FlyweightFactory</p><p>享元类：ConcreteFlyweight</p><p>享元对象：Flyweight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个HashMap用于存储享元对象，实现享元池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap flyweights = newHashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果对象存在，则直接从享元池获取</span></span><br><span class="line">        <span class="keyword">if</span>(flyweights.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>(Flyweight)flyweights.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Flyweight fw = newConcreteFlyweight();</span><br><span class="line">            flyweights.put(key,fw);</span><br><span class="line">            <span class="keyword">return</span> fw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><blockquote><p>当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。</p><p><strong>String中的享元模式</strong></p><p> Java中将String类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。</p></blockquote><blockquote><p><strong>Integer中的享元模式</strong></p><p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code>之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象</p></blockquote><blockquote><p><strong>Long中的享元模式</strong></p><p>与Integer原理类似</p></blockquote><blockquote><p><strong>Apache Commons Pool2中的享元模式（对象池）</strong></p><p>将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用，从而在一定程度上减少频繁创建对象所造成的开销。用于充当保存对象的“容器”的对象，被称为“对象池”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><pre><code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式包括（1）私有的构造方法（2）含有一个该类的静态私有对象private static（3）提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</code></pre><a id="more"></a><h3 id="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"><a href="#懒汉模式：全局的单例在第一次使用时构建（延迟初始化）" class="headerlink" title="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"></a>懒汉模式：全局的单例在第一次使用时构建（延迟初始化）</h3><p>优点：<br>    避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法。<br>缺点：<br>    懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉模式：全局的单例实例在类装载时构建"><a href="#饿汉模式：全局的单例实例在类装载时构建" class="headerlink" title="饿汉模式：全局的单例实例在类装载时构建"></a>饿汉模式：全局的单例实例在类装载时构建</h3><p>1.线程安全<br>2.在类加载的同时已经创建好一个静态对象，调用时反应速度快  </p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><pre><code>资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h3><p>数据库连接池，多线程连接池。Windows应用管理器</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例<br>2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。<br>3.提供了对唯一实例的受控访问。<br>4.由于在系统内存中只存在一个对象，因此可以<strong>节约系统资源</strong>，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。<br>5.允许可变数目的实例。<br>6.避免对共享资源的多重占用。</p></blockquote><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>单例模式可能导致内存泄漏（OOM）</p><p>1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。<br>2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。<br>3.单例类的职责过重，在一定程度上违背了“单一职责原则”。<br>4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_集合中的快速失败与安全失败</title>
      <link href="/2019/05/JAVAVA-java%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5/"/>
      <url>/2019/05/JAVAVA-java%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="快速失败-fail—fast-机制"><a href="#快速失败-fail—fast-机制" class="headerlink" title="快速失败(fail—fast)机制"></a>快速失败(fail—fast)机制</h2><blockquote><p>java集合框架中的一种错误检测机制。多线程下用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除），则会抛出Concurrent Modification Exception。<a id="more"></a></p><p>fail-fast机制并不保证在不同步的修改下一定会抛出异常，这种机制一般仅用于检测bug。</p><p>【在循环迭代中修改会报异常，在迭代中修改不会报异常】</p><p><strong>java.util包下的集合类都是采用快速失败机制的，不能在多线程下发生并发修改（只能在迭代过程中被修改）。</strong></p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>这里异常的抛出条件是检测到 <strong>modCount!=expectedmodCount</strong>这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">6</span>)&#123;</span><br><span class="line">            list.remove(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line">----&gt;<span class="keyword">for</span>语句修改结果报错&lt;-------------------</span><br><span class="line">----&gt;Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException&lt;------------</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.next() == <span class="number">6</span>) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line">-------&gt;结果不报错&lt;------------------</span><br></pre></td></tr></table></figure><ul><li>迭代器是作为当前集合的内部类实现的，当迭代器创建的时候保持了当前集合的引用；</li><li>集合内部维护一个int变量modCount，用来记录集合被修改的次数，比如add，remove等都会使该字段递增；</li><li>modCount这个参数记录了某个List改变大小的次数，如果modCount改变的不符合预期，那么就会抛出异常。</li><li>迭代器内部也维护着当前集合的修改次数的字段，迭代器创建时该字段初始化为集合的modCount值</li><li>当每一次迭代时，迭代器会比较迭代器维护的字段和modCount的值是否相等，如果不相等就抛ConcurrentModifiedException异常；</li><li>当然，如果用迭代器调用remove方法，那么集合和迭代器维护的修改次数都会递增，以保持两个状态的一致。</li></ul><h2 id="安全失败-fail-safe"><a href="#安全失败-fail-safe" class="headerlink" title="安全失败(fail-safe)"></a>安全失败(fail-safe)</h2><blockquote><p>在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常</p><p><strong>concurrent包下的都是安全失败的，可以在多线程下并发使用，并发修改。</strong></p></blockquote><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><blockquote><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><blockquote><p>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层</title>
      <link href="/2019/05/Hashmap%E5%BA%95%E5%B1%82/"/>
      <url>/2019/05/Hashmap%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HashMap简介</p><h4 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h4><p><strong>底层是链表+数组，当链表长度大于8自动转化成红黑树。</strong></p><p><strong>首先有一个每个元素都是链表的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。</strong></p><a id="more"></a><p><img src="https://github.com/qiulig/IMG/raw/master/hashmap_1.jpg" alt="hashmap底层"><!--more--></p><p><img src="https://github.com/qiulig/IMG/raw/master/hashmap_2.jpg" alt="hashmap底层"></p><h4 id="2-hashMap的java构建"><a href="#2-hashMap的java构建" class="headerlink" title="2.hashMap的java构建"></a>2.hashMap的java构建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-HashMap的put实现"><a href="#3-HashMap的put实现" class="headerlink" title="3.HashMap的put实现"></a>3.HashMap的put实现</h4><blockquote><p>（1）程序先计算该key的hashCode()值</p><p>（2）对该哈希码进行再哈希，然后把哈希值和(数组长度-1)进行按位与操作，得到数组的下标</p><p>（3）该位置没有链表节点就把&lt;key,value&gt;放入该位置。有节点就对链表进行遍历，看是否有key一样的节点，有则value进行覆盖更新，没有就创建节点，把节点放链表表头（头插法）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//HashMap 允许存放null键和null值</span></span><br><span class="line">    <span class="comment">//当key为null时，调用putForNullKey,将value放置在数组第一个位置</span></span><br><span class="line">    <span class="keyword">if</span>(key==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key的keycode重新计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hascode());</span><br><span class="line">    <span class="comment">//搜索指定hash值在对应table的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash,table.length);</span><br><span class="line">    <span class="comment">//如果i索引处的entry不为null,通过循环不断遍历e元素的下一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[i];e!=<span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || ley.equals(k)))&#123;</span><br><span class="line">            V.oldValue = e.value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果i索引处的entry为null,表明此处还没有entry</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//将key、value添加到i索引处</span></span><br><span class="line">    addEntry(hash,key,value,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash,K key,V value,<span class="keyword">int</span> bucketIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取指定bucketIndex索引处的Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  <span class="comment">//将新创建的Entry放入bucletIndex索引处，并让新的Enrty指向原来的Entry</span></span><br><span class="line">   table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt; (hash,key,value,e);</span><br><span class="line">   <span class="comment">//如果Map中的key-value对数量超过了极限</span></span><br><span class="line">   <span class="keyword">if</span>(size++&gt;=threshold)</span><br><span class="line">       <span class="comment">//把table对象的长度扩充为2倍</span></span><br><span class="line">       resize(<span class="number">2</span>*table.length); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HashMap长度扩充</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line">    Entry[] oldTable  = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span>(oldCapacity == MAXIMUM_CAPACITY)&#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>) (newCapacity*loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span></span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;src.length;j++)&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span>(e!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash,newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(e!=<span class="keyword">null</span>)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行hash计算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-HashMap的get方法"><a href="#4-HashMap的get方法" class="headerlink" title="4.HashMap的get方法"></a>4.HashMap的get方法</h4><blockquote><p>（1）通过key的两次hash的值与数组的长度-1进行按位与操作，定位到数组的某个位置</p><p>（2）对该列的链表进行遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();  </span><br><span class="line">     <span class="keyword">int</span> hash = hash(key.hasCode());</span><br><span class="line">     <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[indexFor(hash,table.length)]);e!=<span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span>(e.hash == hash &amp;&amp; (k = e.key) == key || key.equals(k))&#123;</span><br><span class="line">             <span class="keyword">return</span> e.value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-HashMap总结"><a href="#5-HashMap总结" class="headerlink" title="5.HashMap总结"></a>5.HashMap总结</h4><p>（1）hashmap可以存储null值，线性不安全</p><p>（2）hashmap扩容：当 HashMap 中的结点个数超过数组大小<em>loadFactor（加载因子） 时， 就会进行数组扩容，loadFactor 的默认值为 0.75。也就是说，默认情况下，数组大小为 16，那么当 HashMap中结点个数超过 16</em>0.75=12 的时候， 就把数组的大小扩展为 2*16=32， 即扩大一倍，然后重新计算每个元素在数组中的位置，并放进去， 而这是一个非常消耗性能的操作。</p><p>（3）多线程 put 操作后， get 操作导致死循环,导致 cpu100%的现象。 主要是多线程同时put 时， 如果同时触发了 rehash 操作，会导致扩容后的 HashMap 中的链表中出现循环节点， 进而使得后面 get 的时候，会死循环。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_内存泄漏和内存溢出</title>
      <link href="/2019/05/JVMVM-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
      <url>/2019/05/JVMVM-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><blockquote><p>一个不再被程序使用的对象或者变量还在内存中占有存储空间。</p><p>（1）堆中申请的空间没有被释放</p><p>（2）对象不在使用但还在内存中保留</p><a id="more"></a></blockquote><h6 id="内存泄漏的原因："><a href="#内存泄漏的原因：" class="headerlink" title="内存泄漏的原因："></a>内存泄漏的原因：</h6><blockquote><p>（1）静态集合类，如hashmap和vector，如果容器为静态，她们的生命周期与程序一致。</p><p>（2）各种连接，如数据库连接，IO连接</p><p>（3）监听器：通常一个应用中会用到多个监听器，但是在释放对象的同时往往没有相应的删除监听器</p><p>（4）变量不合理的作用域。一方面一个变量的定义作用范围大于其使用范围，很可能造成内存泄漏。另一方面如果没有及时把对象设置为null,很可能导致内存泄漏。</p><p>（5）单例模式：一直存在着一个对对象的引用，并且以一个静态变量的方式存储，因此它在JVM整个生命周期都存在。</p></blockquote><h6 id="内存泄漏解决方案："><a href="#内存泄漏解决方案：" class="headerlink" title="内存泄漏解决方案："></a>内存泄漏解决方案：</h6><blockquote><p>（1）避免在循环中创建对象</p><p>（2） 尽早释放无用的对象引用</p><p>（3）尽量少用静态变量</p><p>（4）使用字符串处理，避免使用String,应大量使用StringBuffer,因为每个String对象都得独立占用内存一块区域</p></blockquote><h2 id="内存溢出OOM"><a href="#内存溢出OOM" class="headerlink" title="内存溢出OOM"></a>内存溢出OOM</h2><h6 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h6><blockquote><p>程序运行过程中无法申请到足够的内存而导致的一种错误，除了程序计数器外，其他几个运行区都有OOM的可能。</p></blockquote><h6 id="内存溢出情况："><a href="#内存溢出情况：" class="headerlink" title="内存溢出情况："></a>内存溢出情况：</h6><blockquote><p>（1）虚拟机栈和本地方法栈溢出</p><pre><code>如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackOverflowError 异常。  如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError 异常。  </code></pre><p> （2）<strong>堆溢出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 一般的异常信息： java.lang.OutOfMemoryError:Java heap spaces</span><br><span class="line">&gt;  出现这种异常，一般手段是先通过内存映像分析工具(如 Eclipse Memory Analyzer)对 dump 出来的堆转存快照进行分析,</span><br><span class="line">&gt;  重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏还是内存溢出。</span><br><span class="line">&gt;     1.如果是内存泄漏， 可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。</span><br><span class="line">&gt;     2.如果不存在泄漏， 那就应该检查虚拟机的参数(-Xmx 与-Xms)的设置是否适当。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（3）<strong>方法区溢出</strong></p><pre><code>异常信息： java.lang.OutOfMemoryError:PermGen space。</code></pre><p>（4）<strong>运行时常量池溢出</strong></p><pre><code>异常信息： java.lang.OutOfMemoryError:PermGen space。  </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果要向运行时常量池中添加内容，最简单的做法就是使用 String.intern()这个Native 方法。</span><br><span class="line">&gt;     该方法的作用是:如果池中已经包含一个等于此 String 的字符串， 则返回代表池中这个字符串的 String 对象；</span><br><span class="line">&gt;     否则，将此 String 对象包含的字符串添加到常量池中， 并且返回此 String 对象的引用 。</span><br><span class="line">&gt; 由于常量池分配在方法区内，我们可以通过-XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小， 从而间接限制其中常量池的容量。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h6 id="内存溢出原因："><a href="#内存溢出原因：" class="headerlink" title="内存溢出原因："></a>内存溢出原因：</h6><blockquote><p>1.内存中加载的数据量过于庞大， 如一次从数据库取出过多数据；</p><p>2.集合类中有对对象的引用， 使用完后未清空， 使得 JVM 不能回收；<br>3.代码中存在死循环或循环产生过多重复的对象实体；<br>4.启动参数内存值设定的过小。</p></blockquote><h6 id="内存溢出解决方法："><a href="#内存溢出解决方法：" class="headerlink" title="内存溢出解决方法："></a>内存溢出解决方法：</h6><blockquote><p>(1) 修改 JVM 启动参数， 直接增加内存。 (-Xms， -Xmx 参数一定不要忘记加。一般要将-Xms 和-Xmx 选项设置为相同， 以避免在每次 GC 后调整堆的大小； 建  议堆的最大值设置为可用内存的最大值的 80%)。  </p><p>(2) 检查错误日志， 查看“OutOfMemory” 错误前是否有其它异常或错误。 </p><p>(3)对代码进行走查和分析， 找出可能发生内存溢出的位置</p><p>(4)  使用内存查看工具动态查看内存使用情况（Jconsole）。</p></blockquote><h2 id="减少gc次数的方法："><a href="#减少gc次数的方法：" class="headerlink" title="减少gc次数的方法："></a>减少gc次数的方法：</h2><blockquote><p><strong>（1）对象不用时最好显式置为 Null</strong></p><pre><code>一般而言,为 Null 的对象都会被作为垃圾处理,所以将不用的对象显式地设  为 Null,有利于 GC 收集器判定垃圾,从而提高了 GC 的效率。  </code></pre><p><strong>（2）尽量少用 System.gc()</strong>  </p><pre><code>此函数建议 JVM进行主 GC,虽然只是建议而非一定,但很多情况下它会触发  主 GC,从而增加主 GC 的频率,也即增加了间歇性停顿的次数。  </code></pre><p><strong>（3）尽量少用静态变量</strong>  </p><pre><code>静态变量属于全局变量,不会被 GC 回收,它们会一直占用内存。  </code></pre><p><strong>（4） 尽量使用 StringBuffer,而不用 String 来累加字符串。</strong><br>    由于 String 是固定长的字符串对象,累加 String 对象时,并非在一个 String  对象中扩增,而是重新创建新的 String 对象,如 Str5=Str1+Str2+Str3+Str4,这条  语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新  的 String 对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多  的垃圾。 避免这种情况可以改用 StringBuffer 来累加字符串,因 StringBuffer 是可变长的,它在原有基础上进行扩增,不会产生中间对象。<br><strong>（5）分散对象创建或删除的时间</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM 在面临这种情况时,只能进行主 GC,以回收内存或整合</span><br><span class="line">&gt; 内存碎片从而增加主 GC 的频率。集中删除对象,道理也是一样的。 它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大</span><br><span class="line">&gt; 增加了下一次创建新对象时强制主 GC 的机会。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（6） <strong>尽量少用 finalize 函数。 因为它会加大 GC 的工作量， 因此尽量少</strong>用finalize 方式回收资源。  </p><p><strong>（7） 如果需要使用经常用到的图片， 可以使用软引用类型， 它可以尽可能</strong></p><p><strong>（8）能用基本类型如 int,long,就不用 Integer,Long 对象</strong></p><pre><code>基本类型变量占用的内存资源比相应包装类对象占用的少得多,如果没有必要,最好使用基本变量。  </code></pre><p><strong>（9） 增大-Xmx 的值。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_深拷贝和浅拷贝</title>
      <link href="/2019/05/Java-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/05/Java-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>对基本数据类型进行了拷贝</p><p>对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。</p><h6 id="即"><a href="#即" class="headerlink" title="即"></a>即</h6><pre><code>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝</code></pre><a id="more"></a><h6 id="底层实现："><a href="#底层实现：" class="headerlink" title="底层实现："></a>底层实现：</h6><p>（1）对类实现Cloneable接口（implements Cloneable），并且重写clone</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;  String name;</span><br><span class="line">&gt;  String <span class="keyword">int</span> age;</span><br><span class="line">&gt;  Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line">&gt;  <span class="meta">@Override</span></span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;  <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（2）用clone()方法创建新的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;     A a = <span class="keyword">new</span> A();</span><br><span class="line">&gt;     A aclone = (A)a.clone();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>对基本数据类型进行了拷贝</p><p>对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量</p><h6 id="即-1"><a href="#即-1" class="headerlink" title="即"></a>即</h6><pre><code>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容</code></pre><h6 id="底层实现：-1"><a href="#底层实现：-1" class="headerlink" title="底层实现："></a>底层实现：</h6><ol><li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li><li><p>继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，<strong>再进行一次 clone()</strong>。对A而言就是深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;     String name;</span><br><span class="line">&gt;     String <span class="keyword">int</span> age;</span><br><span class="line">&gt;     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;     <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;        <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>一个对象内部只有基本数据类型，那用 clone() 方法获取到的就是这个对象的深拷贝，而如果其内部还有引用数据类型，那用 clone() 方法就是一次浅拷贝的操作。</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【42】接雨水</title>
      <link href="/2019/05/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2019/05/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/42.png" alt="图"></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>思路1：转化成每个位置留下水量的总和</p><pre><code>i位置上留下的水为[0 , (i-1)]的最大值max1,(i+1,length)位置上的max2的两者较小值-该位置的高度：min(max2-max1) - arr[i]。</code></pre><p>思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。</p><p>思路3：跟思路2一致，减掉了一个指针</p><p>思路4：左边最大值小于右边最大值，左指针右滑，左指针位置上能装的水就是左边最大值减去左指针指的值，若左指针指向的值大于左边大值，就不减，说明不能储水，更新左边最大值，当右边最大值小于左边最大值时，右指针左滑，做法跟前类似，直到左指针小于等于右指针跳出循环。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>思路1代码：转化成每个位置留下水量的总和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getWater1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; i; l++) &#123;</span><br><span class="line">                leftMax = Math.max(arr[l], leftMax);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = i + <span class="number">1</span>; r &lt; arr.length; r++) &#123;</span><br><span class="line">                rightMax = Math.max(arr[r], rightMax);</span><br><span class="line">            &#125;</span><br><span class="line">            value += Math.max(<span class="number">0</span>, Math.min(leftMax, rightMax) - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>思路2代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMaxs[<span class="number">0</span>] = arr[<span class="number">0</span>];<span class="comment">//左指针初始化为第一个数</span></span><br><span class="line">        <span class="comment">//求左边的max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            leftMaxs[i] = Math.max(leftMaxs[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] rightMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMaxs[n - <span class="number">1</span>] = arr[n + <span class="number">1</span>];<span class="comment">//右指针初始化为数组最后一个数</span></span><br><span class="line"><span class="comment">//求右边的max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightMaxs[i] = Math.max(rightMaxs[i + <span class="number">1</span>], arr[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            value += Math.max(<span class="number">0</span>, Math.min(leftMaxs[i - <span class="number">1</span>], rightMaxs[i - <span class="number">1</span>]) - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>思路3代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路3：减少一个指针</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> n = arr.length - <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span>[] rightMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">     rightMaxs[n - <span class="number">1</span>] = arr[n + <span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         rightMaxs[i] = Math.max(rightMaxs[i + <span class="number">1</span>], arr[i + <span class="number">2</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">         value += Math.max(<span class="number">0</span>, Math.min(leftMax, rightMaxs[i - <span class="number">1</span>]) - arr[i]);</span><br><span class="line">         leftMax = Math.max(leftMax, arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>思路4代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap4</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rightMax = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;<span class="comment">//从第二个查看是否能蓄水</span></span><br><span class="line">        <span class="keyword">int</span> r = arr.length - <span class="number">2</span>;<span class="comment">////从倒数第二个查看是否能蓄水</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt;= rightMax) &#123;</span><br><span class="line">                value += Math.max(<span class="number">0</span>, leftMax - arr[l]);</span><br><span class="line">                leftMax = Math.max(leftMax, arr[l++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value += Math.max(<span class="number">0</span>, rightMax - arr[r]);</span><br><span class="line">                rightMax = Math.max(rightMax, arr[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p>思路1提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_11.png" alt="接雨水"></p><p>思路2提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_12.png" alt="接雨水"></p><p>思路3提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_13.png" alt="接雨水"></p><p>思路4提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_14.png" alt="接雨水"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 滑动窗口法 </tag>
            
            <tag> 困难 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【11】盛最多水的容器</title>
      <link href="/2019/05/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/05/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定  <em>n</em>  个非负整数  <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画  <em>n</em>  条垂直线，垂直线  <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><a id="more"></a><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://github.com/qiulig/IMG/raw/master/11.png" alt="图"></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.  解题思路"></a>2.  解题思路</h3><p>这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。</p><p>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量  res  来持续存储到目前为止所获得的最大面积。 </p><p>在每一步中，我们会找出指针所指向的两条线段形成的区域，更新  res，并将指向较短线段的指针向较长线段那端移动一步。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            res = Math.max(res,(right-left)*Math.min(height[left],height[right]));</span><br><span class="line">            <span class="comment">//舍弃高度较小的</span></span><br><span class="line">            <span class="keyword">if</span> ((height[left] &gt; height[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/11_1.png" alt="盛最多水的容器"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 滑动窗口法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【10】正则表达式匹配</title>
      <link href="/2019/05/leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/05/leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>)。实现支持  <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。<a id="more"></a></p><p>‘.’ 匹配任意单个字符。<br>‘*’ 匹配零个或多个前面的元素。</p><p>匹配应该覆盖<strong>整个</strong>字符串 (<code>s</code>) ，而不是部分字符串。</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li></ul><p><strong>示例 1:</strong></p><p><strong>输入:</strong><br>s = “aa”<br>p = “a”<br><strong>输出:</strong> false<br><strong>解释:</strong> “a” 无法匹配 “aa” 整个字符串。</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong><br>s = “aa”<br>p = “a<em>“<br><strong>输出:</strong> true<br><strong>解释:</strong> ‘</em>‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong><br>s = “ab”<br>p = “.<em>“<br><strong>输出:</strong> true<br><strong>解释:</strong> “.</em>“ 表示可匹配零个或多个(‘*’)任意字符(‘.’)。</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong><br>s = “aab”<br>p = “c<em>a</em>b”<br><strong>输出:</strong> true<br><strong>解释:</strong> ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong><br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br><strong>输出:</strong> false</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：</p><blockquote><p>跟剑指offer的52题一致</p><p>这道题的核心其实在于分析’<em>‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’</em>‘的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。</p><p><strong>情况1：Patttern第二个字符是’*’时</strong>：</p><p>1.第一个字符不匹配（’.’与任意字符视作匹配），那么’*’只能代表匹配0次</p><p>‘ba’与’a*ba’，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式</p><p>2.第一个字符匹配，那么’*’可能代表匹配0次，1次，多次，</p><p>(1)’aaa’与’a*aaa’: 匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；</p><p>(2)’aba’与’a*ba’:匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；</p><p>(3)’aaaba’与’a*ba’:匹配多次时，字符串往后移动一个字符，模式不变；</p><p><strong>情况2：Patttern第二个字符不是’*’时：</strong></p><p>(1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。</p><p>(2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。</p></blockquote><p>方法2：动态规划</p><blockquote><p>定义一个dp[][]数组，其中d[i][j]表示s[0,i]和p[0][j]是否匹配</p><p>dp初始化:dp[0][0] = true，代表str为空串，pattern为空串的情况</p><pre><code>求dp[0][j]即求str为空串，pattern是否匹配当遇到后一个为 * 时，且dp[0][i-1]为true则匹配(匹配前面字符0次)，标记dp[0][i+1] = true</code></pre><p>情况1：当前字母匹配，str和pattern都往后移动一位</p><pre><code>dp[i+1][j+1] = dp[i][j]</code></pre><p>情况2：后一个pattern是   *  ,前一个pattern跟str不匹配,str不变，pattern后移动两位</p><pre><code>dp[i+1][j+1] = dp[i+1][j-1]</code></pre><p>情况3：后一个pattern是 * ,前一个pattern跟str匹配</p><pre><code>(1)匹配0次，str不动，pattern后移2位        dp[i+1][j+1] = dp[i+1][j-1](2)匹配一次，str移动1位，pattern移动2位        dp[i+1][j+1] =dp[i][j-1](3)匹配多次，str移动1次，pattern不动        dp[i+1][j+1] = dp[i][j+1]</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> matchCore(str.toCharArray(), <span class="number">0</span>, pattern.toCharArray(), <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">       <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//pattern先到尾，匹配失败</span></span><br><span class="line">       <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;</span><br><span class="line">       <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位</span></span><br><span class="line">       <span class="comment">//   //如果当前pattern的下一个是*并且没有超出pattern的长度时</span></span><br><span class="line">       <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">           <span class="comment">// //如果当前字符str[index]和pattern[index]相等，或者当前pattern为‘.’</span></span><br><span class="line">           <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">               <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//模式后移2，视为x*匹配0个字符(当前pattern[index+1]='*'且str[index]!=pattern[index]）</span></span><br><span class="line">                       || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//视为模式匹配1个字符 (当前pattern[i+1]='*'且str[index]=pattern[index])</span></span><br><span class="line">                       || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配1个，再匹配str中的下一个（当前pattern[index]='.'）</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//当前字符str[index]和pattern[index]不相等&amp;&amp;当前pattern不为‘.’</span></span><br><span class="line">               <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">       <span class="comment">//pattern[index]='.'的情况，strindex和pattern都加1向下匹配</span></span><br><span class="line">       <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">           <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">           <span class="comment">//i= 0，j= 0表示str和pattern为空串，匹配成功标true</span></span><br><span class="line">           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//str为空串，pattern不为空串的情况</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">               <span class="comment">//前一个为true后一个为*，*匹配0个，则标记下一个为true</span></span><br><span class="line">               <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i - <span class="number">1</span>]) &#123;</span><br><span class="line">                   dp[<span class="number">0</span>][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">                   <span class="comment">//当前字母匹配，字符str和pattern都后移动一位</span></span><br><span class="line">                   <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span> || p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                       dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//后一个字符是*</span></span><br><span class="line">                   <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                       <span class="comment">//str与pattern不匹配</span></span><br><span class="line">                       <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j - <span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                           <span class="comment">//str不变，pattern后移动两位</span></span><br><span class="line">                           dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">//匹配0次，str不动，pattern后移2位，匹配一次，str移动一位，pattern移动2位，匹配多次，str移动1次，pattern不动</span></span><br><span class="line">                          dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j-<span class="number">1</span>] || dp[i][j - <span class="number">1</span>] || dp[i][j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/10_1.jpg" alt="单纯的匹配"></p><p><img src="https://github.com/qiulig/IMG/raw/master/10_2.jpg" alt="正则表达式匹配"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 困难 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【234】回文链表</title>
      <link href="/2019/05/leetcode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/05/leetcode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请判断一个链表是否为回文链表。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 1-&gt;2<br><strong>输出:</strong> false</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;2-&gt;1<br><strong>输出:</strong> true</p><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：将链表的数值依次入栈，然后弹栈跟listnode从头到尾比较</p><p>方法2：快慢指针弦找到中间点，再反转后面链表，再遍历比较</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            ListNode res = head;</span><br><span class="line">            <span class="comment">//链表入栈</span></span><br><span class="line">            <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出比较</span></span><br><span class="line">            <span class="keyword">while</span> (res!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.pop() == res.val)&#123;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode lat = head.next;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="comment">//快慢指针,pre一次一步，lat一次两步</span></span><br><span class="line">        <span class="keyword">while</span>(lat != <span class="keyword">null</span> &amp;&amp; lat.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            lat = lat.next.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转置后半链表</span></span><br><span class="line">        ListNode cur = pre.next;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode q = cur.next;</span><br><span class="line">            cur.next = p;</span><br><span class="line">            p = cur;</span><br><span class="line">            cur = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历比较</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val != head.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/234-1.jpg" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/234-2.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【9】回文数</title>
      <link href="/2019/05/leetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2019/05/leetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 121<br><strong>输出:</strong> true</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> -121<br><strong>输出:</strong> false<br><strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 10<br><strong>输出:</strong> false<br><strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：转换成字符串，将字符串反转进行比较是否相等</p><p>方法2：用一个stack存入数字从低位到高位的数；依次弹出（高位到低位弹出）跟每次数值取余的数进行对比</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        String res = x+<span class="string">""</span>;</span><br><span class="line">        <span class="comment">//字符串反转</span></span><br><span class="line">        String ans = <span class="keyword">new</span> StringBuilder(x+<span class="string">""</span>).reverse().toString();</span><br><span class="line">        <span class="keyword">if</span>(res.equals(ans))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 依次从右到左入栈 </span></span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            stack.push(x%<span class="number">10</span>);</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (res&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//pop弹出,从左到右的字符串，res%10是从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(stack.pop()==res%<span class="number">10</span>)&#123;</span><br><span class="line">                res = res/<span class="number">10</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/9-1.png" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/9-2.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【8】字符串转换成整数</title>
      <link href="/2019/05/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
      <url>/2019/05/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。<a id="more"></a></p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “42”<br><strong>输出:</strong> 42</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “   -42”<br><strong>输出:</strong> -42<br><strong>解释:</strong> 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “4193 with words”<br><strong>输出:</strong> 4193<br><strong>解释:</strong> 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> “words and 987”<br><strong>输出:</strong> 0<br><strong>解释:</strong> 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> “-91283472332”<br><strong>输出:</strong> -2147483648<br><strong>解释:</strong> 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1)  用一个标志位flag记录字符串的正负号</p><p>(2)  依次进行叠加，如果遇到溢出，返回它的最大值或者最小值</p><p>最大溢出判断：</p><pre><code>res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//去掉前后空格</span></span><br><span class="line">        String str = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>||str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断只有符号的情况</span></span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">1</span>&amp;&amp;(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>||str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//为正数，flag设为1，负数设为 -1,并截取后面的字符串进行字符串转换成整数</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>&amp;&amp; (str.charAt(<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">1</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">1</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>&amp;&amp;(str.charAt(<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">1</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">1</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((str.charAt(<span class="number">0</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">0</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">0</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字符串转换成整数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> flag,String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> pop = str.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//只需要判断上溢出情况，因为我们将符号单独拎出来了</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag==<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//上溢，输出最大值</span></span><br><span class="line">                        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//下溢出，输出最小值</span></span><br><span class="line">                        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = res*<span class="number">10</span> +pop;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="comment">//不是有效的字符[0-9]，直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/8.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【7】整数反转</title>
      <link href="/2019/05/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/05/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 123<br><strong>输出:</strong> 321</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> -123<br><strong>输出:</strong> -321</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 120<br><strong>输出:</strong> 21</p><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>主要是注意溢出问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; （<span class="number">1</span>）当x&gt;<span class="number">0</span>时，溢出考虑上界</span><br><span class="line">&gt;     <span class="number">1</span>)如果 result 的值大于 Integer.MAX_VALUE / <span class="number">10</span> ，那么一定会溢出</span><br><span class="line">&gt;     <span class="number">2</span>)如果 result 的值等于 Integer.MAX_VALUE / <span class="number">10</span>，那么 pop 的值如果大于 Integer.MAX_VALUE % <span class="number">10</span> 也会溢出</span><br><span class="line">&gt; (<span class="number">2</span>) 当x&lt;<span class="number">0</span> 时，溢出考虑下界</span><br><span class="line">&gt;     <span class="number">1</span>)result 的值小于 Integer.MIN_VALUE / <span class="number">10</span> ，那么一定会溢出</span><br><span class="line">&gt;     <span class="number">2</span>)result 的值等于 Integer.MIN_VALUE / <span class="number">10</span>，那么 pop 的值如果小于于 Integer.MIN_VALUE % <span class="number">10</span> 也会溢出</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x%<span class="number">10</span>;</span><br><span class="line">        x = x/<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//考虑上界溢出</span></span><br><span class="line">        <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//考虑下界溢出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; Integer.MIN_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最后一位</span></span><br><span class="line">        res = res*<span class="number">10</span> +pop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/7.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>得到的最短的回文长度</title>
      <link href="/2019/05/%E5%9B%9E%E6%96%87/"/>
      <url>/2019/05/%E5%9B%9E%E6%96%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>京京和东东是好朋友。东东很喜欢回文。回文是指从前往后读和从后往前读是一样的词语。京京准备给东东一个惊喜，先取定一个字符串s，然后在后面附上0个或者更多个字母形成回文，京京希望这个回文越短越好。请帮助京京计算他能够得到的最短的回文长度。</p><a id="more"></a><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>输入包括一个字符串s，字符串s长度length(1 ≤ length ≤ 50)。</p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>输出一个整数，表示京京能够得到的最短的回文长度。</p><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>abab</p><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><p>5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>转化成求字符串中的最长回文子串的大小，结果即不是回文那部分逆序即可。</p><p>从左往右，</p><p>三个概念：回文半径数组pArr[]，回文右边界pr，取得回文右边界的轴中心i</p><p>1）没在回文右边界里边，暴力</p><p>2）i’在回文范围里，回文右边界不扩</p><p>3）i’在回文范围外，回文右边界不扩</p><p>4）i’压线，回文右边界扩</p><p>直到回文右边界第一次到达最后一个字符</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//manacher预处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">char</span>[] manacherString(String str) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArr = str.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != res.length; i++) &#123;</span><br><span class="line">            res[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">'#'</span> : charArr[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">shortestEnd</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] charArr = manacherString(str);</span><br><span class="line">        <span class="keyword">int</span>[] pArr = <span class="keyword">new</span> <span class="keyword">int</span>[charArr.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pR = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxContainsEnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != charArr.length; i++) &#123;</span><br><span class="line">            pArr[i] = pR &gt; i ? Math.min(pArr[<span class="number">2</span> * index - i], pR - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])</span><br><span class="line">                    pArr[i]++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i + pArr[i] &gt; pR) &#123;</span><br><span class="line">                pR = i + pArr[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右边界到达最后一个字符就结束，那个中心就是包含最后一个字符的最长的回文</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pR == charArr.length) &#123;</span><br><span class="line">                <span class="comment">//得到那个中心</span></span><br><span class="line"></span><br><span class="line">                maxContainsEnd = pArr[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原来的长度 + 扩充的长度（字符最大的半径[str.length+1-回文最大的半径maxContainEnd]）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.length() + str.length() - maxContainsEnd + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sr.nextLine();</span><br><span class="line">        System.out.println(shortestEnd(s));      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> manacher算法 </tag>
            
            <tag> 京东笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【5】最长回文子串</title>
      <link href="/2019/05/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/05/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串  <code>s</code>，找到  <code>s</code>  中最长的回文子串。你可以假设 <code>s</code>  的最大长度为 1000。<a id="more"></a></p><p><strong>示例 1：</strong></p><p><strong>输入:</strong> “babad”<br><strong>输出:</strong> “bab”<br><strong>注意:</strong> “aba” 也是一个有效答案。</p><p><strong>示例 2：</strong></p><p><strong>输入:</strong> “cbbd”<br><strong>输出:</strong> “bb”</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><h5 id="方法1：暴力破解方法"><a href="#方法1：暴力破解方法" class="headerlink" title="方法1：暴力破解方法"></a>方法1：暴力破解方法</h5><h5 id="方法2：动态规划"><a href="#方法2：动态规划" class="headerlink" title="方法2：动态规划"></a>方法2：动态规划</h5><blockquote><p>新建一个dp[i][j]代表的意思是索引从i到j的子字符串是否是回文，假设s = cbbd,则可以dp对应坐标索引下的子字符串：</p><table><thead><tr><th></th><th>i = 0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>j = 0</td><td>c</td><td>cb</td><td>cbb</td><td>cbbd</td></tr><tr><td>1</td><td></td><td>b</td><td>bb</td><td>bbd</td></tr><tr><td>2</td><td></td><td></td><td>b</td><td>bd</td></tr><tr><td>3</td><td></td><td></td><td></td><td>d</td></tr></tbody></table><p>如果dp[i][j]所代表的字符串为回文，则将dp设为1.由上表可以总结出：</p><p>（1）当i = j 时，dp[j][i]  = 1</p><p>（2）i-j=1时,比如dp[1][2]为bb，表示两个相邻的字符，此时我们只要判断str[1]==str[2]就能得出dp[1][2]的结果</p><p>（3）i-j&gt;1时，我们来看dp[0][2]，首先还是要判断开头和结尾是否相等，也就是判断 str[0]==str[2]，假如此时str[0]=str[2]，我们还要再看剩下的子串是否回文， 我们可以直接从dp[j+1][i-1]来判断剩下的子串，把结果直接拿来用,判断是否是1（1表示回文）</p><p>即有公式</p><pre><code>dp[i][j] = (dp[i+1][j-1] &amp;&amp;s[i]=S[j]​) == true?1:0</code></pre><p>dp数组初始化如下：</p><pre><code>dp[i][i] = 1</code></pre><p>   dp[i][i+1] = ( S[i] == S[i+1] ?1:0;</p></blockquote><h5 id="方法3：中心扩展方法"><a href="#方法3：中心扩展方法" class="headerlink" title="方法3：中心扩展方法"></a>方法3：中心扩展方法</h5><blockquote><p>回文中心的两侧互为镜像。因此，回文可以从他的中心展开，并且只有2n-1个这样的中心(一个元素为中心的情况有n个，两个元素为中心的情况有n-1个)</p></blockquote><h5 id="方法4：manacher算法"><a href="#方法4：manacher算法" class="headerlink" title="方法4：manacher算法"></a>方法4：manacher算法</h5><blockquote><p>（1）预处理：回文的长度可奇可偶，故在每个字符的左右都加上一个特殊字符“#”,得到长度为奇数的字符串</p><p>（2）回文子串的半径：以中间的 ‘1’ 为中心的回文子串 “#2#2#1#2#2#” 的半径是6，而未添加#号的回文子串为 “22122”，长度是5，为半径减1。</p><p>（3）子串的起始位置：（字符串前面在加一个特殊字符”\$”,在字符末尾加另一个特殊字符”.”）中间位置减去半径再除以2。</p><p>（4）子串的终点位置：起点位置+半径-1</p><p>（5）马拉车核心</p><pre><code>p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;</code></pre><p>其中p[i]代表以i为中心的半径，id为能延伸到最右端的位置的那个回文子串的中心点位置，mx是回文串能延伸到的最右端的位置</p><p><img src="https://github.com/qiulig/IMG/raw/master/5_manecher1.png" alt="manecher"></p><p>1)mx - i &gt; p[j]，即以j为半径的回文在以id为半径的回文内(j跟i是对称的),其中 j = 2*id - i，因为 j 到 id 之间到距离等于 id 到 i 之间到距离，为 i - id，所以 j = id - (i - id) = 2*id - i.</p><p><img src="https://github.com/qiulig/IMG/raw/master/5_manecher2.png" alt="manecher"></p><p>2)mx - i &lt; p[j],即以j为中心的回文子串不一定完全包含于以id为中心的回文子串中，基于对称性可知，图中两个绿框所包围的部分是相同的，也就是说以i为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 p[i] = mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了，这就是后面紧跟到while循环的作用。</p><p>3)对于 mx &lt;= i 的情况，无法对 P[i]做更多的假设，只能P[i] = 1，然后再去匹配了。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>思路1：暴力破解方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       String temp = <span class="string">""</span>;</span><br><span class="line">       String res  =<span class="string">""</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;s.length();j++)&#123;</span><br><span class="line">               temp = temp+s.charAt(j);</span><br><span class="line">               <span class="comment">//re用来保存子字符串反转的结果</span></span><br><span class="line">               String re  = <span class="keyword">new</span> StringBuffer(temp).reverse().toString();</span><br><span class="line">               <span class="comment">//子字符串跟反转的字符串相等则为回文</span></span><br><span class="line">               <span class="keyword">if</span>(temp.equals(re))&#123;</span><br><span class="line">                   res = res.length()&gt;temp.length()?res:temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = <span class="string">""</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：动态规划思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个行列均为字符串长度的二维数组，创建时默认初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++)&#123;</span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;<span class="comment">//如果是回文字符串</span></span><br><span class="line">              <span class="comment">//新得到的回文比之前的回文字符串要长，更新字符串长度，记录字符串</span></span><br><span class="line">                    <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; max)&#123;</span><br><span class="line">                        max = j - i + <span class="number">1</span>;</span><br><span class="line">                        res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3：中心扩展方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span>  String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i); <span class="comment">//奇数的回文，中心有一个字母，以该字母往外扩</span></span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);  <span class="comment">//偶数的回文，中心有两个字母，以这两个字母往外扩</span></span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：马拉车算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) </span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"> <span class="comment">//manacher预处理</span></span><br><span class="line">        <span class="comment">//起点加特殊字符$ </span></span><br><span class="line">        String t = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="comment">//每个字符左右都加特殊字符 #</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            t += s.charAt(i);</span><br><span class="line">            t += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点加特殊字符&amp;</span></span><br><span class="line">        t+=<span class="string">"&amp;"</span>;</span><br><span class="line"> <span class="comment">//马拉车算法实现</span></span><br><span class="line">        <span class="comment">//定义半径</span></span><br><span class="line">        <span class="keyword">int</span> []p = <span class="keyword">new</span> <span class="keyword">int</span>[t.length()];</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.length()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//mancher核心算法</span></span><br><span class="line">            p[i] = mx &gt; i ? Math.min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//半径往外扩</span></span><br><span class="line">            <span class="keyword">while</span> (t.charAt(i + p[i]) == t.charAt(i-p[i]))</span><br><span class="line">                ++p[i];</span><br><span class="line">            <span class="comment">//以i为中心的回文子串不一定完全包含于以id为中心的回文子串中</span></span><br><span class="line">            <span class="keyword">if</span> ((mx-i) &lt;  p[i]) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">                resLen = p[i];</span><br><span class="line">                resCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring((resCenter - resLen) / <span class="number">2</span>, (resCenter - resLen) / <span class="number">2</span> + resLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/5_2.png" alt="动态规划"></p><p><img src="https://github.com/qiulig/IMG/raw/master/5_3.png" alt="中心扩展"></p><p><img src="https://github.com/qiulig/IMG/raw/master/5_4.png" alt="马拉车算法"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> manacher算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【4】寻找两个有序数组的中位数</title>
      <link href="/2019/05/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/05/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code>  和 <code>nums2</code>。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。<a id="more"></a></p><p><strong>示例 1:</strong></p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0</p><p><strong>示例 2:</strong></p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>排序输出中间值，但是复杂度不符合题意</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：复杂度不符合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将两个数组放到一个数组中并从小到大排序</span></span><br><span class="line">        <span class="keyword">int</span>[] ints = ArrayUtils.addAll(nums1, nums2);</span><br><span class="line">        Arrays.sort(ints);</span><br><span class="line">        <span class="comment">//奇数个数返回 中间索引，偶数个返回最中间的两个数的平均，注意/2可能为小数，要/2d或者/2.0强转为double类型</span></span><br><span class="line">        <span class="keyword">if</span>(ints.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (ints[(ints.length+<span class="number">1</span>)/<span class="number">2</span>]+ints[(ints.length+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>d;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> ints[(ints.length-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：复杂度还是不符合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1Length = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2Length = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> totalLength = n1Length + n2Length;</span><br><span class="line">        <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArrayIndex = totalLength / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n1Index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2Index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> last1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last2 = <span class="number">0</span>;  <span class="comment">//用于记录偶数情况下的last1的前一个数</span></span><br><span class="line">        <span class="keyword">while</span> (arrayIndex &lt;= maxArrayIndex) &#123;</span><br><span class="line">            last2 = last1;</span><br><span class="line">            <span class="comment">//只剩下nums2的情况了，nums1的全部数跟nums2排序都还没到达中间</span></span><br><span class="line">            <span class="keyword">if</span> (n1Index &gt;= n1Length) &#123;</span><br><span class="line">                last1 = nums2[n2Index++];</span><br><span class="line">            <span class="comment">//只剩下nums1的情况了，nums2的全部数跟nums1排序都还没到达中间</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n2Index &gt;= n2Length) &#123;</span><br><span class="line">                last1 = nums1[n1Index++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//哪个小哪个索引坐标【n1Index或者n2Index】开始滑动</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[n1Index] &lt;= nums2[n2Index]) &#123;</span><br><span class="line">                    last1 = nums1[n1Index++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    last1 = nums2[n2Index++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//整体数组【nums1 U nums2】的索引每循环依次自增1，直到到达整体数组中间位置</span></span><br><span class="line">            arrayIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (last1 + last2) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> last1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/4.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【3】无重复字符的最长子串</title>
      <link href="/2019/05/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/05/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “abcabcbb”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;abc&quot;，所以其</code>长度为 3。</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “bbbbb”<br><strong>输出:</strong> 1<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;b&quot;</code>，所以其长度为 1。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “pwwkew”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;wke&quot;</code>，所以其长度为 3。<br>     请注意，你的答案必须是 <strong>子串</strong> 的长度，<code>&quot;pwke&quot;</code> 是一个<em>子序列，</em>不是子串。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>滑动窗口思想</p><pre><code>准备一个list用于滑动窗口，</code></pre><p>（1）当list里面没有该字符时，加入该字符，list.size()就是无重复字符发长度。依次跟MaxLength比较取最大</p><p>（2）当list里面存在该值时，移除list里面该字符出现的第一个索引所在位置之前的所有字符[因为要求最长字串，即连续，所以要移除之前全部的字符]</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MaxLength = <span class="number">0</span>;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//list里面没有该字符就判断加入该字符是否就是最长的字符串</span></span><br><span class="line">            <span class="keyword">if</span>(!list.contains(s.charAt(i)))&#123;</span><br><span class="line">                list.add(s.charAt(i));</span><br><span class="line">                MaxLength = Math.max(MaxLength,list.size());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//加入重复的字符，并返回第一个与之相等的字符的索引位置</span></span><br><span class="line">                list.add(s.charAt(i));</span><br><span class="line">                <span class="keyword">int</span> index = list.indexOf(s.charAt(i)); </span><br><span class="line">                <span class="comment">// 移除该值以及该字符前面所有的字符</span></span><br><span class="line">                <span class="keyword">while</span>(index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    list.remove(index--); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/3.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【2】两数相加</title>
      <link href="/2019/05/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2019/05/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给出两个 <strong>非空</strong>  的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<a id="more"></a></p><p><strong>示例：</strong></p><p><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出：</strong>7 -&gt; 0 -&gt; 8<br><strong>原因：</strong>342 + 465 = 807</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>（1）设置一个进位位flag,flag的值为(当前两链表值相加+flag)/10,链表存储的值为(当前两链表值相加+flag)%10，依次遍历直到两个链表都到达尾部</p><p>（2）如果结束了flag不为0，则将flag的值继续添加到结果链表的尾部。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//用于指向res链表头</span></span><br><span class="line">            ListNode ress = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode res = ress;</span><br><span class="line">            <span class="comment">//用于最后的进位和各位数的进位</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span> ||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//还没为空时为l1.val,空的时候设为0</span></span><br><span class="line">                <span class="keyword">int</span> x = l1!=<span class="keyword">null</span> ?l1.val:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> y = l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> value = x+y+flag;  </span><br><span class="line">                <span class="comment">//得到进位位</span></span><br><span class="line">                flag = value/<span class="number">10</span>; </span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(value%<span class="number">10</span>);</span><br><span class="line">                res = res.next;   </span><br><span class="line">                <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果到最后一个数相加还有进位位，则链表长度扩展一位</span></span><br><span class="line">            <span class="keyword">if</span>(flag&gt;<span class="number">0</span>)  </span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">            <span class="keyword">return</span> ress.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/2.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【15】三数之和</title>
      <link href="/2019/05/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/05/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述："><a href="#1-题目描述：" class="headerlink" title="1.题目描述："></a>1.题目描述：</h3><h5 id="给定一个包含-n-个整数的数组-nums，判断-nums-中是否存在三个元素-a，b，c-，使得-a-b-c-0-？找出所有满足条件且不重复的三元组。"><a href="#给定一个包含-n-个整数的数组-nums，判断-nums-中是否存在三个元素-a，b，c-，使得-a-b-c-0-？找出所有满足条件且不重复的三元组。" class="headerlink" title="给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。"></a>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。<a id="more"></a></h5><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><blockquote><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p></blockquote><blockquote><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><ul><li>首先按升序排序；然后定义下标变量i,j,k，因为是三元组，所以要三个变量如果简单的遍历，那么跟是否有序没有关系，其时间复杂度将达到O(n^3)。仔细想想：如果当前选择了a、b、c三个数，如果其和小于目标target，那么需要将其中一个数用更大的数替换；反之亦然。但究竟替换三个数中的哪个数？无法确定就只能先固定两个变量，让其第三个变化（替换）。一种办法是：固定前两个数i,j，然后让k在一个范围中二分变化（二分查找思想）</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;Integer&gt; targets = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 用于去重</span></span><br><span class="line">        <span class="keyword">if</span>((nums.length&gt;<span class="number">0</span> &amp;&amp; nums.length&lt;<span class="number">3</span>) ||(nums.length&gt;<span class="number">0</span> &amp;&amp;nums[<span class="number">0</span>]&gt;<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=nums.length-<span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (!targets.contains(target)) &#123; <span class="comment">//用于去重</span></span><br><span class="line">                targets.add(target);</span><br><span class="line">                <span class="keyword">int</span> k = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[k] + nums[j] == target) &#123;</span><br><span class="line">                        List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                        li.add(nums[i]);</span><br><span class="line">                        li.add(nums[k]);</span><br><span class="line">                        li.add(nums[j]);</span><br><span class="line">                        list.add(li);</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; j &amp;&amp; nums[k] == nums[k + <span class="number">1</span>])</span><br><span class="line">                            ++k;</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                            --j;</span><br><span class="line">                        k++;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] + nums[j] &lt; target) &#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-我的提交记录"><a href="#4-我的提交记录" class="headerlink" title="4.我的提交记录"></a>4.我的提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/15.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【1】两数之和</title>
      <link href="/2019/05/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/05/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数数组  <code>nums</code> 和一个目标值  <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<a id="more"></a></p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9</p><p>所以返回 [<strong>0, 1</strong>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>依次遍历数组里面的数值</p><p>（1）用一个hashmap存储（target-nums[i],索引位置）</p><p>（2）如果下一次出现nums[i],说明找到了。直接将她的坐标跟之前存储的坐标存到结果。</p><p>如示例：nums = [2, 7, 11, 15], target = 9</p><p>   i = 0 时， map存入（7,0）</p><p>   i= 1时，发现map.get(num[i]) = map.get(7)!=null, 存在，即找到了，直接将map.get(7) =0,i = 1,这两个值存到结果res里面返回。 </p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//用一个hashmap进行存储【key = target-nums[i],value = 索引位置】</span></span><br><span class="line">            Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">            <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">               <span class="comment">//此时只要寻找map里面是否有nums[i],即找到两数之和</span></span><br><span class="line">               <span class="comment">//map.get(nums[i])指向的是(target-nums[i])那个数的索引，i指向的是nums[i]的索引</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(nums[i])!=<span class="keyword">null</span>)&#123;       </span><br><span class="line">                    res= <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(target-nums[i],i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-我的提交记录"><a href="#4-我的提交记录" class="headerlink" title="4.我的提交记录"></a>4.我的提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/1.png" alt="两数之和"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile介绍</title>
      <link href="/2019/05/volatile%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/05/volatile%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="并发编程的三大概念："><a href="#并发编程的三大概念：" class="headerlink" title="并发编程的三大概念："></a>并发编程的三大概念：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (1)原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</span><br><span class="line">  (2)可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</span><br><span class="line">  (3)有序性：程序执行的顺序按照代码的先后顺序执行。</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a><a id="more"></a></h4><h4 id="volatile介绍："><a href="#volatile介绍：" class="headerlink" title="volatile介绍："></a>volatile介绍：</h4><blockquote><p>1.volatile是虚拟机提供的最轻量级的同步机制</p><pre><code>保证变量对所有线程的可见性但是不保证原子性，需要通过加锁保证原子性。特例：1)运算结果并不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值2)变量不需要与其他状态变量共同参与不变约束</code></pre><p>2.禁止指令重排</p><pre><code>指令重拍是指CPU采用了允许多条指令不按程序规定的顺序分开发送给各相应电路单元处理，也能得到正确的结果。</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
          <category> 线程 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【66】机器人的运动范围</title>
      <link href="/2019/05/66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
      <url>/2019/05/66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>本题使用的方法同样还是回溯法，另外还需要会计算给定整数上的各个位上数之和。</p><pre><code>(1)使用一个访问数组记录是否已经经过该格子。机器人从(0,0)开始移动，当它准备进入(i,j)的格子时，通过检查坐标的数位来判断机器人是否能够进入。(2)如果机器人能进入(i,j)的格子，接着在判断它是否能进入四个相邻的格子(i,j-1),(i,j+1),(i-1,j),(i+1,j)。</code></pre><p>因此，可以用回溯法来解决这一问题。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rows&lt;<span class="number">1</span>||cols&lt;<span class="number">1</span>||threshold&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">boolean</span> []visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</span><br><span class="line">        <span class="keyword">return</span> count(threshold,rows,cols,visit,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span>[] visit, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(threshold,rows,cols,visit,row,col))</span><br><span class="line">        &#123;</span><br><span class="line">            visit[row*cols+col]=<span class="keyword">true</span>;</span><br><span class="line">            res=<span class="number">1</span>+count(threshold,rows,cols,visit,row,col+<span class="number">1</span>)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row,col-<span class="number">1</span>)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row+<span class="number">1</span>,col)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row-<span class="number">1</span>,col);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[] visit, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">                     &amp;&amp; visit[row * cols + col] == <span class="keyword">false</span> &amp;&amp;getNum(col) + getNum(row) &lt;= threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取位数之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【65】矩阵中的路径</title>
      <link href="/2019/05/65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/05/65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 * 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>回溯法</p><p>(1)在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。<br>　　由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。<br>　　需要判断这个矩阵中的每一个结点是否可以走一条路径，在走的过程中，设置一个和矩阵大小相同的整型数组flag表示是否已经访问，如果某个结点访问了，那么该结点的是否访问则为1。每次遍历一个结点的时候，递归的方式分别向左、向右、向上、向下。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(helper(matrix, rows, cols, i, j, str, <span class="number">0</span>, flag))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> k, <span class="keyword">int</span>[] flag)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = i * cols + j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols </span><br><span class="line">                || matrix[index] != str[k] || flag[index] == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// /下标不符合，index对应的值不为和字符数组中的不一致，或者该index已经被访问，这些情况只要有符合的就返回false</span></span><br><span class="line">            <span class="comment">// 只有上面的所有情况都不符合，也就是值相等，且没有访问过，下标不符合</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == str.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">if</span>(helper(matrix, rows, cols, i - <span class="number">1</span>, j, str, k + <span class="number">1</span>, flag)<span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        ||helper(matrix, rows, cols, i + <span class="number">1</span>, j, str, k + <span class="number">1</span>, flag)<span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">        ||helper(matrix, rows, cols, i, j - <span class="number">1</span>, str, k + <span class="number">1</span>, flag)<span class="comment">//上</span></span><br><span class="line"></span><br><span class="line">      ||helper(matrix, rows, cols, i , j + <span class="number">1</span>, str, k + <span class="number">1</span>, flag))<span class="comment">//下  </span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【64】滑动窗口的最大值</title>
      <link href="/2019/05/64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2019/05/64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。<a id="more"></a></p><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>{2,3,4,2,6,2,5,1} ，3</p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>{4,4,6,6,6,5}</p><h6 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h6><p> 存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}；</p><p> 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： </p><pre><code>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</code></pre></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>我们可以使用双向队列（Linklist），队列中只存放当前元素的下标，</p><pre><code>(1)设新来的元素为k，如果前面的元素比k小，直接把前面的删除（因为不可能成为后面窗口的最大值）(2)如果前面的元素比k大，判断是否还在窗口范围内，不在则移除</code></pre><h6 id="以数组-2-3-4-2-6-2-5-1-为例"><a href="#以数组-2-3-4-2-6-2-5-1-为例" class="headerlink" title="以数组{2,3,4,2,6,2,5,1}为例"></a>以数组{2,3,4,2,6,2,5,1}为例</h6><pre><code>数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。第五个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (num==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">if</span> (num.length&lt;size||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num.length; i++)&#123;</span><br><span class="line">     <span class="comment">//如果前面的数比插入的数小，直接把前面删除(因为不可能成为后面窗口的最大值)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()&amp;&amp;num[i]&gt;=num[queue.getLast()])</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        <span class="comment">//如果前面的元素比k大，判断是否还在窗口范围内，不在则移除</span></span><br><span class="line">        <span class="comment">//(i-(size-1))即滑动窗口最左侧的坐标索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()&amp;&amp;queue.getFirst()&lt;i-(size-<span class="number">1</span>))</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        <span class="comment">//加入队尾</span></span><br><span class="line"></span><br><span class="line">        queue.offerLast(i);</span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>&gt;=size)</span><br><span class="line">            arr.add(num[queue.getFirst()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【63】数据流中的中位数</title>
      <link href="/2019/05/63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/05/63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用一个list存储插入的数，然后对其进行排序</p><p>(1) size == 0 , 返回 null;</p><p>(2) size是偶数 , 返回 数值排序之后中间两个数的平均值;</p><p>(3) size是奇数，返回 list.get(size/2);</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//添加操作</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">            list.add(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取中位数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">if</span>(size!=<span class="number">0</span>)&#123;</span><br><span class="line">               </span><br><span class="line">                Collections.sort(list);</span><br><span class="line">                <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> (list.get(size/<span class="number">2</span>)+list.get(size/<span class="number">2</span>-<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> list.get(size/<span class="number">2</span>)*<span class="number">1.0</span>;                  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【62】二叉搜索树的第K个结点</title>
      <link href="/2019/05/62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>方法1：</p><blockquote><p>用PriorityQueue将所有结点放到queue中，再依次弹出里面的数据（队首数据依次弹出），弹出的第k个数据就是要求的数值，再将它构建成TreeNode即可。</p></blockquote><p>方法2：</p><blockquote><p>根据二叉搜索树的特点，左子树上的点小于该点，右子树上的点大于该点。所以按照中序遍历的方法得到的序列即是从小到大的序列。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">     <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        preOrderRec(pRoot);</span><br><span class="line">        <span class="keyword">if</span>(queue.size()&lt;k ||k &lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode( queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderRec</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(root.val);</span><br><span class="line">            preOrderRec(root.left);</span><br><span class="line">            preOrderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    TreeNode node=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>||pRoot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        KthNode(pRoot.left,k);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(k==index)</span><br><span class="line">        &#123; node=pRoot;</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        KthNode(pRoot.right,k);</span><br><span class="line">        <span class="keyword">return</span> node;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSR303参数校验和全局异常处理</title>
      <link href="/2019/05/JSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2019/05/JSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。故引出使用JSR303来做参数校验。参数校验的实现: <a id="more"></a></p><ul><li><p>手机号和密码字段自定义注解</p></li><li><p>为了让客户端显示更加友好 </p></li><li><p>需要自定义异常拦截器</p></li></ul></blockquote><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--JSR303参数检验+全局异常处理器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2-在需要验证的类前加-Valid并在该类内需要参数检查的成员上加自定义注解"><a href="#2-在需要验证的类前加-Valid并在该类内需要参数检查的成员上加自定义注解" class="headerlink" title="2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解"></a>2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/do_login"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">doLogin</span><span class="params">(HttpServletResponse  response,                                             </span></span></span><br><span class="line"><span class="function"><span class="params">                               @Valid LoginVo loginVo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(loginVo.toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginVo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@IsMobile</span></span><br><span class="line">    <span class="keyword">private</span>  String mobile;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-IsMobile注解的编写-可参考-NotNull"><a href="#3-IsMobile注解的编写-可参考-NotNull" class="headerlink" title="3. IsMobile注解的编写[可参考@NotNull]"></a>3. IsMobile注解的编写[可参考@NotNull]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">            ElementType.METHOD,</span><br><span class="line">            ElementType.FIELD, </span><br><span class="line">            ElementType.ANNOTATION_TYPE, </span><br><span class="line">            ElementType.CONSTRUCTOR,</span><br><span class="line">            ElementType.PARAMETER, </span><br><span class="line">            ElementType.TYPE_USE</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(</span><br><span class="line">        validatedBy = &#123;IsMobileValidator.class&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IsMobile &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "电话号码格式错误"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-指定校验器的实现-IsMobileValidator-class"><a href="#4-指定校验器的实现-IsMobileValidator-class" class="headerlink" title="4.指定校验器的实现[IsMobileValidator.class]"></a>4.指定校验器的实现[IsMobileValidator.class]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsMobileValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">IsMobile</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> required = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//初始化方法拿到注解，可以定义一个字符为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IsMobile constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        constraintAnnotation.required();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//值是必须的</span></span><br><span class="line">        <span class="keyword">if</span>(required)&#123;</span><br><span class="line">            <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-自定义异常拦截器"><a href="#5-自定义异常拦截器" class="headerlink" title="5.自定义异常拦截器"></a>5.自定义异常拦截器</h4><blockquote><p>当校验不通过时，会抛出异常。这时如果没有定义全局异常处理器进行处理（对异常进行封装和返回）。则会发生400错误（即只有请求的发起，却没有收到正常的响应（response），因为还没有来得及return就抛出了异常（这种异常没有被处理））。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">exceptionHandler</span><span class="params">(HttpServletRequest request,Exception e)</span></span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> GlobalException) &#123;</span><br><span class="line">            GlobalException ex = (GlobalException) e;</span><br><span class="line">            <span class="keyword">return</span> Result.Error(ex.getCm());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> BindException)&#123;</span><br><span class="line">            BindException ex = (BindException) e;</span><br><span class="line">            List&lt;ObjectError&gt; errors = ex.getAllErrors();</span><br><span class="line">            <span class="comment">//为了方便起见，只取第一个错误</span></span><br><span class="line"></span><br><span class="line">            ObjectError error = errors.get(<span class="number">0</span>);</span><br><span class="line">            String msg = error.getDefaultMessage();</span><br><span class="line">            <span class="keyword">return</span> Result.Error(CodeMsg.BIND_ERROR.fillArgs(msg));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.Error(CodeMsg.SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用缓存key</title>
      <link href="/2019/05/%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key/"/>
      <url>/2019/05/%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="通用缓存key的作用"><a href="#通用缓存key的作用" class="headerlink" title="通用缓存key的作用"></a>通用缓存key的作用</h2><h5 id="当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id-订单Id，用户id等-此时若是id出现重复，将给系统带来错误。"><a href="#当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id-订单Id，用户id等-此时若是id出现重复，将给系统带来错误。" class="headerlink" title="当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。"></a>当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。<a id="more"></a></h5><p>方法：利用一个前缀来规定不同模块的缓存的key,这样不同模块之间就不会重复。</p><p>通用缓存key采用模板模式：接口-&gt;抽象类-&gt;实现类</p><h5 id="1-接口"><a href="#1-接口" class="headerlink" title="1. 接口"></a>1. 接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyPrefix</span> </span>&#123;</span><br><span class="line">    <span class="comment">//过期时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expireSeconds</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePrefix</span> <span class="keyword">implements</span> <span class="title">KeyPrefix</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expireSeconds;</span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="comment">//无过期时间的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePrefix</span><span class="params">(String prefix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>(<span class="number">0</span>, prefix);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//含有过期时间的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePrefix</span><span class="params">( <span class="keyword">int</span> expireSeconds, String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expireSeconds = expireSeconds;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expireSeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> expireSeconds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取前缀，前缀为 className：prefix</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String className = getClass().getSimpleName();</span><br><span class="line">        <span class="keyword">return</span> className+<span class="string">":"</span> + prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-实现类"><a href="#3-实现类" class="headerlink" title="3. 实现类"></a>3. 实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaKey</span> <span class="keyword">extends</span> <span class="title">BasePrefix</span></span>&#123;</span><br><span class="line">    <span class="comment">//继承父类的无过期时间的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiaoshaKey</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置它这个类的前缀是className:go</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MiaoshaKey isGoodsOver = <span class="keyword">new</span> MiaoshaKey(<span class="string">"go"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitMQ实现消息缓冲</title>
      <link href="/2019/05/rabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2019/05/rabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>RabbitMQ主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是AMQP协议，它是一种二进制协议。默认启动端口5672`</p></blockquote><a id="more"></a><p>rabbitMQ的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，生产者producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。</p><ul><li><p><strong>Direct</strong>：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个       routing_key, 根据key全文匹配去寻找队列</p></li><li><p><strong>Topic</strong>：按规则转发消息（最灵活）<em>转发消息主要是根据通配符</em></p></li><li><p><strong>Headers</strong>：设置 header attribute 参数类型的交换机</p></li><li><p><strong>Fanout</strong>：转发消息到所有绑定队列(广播方式)</p><p><img src="https://github.com/qiulig/IMG/raw/master/rabbitMQ.png" alt="rabbitMQ原理"></p></li></ul><h3 id="下面介绍4种交换机与springboot的集成"><a href="#下面介绍4种交换机与springboot的集成" class="headerlink" title="下面介绍4种交换机与springboot的集成"></a>下面介绍4种交换机与springboot的集成</h3><p>添加依赖包amqp,统一配置application.properties</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--rabbitMQ依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">##rabbitMQ</span><br><span class="line">spring.rabbitmq.host=127.0.0.1</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br><span class="line">#消费者数量</span><br><span class="line">spring.rabbitmq.listener.simple.concurrency= 10</span><br><span class="line">spring.rabbitmq.listener.simple.max-concurrency= 10</span><br><span class="line">#消费者每次从队列获取的消息数量</span><br><span class="line">spring.rabbitmq.listener.simple.prefetch= 1</span><br><span class="line">#消费者自动启动</span><br><span class="line">spring.rabbitmq.listener.simple.auto-startup=true</span><br><span class="line">#消费失败，自动重新入队</span><br><span class="line">spring.rabbitmq.listener.simple.default-requeue-rejected= true</span><br><span class="line">#启用发送重试</span><br><span class="line">spring.rabbitmq.template.retry.enabled=true </span><br><span class="line">spring.rabbitmq.template.retry.initial-interval=1000</span><br><span class="line">spring.rabbitmq.template.retry.max-attempts=3</span><br></pre></td></tr></table></figure><h4 id="1-Direct交换机制"><a href="#1-Direct交换机制" class="headerlink" title="1. Direct交换机制"></a>1. Direct交换机制</h4><blockquote><p>一个队列会和一个交换机绑定，除此之外再绑定一个routing_key，当消息被发送的时候，需要指定一个binding_key，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个binding_key也是支持应用到多个队列中的。 这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。</p></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/direct.png" alt="direct原理"></p><h5 id="1-1-编写config"><a href="#1-1-编写config" class="headerlink" title="1.1 编写config"></a>1.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  QUEUE =<span class="string">"queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-创建消息发送者"><a href="#1-2-创建消息发送者" class="headerlink" title="1.2 创建消息发送者"></a>1.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate  amqpTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(MQreceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">        String msg = redisService.beanToString(message);</span><br><span class="line">        log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">        amqpTemplate.convertAndSend(MQconfig.Queue,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-创建消息接收者"><a href="#1-3-创建消息接收者" class="headerlink" title="1.3 创建消息接收者"></a>1.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(MQreceiver.class);</span><br><span class="line">    <span class="comment">//监听了queue的队列</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQconfig.Queue)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive message"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-编写controller测试"><a href="#1-4-编写controller测试" class="headerlink" title="1.4 编写controller测试"></a>1.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123; <span class="meta">@Autowired</span></span><br><span class="line">    MQsender sender;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/mq"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Result&lt;Boolean&gt; <span class="title">mq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sender.send(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-Fanout交换机制"><a href="#2-Fanout交换机制" class="headerlink" title="2. Fanout交换机制"></a>2. Fanout交换机制</h4><ul><li><p>扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。</p><p><img src="https://github.com/qiulig/IMG/raw/master/fanout.png" alt="Fanout原理"></p></li></ul><h5 id="2-1-编写config"><a href="#2-1-编写config" class="headerlink" title="2.1 编写config"></a>2.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  FANOUT_EXCHANGE =<span class="string">"fanoutxchage"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span>       </span><br><span class="line">          BindingBuilder.bind(topticQueue2()).to(fanoutExchange());</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-创建消息发送者"><a href="#2-2-创建消息发送者" class="headerlink" title="2.2 创建消息发送者"></a>2.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> AmqpTemplate amqpTemplate;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> RedisService redisService;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFanout</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String msg = redisService.beanToString(message);</span><br><span class="line">    log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">    amqpTemplate.convertAndSend(MQconfig.FANOUT_EXCHANGE,<span class="string">""</span>,msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-创建消息接收者"><a href="#2-3-创建消息接收者" class="headerlink" title="2.3 创建消息接收者"></a>2.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">     <span class="comment">//fanout 广播模式都接受故不需要listener</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-编写controller测试"><a href="#2-4-编写controller测试" class="headerlink" title="2.4 编写controller测试"></a>2.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(<span class="string">"/mq/fanout"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Result&lt;String&gt; <span class="title">fanout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sender.sendFanout(<span class="string">"hellommxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">"hello xuanzi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-topic交换机制"><a href="#3-topic交换机制" class="headerlink" title="3. topic交换机制"></a>3. topic交换机制</h4><blockquote><p>通配符交换机，exchange会把消息发送到一个或者多个满足通配符规则的<code>routing-key</code>的queue。其中<em>表号匹配一个word，#匹配多个word和路径，路径之间通过.隔开。如满足a.</em>.c的routing-key有a.hello.c；满足#.hello的routing-key有a.b.c.helo。</p></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/topic.png" alt="topic原理"></p><h5 id="1-1-编写config-1"><a href="#1-1-编写config-1" class="headerlink" title="1.1 编写config"></a>1.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  TOPIC_QUEUE1 =<span class="string">"topic.queue1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  TOPIC_QUEUE2 =<span class="string">"topic.queue2"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  TOPIC_EXCHANGE =<span class="string">"topicExchange"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topticQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE1,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE2,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPIC_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topticQueue1()).to(topicExchange()).with(<span class="string">"topic.key1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topticQueue2()).to(topicExchange()).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-创建消息发送者-1"><a href="#1-2-创建消息发送者-1" class="headerlink" title="1.2 创建消息发送者"></a>1.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTopic</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">    String msg = redisService.beanToString(message);</span><br><span class="line">    log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">  amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE,</span><br><span class="line">                                <span class="string">"topic.key1"</span>,msg+<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE,</span><br><span class="line">                                <span class="string">"topic.key2"</span>,msg+<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-创建消息接收者-1"><a href="#1-3-创建消息接收者-1" class="headerlink" title="1.3 创建消息接收者"></a>1.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQconfig.TOPIC_QUEUE1)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveTopic1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive topic queue1 message"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQconfig.TOPIC_QUEUE2)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveTopic2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive topic queue2 message"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-编写controller测试-1"><a href="#1-4-编写controller测试-1" class="headerlink" title="1.4 编写controller测试"></a>1.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(<span class="string">"/mq/topic"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Result&lt;String&gt; <span class="title">topic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sender.sendTopic(<span class="string">"hellommxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">"hello xuanzi"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-header交换机制"><a href="#4-header交换机制" class="headerlink" title="4. header交换机制"></a>4. header交换机制</h4><blockquote><p>header exchange(头交换机)和主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据。<br>主题交换机路由键只有是字符串,而头交换机可以是整型和哈希值</p></blockquote><h5 id="1-1-编写config-2"><a href="#1-1-编写config-2" class="headerlink" title="1.1 编写config"></a>1.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  HEADER_QUEUE =<span class="string">"header.queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeadersExchange <span class="title">headersExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeadersExchange(HEADERS_EXCHANGE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">headerQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Queue(HEADER_QUEUE,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Binding <span class="title">headerBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Map&lt;String,Object&gt; map =<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">       map.put(<span class="string">"header1"</span>,<span class="string">"value1"</span>);</span><br><span class="line"></span><br><span class="line">       map.put(<span class="string">"header2"</span>,<span class="string">"value2"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> </span><br><span class="line">         BindingBuilder.bind(headerQueue()).to(headersExchange())</span><br><span class="line">                                           .whereAll(map).match();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-创建消息发送者-2"><a href="#1-2-创建消息发送者-2" class="headerlink" title="1.2 创建消息发送者"></a>1.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendheader</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String msg = redisService.beanToString(message);</span><br><span class="line">    log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">    MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">    properties.setHeader(<span class="string">"header1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    properties.setHeader(<span class="string">"header2"</span>,<span class="string">"value2"</span>);</span><br><span class="line">    Message obj = <span class="keyword">new</span> Message(msg.getBytes(),properties);</span><br><span class="line">    amqpTemplate.convertAndSend(MQconfig.HEADERS_EXCHANGE,<span class="string">""</span>,obj);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-创建消息接收者-2"><a href="#1-3-创建消息接收者-2" class="headerlink" title="1.3 创建消息接收者"></a>1.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RabbitListener</span>(queues = MQconfig.HEADER_QUEUE)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveHeader</span><span class="params">(<span class="keyword">byte</span>[] message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          log.info(<span class="string">"receive header queue message"</span>+message);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-编写controller测试-2"><a href="#1-4-编写controller测试-2" class="headerlink" title="1.4 编写controller测试"></a>1.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">      <span class="meta">@RequestMapping</span>(<span class="string">"/mq/header"</span>)</span><br><span class="line">      <span class="meta">@ResponseBody</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span>  Result&lt;String&gt; <span class="title">header</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          sender.sendheader(<span class="string">"hellommxx"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> Result.success(<span class="string">"hello xuanzi"</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存java端实现</title>
      <link href="/2019/05/Redis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/Redis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>redis是一个key-value<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">存储系统</a>。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(<a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">链表</a>)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">数据类型</a>都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。<a id="more"></a></p><h5 id="1-引入redis依赖"><a href="#1-引入redis依赖" class="headerlink" title="1. 引入redis依赖"></a>1. 引入redis依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="2-在application-properties添加redis配置文件"><a href="#2-在application-properties添加redis配置文件" class="headerlink" title="2.在application.properties添加redis配置文件"></a>2.在application.properties添加redis配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#redis</span><br><span class="line">redis.host=127.0.0.1</span><br><span class="line">redis.port=6379</span><br><span class="line">redis.timeout=3</span><br><span class="line">redis.password=2966</span><br><span class="line">redis.poolMaxTotal=10   //资源池中最大连接数</span><br><span class="line">redis.poolMaxIdle=10   //允许的最大空闲的连接数</span><br><span class="line">redis.poolMaxWait=3</span><br></pre></td></tr></table></figure><h5 id="3-定义redis的类，引入redis的配置"><a href="#3-定义redis的类，引入redis的配置" class="headerlink" title="3.定义redis的类，引入redis的配置"></a>3.定义redis的类，引入redis的配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"redis"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String host;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> timeout;<span class="comment">//秒</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> poolMaxTotal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> poolMaxIdle;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> poolMaxWait;<span class="comment">//秒</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-RedisPoolFactory类，用于返回一个redis池"><a href="#4-RedisPoolFactory类，用于返回一个redis池" class="headerlink" title="4.RedisPoolFactory类，用于返回一个redis池"></a>4.RedisPoolFactory类，用于返回一个redis池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPoolFactory</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   RedisConfig redisConfig;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisPool <span class="title">JedisPoolFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">      <span class="comment">//允许最大空闲的连接数</span></span><br><span class="line">      poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());</span><br><span class="line">      <span class="comment">//资源池中最大连接数</span></span><br><span class="line">      poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());</span><br><span class="line">      <span class="comment">//最大等待毫秒数</span></span><br><span class="line">      poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * <span class="number">1000</span>);</span><br><span class="line">      JedisPool jp = <span class="keyword">new</span> JedisPool(poolConfig,</span><br><span class="line">                                   redisConfig.getHost(),                                                                                                                                                                                                                                                    </span><br><span class="line">                                   redisConfig.getPort(),</span><br><span class="line"></span><br><span class="line">                                   redisConfig.getTimeout()*<span class="number">1000</span>,          </span><br><span class="line"></span><br><span class="line">                                   redisConfig.getPassword(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> jp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-编写RedisService类"><a href="#5-编写RedisService类" class="headerlink" title="5.编写RedisService类"></a>5.编写RedisService类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line">    <span class="comment">//里面编写redis操作：增删改查</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">returnToPool</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">             jedis.close();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-1-获取单个对象-get"><a href="#5-1-获取单个对象-get" class="headerlink" title="5.1 获取单个对象(get)"></a>5.1 获取单个对象(get)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的get key </span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(KeyPrefix prefix, String key,  Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">             <span class="comment">//生成真正的key,之前设置通用缓存key时的key设为className:key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">             <span class="comment">//跟redis里面的获取一个key操作一致 </span></span><br><span class="line">             String  str = jedis.get(realKey);</span><br><span class="line">             <span class="comment">//将结果转换成一个java对象</span></span><br><span class="line">             T t =  stringToBean(str, clazz);</span><br><span class="line">             <span class="keyword">return</span> t;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">//关闭池资源</span></span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//json转换为java对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; <span class="function">T <span class="title">stringToBean</span><span class="params">(String str, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span> || clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断类型</span></span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span>.class || clazz == Integer.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> (T)Integer.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> (T)str;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span>.class || clazz == Long.class) &#123;</span><br><span class="line">            <span class="keyword">return</span>  (T)Long.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJavaObject(JSON.parseObject(str), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-2-设置对象-set"><a href="#5-2-设置对象-set" class="headerlink" title="5.2 设置对象(set)"></a>5.2 设置对象(set)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的set key value</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">set</span><span class="params">(KeyPrefix prefix, String key,  T value)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">             <span class="comment">//对象转换为json字符串</span></span><br><span class="line">             String str = beanToString(value);</span><br><span class="line">             <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">             <span class="comment">//获取过期时间</span></span><br><span class="line">             <span class="keyword">int</span> seconds =  prefix.expireSeconds();</span><br><span class="line">             <span class="keyword">if</span>(seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//永久有效，无过期时间</span></span><br><span class="line">                 jedis.set(realKey, str);</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//为指定的 key 设置值及其过期时间。</span></span><br><span class="line">                 jedis.setex(realKey, seconds, str);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象转化为Json字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; <span class="function">String <span class="title">beanToString</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; clazz = value.getClass();</span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span>.class || clazz == Integer.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> (String)value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span>.class || clazz == Long.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-3-判断key是否存在-exists"><a href="#5-3-判断key是否存在-exists" class="headerlink" title="5.3 判断key是否存在(exists)"></a>5.3 判断key是否存在(exists)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想当于redis里面的 exists key</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">     Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         jedis =  jedisPool.getResource();</span><br><span class="line">        <span class="comment">//生成真正的key</span></span><br><span class="line">         String realKey  = prefix.getPrefix() + key;</span><br><span class="line">        <span class="keyword">return</span>  jedis.exists(realKey);</span><br><span class="line">     &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          returnToPool(jedis);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-4-增加值-incr"><a href="#5-4-增加值-incr" class="headerlink" title="5.4 增加值(incr)"></a>5.4 增加值(incr)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的incr key_name</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Long <span class="title">incr</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">return</span>  jedis.incr(realKey);</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-5-减少值-decr"><a href="#5-5-减少值-decr" class="headerlink" title="5.5 减少值(decr)"></a>5.5 减少值(decr)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的decr key_name</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Long <span class="title">decr</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">return</span>  jedis.decr(realKey);</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-6-删除-del"><a href="#5-6-删除-del" class="headerlink" title="5.6 删除(del)"></a>5.6 删除(del)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的del key_name</span></span><br><span class="line">    <span class="comment">//已知key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">            String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">long</span> ret  = jedis.del(realKey);</span><br><span class="line">            <span class="keyword">return</span> ret &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            returnToPool(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过正则匹配删除 某key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(KeyPrefix prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; keys = scanKeys(prefix.getPrefix());</span><br><span class="line">        <span class="keyword">if</span>(keys==<span class="keyword">null</span> || keys.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.del(keys.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">scanKeys</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            String cursor = <span class="string">"0"</span>;</span><br><span class="line">            <span class="comment">//scan搜索</span></span><br><span class="line">            ScanParams sp = <span class="keyword">new</span> ScanParams();</span><br><span class="line">            sp.match(<span class="string">"*"</span>+key+<span class="string">"*"</span>);</span><br><span class="line">            <span class="comment">//设置scan的个数</span></span><br><span class="line">            sp.count(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                ScanResult&lt;String&gt; ret = jedis.scan(cursor, sp);</span><br><span class="line">                <span class="comment">//返回结果</span></span><br><span class="line">                List&lt;String&gt; result = ret.getResult();</span><br><span class="line">                <span class="keyword">if</span>(result!=<span class="keyword">null</span> &amp;&amp; result.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//搜索的结果存入list</span></span><br><span class="line">                    keys.addAll(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//再处理cursor，用于返回下次遍历的游标</span></span><br><span class="line">                cursor = ret.getStringCursor();</span><br><span class="line">            &#125;<span class="keyword">while</span>(!cursor.equals(<span class="string">"0"</span>));</span><br><span class="line">            <span class="keyword">return</span> keys;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="6-controller层测试"><a href="#6-controller层测试" class="headerlink" title="6.controller层测试"></a>6.controller层测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis/get"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Result&lt;User&gt; <span class="title">getRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">   User user = redisService.get(UserKey.getById,<span class="string">"key1"</span>,User.class);</span><br><span class="line">    <span class="keyword">return</span> Result.success(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis/set"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Result&lt;Boolean&gt; <span class="title">setRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">"1111"</span>);</span><br><span class="line">    redisService.set(UserKey.getById,<span class="string">""</span>+<span class="number">1</span>,user);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【61】序列化二叉树</title>
      <link href="/2019/05/61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树 <a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>二叉树的序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>先序序列化二叉树——&gt;&gt;&gt;&gt;定义一个stringbuilder保存序列过程中的结果：</p><p>(1)按照先序遍历方式遍历二叉树，若结点非空则把 “结点值,” append到builder中；</p><p>(2)若结点空则把 “#,” append到builder中；</p><p>(3)最后用builder生成字符串就是序列化结果。</p><p>二叉树的反序列化</p><pre><code>根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</code></pre><p>(1)先序序列化结果重构二叉树</p><p>(2)String[] nodes=str.split(“,”)；//由每个结点的结束符号划分序列化结果序列，得到各个结点值；</p><p>(3)然后按照先序遍历的顺序“根左右”的特性，遍历nodes数组建立二叉树：</p><p>  1)当前遍历元素非 # 则作为一个结点插入树中作为上一结点的左儿子；</p><p>  2)当前遍历元素为 # 则表示此子树已结束，遍历下一元素作为上一结点的右儿子；</p><p>即：<strong>遇数作左；遇#变向</strong></p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;    </span><br><span class="line">        TreeNode left = <span class="keyword">null</span>;    </span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">this</span>.val = val;    </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;     </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//递归先序遍历对二叉树进行序列化</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;        </span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;            </span><br><span class="line">            sb.append(<span class="string">"#,"</span>);            </span><br><span class="line">            <span class="keyword">return</span> sb.toString();        </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="comment">//先序遍历根结点</span></span><br><span class="line">        sb.append(root.val + <span class="string">","</span>);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        sb.append(Serialize(root.left));   </span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        sb.append(Serialize(root.right));        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//反序列化 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//特殊输入</span></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()&lt;=<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将字符串按照","拆分为数组</span></span><br><span class="line">        String[] strr = str.split(<span class="string">","</span>);        </span><br><span class="line">        <span class="keyword">int</span> len = strr.length;        </span><br><span class="line">        index++;        </span><br><span class="line">        <span class="keyword">if</span>(index &gt;= len)&#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="comment">//如果遇到的是#表示空节点，不再建立子树，这个结点null就是子树的根结点返回</span></span><br><span class="line">        <span class="keyword">if</span>(!strr[index].equals(<span class="string">"#"</span>))&#123;            </span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(Integer.valueOf(strr[index]));            </span><br><span class="line">            <span class="comment">//恢复左子树</span></span><br><span class="line">            node.left = Deserialize(str);            </span><br><span class="line">            <span class="comment">//恢复右子树</span></span><br><span class="line">            node.right = Deserialize(str);       </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//建立二叉树完成，返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> node;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【60】把二叉树打印成多行</title>
      <link href="/2019/05/60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/"/>
      <url>/2019/05/60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 <a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>利用层次遍历二叉树的方式，用一个队列进行辅助，每次打印前取n = queue.size()，可以保证逐行打印。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="comment">//加入根结点</span></span><br><span class="line">       queue.add(pRoot);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//每遍历一次，就新建一次tmp</span></span><br><span class="line">           ArrayList&lt;Integer&gt;  tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(queue.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//加入左结点</span></span><br><span class="line">                   queue.add(queue.peek().left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(queue.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//加入右结点</span></span><br><span class="line">                   queue.add(queue.peek().right);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//删除并返回queue中的头元素，删掉根（上一层结点元素）</span></span><br><span class="line">               tmp.add(queue.poll().val);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将一层的左右结点加入res</span></span><br><span class="line">           res.add(tmp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【59】按之字形顺序打印二叉树</title>
      <link href="/2019/05/59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用一个布尔量控制从左到右还是从右到左的顺序；如果为真则他的左右孩子按照从左到右的顺序放入list中，否则按照从右到左的顺序，当本行结束之后，再把list中的数据放入一个result中。其中用一个null值作为层次的分隔符。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">      ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.addLast(<span class="keyword">null</span>);<span class="comment">//层分隔符</span></span><br><span class="line">       queue.addLast(pRoot);</span><br><span class="line">       <span class="keyword">boolean</span> leftToRight = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">           TreeNode node = queue.removeFirst();</span><br><span class="line">           <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;<span class="comment">//到达层分隔符</span></span><br><span class="line">               Iterator&lt;TreeNode&gt; iter = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (leftToRight) &#123;</span><br><span class="line">                      iter = queue.iterator();<span class="comment">//从前往后遍历</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">//从后往前遍历</span></span><br><span class="line"></span><br><span class="line">                       iter = queue.descendingIterator();</span><br><span class="line">                   &#125;</span><br><span class="line">               leftToRight = !leftToRight;</span><br><span class="line">               <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                       TreeNode temp = (TreeNode) iter.next();</span><br><span class="line">                       list.add(temp.val);</span><br><span class="line">                   &#125;</span><br><span class="line">               result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">               list.clear();</span><br><span class="line">               queue.addLast(<span class="keyword">null</span>);<span class="comment">//添加层分隔符</span></span><br><span class="line">               <span class="keyword">continue</span>;<span class="comment">//一定要continue</span></span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.addLast(node.left);</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.addLast(node.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【58】对称的二叉树</title>
      <link href="/2019/05/58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p> 【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。</p><p>【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。</p><p>【分析3】根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到</p><pre><code>① 如果Root和Root&apos;均为空，则返回true；② 如果Root为空或者Root&apos;为空，则返回false；③ 如果Root对应的值与Root&apos;对应的值不相等，则返回false。</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span> || pRoot.left==<span class="keyword">null</span>&amp;&amp;pRoot.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetrical(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">Symmetrical</span><span class="params">(TreeNode left,TreeNode right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val==right.val)</span><br><span class="line">                    <span class="comment">//右子树的左边跟左子树的右边是否对称</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>    Symmetrical(left.left,right.right)</span><br><span class="line">                   <span class="comment">//左子树的右边跟右子树的左边是否对称</span></span><br><span class="line">                   &amp;&amp; Symmetrical(left.right,right.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【57】二叉树的下一个结点</title>
      <link href="/2019/05/57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>情况1：该节点有右子树：</p><pre><code>         6     /      \   3         10 /   \      /    \2     5    8      12</code></pre><p>中序遍历结果为：2–&gt;3–&gt;5–&gt;<strong>6–&gt;8</strong>–&gt;10–&gt;12</p><p>即它的下一个结点就是它的右子树中<strong>最左子结点</strong></p></blockquote><blockquote><p>情况2.1：该节点无右子树：(为父节点6的左子节点)</p><pre><code>        6     /     \   3        10  /        /    \2         8      12</code></pre><p>2–&gt;<strong>3–&gt;6</strong>–&gt;8–&gt;10–&gt;12</p><p>该节点是父节点的左子节点的这种情况比较简单，直接将父节点返回即可</p></blockquote><blockquote><p>情况2.2：该节点无右子树：(为父节点6的右子节点)</p><pre><code>          6       /    \     3        10  /     \     /   \2       5    8    null</code></pre><p>   2–&gt;3–&gt;6–&gt;8–&gt;<strong>10 –&gt;null</strong></p><p>如果是父节点的右子节点的话，需要不断的向上移动，直到对应的节点不是父节点的右节点（即左节点），既然他是父节点的左节点，此时将这个节点父节点返回即可，或者遍历到了根节点，返回null；</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该节点有右子树,它的下一个结点就是它的右子树中最左子结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该节点无右子树，父节点不为空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//pNode为父节点的左节点为该节点，直接返回父节点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left== pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">       <span class="comment">//为父节点的右子节点，不断的向上移动，直到对应的节点不是父节点的左子节点                  </span></span><br><span class="line">       <span class="comment">//一直回溯如果遍历到他是父节点的左节点，此时将这个节点父节点返回即可，</span></span><br><span class="line">       <span class="comment">//或者遍历到了根节点，返回null；</span></span><br><span class="line"></span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【56】删除链表中重复的结点</title>
      <link href="/2019/05/56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 <a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>方法一：重头构建该链表</p><p>(1) 新建两个list，一个用于存放只出现一次的数值，一个存放重复的数值</p><p>(2) 将只出现过一次的数重头构建成链表</p><p>方法二：递归思想</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; ss = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           ArrayList&lt;Integer&gt; ss2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">           ListNode node = res;</span><br><span class="line">           <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(!ss.contains(pHead.val) &amp;&amp; !ss2.contains(pHead.val))&#123;</span><br><span class="line"></span><br><span class="line">                   ss.add(pHead.val);</span><br><span class="line">                   pHead = pHead.next;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ss2.add(pHead.val);</span><br><span class="line">                   ss.remove(Integer.valueOf(pHead.val));</span><br><span class="line">                   pHead = pHead.next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ss.size();i++)&#123;</span><br><span class="line">               res.next =<span class="keyword">new</span> ListNode(ss.get(i));</span><br><span class="line">               res = res.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> node.next;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有0个或1个结点，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pHead.val == pHead.next.val) &#123; <span class="comment">// 当前结点是重复结点</span></span><br><span class="line">            ListNode pNode = pHead.next;</span><br><span class="line">            <span class="keyword">while</span> (pNode != <span class="keyword">null</span> &amp;&amp; pNode.val == pHead.val) &#123;</span><br><span class="line">              <span class="comment">// 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点</span></span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从第一个与当前结点不同的结点开始递归</span></span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(pNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前结点不是重复结点</span></span><br><span class="line">            <span class="comment">// 保留当前结点，从下一个结点开始递归</span></span><br><span class="line">            pHead.next = deleteDuplication(pHead.next); </span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【55】链表中环的入口结点</title>
      <link href="/2019/05/55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>方法1：</p><pre><code>利用hashSet不存储重复值的思想</code></pre><p>方法2：</p><p>链表包含环，像数字6的图形。</p><p>(1)设置快慢指针，假设快指针在环内与慢指针相遇，设头节点到入口结点的距离为x,入口结点到相遇点为y,相遇点到入口结点距离为z,则有(x+y)*2 = (x+y+z+y),即z = x，即相遇点到入口结点的距离跟头节点到入口结点的距离相等。</p><p>(2)这时再设置fast = pHead,一个指针重头走，另一个指针重相遇节点走，当两个点相等时即为入口节点所在。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">         HashSet&lt;ListNode&gt; hs = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">         <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(!hs.add(pHead))<span class="comment">//如果包含了，那么这个就是入口结点</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">             pHead = pHead.next;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                fast=pHead;</span><br><span class="line">                <span class="keyword">while</span> (fast!=slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【54】字符流中第一个不重复的字符</title>
      <link href="/2019/05/54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2019/05/54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>桶排序思想</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源源不断的有字母放到字符串中，建立一个256个大小的int型数组来代表哈希表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String str=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;=<span class="number">256</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str+=ch;<span class="comment">//字符放入字符串</span></span><br><span class="line">            count[ch]++;<span class="comment">//根据字符，修改数组字符元素的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:str.toCharArray())&#123;<span class="comment">// //注意的是，要找第一个出现一次的字符，所以遍历字符串，不能遍历哈希数组</span></span><br><span class="line">            <span class="keyword">if</span>(count[c]==<span class="number">1</span>)&#123;<span class="comment">//如果字符串作为下表的元素值为1，说明该字符出现一次，直接返回该字符</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【53】表示数值的字符串</title>
      <link href="/2019/05/53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/05/53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>(1) 先判断每个字符是否合法</p><p>(2) 正负号的位置和e不能在结尾位置</p><p>(3) 小数点只能存在一个</p><p>(4)正负号在中间位置时，前面是e后面是数字</p><p>(5)e后面不能有小数点</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;      </span><br><span class="line">        String ss = String.valueOf(str);    </span><br><span class="line">        <span class="keyword">int</span> len = ss.length();</span><br><span class="line">        <span class="comment">//先判断每个字符是否合法  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;            </span><br><span class="line">            <span class="keyword">char</span> c = ss.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!((c&gt;=<span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c==<span class="string">'e'</span> || c==<span class="string">'E'</span>|| c==<span class="string">'+'</span> || c==<span class="string">'-'</span>|| c==<span class="string">'.'</span>))          </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////正负号,E不能在末尾      </span></span><br><span class="line">        <span class="keyword">if</span>(ss.charAt(len-<span class="number">1</span>) == <span class="string">'+'</span> || ss.charAt(len-<span class="number">1</span>) == <span class="string">'-'</span> </span><br><span class="line">           || ss.charAt(len-<span class="number">1</span>) == <span class="string">'E'</span> || ss.charAt(len-<span class="number">1</span>) == <span class="string">'e'</span>)        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断小数点，只能有一个       </span></span><br><span class="line">        <span class="keyword">if</span>(ss.indexOf(<span class="string">"."</span>) != ss.lastIndexOf(<span class="string">"."</span>))  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;       </span><br><span class="line">        <span class="comment">//正负号在中间的位置时，前面的是e，E,后面是数字      </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len-<span class="number">1</span>; i++)&#123;         </span><br><span class="line">            <span class="keyword">char</span> c = ss.charAt(i);          </span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'+'</span> || c==<span class="string">'-'</span>)&#123;             </span><br><span class="line">               <span class="keyword">if</span>(!(ss.charAt(i-<span class="number">1</span>) == <span class="string">'e'</span> || ss.charAt(i-<span class="number">1</span>) == <span class="string">'E'</span>)   </span><br><span class="line">                   ||!(ss.charAt(i+<span class="number">1</span>)&gt;=<span class="string">'0'</span> &amp;&amp; ss.charAt(i+<span class="number">1</span>)&lt;=<span class="string">'9'</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;               </span><br><span class="line">                &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////e的后面不能有数字12E+4.3        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;            </span><br><span class="line">            <span class="keyword">char</span> c = ss.charAt(i);          </span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'e'</span> || c==<span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==len-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;               </span><br><span class="line">                <span class="keyword">if</span>(ss.charAt(i+<span class="number">1</span>) == <span class="string">'+'</span> || ss.charAt(i+<span class="number">1</span>) == <span class="string">'-'</span>)&#123;</span><br><span class="line">                    <span class="comment">//从i+2开始往后没有小数点.则返回-1</span></span><br><span class="line">                    <span class="keyword">if</span>(ss.indexOf(<span class="string">"."</span>, i+<span class="number">2</span>) != -<span class="number">1</span>)&#123;                     </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;                   </span><br><span class="line">                      &#125;               </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ss.indexOf(<span class="string">"."</span>, i+<span class="number">1</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【52】正则表达式匹配</title>
      <link href="/2019/05/52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/05/52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>这道题的核心其实在于分析’*‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’*’的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。</p><p><strong>情况1：Patttern第二个字符是’*’时</strong>：</p><p>1.第一个字符不匹配（’.’与任意字符视作匹配），那么’*’只能代表匹配0次</p><pre><code>&apos;ba&apos;与&apos;a*ba&apos;，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式</code></pre><p>2.第一个字符匹配，那么’*‘可能代表匹配0次，1次，多次，</p><pre><code>(1)&apos;aaa&apos;与&apos;a*aaa&apos;: 匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；(2)&apos;aba&apos;与&apos;a*ba&apos;:匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；(3)&apos;aaaba&apos;与&apos;a*ba&apos;:匹配多次时，字符串往后移动一个字符，模式不变；</code></pre><p><strong>情况2：Patttern第二个字符不是’*‘时：</strong></p><pre><code>(1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。(2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> strIndex = <span class="number">0</span>,patternIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功    </span></span><br><span class="line">        <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">    <span class="comment">//pattern先到尾，匹配失败    </span></span><br><span class="line">        <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;    </span><br><span class="line">        <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位 </span></span><br><span class="line">        <span class="comment">//   //如果当前pattern的下一个是*并且没有超出pattern的长度时</span></span><br><span class="line">        <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;     </span><br><span class="line">            <span class="comment">// //如果当前字符str[index]和pattern[index]相等，或者当前pattern为‘.’</span></span><br><span class="line">            <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;            </span><br><span class="line">                <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//模式后移2，视为x*匹配0个字符(当前pattern[index+1]='*'且str[index]!=pattern[index]）                    </span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//视为模式匹配1个字符 (当前pattern[i+1]='*'且str[index]=pattern[index])                   </span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配1个，再匹配str中的下一个（当前pattern[index]='.'）        </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">//当前字符str[index]和pattern[index]不相等&amp;&amp;当前pattern不为‘.’</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);        </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false  </span></span><br><span class="line">         <span class="comment">//pattern[index]='.'的情况，strindex和pattern都加1向下匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;        </span><br><span class="line">            <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【51】构建乘积数组</title>
      <link href="/2019/05/51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2019/05/51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。<strong>不能使用除法</strong>。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>题目的意思就是B[i] = A[0]*A[1]….*A[n-2]*A[n-1]  / A[i],但是题目要求不能用除法</p><p>创建一个left数组和一个rigth数组，拿n = 3为例               </p></blockquote><table><thead><tr><th>res[i]</th><th>left[0]*right[0]</th><th>left[1]*right[1]</th><th>left[2]*right[2]</th><th>left[3]*right[3]</th></tr></thead><tbody><tr><td>right数组</td><td>A[2]*A[1]*A[0]*1</td><td>A[1]*A[0]*1</td><td>A[0]*1</td><td>1</td></tr><tr><td>left数组</td><td>1</td><td>1*A[0]</td><td>1*A[0]*A[1]</td><td>1*A[0]*A[1]*A[2]</td></tr></tbody></table><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> []res = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> []left = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> []right = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            left[i] = A[i-<span class="number">1</span>]*left[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right[A.length-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>]*A[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            res[i] = left[i]*right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【50】数组中重复的数字</title>
      <link href="/2019/05/50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>在一个<strong>长度为n</strong>的数组里的所有数字都在<strong>0到n-1的范围</strong>内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>长度为n,数字都在[0,n-1]范围，可以利用桶排序的思想，将numbers[i]的个数存入相应的res索引下，当第一次桶里有2个numbers[i]时，直接返回即找到第一个数组里面的重复数字。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span> [length];</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">           res[numbers[i]]++;</span><br><span class="line">            <span class="comment">//有重复的数</span></span><br><span class="line">            <span class="keyword">if</span>(res[numbers[i]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">              duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">               flag = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【49】把字符串转换成整数</title>
      <link href="/2019/05/49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
      <url>/2019/05/49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<a id="more"></a></p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h6><p>输入一个字符串,包括数字字母符号,可以为空</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h6><p>如果是合法的数值表达则返回该数字，否则返回0</p><p>示例1：</p><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>+2147483647<br>    1a33</p><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><p>2147483647<br>    0</p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>(1) 首先判断第一个字符是符号‘ + ‘ 或者 ’ - ‘ 还是数字</p><p>(2) 首字母为 ’ + ‘，则设flag 为 1，计算[1,len)的数值</p><p>(3) 首字母为 ’  -  ‘，则设flag为-1，计算[1,len)的数值</p><p>(4) 首字母为数字，则计算[0,len)的数值</p><p>计算时有个是否溢出判断。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.trim().equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) ==<span class="string">'+'</span>||str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>) &#123;</span><br><span class="line">                flag = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = cal(str,<span class="number">1</span>,str.length(),flag);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum = cal(str,<span class="number">0</span>,str.length(),flag);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum*flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">int</span> <span class="title">cal</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end,<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span> &amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span> &amp;&amp; sum&gt;Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"上溢出"</span>);</span><br><span class="line">                <span class="keyword">if</span>(flag == -<span class="number">1</span> &amp;&amp; sum&lt;Integer.MIN_VALUE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"下溢出"</span>);</span><br><span class="line">                sum = sum*<span class="number">10</span>+str.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【48】不用加减乘除做加法</title>
      <link href="/2019/05/48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
      <url>/2019/05/48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>利用&amp;、|、^等运算</p><p>(1)定义一个sum和一个进位位carry，sum用来记录二进制的两位数无进位相加得到的值（num1^num2）,进位位carry用来记录需要向哪个位进位（num&amp;num2&lt;&lt;1）</p><p>(2)将得到的sum和carry重新赋值给num1和num2.循环的结束条件是进位位为0时终止。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//异或，相同为0不同为1 ,得到的结果相当于二进制的两个数无进位相加，         </span></span><br><span class="line">            <span class="comment">//相加为2的结果是0.如6和12相异或，即（0110^1100） = 1010</span></span><br><span class="line"></span><br><span class="line">            sum = num1 ^ num2;</span><br><span class="line">            <span class="comment">//num1&amp;num2得到该位数需要进位，即向前进位&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line">            carry = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 = sum;  </span><br><span class="line"></span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num2!=<span class="number">0</span>);  <span class="comment">//直到无进位结束</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【47】求1+2+...+n</title>
      <link href="/2019/05/47-%E6%B1%821-2-n/"/>
      <url>/2019/05/47-%E6%B1%821-2-n/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>1.需利用逻辑与的短路特性实现递归终止。 </p><p>2.当n==0时，(n&gt;0)&amp;&amp;((ans+=Sum_Solution(n-1))&gt;0)只执行前面的判断，不执行后面的递归了，使这条语句为false，并且不往上回溯，可以执行下面return的语句了。然后直接返回ans；</p><p>3.当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="keyword">boolean</span> flag = (ans &gt; <span class="number">0</span>) &amp;&amp; (ans += Sum_Solution(n - <span class="number">1</span>))&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【46】孩子们的游戏(圆圈中最后剩下的数)</title>
      <link href="/2019/05/46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/05/46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) <a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>模拟游戏过程</p><p>i一直记录的是小朋友自己最初的的位置[0,n-1]</p><p>step记录的是报数，报到m-1时array[i]这个小朋友出局，记-1，step重头计数。人数这时减1.</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span> ;  <span class="comment">//初始状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = n;  <span class="comment">//人数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count&gt;<span class="number">0</span>)&#123;  <span class="comment">//游戏开始</span></span><br><span class="line">            <span class="comment">//报数，其实报的一直都是自己的位置数，不是[0,m-1],而是[0,n-1]</span></span><br><span class="line"></span><br><span class="line">            i++; </span><br><span class="line">            <span class="comment">//假如有8人，报数范围是[0,7],轮询一圈后那么第一个人不报8而是报0 </span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=n)  </span><br><span class="line"></span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==-<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//标记为-1即出局，不遍历下边的了</span></span><br><span class="line"></span><br><span class="line">            step++;   <span class="comment">//step用来记录报数报到哪了</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(step==m-<span class="number">1</span>)&#123;  <span class="comment">//找到喊m-1的小朋友</span></span><br><span class="line"></span><br><span class="line">                array[i] = -<span class="number">1</span>; <span class="comment">//出局</span></span><br><span class="line"></span><br><span class="line">                step = -<span class="number">1</span>;     <span class="comment">//重头开始记录报数</span></span><br><span class="line"></span><br><span class="line">                count--;   <span class="comment">//人数减1</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【45】扑克牌顺子</title>
      <link href="/2019/05/45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/"/>
      <url>/2019/05/45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>组成顺子的条件是：</p><p>(1) 数组长度为5</p><p>(2)数组中数不重复</p><p>(3)最大值Max减最小值Min&lt;5,其中Max和Min不能为0,即不包括大小王的最大值最小值</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length&lt;<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> Max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> Min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> count[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">14</span>];</span><br><span class="line">        <span class="comment">//除0以外没有重复的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            count[numbers[i]]++;</span><br><span class="line">            <span class="comment">//如果是大小王的话，可以允许多个，直接continue不执行count[numbers[i]&gt;=2的判断,而且最大值最小值的判断也会跳过0</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count[numbers[i]]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(Max&lt;numbers[i]) &#123;</span><br><span class="line">                Max = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Min &gt;numbers[i])&#123;</span><br><span class="line">                Min = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( Max - Min &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【44】翻转单词顺序列</title>
      <link href="/2019/05/44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用str.split(“ ”) 去切分子字符串变成str[],然后再拼接。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)&#123; <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="comment">//去掉前后空格，避免输入字符串全是空格情况，保证后面的split切分正确</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(str.trim().equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        String res[] = str.split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder ss = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//第二个到最后一个数组值后面要加“ ” </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = res.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ss.append(res[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个就是数组末尾了不需要加“ ”，保持反转后的数组长度跟原来一样</span></span><br><span class="line"></span><br><span class="line">        ss.append(res[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ss.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【43】左旋转字符串</title>
      <link href="/2019/05/43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/05/43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>两个子字符串 拼接就行了。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(n&gt;str.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> str.substring(n,str.length())+str.substring(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【42】和为s的两个数字</title>
      <link href="/2019/05/42-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/42-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h6><p>对应每个测试案例，输出两个数，小的先输出。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>将数组的数值依次放入list里面，每次放入之前查询list里面是否有（sum-array[i]），如果有,再判断两数乘积是否比之前存的两数乘积小，如果判断成功，则将这两个数放到index1和index2中。最后将这两个index放到list里面返回。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ss = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> Min_ = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//index1用于存放比较小的那个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//index2用于存放比较大的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(sum-array[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Min_&gt;(sum-array[i])*array[i])&#123;</span><br><span class="line">                    Min_ = (sum-array[i])*array[i];</span><br><span class="line">                    index1 = array[i]&lt;(sum-array[i])?</span><br><span class="line">                                           array[i]:(sum-array[i]);</span><br><span class="line"></span><br><span class="line">                    index2 = sum-index1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index1!=<span class="number">0</span>||index2!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">               ss.add(index1);</span><br><span class="line">               ss.add(index2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【41】和为S的连续正数序列</title>
      <link href="/2019/05/41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>滑动窗口移动方法</p><p>(1) 求出滑动窗口的累加和，公式为等差数列求和公式</p><p>(2)如果累加和等于sum,则将该滑动窗口内的数存到一个list里面，并右移动左指针</p><p>(3)如果累加和小于sum,则右移动右指针，加数进来</p><p>(4)如果累加和大约sum，则左指针右移动，减数出去</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小</span></span><br><span class="line">        <span class="keyword">int</span> plow = <span class="number">1</span>,phigh = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(phigh &gt; plow)&#123;</span><br><span class="line">            <span class="comment">//由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2</span></span><br><span class="line">            <span class="keyword">int</span> cur = (phigh + plow) * (phigh - plow + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//相等，那么就将窗口范围的所有数添加进结果集</span></span><br><span class="line">            <span class="keyword">if</span>(cur == sum)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=plow;i&lt;=phigh;i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                plow++;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和小于sum，那么右边窗口右移一下</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; sum)&#123;</span><br><span class="line">                phigh++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和大于sum，那么左边窗口右移一下</span></span><br><span class="line">                plow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【40】数组中只出现一次的数字</title>
      <link href="/2019/05/40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>将数组依次放到list里面，如果list里面含有准备要进去的数值，则remove掉，剩下的两个数组即为该数组中只出现过一次的数字</p></blockquote><p>list.remove要用(Object object)方法而不是list.remove(int index);</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">         ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(array[i]))&#123;</span><br><span class="line">            <span class="comment">//这里remove掉的是里面的数array[i]，而不是array[i]索引对应的数</span></span><br><span class="line"></span><br><span class="line">                res.remove(Integer.valueOf(array[i]));</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = res.get(<span class="number">0</span>);</span><br><span class="line">        num2[<span class="number">0</span>] = res.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【39】平衡二叉树</title>
      <link href="/2019/05/39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>预备知识：平衡二叉树是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>思想：从根节点开始，先判断左右子树的高度差是否超过1，然后接着判断左右子树是否是平衡二叉树。这边用到了递归思想。</p><p>代码如下：</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span>) &#123; <span class="comment">//一棵空树就是平衡二叉树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( Math.abs(getDepth(root.left)  - getDepth(root.right)) &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="comment">//满足左右子树高度差小于等于1,那就接着判断左右子树是不是二叉树</span></span><br><span class="line">            <span class="keyword">return</span> (IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不满足左右子树高度差小于等于1,那这棵树肯定不是平衡二叉树啦</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归求二叉树深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> ( left &gt; right ? left : right ) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【38】二叉树的深度</title>
      <link href="/2019/05/38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
      <url>/2019/05/38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><a id="more"></a></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>①如果一棵树只有一个结点，它的深度为1。</p><p>②如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。</p><p>③如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//----递归求二叉树深度----</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> (left&gt;right)?(left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【37】数字在排序数组中出现的次数</title>
      <link href="/2019/05/37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2019/05/37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>统计一个数字在<strong>排序数组</strong>中出现的次数。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>排序数组嘛，找到数组里面第一个等于k的，一直res++直到数组值不等于k。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(array[i] == k)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【36】两个链表的第一个公共结点</title>
      <link href="/2019/05/36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入两个链表，找出它们的第一个公共结点。 <a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>两个链表有公共点，考虑Y型的两链表相连，先计算出两个链表的长度，然后长的链表先走差值步，之后同步走，当遇到cur1==cur2时说明两链表相遇。直接返回即可。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode cur1 = head1;</span><br><span class="line">            ListNode cur2 = head2;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//得到差值步（head1.length-head2.length）</span></span><br><span class="line">            <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相交为Y型则最后一个结点应该相同</span></span><br><span class="line">            <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">            n = Math.abs(n);<span class="comment">//差值步</span></span><br><span class="line">            <span class="comment">//走差值步</span></span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相等时则为相交点</span></span><br><span class="line">            <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>争吵问题.md</title>
      <link href="/2019/05/%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md/"/>
      <url>/2019/05/%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h5><p>有一个队列，每个人要么朝左边（L表示）,要么朝右边(R表示)，因为每个人都讨厌其他任何人，只要两人面对面就会发生争吵。争吵结果是胜者留在队列中，败的人移除队中。如果序列中有多对争吵，可以任选一对，胜者留在队中，败者出局，求最后队列最少人数是多少。<a id="more"></a></p><p>例子：</p><p>LRRLRL</p><p>输出：2</p><p><strong>Hint</strong></p><p>一种可能的变化情况是：LRRLRL -&gt; LRLRL -&gt; LRRL -&gt; LRL -&gt; LR</p><h5 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h5><p>由题意可知，如果真的吵架就只有RL（两人面对面）情况，像LL,RR,LR就不会争吵。</p><ul><li><p>如果吵架前面是R，则吵架结果应该是L胜利.</p></li><li><p>如果吵架前面是L，则吵架结果为R胜利</p></li></ul><h5 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String arr =<span class="string">"LRRLRL"</span>;</span><br><span class="line">        String res = solut(arr);</span><br><span class="line">        System.out.println(res.length());</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String  <span class="title">solut</span><span class="params">(String arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取第一次争吵得到的结果</span></span><br><span class="line">       String str = solution(arr);</span><br><span class="line">       <span class="comment">//如果还存在第二次争吵，则继续，否则得到结果</span></span><br><span class="line">        <span class="keyword">while</span> (str.contains(<span class="string">"RL"</span>))&#123;</span><br><span class="line">            str = solution(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">solution</span><span class="params">(String arr)</span></span>&#123;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//争吵</span></span><br><span class="line">            <span class="keyword">if</span>(arr.charAt(i)==<span class="string">'R'</span>&amp;&amp;arr.charAt(i+<span class="number">1</span>)==<span class="string">'L'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(<span class="string">'R'</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.get(list.size()-<span class="number">1</span>)==<span class="string">'L'</span>) &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        list.add(<span class="string">'R'</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        list.add(<span class="string">'L'</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有争吵，下一次争吵中还有该人</span></span><br><span class="line">                list.add(arr.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将list转换成String</span></span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            str = str+list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试题 </tag>
            
            <tag> 讯飞科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【34】第一个只出现一次的字符位置</title>
      <link href="/2019/05/34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE/"/>
      <url>/2019/05/34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>1.用两个list,一个list用来存放只出现一次的字符，一个用来存放出现多次的字符</p><p>2.依次遍历str里面的字符，如果list1和list2里面都没有，则说明这个字符是第一次出现，将其添加到list1，否则说明之前出现过该字符，将其移除list1并添加到list2里面</p><p>3.最后判断list里面是否有值，有则返回list里面的第一个值在str出现的第一次的位置，即为第一次出现的字符位置。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str.length() == <span class="number">0</span> || str == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//list1存放str中出现1次的字符</span></span><br><span class="line">       ArrayList&lt;Character&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">        <span class="comment">//list2用来存放多次出现的字符</span></span><br><span class="line">       ArrayList&lt;Character&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">           <span class="comment">//两个list里面都没有这个字符</span></span><br><span class="line">           <span class="keyword">if</span> (!list1.contains(ch) &amp;&amp; !list2.contains(ch)) &#123;</span><br><span class="line">               <span class="comment">//将字符放到list1中</span></span><br><span class="line">               list1.add(Character.valueOf(ch));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//将list1之前加入的删掉（此时出现了相同字符，删掉相同字符）</span></span><br><span class="line">               list1.remove(Character.valueOf(ch));</span><br><span class="line">               <span class="comment">//将str中含有的相同字符存入list2</span></span><br><span class="line">               list2.add(Character.valueOf(ch));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (list1.size() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> str.indexOf(list1.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【35】数组中的逆序对</title>
      <link href="/2019/05/35.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2019/05/35.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<a id="more"></a></p><p>题目保证输入的数组中没有的相同的数字</p><p>数据范围：</p><ol><li><p>对于%50的数据,size&lt;=10^4 </p></li><li><p>对于%75的数据,size&lt;=10^5</p></li><li><p>对于%100的数据,size&lt;=2*10^5</p></li></ol><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><pre><code>数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；</code></pre><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>方法1：暴力破解:时间超时</p><p>考察每一位，判断从这一位往后有多少小于该位的，结果累加，得到最后结果。</p><p>方法2：归并算法</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1(超时)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []array=&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> num=InversePairs(array);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;array.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i]&gt;array[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = InversePairsCore(array,copy,<span class="number">0</span>,array.length-<span class="number">1</span>);<span class="comment">//数值过大求余</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">int</span> <span class="title">InversePairsCore</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] copy,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low==high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftCount=</span><br><span class="line">                   InversePairsCore(array,copy,low,mid)%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightCount = </span><br><span class="line">                InversePairsCore(array,copy,mid+<span class="number">1</span>,high)%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=mid;</span><br><span class="line">        <span class="keyword">int</span> j=high;</span><br><span class="line">        <span class="keyword">int</span> locCopy = high;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=low&amp;&amp;j&gt;mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                count += j-mid;</span><br><span class="line">                copy[locCopy--] = array[i--];</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">1000000007</span>)<span class="comment">//数值过大求余</span></span><br><span class="line">                &#123;</span><br><span class="line">                    count%=<span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                copy[locCopy--] = array[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=low;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[locCopy--]=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;mid;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[locCopy--]=array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=low;s&lt;=high;s++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[s] = copy[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (leftCount+rightCount+count)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【33】丑数</title>
      <link href="/2019/05/33-%E4%B8%91%E6%95%B0/"/>
      <url>/2019/05/33-%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an</p><p>所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2<em>a1, 2</em>a2, 2*a3 …..</p><p>包含3的有序丑数序列:3<em>a1, 3</em>a2, 3<em>a3 ….. 包含5的有序丑数序列:5</em>a1, 5<em>a2, 5</em>a3 …..</p><p>以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr=<span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//第一个丑数为1，放入数组的第一个元素</span></span><br><span class="line">        <span class="keyword">int</span> t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t3=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//寻找3个序列中最小的那个数</span></span><br><span class="line">          arr[i]=Math.min(arr[t2]*<span class="number">2</span>,Math.min(arr[t3]*<span class="number">3</span>,arr[t5]*<span class="number">5</span>));</span><br><span class="line">            <span class="comment">//最小的那个数的序列值加1</span></span><br><span class="line">            <span class="keyword">if</span>(arr[t2]*<span class="number">2</span>==arr[i])</span><br><span class="line">                t2++;</span><br><span class="line">            <span class="keyword">if</span>(arr[t3]*<span class="number">3</span>==arr[i])</span><br><span class="line">                t3++;</span><br><span class="line">            <span class="keyword">if</span>(arr[t5]*<span class="number">5</span>==arr[i])</span><br><span class="line">                t5++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[index-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【32】把数组排成最小的数</title>
      <link href="/2019/05/32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2019/05/32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>方法1：</p><p>(1) 求出数组里面最大的数的位数，然后其他的数位数不够的进行补位</p><p>(2) 补位原则：如数组{3,32,321},最大位数为3，所以3进行补位变成333，补的两位为str[i]数组里面的最后一个charAt[str[i].length()-1];所以32补位变成322</p><p>(3) 对数组{333，322，321}进行从小到大排序，然后根据索引把字符串拼接即可得到答案。即从小到大排序为{321，322，333}，这三个数对应原数组的{321，32，3}，最后答案即为321323.</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(numbers.length&lt;=<span class="number">0</span>||numbers == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//排序，可得到最大的数为numbers[len-1]</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="comment">//求位数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Max_ = numbers[numbers.length-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//得到最大的数的位数</span></span><br><span class="line">        <span class="keyword">while</span>(Max_&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            Max_ = Max_/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数组变成字符串数组</span></span><br><span class="line">        String str[] = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            str[i] = <span class="string">""</span>+numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//补位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="comment">//得到补位要填充的数</span></span><br><span class="line">            String tmp =<span class="string">""</span> +str[i].charAt(str[i].length()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//原数组的位数</span></span><br><span class="line">            <span class="keyword">int</span> len =str[i].length(); </span><br><span class="line">            <span class="comment">//补足到相同的位数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;count-len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                str[i] = str[i]+tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ss= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//该数组的索引对应着numbers的索引</span></span><br><span class="line">        String strcopy[] = str.clone();</span><br><span class="line">        <span class="comment">//将其进行从小到大的排序</span></span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        <span class="comment">//得到从小到大排序后原数组所在的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;numbers.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i].equals(strcopy[j]))&#123;</span><br><span class="line">                    ss.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将索引进行拼接得到结果</span></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            res = res +numbers[ss.get(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【31】整数中1出现的次数</title>
      <link href="/2019/05/31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2019/05/31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>方法1：</p><p>将每个数变成string,然后将string里面的1替换成”“,长度的减少就是这个string里面1的个数，但是这个方法中String是不可变字符串，故占用内存过多。</p></li><li><p>方法2：</p><p>依次计算出每个数中包含1的个数</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       String s = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           s = i+<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">           count += s.length()-s.replaceAll(<span class="string">"1"</span>, <span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">               sum+=NumberOf1(i);</span><br><span class="line">           <span class="keyword">return</span> sum;</span><br><span class="line">       &#125;    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">10</span>==<span class="number">1</span>)<span class="comment">//求余</span></span><br><span class="line">            &#123;</span><br><span class="line">               count++; </span><br><span class="line">            &#125;</span><br><span class="line">            n=n/<span class="number">10</span>;     </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【30】连续子数组的最大和</title>
      <link href="/2019/05/30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2019/05/30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？<a id="more"></a>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。</p><ul><li><p>当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令cur = 0.表示从下一个数开始累加。</p></li><li><p>当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最大值即可。</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                cur += array[i];</span><br><span class="line">                res = Math.max(res,cur);</span><br><span class="line">                cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【29】最小的K个数</title>
      <link href="/2019/05/29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/05/29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>排序问题，本次使用快排，快排思想即：</p><p>“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input.length&lt;k)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        quicksort(input, <span class="number">0</span>, input.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> position = partition(arr, low, high);</span><br><span class="line">            quicksort(arr, low, position - <span class="number">1</span>);</span><br><span class="line">            quicksort(arr, position + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//设置基准值</span></span><br><span class="line">            <span class="keyword">int</span> key = arr[low];</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="comment">//从右到左，直到找到一个小于key的值</span></span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= key) --high;</span><br><span class="line">                <span class="comment">//将该值填入前的坑</span></span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                <span class="comment">//从左到右，直到找到一个大于key的值</span></span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= key) ++low;</span><br><span class="line">                <span class="comment">//将该值填入前一个坑</span></span><br><span class="line">                arr[high] = arr[low];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将基准值填入最后一个坑</span></span><br><span class="line">            arr[low] = key;</span><br><span class="line">            <span class="comment">//最后一个坑划分了左边小于该值，右边大于该值</span></span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【28】数组中出现次数超过一半的数字</title>
      <link href="/2019/05/28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>利用一个hashmap用来存储数组里面每个数出现的次数，然后遍历map，比较每个数的value是否超过数组的一半</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">            HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(array[i]))&#123;</span><br><span class="line">                    map.put(array[i],map.get(array[i])+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(array[i],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(entry.getValue()&gt;array.length/<span class="number">2</span>)</span><br><span class="line">                        res = entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【27】字符串的排列</title>
      <link href="/2019/05/27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2019/05/27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>算法思路：（递归实现）<br>(1)n个元素的全排列=（n-1个元素的全排列）+（另一个元素作为前缀）；<br>(2)出口：如果只有一个元素的全排列，则说明已经排完，则输出数组；</p><p>(3)不断将每个元素放作第一个元素，然后将这个元素作为前缀，并将其余元素继续全排列，等到出口，出口出去后还需要还原数组； </p><p>以字符串abc为例：</p><ul><li>a 作为开头 -&gt; 求 bc 全排列 -&gt; 得到 bc 和 cb -&gt; 与 a 合并 -&gt; 得到 abc 和 acb</li><li>b 作为开头 -&gt; 求 ac 全排列 -&gt; 得到 ac 和 ca -&gt; 与 b 合并 -&gt; 得到 bac 和 bca</li><li>c 作为开头 -&gt; 求 ab 全排列 -&gt; 得到 ab 和 ba -&gt; 与 c 合并 -&gt; 得到 cab 和 cba</li></ul></blockquote><ol><li><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//用于排序输出</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将字符串转化成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">//从第0个字符开始全排列      </span></span><br><span class="line">        res=Permu(chars,<span class="number">0</span>,res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permu</span><span class="params">(<span class="keyword">char</span>[] str,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> start, ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置递归的出口,即当需要全排列的范围只有一个元素，则全排结束</span></span><br><span class="line">        <span class="keyword">if</span> (start == str.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//去除重复的字符串</span></span><br><span class="line">            <span class="keyword">if</span> (list.contains(String.valueOf(str))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(String.valueOf(str));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//for循环将start~len-1每一个数放到start位置中去，并实现全排列</span></span><br><span class="line">            <span class="comment">//str[start]-----str[len-1]的全排列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; str.length; j++) &#123;</span><br><span class="line">                <span class="comment">//取出第j个字符作为第一个字符</span></span><br><span class="line">                swap(str,j,start);</span><br><span class="line">                <span class="comment">//求出str[start+1]----str[len-1]的全排列</span></span><br><span class="line">                Permu(str, start+ <span class="number">1</span>, list);</span><br><span class="line">                <span class="comment">//恢复原数组</span></span><br><span class="line">                swap(str,j,start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成字典序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;<span class="comment">//因为会出现原位置与原位置交换，直接空即可</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[a];</span><br><span class="line">            chars[a]=chars[b];</span><br><span class="line">            chars[b]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【26】二叉搜索树与双向链表</title>
      <link href="/2019/05/26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/05/26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个<strong>排序</strong>的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<a id="more"></a></p><p>二叉树如</p><pre><code>             10         /        \      6            14   /     \       /      \4         8    12        16</code></pre><p>转化成双向链表    4 <----> 6  <----> 8  <----> 10  <---->12 <---->14<---->16</----></----></----></----></----></----></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>(1)二叉搜索树中，每个结点都有两个分别指向其左、右子树的指针，左子树结点的值总是小于父结点的值，右子树结点的值总是大于父结点的值。</p><p>(2)双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。所以这两种数据结构的结点是一致<br>    为了减少指针的变换次数，并让操作更加简单，在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。</p><p>链表是有序的，可以借助二叉树<strong>中序遍历</strong>，因为中序遍历算法的特点就是从小到大访问结点。当遍历访问到根结点时，假设根结点的左侧已经处理好，只需将根结点与上次访问的最近结点（左子树中最大值结点）的指针连接好即可。进而更新当前链表的最后一个结点指针。同时中序遍历过程正好是转换成链表的过程，可采用递归方法处理</p><p>思想：<em>把左子树、右子树都转换成排序的双向链表之后在和根结点链接起来，整个二叉树也变成了排序的双向链表。</em></p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="comment">//假如根节点为空，返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;<span class="comment">//假如只有一个根节点，则返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1、将左子树构造成双链表，并返回该链表头结点left</span></span><br><span class="line">    TreeNode left=Convert(root.left);</span><br><span class="line">    <span class="comment">//2、定位到左子树链表的最后一个节点（左子树最右边的节点）</span></span><br><span class="line">    <span class="comment">//创建一个临时节点P,用来遍历找到左链表的最后一个节点(左子树最右边的节点)，p初始化指向做左子树的根节点，</span></span><br><span class="line">    TreeNode p=left;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//最终p为左子树最右边的节点</span></span><br><span class="line">        p=p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、如果左子树链表不为空，将当前root追加到左子树链表后 </span></span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="keyword">null</span>)&#123;<span class="comment">//左子树链表不为空</span></span><br><span class="line">       <span class="comment">//左子树链表的最后一个节点p（左子树最右边节点）的右指针指向当前root节点</span></span><br><span class="line">        p.right=root;</span><br><span class="line">       <span class="comment">//当前root节点的左指针指向左子树链表的最后一个节点p（左子树最右边节点）</span></span><br><span class="line">        root.left=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、将右子树构造成双链表，并返回该链表的头结点right</span></span><br><span class="line">    TreeNode right=Convert(root.right);</span><br><span class="line">    <span class="comment">//5、如果右子树链表不为空，将右子树链表追加到当前root后</span></span><br><span class="line">    <span class="keyword">if</span>(right!=<span class="keyword">null</span>)&#123;<span class="comment">//右子树链表不为空</span></span><br><span class="line">        right.left=root;<span class="comment">//右子树链表的头结点right的左指针指向当前root</span></span><br><span class="line">        root.right=right;<span class="comment">//当前root的右指针指向右子树链表的头结点right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left!=<span class="keyword">null</span>?left:root;<span class="comment">//根据左子树链表是否为空返回整个双向链表的头指针。    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【25】复杂链表的复制</title>
      <link href="/2019/05/25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/05/25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode head = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">        RandomListNode ans = head;</span><br><span class="line">        <span class="keyword">if</span> (pHead.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.random = <span class="keyword">new</span> RandomListNode(pHead.random.label);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">            head.next = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">            <span class="keyword">if</span> (pHead.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                head.next.random = <span class="keyword">new</span> </span><br><span class="line">                                RandomListNode(pHead.random.label);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomListNode currentNode = pHead;</span><br><span class="line">        <span class="comment">//1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123; </span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(currentNode.label);</span><br><span class="line">            RandomListNode nextNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode;</span><br><span class="line">            cloneNode.next = nextNode;</span><br><span class="line">            currentNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        <span class="comment">//2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode.next.random = currentNode.random==<span class="keyword">null</span>?<span class="keyword">null</span>:currentNode.random.next;</span><br><span class="line">            currentNode = currentNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode.next;</span><br><span class="line">            cloneNode.next = cloneNode.next==<span class="keyword">null</span>?<span class="keyword">null</span>:cloneNode.next.next;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【24】二叉树中和为某值的路径</title>
      <link href="/2019/05/24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/05/24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一棵二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>整个过程可以采用先序遍历方式的DFS，即根节点—–&gt;左子树—–&gt;右子树。 </p><blockquote><p>随后考虑一次遍历完成后的处理，</p><p>(1)当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点；</p><p>(2)如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。 </p><p>(3)考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 </p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个类型为ArrayList&lt;Integer&gt;的list</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathlist=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//创建一个list,用于存放遍历的值</span></span><br><span class="line">    ArrayList&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果树为空，则返回空的pathlist</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> pathlist;</span><br><span class="line">        <span class="comment">//将root值放入list</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//如果根的左子树、右子树、目标值=根值，则返回path</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>&amp;&amp;target==root.val)</span><br><span class="line">        &#123;</span><br><span class="line">            pathlist.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此时根值小于目标值并且含有左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;=target&amp;&amp;root.left!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//将遍历左子树，将根设为左子树并且此时的target=target-遍历过的root值</span></span><br><span class="line">            FindPath(root.left,target-root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此时根值小于目标值并且含有右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;=target&amp;&amp;root.right!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//将遍历右子树，将根设为右子树并且此时的target=target-遍历过的root值</span></span><br><span class="line">            FindPath(root.right,target-root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不论路径的值是否等于输入整数值，都要回退，</span></span><br><span class="line">        <span class="comment">//即使用remove函数移除路径上的最后一个节点。</span></span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pathlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【23】二叉搜索树的后序遍历序列</title>
      <link href="/2019/05/23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>二叉搜索树后序遍历为：左子树—-&gt;右子树—-&gt;根，且左子树值&lt;根值&lt;右子树值</p><blockquote><p>如二叉搜索树：</p><pre><code>           10        /       \    6              12 /    \           /   \3      7        11     20</code></pre><p>后序遍历结果为：3   7    6   11  20   12  10</p><p>对于一个数组sequence，最后一个元素是sequence[len-1] （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于sequence[len-1] ，后一段（右子树）大于sequence[len-1] ，且这两段（子树）都是合法的后序序列 </p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span>||sequence.length&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=sequence.length;  <span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">int</span> root=sequence[len-<span class="number">1</span>];  <span class="comment">//数组的最后一个数为根</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root&lt;=sequence[i])   <span class="comment">//左子树的数值都小于根</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的j即为划分出来的左子树部分和右子树部分的分界</span></span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=len-<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">       <span class="comment">//j到len-1都都为右子树，数值都大于root,如果root大于他们，则返回false</span></span><br><span class="line">            <span class="keyword">if</span>(root&gt;sequence[j])  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断左子树</span></span><br><span class="line">        <span class="keyword">boolean</span> leftflag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           leftflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,<span class="number">0</span>,i));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断右子树</span></span><br><span class="line">        <span class="keyword">boolean</span> rightflag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;len-<span class="number">1</span>) &#123;</span><br><span class="line">            rightflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,sequence.length-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftflag &amp;&amp; rightflag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【22】从上到下打印二叉树</title>
      <link href="/2019/05/22-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/22-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>使用两个队列一个存放节点treelist，一个存放值intlist。</p><blockquote><p>先将根节点root加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来,并将root值存入intlist,遍历结束条件是i值到达treelist.size-1</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//创建一个列表用来存储节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; treelist=<span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; intlist=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)  <span class="comment">//没有节点</span></span><br><span class="line">            <span class="keyword">return</span> intlist;</span><br><span class="line">        <span class="comment">//1.先存入根节点</span></span><br><span class="line">        treelist.add(root);</span><br><span class="line">        <span class="comment">//2.循环遍历列表，一开始列表里存了root</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;treelist.size();i++)</span><br><span class="line">        &#123; </span><br><span class="line">            TreeNode node=treelist.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.如果左子节点不为空，则将节点加入列表</span></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                treelist.add(node.left);</span><br><span class="line">            <span class="comment">//3、如果右子节点不为空，则将右子节点加入到列表中，这时列表的size加1</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                treelist.add(node.right);</span><br><span class="line"></span><br><span class="line">            intlist.add(node.val);</span><br><span class="line">            <span class="comment">//4、因为执行上面操作后会增加列表的size</span></span><br><span class="line">            <span class="comment">//因此可以继续循环下一个节点，直到循环完所有节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intlist;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【21】栈的压入、弹出</title>
      <link href="/2019/05/21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA/"/>
      <url>/2019/05/21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>依次入栈pushA数组中的数,直到pushA[i] =popA[index],此时将栈顶这个相等的值弹出。</p></li><li><p>判断栈中是否还有值，如果没有返回true,如果有并且index！=popA.length,依次弹出栈中数值，并与popA[index++]比较,两个不相等返回false,到栈为空时没执行false则返回true</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//用于pushA入栈</span></span><br><span class="line">           Stack&lt;Integer&gt; a = <span class="keyword">new</span> Stack();</span><br><span class="line">           <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">               a.push(pushA[i]);</span><br><span class="line">               <span class="comment">//当遇到与popA[index]相等的数时，弹出该数</span></span><br><span class="line">               <span class="keyword">if</span>(pushA[i] == popA[index])&#123;</span><br><span class="line">                   <span class="keyword">if</span>(index++ == popA.length-<span class="number">1</span>)&#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   a.pop();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//栈中还有值，index还没到达popA尾部，依次弹出与popA比较</span></span><br><span class="line">           <span class="keyword">while</span> (!a.isEmpty())&#123;</span><br><span class="line">               <span class="keyword">if</span>(a.pop()!=popA[index++])&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【20】包含min函数的栈</title>
      <link href="/2019/05/20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2019/05/20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>解题思路：利用辅助栈来存储现有栈的最小值。在入栈和出栈的时候将现有栈和最小值栈进行比较。<br>(1)入栈时，若新值比最小值栈的栈顶还小，则将该值同时push到最小值栈；  (2)出栈时，若现有栈的栈顶和最小值栈栈顶一致，则同时出栈，<br>(3)否则，仅仅现有栈pop；通过这一操作，最小值栈的栈顶将永远是现有栈元素中的最小值。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于存储所有的数据，压入push,弹出pop</span></span><br><span class="line">        Stack&lt;Integer&gt; data_stack =<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储栈最小的值</span></span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; min_stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果最小值栈为空或者栈顶值比新入的node值大</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(min_stack.isEmpty()||min_stack.peek()&gt;=node)&#123;</span><br><span class="line">                <span class="comment">//压入node，保持栈顶为栈的最小值</span></span><br><span class="line"></span><br><span class="line">                min_stack.push(node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则再次压入栈顶值</span></span><br><span class="line"></span><br><span class="line">                min_stack.push(min_stack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数据都压入data_stack</span></span><br><span class="line"></span><br><span class="line">            data_stack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出栈</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data_stack.empty()||min_stack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出数据</span></span><br><span class="line"></span><br><span class="line">            data_stack.pop();</span><br><span class="line">            <span class="comment">//弹出min栈顶，此时min_stack的栈顶为弹出某数剩下数的最小值</span></span><br><span class="line"></span><br><span class="line">            min_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看栈的栈顶元素</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!data_stack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> data_stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看最小的元素，即min_stack的栈顶</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!min_stack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>stack.peek:获取栈顶元素，返回栈顶元素但是不移除它</p><p>stack.add:向栈中添加元素，成功返回true</p><p>stack.push:向栈中添加元素，返回结果是当前添加的元素</p><p>stack.pop:移除并返回栈顶元素</p><p>stack.isEmpty:检查是否为空栈</p><p>stack.search(“value”):查看某元素再栈中的位置，计算从1开始</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【19】顺时针打印矩阵</title>
      <link href="/2019/04/19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/04/19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>打印分为四步：循环的次数即打印的圈速，即</p><p>  rows&gt;start*2&amp;&amp;column&gt;start*2</p><p>(1) 从左到右打印一行:</p><p>  开始于[start,start]，结束于[start,col-start-1]</p><p>(2) 从上到下打印一行,               </p><p>开始于[start+1,col-start-1],结束于[col-start-1,col-start-1]</p><p>(3) 从右到左打印一行</p><p> 开始于[col-start-1,col-start-2],结束于[col-start-1,start]</p><p>(4) 从下到上打印一行</p><p> 开始于[col-start-2,start],结束于[start+1,start]</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 矩阵行数     </span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;      </span><br><span class="line">        <span class="comment">// 矩阵列数    </span></span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;        </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();        </span><br><span class="line">      <span class="comment">// 让循环继续的条件是当前行数大于该圈循环开始的行数的两倍以及当前列数大于</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//该圈循环开始的列数的两倍（每圈循环开始的行数、列数相同）     </span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从(0,0)开始循环,圈数：start=0第一圈，start=1第二圈...以此类推    </span></span><br><span class="line">        <span class="keyword">while</span> (rows &gt; start * <span class="number">2</span> &amp;&amp; columns &gt; start * <span class="number">2</span>)&#123;         </span><br><span class="line">            <span class="comment">// 每一圈最后一行下标           </span></span><br><span class="line">            <span class="keyword">int</span> endRow = rows - <span class="number">1</span> - start;</span><br><span class="line">            <span class="comment">// 每一圈最后一列下标           </span></span><br><span class="line">            <span class="keyword">int</span> endColumn = columns - <span class="number">1</span> - start;           </span><br><span class="line">   <span class="comment">// 开始一圈圈打印，每打印一圈分为四步，从左到右、从上到下、从右到左、从下到上           </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左到右，第一步一定会走        </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endColumn; i++)            </span><br><span class="line">                list.add(matrix[start][i]);</span><br><span class="line">            <span class="comment">// 从上到下，最后一行大于开始行          </span></span><br><span class="line">            <span class="keyword">if</span> (endRow &gt; start)&#123;            </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endRow; i++)                   </span><br><span class="line">                    list.add(matrix[i][endColumn]);        </span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="comment">// 从右到左，最后一行大于开始行，最后一列大于开始列        </span></span><br><span class="line">            <span class="keyword">if</span> (endRow &gt; start &amp;&amp; endColumn &gt; start)&#123;            </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endColumn - <span class="number">1</span>; i &gt;= start; i--)                </span><br><span class="line">                    list.add(matrix[endRow][i]);           </span><br><span class="line">            &#125;          </span><br><span class="line">    <span class="comment">// 从下到上,至少是三行两列，也就是最后一行大于开始行加2，最后一列大于开始列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endRow &gt;= start + <span class="number">2</span> &amp;&amp; endColumn &gt; start)&#123;               </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endRow - <span class="number">1</span>; i &gt; start; i--)                </span><br><span class="line">                    list.add(matrix[i][start]);        </span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="comment">// 继续打印下一圈         </span></span><br><span class="line">            start++;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【18】二叉树的镜像</title>
      <link href="/2019/04/18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2019/04/18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像。<a id="more"></a></p><p>二叉树的镜像定义：</p><pre><code>        8     /      \   6         10 /   \     /    \5     7    9     11   </code></pre><p>镜像二叉树</p><pre><code>           8       /       \    10             6  /    \         /    \11      9       7       5</code></pre><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>(1)镜像即左右子树交换位置，故交换左子树右子树位置</p><p>(2)交换后的左右子树的节点保持原来的顺序，故要交换左右子树自己的左右子树</p><p>(3)终止条件为root==null || root.left==null ||root.right == null</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   int val = 0;</span></span><br><span class="line"><span class="comment">   TreeNode left = null;</span></span><br><span class="line"><span class="comment">   TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">   this.val = val;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(root!=<span class="keyword">null</span>&amp;&amp;(root.left!=<span class="keyword">null</span>||root.right!=<span class="keyword">null</span>))&#123;</span><br><span class="line">              <span class="comment">//这三句是左子树跟右子树交换</span></span><br><span class="line">              TreeNode tem=root.left;  </span><br><span class="line"></span><br><span class="line">              root.left=root.right;</span><br><span class="line">              root.right=tem;</span><br><span class="line">              <span class="comment">//然后将根节点换成root.left</span></span><br><span class="line"></span><br><span class="line">              Mirror(root.left);</span><br><span class="line">              <span class="comment">//然后将根节点换成root.right</span></span><br><span class="line"></span><br><span class="line">              Mirror(root.right);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【17】树的子结构</title>
      <link href="/2019/04/17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2019/04/17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>大体思路是首先判断B的根节点和A的根节点是否相同（这里的相同是指节点的值相同并且左右子节点相同），如果相同比较他们的左右子节点，这一步骤是相同的，可以用递归完成，直到B遍历到每个尾节点，如果这一过程比较的所有节点是相同的，则证明B是A的子结构。如果B的根节点和A的根节点不同，则A向他的左右子节点滑动，然后继续跟B的子节点比较，步骤同上。 </p><pre><code>(1) 如果root1.val==root2.val,那个就以这个为起点判断是否A包含B (2) 如果没找到，就以root1.left作为起点继续判断A是否包含B(3) 如果没找到，再以root1.right作为起点判断A是否包含B</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">          <span class="keyword">if</span> (root2 != <span class="keyword">null</span> &amp;&amp; root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//如果找到了对应Tree2的根节点的点</span></span><br><span class="line">              <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                  <span class="comment">//以这个根节点为为起点判断是否包含Tree2</span></span><br><span class="line">                  result = doesTree1HaveTree(root1,root2);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                  result = HasSubtree(root1.left,root2);</span><br><span class="line">              &#125;</span><br><span class="line">        <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                  result = HasSubtree(root1.right,root2);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//返回结果</span></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doesTree1HaveTree</span><span class="params">(TreeNode node1, TreeNode node2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;        <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">          <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">          <span class="keyword">if</span> (node1.val != node2.val) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">          <span class="keyword">return</span> doesTree1HaveTree(node1.left,node2.left) &amp;&amp;  </span><br><span class="line">                 doesTree1HaveTree(node1.right,node2.right);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【16】合并两个排序的链表</title>
      <link href="/2019/04/16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<a id="more"></a></p><p>例：</p><pre><code>链表1：  1  ----&gt;  3  ----&gt;  5  ----&gt; 8链表2：  2  ----&gt;  4 ----&gt;   6 ----&gt;  7</code></pre><p>合并结果：</p><pre><code>1 ----&gt; 2 ----&gt; 3 ----&gt; 4 ----&gt; 5 ----&gt; 6 ----&gt; 7  ----&gt; 8</code></pre></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>判断有没有ListNode是空的，如果有则返回另一个</p></li><li><p>递归实现，如果List1.val&lt;list2.val,pMergeHead = list1,否则pMergeHead = list2，递归直到两个ListNode都为空</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pMergeHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">            pMergeHead = list1;</span><br><span class="line">            pMergeHead.next = Merge(list1.next,list2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pMergeHead = list2;</span><br><span class="line">            pMergeHead.next = Merge(list1,list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pMergeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【15】反转链表</title>
      <link href="/2019/04/15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>用一个栈stack依次存储ListNode里面的值，因为stack的特点是先进后出，故依次弹出即为反转链表</p></li><li><p>用一个链表temp依次存储弹出的值，依次next存入下一个链表值，链表res指向这个temp的头节点</p></li><li><p>反转链表的结果为res.next,因为我们之前设temp的头节点为-1（自己设的）。</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* public static class ListNode &#123;</span></span><br><span class="line"><span class="comment">        int val;</span></span><br><span class="line"><span class="comment">        ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">            this.val = val;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode temp = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            ListNode res = temp;</span><br><span class="line">            <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp.next  = <span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【14】链表中倒数第K个结点</title>
      <link href="/2019/04/14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/04/14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>先用一个count计算出链表的长度，如果count&lt;k，返回null</p></li><li><p>链表的倒数第K个即为链表的正数（count-k+1）个,一个for循环，将指针轮询到那个点，然后再将起后面截断（head.next = null）即可。</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            ListNode root = head;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">                root = root.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//倒数第K个即正数第（count-k+1）个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;(count-k+<span class="number">1</span>);i++)&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【13】调整数值顺序使奇数位于偶数前面</title>
      <link href="/2019/04/13-%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
      <url>/2019/04/13-%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>依次遍历array数组，遇到奇数存到原来的array数组前面，遇到偶数放到res数组，然后将两个数组拼接即可。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> []res = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count2  = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                <span class="comment">//如果是奇数，则放在数组前面</span></span><br><span class="line">                <span class="keyword">if</span>(array[i]%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                    array[count++] = array[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//偶数放在另一个数组里</span></span><br><span class="line">                    res[count2++] = array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = count;i&lt;array.length;i++)&#123;</span><br><span class="line">                array[i] = res[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【12】数值的整数次方</title>
      <link href="/2019/04/12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
      <url>/2019/04/12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>（1）exponent &gt; 0,如2^3,则可以直接运算得出结果</p></li><li><p>（2）exponent &lt; 0,如2^-3,则结果为（1/2）^3</p></li><li><p>（3）exponent = 0,如2^0,则结果为1</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> powCal(<span class="number">1.0</span>/base,-<span class="number">1</span>*exponent);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> powCal(base,exponent);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//计算base的exponent次方</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">powCal</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;exponent;i++)&#123;</span><br><span class="line">               res  = res*base;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【11】二进制中1的个数</title>
      <link href="/2019/04/11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/04/11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>方法1：直接将其转成二进制数组</p></li><li><p>方法2：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> []a=Integer.toBinaryString(n).toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                 count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【10】矩形覆盖</title>
      <link href="/2019/04/10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
      <url>/2019/04/10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><a id="more"></a></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>类似于青蛙跳台阶</p><ul><li><p>当 n = 1时，只有一种横向排列的方式</p></li><li><p>当 n = 2时，有两种选择，横向或者竖向</p></li><li><p>当 n = 3时，如果选择竖向，则还剩下2*2的排列，如果选择横向，只有一种选择方案(剩下的一个横向一个竖向)</p></li><li><p>递推可得F(2 * n) = F(2 * (n-1))+F(2 * (n-2) ) , n&gt;=3</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(inttarget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            return0;</span><br><span class="line">        &#125;</span><br><span class="line">         elseif(target ==<span class="number">1</span>|| target == <span class="number">2</span>)&#123;</span><br><span class="line">             returntarget;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span>(RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【9】变态跳台阶</title>
      <link href="/2019/04/9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/04/9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f(0) = 0</span></span><br><span class="line"><span class="comment">//f(1) = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。</span></span><br><span class="line"><span class="comment">//f(3) = f(3-1) + f(3-2) + f(3-3) ...</span></span><br><span class="line"><span class="comment">//f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)</span></span><br><span class="line"><span class="comment">/*说明：</span></span><br><span class="line"><span class="comment">1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。</span></span><br><span class="line"><span class="comment">2）n = 1时，只有1种跳法，f(1) = 1</span></span><br><span class="line"><span class="comment">3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)</span></span><br><span class="line"><span class="comment">4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)</span></span><br><span class="line"><span class="comment">5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1)</span></span><br><span class="line"><span class="comment">6) 由以上已经是一种结论，但是为了简单，我们可以继续简化：</span></span><br><span class="line"><span class="comment">    f(n-1) =f(0)+f(1)+f(2)+f(3)+...+f((n-1)-1)        </span></span><br><span class="line"><span class="comment">           =f(0)+f(1)+f(2)+f(3)+...+f(n-2) </span></span><br><span class="line"><span class="comment">      f(n) =f(0)+f(1)+f(2)+f(3)+...+f(n-2)+f(n-1)=f(n-1)+f(n-1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以得出：f(n) = 2*f(n-1)*/</span></span><br></pre></td></tr></table></figure><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【8】跳台阶</title>
      <link href="/2019/04/8-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/04/8-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>把n级台阶的跳的次数看成是n的函数,即为f(n),当n&gt;2时,第一次跳有两种跳法,</p><p>第一次跳1级,则该次跳法数目为后面剩下的n-1级台阶的跳法数目f(n-1)。</p><p>第一次跳2级,则该次跳法数目为后面剩下的n-2级台阶的跳法数目f(n-2)。</p><p>所以f(n)=f(n-1)+f(n-2),即相当于斐波那契数列。`</p></li></ol><p>即该题跟斐波那契数列是相似的，青蛙跳台阶的公式为</p><pre><code>F(n) = F(n-1)+F(n-2),n&gt;=3</code></pre><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> one_=<span class="number">1</span>; <span class="comment">//第一次跳台阶的方法数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> two_=<span class="number">2</span>; <span class="comment">//第二次跳台阶的方法数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> finN=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=target;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            finN=one_+two_;</span><br><span class="line">            one_=two_;</span><br><span class="line">            two_=finN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【7】斐波那契数组</title>
      <link href="/2019/04/7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E7%BB%84/"/>
      <url>/2019/04/7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p><ul><li><p>斐波那契数列：1     1     2     3     5     8     13     21     34  ….</p><a id="more"></a></li></ul><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>斐波那契数列：从第三项开始，每一项都等于前两项之和。通项公式为</p><pre><code>F(n) = F(n-1)+F(n-2),n&gt;=3</code></pre></li></ul><p>方法1：通过递归实现，但是时间复杂度和空间复杂度都会很大</p><p>方法2：依次F(n-1)和F(n-2)值，求F(n)就很简单啦</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> (Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>));   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> one_ = <span class="number">1</span>;  <span class="comment">//用于存储f(n-2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> two_ =<span class="number">1</span>;   <span class="comment">//用于存储f(n-1)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">             fin = one_+two_;</span><br><span class="line">             <span class="comment">//向前递推</span></span><br><span class="line"></span><br><span class="line">             one_ = two_;   <span class="comment">//下一次的f(n-2)为 上一次结果的f(n-1)</span></span><br><span class="line"></span><br><span class="line">             two_ = fin;    <span class="comment">//下一次的f(n-1)为 上一次结果的fin </span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【6】旋转数组的最小数字</title>
      <link href="/2019/04/6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2019/04/6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>方法1：重头到尾遍历，找到数组的最小值，时间复杂度为O(N)</p></blockquote><blockquote><p>方法2：二分遍历查找</p></blockquote><ul><li><p>mid = low +(high-low)/2;</p></li><li><p>需要考虑三种情况：</p><ul><li><p>arr[mid] &gt; arr[high],如[3,4,5,1,2]说明最小数字在mid的右边，缩小范围，low = mid+1;</p></li><li><p>arr[mid]&lt;arr[high],如[1,2,3,4,5]说明最小数字在mid的左边，high = mid-1;</p></li><li><p>arr[mid] = arr[high],如[0,1,1,1,1]或者[1,1,1,0,1],一步步缩小范围，high = high-1;</p></li></ul></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; arr[high])&#123;</span><br><span class="line"></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] == arr[high])&#123;</span><br><span class="line"></span><br><span class="line">                high = high - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[low];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【5】两个栈实现队列</title>
      <link href="/2019/04/5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2019/04/5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h4><ul><li style="list-style: none"><input type="checkbox"> 栈的规则是先进后出，队列的规则是先进先出</li></ul><ol><li><p>stack1一直维持着栈底–栈顶是队列的入队顺序</p></li><li><p>stack2一直维持着栈顶–栈尾为队列的入队顺序</p></li><li><p>当执行队列的入队（push）时，如果stack2为空，则直接插入到stack1,stack1从栈底到栈顶的顺序为入队顺序，如果stack2不为空，则将stack2的元素倒入（栈顶—栈尾）stack1,然后再插入数据</p></li></ol><p>4- 当执行队列的出队(pop)操作时，应该出的是stack1的栈底元素，故将stack1依次倒入stack2,这时stack2的栈顶就是要出队的数值，此时stack1为空，stack2从（栈顶–栈尾）为入队顺序</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//队列的入队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将stack2倒入stack1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将元素插入stack1</span></span><br><span class="line"></span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列的出队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将stack1倒入stack2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stack2的栈顶就是出队数值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【4】重建二叉树</title>
      <link href="/2019/04/4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/04/4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>先序遍历为：根-&gt;左子树-&gt;右子树，中序遍历为左子树-&gt;根-&gt;右子树</p></li><li><p>先找到根结点，为先序遍历的第一个数值</p></li><li><p>根据这个数值，可以划分中序中的左子树和右子树范围</p></li><li><p>递归构建左子树和右子树</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//** * Definition for binary tree </span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123; </span><br><span class="line">     <span class="keyword">int</span> val; </span><br><span class="line">     TreeNode left; </span><br><span class="line">     TreeNode right; </span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span> || in.length==<span class="number">0</span>)               </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;           </span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);    <span class="comment">//根结点       </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre.length;i++)&#123;      </span><br><span class="line">        <span class="comment">//找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点         </span></span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == in[i])&#123;    </span><br><span class="line">        <span class="comment">//递归构建左子树，此时前序的范围缩小为[1,i+1),中序缩小为[0,i)              </span></span><br><span class="line">             node.left =reConstructBinaryTree(Arrays.copyOfRange</span><br><span class="line">                         (pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">        <span class="comment">//递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len)                   </span></span><br><span class="line">             node.right = reConstructBinaryTree(Arrays.copyOfRange</span><br><span class="line">        (pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));                   </span><br><span class="line">                <span class="keyword">break</span>;               </span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;           </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【3】从尾到头打印链表</title>
      <link href="/2019/04/3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>先用一个栈stack存储从头到尾的链表数值</p></li><li><p>再依次弹出，因为栈是先进后出的，故弹出的结果为从尾到头</p></li><li><p>将弹出的结果放入list返回</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(listNode.val);</span><br><span class="line">                listNode = listNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                list.add(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【1】二维数组的查找</title>
      <link href="/2019/04/1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/04/1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述："><a href="#1-题目描述：" class="headerlink" title="1.题目描述："></a>1.题目描述：</h3><blockquote><p> 在一个二维数组中（每个一维数组的长度相同），如数组</p><p>1       2       3</p><p>4       5       6 </p><p>7       8       9</p><p>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<a id="more"></a></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><ol><li><p>选择右上角的数字作为开始点</p></li><li><p>如果array[row][col]&gt;target,则向左查找，col–；</p></li><li><p>如果array[row][col]&lt;target,则向下查找，row++；</p></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;=array.length-<span class="number">1</span>&amp;&amp;col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[row][col]&gt;target)&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[row][col]&lt;target)&#123;</span><br><span class="line">                  row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【2】空格替换</title>
      <link href="/2019/04/2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2/"/>
      <url>/2019/04/2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><a id="more"></a></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h4><ul><li><p>方法1：利用函数replaceAll完成</p></li><li><p>方法2：</p><pre><code>**先计算需要多少的空间**从后向前依次插入</code></pre></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> str.toString().replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> spacenum = <span class="number">0</span>;<span class="comment">//spacenum为计算空格数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</span><br><span class="line">                spacenum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//indexold为为替换前的str下标</span></span><br><span class="line">        <span class="keyword">int</span> indexold = str.length()-<span class="number">1</span>; </span><br><span class="line">        <span class="comment">//计算空格转换成%20之后的str长度</span></span><br><span class="line">        <span class="keyword">int</span> newlength = str.length() + spacenum*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//indexold为为把空格替换为%20后的str下标</span></span><br><span class="line">        <span class="keyword">int</span> indexnew = newlength-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//使str的长度扩大到转换成%20之后的长度,防止下标越界</span></span><br><span class="line">        str.setLength(newlength);</span><br><span class="line">        <span class="keyword">for</span>(;indexold&gt;=<span class="number">0</span> &amp;&amp; indexold&lt;newlength;--indexold)&#123; </span><br><span class="line">                <span class="keyword">if</span>(str.charAt(indexold) == <span class="string">' '</span>)&#123;  </span><br><span class="line"></span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'%'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    str.setCharAt(indexnew--, str.charAt(indexold));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充1：String和StringBuffer的转换"><a href="#补充1：String和StringBuffer的转换" class="headerlink" title="补充1：String和StringBuffer的转换"></a>补充1：String和StringBuffer的转换</h4><p>String转换成StringBuffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">StringBuffer b=<span class="keyword">new</span> StringBuffer(str);</span><br></pre></td></tr></table></figure><p>StringBuffer转换成String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer a=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">String b=a.toString(）</span><br></pre></td></tr></table></figure><h4 id="补充2：String、StringBuffer、StringBuilder"><a href="#补充2：String、StringBuffer、StringBuilder" class="headerlink" title="补充2：String、StringBuffer、StringBuilder"></a>补充2：String、StringBuffer、StringBuilder</h4><blockquote><p>1）运行速度StringBuilder&gt;StringBuffer&gt;String</p></blockquote><blockquote><p>2）String是字符串常量，String对象一旦创建就不能更改。StringBuffer为 字符串变量，可更改</p></blockquote><blockquote><p>3） String适用于少量的字符串操作，StringBuffer适用于多线程下字符缓冲区进行大量操作的情况。 </p><p>4） StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，</p></blockquote><blockquote><p>5） 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。</p><p>6） 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而StringBuffer则每次都需要判断锁，效率相对更低。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_线程TLAB局部缓存区域</title>
      <link href="/2019/04/jvm-%E7%BA%BF%E7%A8%8BTLAB%E5%B1%80%E9%83%A8%E7%BC%93%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/04/jvm-%E7%BA%BF%E7%A8%8BTLAB%E5%B1%80%E9%83%A8%E7%BC%93%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-对象内存分配的两种方法"><a href="#1-对象内存分配的两种方法" class="headerlink" title="1.对象内存分配的两种方法"></a>1.对象内存分配的两种方法</h2><p>Ø 指针碰撞</p><blockquote><p>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”<a id="more"></a></p></blockquote><p>Ø 空闲列表</p><blockquote><p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”</p></blockquote><p>问题：</p><pre><code>多线程执行时，一个线程正在给A对象分配内存，指针还没有来的及修改，其它为B对象分配内存的线程，而且还是引用这之前的指针指向。就出现问题了</code></pre><h3 id="2-TLAB线程本地分配缓存区"><a href="#2-TLAB线程本地分配缓存区" class="headerlink" title="2.TLAB线程本地分配缓存区"></a>2.TLAB线程本地分配缓存区</h3><p>概念：线程本地分配缓存区,这是一个线程专用的内存分配区域。 由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步（虚拟机采用CAS配上失败重试的方式保证更新操作的原子性），而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。</p><h6 id="划重点："><a href="#划重点：" class="headerlink" title="划重点："></a>划重点：</h6><p>1.堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的</p><p>2.Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），<br>   其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配</p><p>3.JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB。默认设定为占用Eden Space的1%。TLAB上的分配由于是线程私有所以没有锁开销。</p><p>4.TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。</p><p>5.所有新创建的Object 都将会存储在新生代Yong Generation中。<br>   如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_内存分配和回收策略</title>
      <link href="/2019/04/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
      <url>/2019/04/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1.内存分配"></a>1.内存分配</h2><p>1.对象优先在eden分配</p><pre><code>对象先在新生代Eden区分配，当Eden区没有足够空间进行分配，虚拟机将发起  Minor GC</code></pre><a id="more"></a><p>2.大对象直接进入老年代</p><pre><code>大对象指的是需要大量的连续内存空间的java对象。如很长的字符串或者数组 -XX:PretenureSizeThreshold:大于该值直接在老年代分配</code></pre><p>3.长期存活的对象直接进入老年代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置对象年龄计数器，GC一遍没死年龄加1,默认老年阈值为15</span><br><span class="line">-XX:MaxTenuringThreshold:老年代年龄设置</span><br></pre></td></tr></table></figure><h6 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h6><pre><code>survivor空间中相同年龄的对象大小总和&gt;survivor的一半，该年龄进入老年代，无需等到MaxTenuringThreshold设定的年龄。</code></pre><h2 id="2-回收策略"><a href="#2-回收策略" class="headerlink" title="2.回收策略"></a>2.回收策略</h2><h6 id="空间分配担保："><a href="#空间分配担保：" class="headerlink" title="空间分配担保："></a>空间分配担保：</h6><pre><code>老年代最大可用空间&gt;新生代所有对象总空间，Minor GC 确保安全。如果允许，继续比较 老年代最大可用空间&gt;晋升到老年代对象的平均大小，如果大于进行Minor GC,否则进行Full GC.</code></pre><h4 id="Full-GC-和Minor-GC"><a href="#Full-GC-和Minor-GC" class="headerlink" title="Full GC 和Minor GC"></a>Full GC 和Minor GC</h4><blockquote><p>对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，与Minor GC对应的是Major GC、Full GC。</p></blockquote><pre><code>(1)Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。(2)Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。(3)Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。</code></pre><h5 id="Minor-GC-触发条件"><a href="#Minor-GC-触发条件" class="headerlink" title="Minor GC 触发条件"></a>Minor GC 触发条件</h5><pre><code>当Eden区满时，触发Minor GC。</code></pre><h5 id="Full-GC-触发条件"><a href="#Full-GC-触发条件" class="headerlink" title="Full GC 触发条件"></a>Full GC 触发条件</h5><pre><code>(1) 调用System.gc(2) 老年代空间不足    新生代对象转入及创建为大对象、大数组时出现不足的现象(3) 永久代空间不足   永久代中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。(4) gc担保失败 老年代最大可用空间&lt;新生代所有对象总空间,继续比较老年代最大可用空间&lt;晋升到老年代对象的平均大小(5) CMS清理阶段，发现有新的垃圾，而老年代没有足够空间</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_对象已死</title>
      <link href="/2019/04/JVM-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB/"/>
      <url>/2019/04/JVM-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>垃圾收集器再对堆进行回收前，第一个要做的事就是确定对象是否还存活，判断方法有2种</p><p>1)引用计数法</p><p>2)可达性分析</p><a id="more"></a><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h4><blockquote><p>给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。</p><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>很难解决对象之间的相互循环引用问题，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器收集它们。</p></blockquote><h4 id="2-可达性分析"><a href="#2-可达性分析" class="headerlink" title="2.可达性分析"></a>2.可达性分析</h4><blockquote><p>通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。</p><h6 id="GC-Roots对象"><a href="#GC-Roots对象" class="headerlink" title="GC Roots对象:"></a>GC Roots对象:</h6><p>(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</p><p>(2). 方法区中的<strong>类静态属性引用的对象</strong>。static对象</p><p>(3). 方法区中<strong>常量</strong>引用的对象。final对象</p><p>(4). <strong>本地方法</strong>栈中JNI(Native方法)引用的对象。</p></blockquote><h5 id="扩展：引用"><a href="#扩展：引用" class="headerlink" title="扩展：引用"></a>扩展：引用</h5><blockquote><p>(1) <strong>强引用</strong> ：只要强引用还存在，【垃圾收集器就永远不会回收该对象】</p><pre><code>Object obj = new Object();</code></pre><p>(2) <strong>软引用</strong> :软引用关联的对象，在系统发生内存溢出异常前，会将这些对象进行第二次回收。如果第二次回收还没有足够内存才抛出内存溢出异常。【内存空间足够，回收器就不会回收它，内存不足就会回收】</p><p>(3) <strong>弱引用</strong>：描述非必需对象。关联的对象只能生存到下一次垃圾回收前，当垃圾收集器工作时，【无论当前内存是否足够，都会回收掉它们】。</p><p>(4) <strong>虚引用</strong> ：无法通过虚引用来取得一个对象实例。唯一目的是能在这个对象被收集器回收时收到一个系统通知。【任何时候都可能被回收】</p></blockquote><h5 id="死亡过程"><a href="#死亡过程" class="headerlink" title="死亡过程"></a>死亡过程</h5><blockquote><p>可达性分析没有发现与GCRoots的引用链 </p><p>1.如果不可达，则标记筛选（条件是对象是否有必要执行finalize）<br>   1)没必要，对象没有覆盖finalize方法或者finalize已经被虚拟机调用<br>   2)有必要。放置在F-Queue队列中。这时候二次标记。如果重新与对象建立连接则不会被回收。</p></blockquote><h5 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h5><blockquote><p>永久代的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类</strong></p><p>1.废弃常量<br>         没有在其他地方引用则回收<br>2.无用的类<br>         (1) 类的实例已被回收<br>         (2) 加载该类的classloader已被回收<br>         (3) 该类对应的class没有被引用，也无反射访问。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_垃圾收集器</title>
      <link href="/2019/04/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2019/04/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>垃圾收集器一共有7种，如果说收集算法是内存回收的方法，那个垃圾收集器就是垃圾回收的具体实现。<a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/垃圾收集器.png" alt="垃圾收集器"></p><p><code>以中间绿线为界，上边三个用于年轻代，下边三个用在年老代，而G1则老少通吃，**黑线**线表示两个回收器可搭配使用，**红线**则表示两者可以在同一区域交替使用。由于G1在JDK1.7才达到商用级别，而且目前线上环境也很少使用。</code></p><table><thead><tr><th>名称</th><th></th><th>区域</th><th>算法</th><th>适用情况</th></tr></thead><tbody><tr><td>Serial</td><td>串行</td><td>年轻代</td><td>复制</td><td>单CPU（或CPU较少）、小型客户端应用</td></tr><tr><td>Parallel Scavenge</td><td>并行</td><td>年轻代</td><td>复制</td><td>多CPU、吞吐量优先（后台处理、科学计算）</td></tr><tr><td>ParNew</td><td>并行</td><td>年轻代</td><td>复制</td><td>多CPU、响应优先（web服务器等）</td></tr><tr><td>CMS</td><td>并发</td><td>年老代</td><td>标记-清除</td><td>响应优先（web服务器等）</td></tr><tr><td>Serial Old</td><td>串行</td><td>年老代</td><td>标记-整理</td><td>单CPU、小型客户端应用</td></tr><tr><td>Parallel Old</td><td>并行</td><td>年老代</td><td>标记-整理</td><td>多CPU、吞吐量优先（后台处理、科学计算）</td></tr></tbody></table><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h3><blockquote><p>从名字就能看出是串行的意思，该回收器是最早实现的，<strong>基于单线程</strong>，</p><p>优点：</p><pre><code>实现简单且效率高，</code></pre><p>缺点：</p><pre><code>进行垃圾回收是会造成“Stop-the-World”(STW)，当回收内存区域较大时，就会造成程序响应时间变长。  </code></pre><p>STW：在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。</p></blockquote><h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h3><blockquote><p>全名Parallel New Generation，也就是<strong>并行新生代垃圾收集</strong>器，该回收器实现与Serial基本上一样，只是采用多线程执行回收。是运行在<strong>服务端模式</strong>下首选的新生代收集器。</p></blockquote><h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h3><blockquote><p>Parallel Scavenge则<strong>侧重于吞吐量的控制</strong>，又名”吞吐量优先”回收器</p><p>(吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）；</p><p><strong>停顿时间</strong>：适合需要与用户交互的程序，良好的响应速度能提升用户体验</p><p><strong>高吞吐量</strong>：高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多的交互任务。</p><p>自适应调节策略：虚拟机会根据当前系统的运行监控信息，动态调整参数以提供最合适的停顿时间或者最大吞吐量。</p><p>该回收器与ParNew的最大区别在于ParNew通常与CMS搭配。</p></blockquote><h3 id="4-CMS收集器"><a href="#4-CMS收集器" class="headerlink" title="4.CMS收集器"></a>4.CMS收集器</h3><blockquote><p>Concurrent Mark Sweep，是一个并发回收器，旨在减少<strong>垃圾回收的停顿时间</strong>。集中应用于<strong>B/S系统的服务端</strong>，尤其注重服务的响应速度</p></blockquote><h6 id="CMS运作操作流程"><a href="#CMS运作操作流程" class="headerlink" title="CMS运作操作流程"></a>CMS运作操作流程</h6><blockquote><p>(1)初始标记：标记GCRoots能直接关联到的对象</p><p>(2)并发标记：GCRoot开始对堆中对象进行可达性分析</p><p>(3)重新标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录</p><p>(4)并发清除：回收标记的垃圾</p></blockquote><h6 id="CMS缺点："><a href="#CMS缺点：" class="headerlink" title="CMS缺点："></a>CMS缺点：</h6><blockquote><p>（1）对CPU资源非常敏感</p><p>（2）无法处理浮动垃圾：CMS在并发清除阶段用户线程还在运行，会产生新的垃圾。这部分垃圾出现在标记之后，要等待下次GC才能清理掉</p><p>（3）基于标记-清除算法，会产生大量的内存碎片。</p></blockquote><h3 id="5-Serial-Old收集器"><a href="#5-Serial-Old收集器" class="headerlink" title="5.Serial Old收集器"></a>5.Serial Old收集器</h3><blockquote><p>   标记-整理算法实现的，相当于Serial的年老代版。</p><p>（1）可以与Parallel Scavenge收集器搭配使用</p><p>（2）作为CMS收集器的后备预案</p></blockquote><h3 id="6-Paraller-Old收集器"><a href="#6-Paraller-Old收集器" class="headerlink" title="6.Paraller Old收集器"></a>6.Paraller Old收集器</h3><blockquote><p>标记-整理算法实现，相当于Parallel Scavenge的年老代版。</p><p>在注重吞吐量以及CPU资源敏感的场合：Parallel Old + Parallel Scavengr </p></blockquote><h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h3><blockquote><p>G1是一款面向服务端应用的垃圾收集器。具备以下特点：</p><p>(1)并行与并发</p><pre><code>并行即使用多个CPU来缩端STW停顿的时间，还可以通过并发方式让java程序继续执行。</code></pre><p> (2)分代收集</p><pre><code>可以不需要其他收集器配合就能独立管理整个GC堆</code></pre><p> (3)空间整合</p><pre><code>标记整理算法实现，在运行期间不会产生内存空间碎片，收集后可以提供规整的可用内存。</code></pre><p> (4)可预测停顿</p><pre><code>除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上时间不超过N秒。</code></pre></blockquote><h6 id="G1收集器运作流程："><a href="#G1收集器运作流程：" class="headerlink" title="G1收集器运作流程："></a>G1收集器运作流程：</h6><blockquote><p>(1)初始标记：标记GCRoots能直接关联到的对象</p><p>(2)并发标记：GCRoot开始对堆中对象进行可达性分析</p><p>(3)最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录</p><p>(4)筛选回收：回收标记的垃圾</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_垃圾回收算法</title>
      <link href="/2019/04/JVM-%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/JVM-%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>垃圾回收算法有4种</p><ol><li><p>标记-清除算法</p></li><li><p>复制算法</p></li><li><p>标记-整理算法</p></li><li><p>分代收集算法</p><a id="more"></a></li></ol><h2 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1.复制算法"></a>1.复制算法</h2><p><code>可用的内存空间分为大小相等的两块，每次只是用其中的一块，当这一块被用完的时候，就将还存活的对象复制到另一块中，然后把原已使用过的那一块内存空间一次回收掉。这个算法常用于新生代的垃圾回收。</code></p><p><img src="https://github.com/qiulig/IMG/raw/master/复制算法.jpg" alt="复制算法"></p><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ol><li>复制算法解决了标记-清除算法的效率问题，以空间换时间。</li></ol><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ol><li>但是当存活对象非常多的时候，复制操作效率将会变低，而且每次只能使用一半的内存空间，利用率不高。</li></ol><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ol><li><p>应用于新生代</p></li><li><p>Serial、ParNew、Parallel Scavenge 垃圾收集器应用的算法</p></li></ol><h2 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记-清除算法"></a>2. 标记-清除算法</h2><p><code>先标记出所有需要被回收的对象，然后在标记完成后统一回收掉所有被标记的对象。</code></p><p><img src="https://github.com/qiulig/IMG/raw/master/标记清除算法.png" alt="标记清除算法"></p><h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><pre><code>效率问题：标记与清除两个过程的效率都不高空间问题：产生大量不连续的内存碎片，碎片太多会导致再程序运行过程中需要分配较大对象时，找不到足够的连续内存尔不得不提前触发垃圾回收动作。</code></pre><h6 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h6><pre><code>应用于老年代的垃圾回收CMS垃圾收集器应用的算法</code></pre><h2 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h2><p>这个算法分为三部分：</p><blockquote><p>标记出所有需要被回收的对象；</p><p>把所有存活的对象都向一端移动；</p><p>把所有存活对象边界以外的内存空间都回收掉。</p></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/标记整理算法.png" alt="标记整理算法"></p><h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><blockquote><p>标记-整理算法解决了复制算法多复制效率低、空间利用率低的问题，</p><p>解决了内存碎片的问题。</p></blockquote><h6 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h6><blockquote><p>Serial Old、Parallel Old 垃圾收集器应用的算法</p><p>主要应用于老年代</p></blockquote><h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><blockquote><p>根据对象生存周期的不同将内存空间划分为不同的块，然后对不同的块使用不同的回收算法。一般把Java堆分为新生代和老年代，新生代中对象的存活周期短，只有少量存活的对象，所以可以使用复制算法，而老年代中对象存活时间长，而且对象比较多，所以可以采用标记-清除和标记-整理算法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_锁问题</title>
      <link href="/2019/03/SQL-%E9%94%81%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/SQL-%E9%94%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><blockquote><p>（1）<strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。  [MYISAM、Memory、Innodb]</p><pre><code>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用</code></pre><p>（2）<strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发 度也最高。[Innodb]  </p><pre><code>行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用</code></pre><p>（3）<strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁  之间，并发度一般。[BDB]</p></blockquote><a id="more"></a><h3 id="MYISAM表级锁"><a href="#MYISAM表级锁" class="headerlink" title="MYISAM表级锁"></a>MYISAM表级锁</h3><h5 id="锁争用"><a href="#锁争用" class="headerlink" title="锁争用"></a>锁争用</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'table%'</span>;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Table_locks_immediate | <span class="number">2979</span> |</span><br><span class="line">| Table_locks_waited | <span class="number">0</span> |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">####Table_locks_waits值高则代表严重的表级锁争用</span><br></pre></td></tr></table></figure><h5 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h5><pre><code>（1）表共享读锁：可以多个用户共同读（2）表独占写锁：写操作独占一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止</code></pre><h5 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h5><pre><code>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁</code></pre><h5 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h5><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。  </p><pre><code> 当concurrent_insert设置为0时，不允许并发插入。   当concurrent_insert设置为1时，如果MyISAM表中没有空洞(即表的中间没有被删除的行),MyISAM允许在一个进程读表的同时, 另一个进程从表尾插入记录。这也是MySQL 的默认设置。   当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</code></pre><h5 id="锁调度"><a href="#锁调度" class="headerlink" title="锁调度"></a>锁调度</h5><pre><code>一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，写进程先获得锁。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一些设置来调节 MyISAM 的调度行为。 </span><br><span class="line">     通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</span><br><span class="line">     通过执行命令SET LOW_PRIORITY_UPDATES=<span class="number">1</span>，使该连接发出的更新请求优先级降低。</span><br><span class="line">     通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</span><br></pre></td></tr></table></figure><h3 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h3><h5 id="锁争用-1"><a href="#锁争用-1" class="headerlink" title="锁争用"></a>锁争用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'innodb_row_lock%'</span>;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| InnoDB_row_lock_current_waits | <span class="number">0</span> |</span><br><span class="line">| InnoDB_row_lock_time | <span class="number">0</span> |</span><br><span class="line">| InnoDB_row_lock_time_avg | <span class="number">0</span> |</span><br><span class="line">| InnoDB_row_lock_time_max | <span class="number">0</span> |</span><br><span class="line">| InnoDB_row_lock_waits | <span class="number">0</span> |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">###InnoDB_row_lock_waits 和 InnoDB_row_lock_time_avg 的值</span><br><span class="line">比较高，代表严重的锁争用</span><br></pre></td></tr></table></figure><h5 id="锁模式-1"><a href="#锁模式-1" class="headerlink" title="锁模式"></a>锁模式</h5><p><strong>共享锁：</strong>允许一个事务去读一行，阻止其他事务获得该行的排他锁<br>         select …  lock in share mode;</p><p><strong>排他锁</strong>：允许获得排他锁的事务更新数据，阻止其他事务获得该行的共享读锁和排他写锁<br>         select … for update;</p><table><thead><tr><th></th><th>X(排他锁)</th><th>IX(意向排他锁)</th><th>S(共享锁)</th><th>IS(意向共享锁)</th></tr></thead><tbody><tr><td>X(排他锁)</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX(意向排他锁)</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S(共享锁)</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS(意向共享锁)</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</span><br><span class="line"> 排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁.另外，为了允许行锁和表锁共存，</span><br><span class="line">   实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</span><br><span class="line"> 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</span><br><span class="line"> 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁</span><br></pre></td></tr></table></figure><h5 id="锁实现方式"><a href="#锁实现方式" class="headerlink" title="锁实现方式"></a>锁实现方式</h5><pre><code>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）在不通过索引条件查询的时候，InnoDB 确实使用的是表锁，而不是行锁。</span><br><span class="line">（<span class="number">2</span>）由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的</span><br><span class="line">（<span class="number">3</span>）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行.另外，不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁</span><br><span class="line">（<span class="number">4</span>）如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。</span><br></pre></td></tr></table></figure><h5 id="表锁使用场景"><a href="#表锁使用场景" class="headerlink" title="表锁使用场景"></a>表锁使用场景</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)事务需要更新大部分或全部数据 </span><br><span class="line">(<span class="number">2</span>)事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的 开销</span><br></pre></td></tr></table></figure><h5 id="避免死锁方法"><a href="#避免死锁方法" class="headerlink" title="避免死锁方法"></a>避免死锁方法</h5><blockquote><p>（1）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表</p><p>（2）在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。</p><p>（3）隔离级别</p><pre><code>在 REPEATABLE-READ 隔离级别下，如果两个线程同时对相同条件记录用 SELECT...FOR UPDATE 加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁.这种情况下，将隔离级别改成 READ COMMITTED，就可避免问题，</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_触发器</title>
      <link href="/2019/03/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2019/03/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>触发器（trigger）是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。</p><a id="more"></a><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><br><strong>CREATE TRIGGER</strong> trigger_name trigger_time[BEFORE&#124;AFTER]<br> trigger_event[INSERT&#124;UPDATE&#124;DELETE]<br><strong>ON</strong> tbl_name<br> <strong>FOR EACH ROW</strong> trigger_stmt<br><br></td><td>创建触发器</td></tr><tr><td><strong>DROP TRIGGER</strong> [schema_name.]trigger_name</td><td>删除触发器</td></tr><tr><td><strong>show triggers \G</strong></td><td>查看触发器</td></tr><tr><td><strong>desc triggers</strong></td><td>查看触发器</td></tr></tbody></table><h3 id="触发器的使用"><a href="#触发器的使用" class="headerlink" title="触发器的使用"></a>触发器的使用</h3><p>触发器执行的语句有以下两个限制。</p><blockquote><pre><code>（1）触发程序不能调用将数据返回客户端的存储程序，也不能使用采用 CALL 语句的动态 SQL  语句     但是允许存储程序通过参数将数据返回触发程序。也就是存储过程或者函数通过 OUT  或者 INOUT 类型的参数将数据返回触发器     是可以的，但是不能调用直接返回数据的过程。  （2）不能在触发器中使用以显式或隐式方式开始或结束事务的语句，如 STARTTRANSACTION、  COMMIT 或 ROLLBACK</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_存储过程和函数</title>
      <link href="/2019/03/SQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2019/03/SQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><pre><code>存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合。</code></pre><a id="more"></a><p>与函数的区别</p><blockquote><p>（1）函数必须有返回值，而存储过程没有</p><p>（2）存储过程的参数可以使用 IN、OUT、INOUT 类型，而函数的参数只能是 IN 类型的。</p></blockquote><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><table><thead><tr><th>语句</th><th>定义</th></tr></thead><tbody><tr><td><br><strong>CREATE PROCEDURE</strong> sp_name<br> ([proc_parameter[,…]])<br> [characteristic …] routine_body<br><br></td><td>创建存储过程</td></tr><tr><td><br><strong>CREATE FUNCTION</strong> sp_name<br> ([func_parameter[,…]]<br> <strong>RETURNS</strong> type  [characteristic …]<br> routine_body<br><br></td><td>创建函数</td></tr><tr><td><br><strong>ALTER {PROCEDURE &#124; FUNCTION}</strong> sp_name<br> [characteristic …]<br><br></td><td>修改 存储过程/函数</td></tr><tr><td><br><strong>CALL</strong> sp_name([parameter[,…]])<br><br></td><td>调用过程</td></tr><tr><td><br><strong>DROP PROCEDURE</strong> name<br><br></td><td>删除存储过程</td></tr><tr><td><br><strong>SHOW {PROCEDURE&#124;FUNCTION} STATUS</strong> [LIKE ‘pattern’]<br><br></td><td>查看存储过程或者函数的状态</td></tr><tr><td><br><strong>SHOW CREATE {PROCEDURE &#124;FUNCTION}</strong> sp_name<br><br></td><td>查看存储过程或者函数的定义</td></tr><tr><td><br><strong>select * from routines</strong> where ROUTINE_NAME = ‘film_in_stock’ \G<br><br></td><td>获取存储过程和函数的包括名称、类型、语法、创建人 等信息。</td></tr><tr><td><br><strong>DECLARE</strong> var_name[,…] type [DEFAULT value]<br><br></td><td>变量的定义{用于begin…end块中}</td></tr><tr><td><br><strong>SET</strong> var_name = expr [, var_name = expr]<br><br></td><td>变量的赋值</td></tr><tr><td><br><strong>DECLARE</strong> condition_name <strong>CONDITION FOR</strong> condition_value<br><br></td><td>条件的定义</td></tr><tr><td><br><strong>DECLARE</strong> handler_type<br> <strong>HANDLER FOR</strong> condition_value[,…] sp_statement<br><br></td><td>条件的处理</td></tr><tr><td><br><strong>DECLARE</strong> cursor_name <strong>CURSOR FOR</strong> select_statement<br><br></td><td>声明光标</td></tr><tr><td><br>OPEN cursor_name<br><br></td><td>打开光标</td></tr><tr><td><br>FETCH cursor_name INTO var_name [, var_name] …<br><br></td><td>fetch光标</td></tr><tr><td><br>CLOSE cursor_name<br><br></td><td>关闭光标</td></tr><tr><td><br><strong>IF</strong> search_condition <strong>THEN</strong> statement_list<br>[<strong>ELSEIF</strong> search_condition <strong>THEN</strong> statement_list] …<br>[<strong>ELSE</strong> statement_list]<br><strong>END IF</strong><br><br></td><td>IF语句</td></tr><tr><td><br><strong>CASE</strong> case_value<br><strong>WHEN</strong> when_value <strong>THEN</strong> statement_list<br>[<strong>WHEN</strong> when_value <strong>THEN</strong> statement_list] …<br>[<strong>ELSE</strong> statement_list]<br><strong>END CASE</strong><br><br></td><td>CASE语句</td></tr><tr><td><br>[begin_label:] <strong>LOOP</strong><br>statement_list<br><strong>END LOOP</strong> [end_label]<br><br></td><td>LOOP语句</td></tr><tr><td><br>[begin_label:] <strong>REPEAT</strong><br>statement_list<br><strong>UNTIL</strong> search_condition<br><strong>END REPEAT</strong> [end_label]<br><br></td><td>REPEAT语句</td></tr><tr><td><br>[begin_label:] <strong>WHILE</strong> search_condition <strong>DO</strong><br>statement_list<br><strong>END WHILE</strong> [end_label]<br><br></td><td>WHILE语句</td></tr></tbody></table><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><blockquote><p>创建存储过程的proc_parameter: </p><pre><code>[ IN | OUT | INOUT ]   param_name type </code></pre></blockquote><blockquote><p>创建函数的func_parameter: </p><pre><code>param_name type  </code></pre></blockquote><blockquote><p>创建函数的type:</p><pre><code>Any valid MySQL data type  </code></pre></blockquote><blockquote><p>创建存储过程/函数的characteristic:<br>            LANGUAGE SQL   //说明下面过程的BODY是使用SQL语言<br>            | [NOT] DETERMINISTIC  //DEDETERMINISTIC 确定的，即每次输入一样输出也一样的程序，NOT DETERMINISTIC 非确定的，默认是非确定的。<br>            | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }   //CONTAINS SQL 表示子程序不包含读或写数据的语句。NO SQL 表示子程序不包含 SQL 语句。READS SQL DATA 表示子程序包含读数据的语句，但不包含写数据的语句。MODIFIES SQL DATA 表示子程序包含写数据的语句。<br>            | SQL SECURITY { DEFINER | INVOKER }   //可以用来指定子程序该用创建子程序者的许可来执行，还是使用调用者的许可来执行。默认值是 DEFINER<br>            | COMMENT ‘string’  //存储过程或者函数的注释信息。</p></blockquote><blockquote><p> 创建存储过程/函数的 routine_body:<br>            Valid SQL procedure statement or statements  </p></blockquote><blockquote><p>修改存储过程/函数中的characteristic:<br>    { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }<br>    | SQL SECURITY { DEFINER | INVOKER }<br>    | COMMENT ‘string</p></blockquote><blockquote><p> 条件的定义condition_value:  </p><pre><code>    SQLSTATE [VALUE] sqlstate_value &lt;|mysql_error_code</code></pre></blockquote><blockquote><p> 条件的处理参数handler_type:</p><pre><code>    CONTINUE  | EXIT  | UNDO  </code></pre><p>condition_value:  </p><pre><code>SQLSTATE [VALUE] sqlstate_value  | condition_name  | SQLWARNING  //对所有以 01 开头的 SQLSTATE 代码的速记| NOT FOUND  //对所有以 02 开头的 SQLSTATE 代码的速记| SQLEXCEPTION  //对所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的速记。| mysql_error_code</code></pre></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELIMITER $$   //delimiter将sql的结束标志设为$$</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; CREATE PROCEDURE film_in_stock(IN p_film_id INT, IN p_store_id INT, OUT p_film_count</span><br><span class="line"></span><br><span class="line">INT)</span><br><span class="line">    -&gt; READS SQL DATA</span><br><span class="line"></span><br><span class="line">    -&gt; BEGIN</span><br><span class="line"></span><br><span class="line">    -&gt; SELECT inventory_id</span><br><span class="line"></span><br><span class="line">    -&gt; FROM inventory</span><br><span class="line"></span><br><span class="line">    -&gt; WHERE film_id = p_film_id</span><br><span class="line"></span><br><span class="line">    -&gt; AND store_id = p_store_id</span><br><span class="line"></span><br><span class="line">    -&gt; AND inventory_in_stock(inventory_id);  ////调用了函数inventory_in_stock()</span><br><span class="line"></span><br><span class="line">    -&gt;</span><br><span class="line"></span><br><span class="line">    -&gt; SELECT FOUND_ROWS() INTO p_film_count;</span><br><span class="line"></span><br><span class="line">    -&gt; END $$</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; DELIMITER ;  //delimiter将sql的结束标志设为;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_视图</title>
      <link href="/2019/03/SQL-%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/03/SQL-%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="视图概念"><a href="#视图概念" class="headerlink" title="视图概念"></a>视图概念</h3><pre><code>视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。</code></pre><a id="more"></a><ul><li>视图中的数据并不属于视图本身，而是属于基本的表，对视图可以像表一样进行insert,update,delete操作。</li><li>视图不能被修改，表修改或者删除后应该删除视图再重建。</li><li>视图的数量没有限制，但是命名不能和视图以及表重复，具有唯一性。</li><li>视图可以被嵌套，一个视图中可以嵌套另一个视图。</li><li>视图不能索引，不能有相关联的触发器和默认值，sql server不能在视图后使用order by排序。</li></ul><h3 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a>视图的操作</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><strong>CREATE</strong> [OR REPLACE] [ALGORITHM = {UNDEFINED &#124; MERGE&#124;TEMPTABLE}]<br><strong>VIEW</strong> view_name [(column_list)]<br><strong>AS</strong> select_statement<br>[WITH [CASCADED &#124; LOCAL] CHECK OPTION]<br><br></td><td>创建视图<br>&gt; LOCAL 是只要满足本视图的条件就可以更新<br>&gt; CASCADED 则是必须满足所有针对该视图的所有视图的条件才可以更新<br></td></tr><tr><td><strong>ALTER</strong> [ALGORITHM = {UNDEFINED &#124;MERGE &#124;TEMPTABLE}]<br><strong>VIEW</strong> view_name [(column_list)]<br><strong>AS</strong> select_statement<br>[WITH [CASCADED &#124; LOCAL] CHECK OPTION]<br><br></td><td>修改视图</td></tr><tr><td><strong>DROP VIEW</strong> [IF EXISTS] view_name [, view_name] …[RESTRICT &#124; CASCADE]</td><td>删除视图</td></tr><tr><td>SHOW TABLES</td><td>查看视图</td></tr><tr><td>SHOW TABLE STATUS [FROM db_name] [LIKE ‘pattern’]</td><td>查看视图的信息</td></tr><tr><td><strong>show create view</strong> view_name  \G</td><td>查看视图定义</td></tr></tbody></table><h5 id="视图不可更新情况："><a href="#视图不可更新情况：" class="headerlink" title="视图不可更新情况："></a>视图不可更新情况：</h5><pre><code>（1）包含以下关键字的 SQL 语句：聚合函数（SUM、MIN、MAX、COUNT 等）、DISTINCT、GROUP BY、HAVING、UNION 或者 UNION ALL。      &gt; create or replace view payment_sum as   select staff_id,sum(amount) from payment **group by** staff_id;（2） 常量视图。     &gt; create or replace view pi as select 3.1415926 as pi;（3）SELECT 中包含子查询。      &gt;create view city_view as             select (select city from city where city_id = 1) ;（4） JION。  （5） FROM 一个不能更新的视图。  （6）WHERE 字句的子查询引用了 FROM 字句中的表</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_索引</title>
      <link href="/2019/03/SQL-%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/03/SQL-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1.索引概述"></a>1.索引概述</h3><pre><code>使用索引是提高 SELECT 操作性能的最佳途径。 MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引MySQL 目前还不支持函数索引，但是支持前缀索引。MySQL 中还支持全文本（FULLTEXT）索引，用于全文搜索，默认情况下，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。</code></pre><a id="more"></a><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><strong>CREATE</strong>[UNIQUE&#124;FULLTEXT&#124;SPATIAL] <strong>INDEX</strong> index_name<br>[USING index_type]<br><strong>ON</strong> tbl_name (index_col_name,…)<br><br></td><td>创建索引<br>index_col_name:<br>col_name [(length)] [ASC&#124;DESC]</td></tr><tr><td><strong>DROP INDEX</strong> index_name<br> <strong>ON</strong> tbl_name</td><td>删除索引</td></tr></tbody></table><h3 id="2-设计索引原则"><a href="#2-设计索引原则" class="headerlink" title="2.设计索引原则"></a>2.设计索引原则</h3><pre><code>（1）搜索的索引列，不一定是所要选择的列。换句话说，最适合索引的列是出现在 WHERE子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。  （2） 使用唯一索引。考虑某列中值的分布。索引的列的基数越大，索引的效果越好。（3） 使用短索引。如果对字符串列进行索引，应该指定一个前缀长度。（4）利用最左前缀（5）不要过度索引</code></pre><h3 id="3-索引失效"><a href="#3-索引失效" class="headerlink" title="3.索引失效"></a>3.索引失效</h3><blockquote><p>（1）如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引.</p><p>（2）如果使用 MEMORY/HEAP 表并且 where 条件中不使用“=”进行索引列，那么不会用到索引。heap 表只有在“=”的条件下才会使用索引。</p><p>（3）用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到</p><p>（4）不符合最左前缀:有复合索引，但是搜索的那个列不是索引第一列</p><p>（5）like以%开始</p><p>（6）如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的</p></blockquote><h3 id="4-查看索引使用情况"><a href="#4-查看索引使用情况" class="headerlink" title="4.查看索引使用情况"></a>4.查看索引使用情况</h3><blockquote><blockquote><p>show status like ‘Handler_read%’;<br>        handler_read_key:索引值被读次数 越高越好<br>        handler_read_rnd_next:查询效率，该值越低越好</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_存储引擎</title>
      <link href="/2019/03/SQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/03/SQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="四种存储引擎"><a href="#四种存储引擎" class="headerlink" title="四种存储引擎"></a>四种存储引擎</h2><a id="more"></a><blockquote><p>(1) MYISAM</p><pre><code>MyISAM 是 MySQL 的默认存储引擎。MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表.(不支持外键)</code></pre><p>(2) Innodb</p><pre><code>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。（支持外键）</code></pre><p>(3) Memory</p><pre><code>MEMORY 存储引擎使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文件，格式是.frm。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的,并且默认使用 HASH 索引，但是一旦服务关闭，表中的数据就会丢失掉。MEMORY 类型的存储引擎主要用在那些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果。</code></pre><p>(4) Merge</p><pre><code>MERGE 存储引擎是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，MERGE表本身并没有数据.对 MERGE 类型的表可以进行查询、更新、删除的操作，这些操作实际  上是对内部的实际的 MyISAM 表进行的。使用MERGE 表来透明地对多个表进行查询和更新操作，而对这种按照时间记录的操作日志表则可以透明地进行插入操作。</code></pre></blockquote><h3 id="1-MYISAM"><a href="#1-MYISAM" class="headerlink" title="1.MYISAM"></a>1.MYISAM</h3><p> 每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，但扩展名分别是：</p><pre><code> .frm（存储表定义）；   .MYD（MYData，存储数据）；   .MYI （MYIndex，存储索引）。  数据文件和索引文件可以放置在不同的目录，平均分布 IO，获得更快的速度。</code></pre><p> MyISAM 的表又支持 3 种不同的存储格式，分别是：</p><pre><code> 静态（固定长度）表：存储迅速，容易缓存，出现故障容易恢复，但占用空间多。 动态表：占用空间少， 但频繁更新删除记录会产生碎片，故障恢复较难 压缩表： 记录被单独压缩，访问开支小。</code></pre><h3 id="2-InnoDB"><a href="#2-InnoDB" class="headerlink" title="2.InnoDB"></a>2.InnoDB</h3><p>(1)自动增长列</p><pre><code>（1）ALTER TABLE *** AUTO_INCREMENT = n: 语句强制设置自动增长列的初识值（2）LAST_INSERT_ID()：查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是第一条记录使用的自动增长值。对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于 MyISAM 表，自动增长列可以是组合索引的其他列.</code></pre><p>(2)外键约束</p><blockquote><blockquote><blockquote><p><strong>CONSTRAINT</strong> <code>fk_city_country</code> <br><strong>FOREIGN KEY</strong> (子表的外键名称)<br><strong>REFERENCES</strong> 父表(父表的名称)<br><strong>ON</strong> DELETE RESTRICT<br> <strong>ON</strong> UPDATE CASCADE<br><br></p></blockquote></blockquote></blockquote><pre><code>RESTRICT/NO ACTION： 限制在子表有关联记录的情况下父表不能更新CASCADE： 表示父表在更新或者删除时，更新或者删除子表对应记录SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL</code></pre><p>(3) 存储方式</p><pre><code>@ 使用共享表空间存储@ 使用多表空间存储</code></pre><h3 id="存储引擎的选用"><a href="#存储引擎的选用" class="headerlink" title="存储引擎的选用"></a>存储引擎的选用</h3><p> <strong>MyISAM</strong>：默认的 MySQL 插件式存储引擎。如果应用是<strong>以读操作和插入操作为主，  只有很少的更新和删除操作</strong>，并且对<strong>事务的完整性、并发性要求不是很高</strong>MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。<br>  <br></p><p> <strong>InnoDB</strong>：用于<strong>事务处理应用程序</strong>，支持外键。如果应用对事务的完整性有比较高的  要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、  删除操作，那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低  由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback）,对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。  <br><br></p><p> <strong>MEMORY</strong>：将所有数据保存在 RAM 中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY 的缺陷是对表的大小有限制，太大的表无法 CACHE 在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。<strong>MEMORY 表通常用于更新不太频繁的小表，用以快速得到访问结果</strong>。 <br><br><br> <strong>MERGE</strong>：用于将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象  引用它们。MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制，并且通过将不同  的表分布在多个磁盘上，可以有效地改善 MERGE 表的访问效率。这对于诸如<strong>数据仓储</strong>等 VLDB  环境十分适合</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_常用函数</title>
      <link href="/2019/03/SQL-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2019/03/SQL-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.常用函数分为以下几种</p><blockquote><p>(1) 字符串</p><p>(2) 数值函数</p><p>(3) 日期和时间函数</p><p>(4) 流程函数</p><p>(5) 其他</p><a id="more"></a></blockquote><h3 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CANCAT(S1,S2,…Sn)</td><td>连接 S1,S2,…Sn 为一个字符串</td></tr><tr><td>INSERT(str,x,y,instr)</td><td>将字符串 str 从第 x 位置开始，y 个字符长的子串替换为字符串 instr</td></tr><tr><td>LOWER(str)</td><td>将字符串 str 中所有字符变为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串 str 中所有字符变为大写</td></tr><tr><td>LEFT(str ,x)</td><td>返回字符串 str 最左边的 x 个字符</td></tr><tr><td>RIGHT(str,x)</td><td>返回字符串 str 最右边的 x 个字符</td></tr><tr><td>LPAD(str,n ,pad)</td><td>用字符串 pad 对 str 最左边进行填充，直到长度为 n 个字符长度</td></tr><tr><td>RPAD(str,n ,pad)</td><td>用字符串 pad 对 str 最右边进行填充，直到长度为 n 个字符长度</td></tr><tr><td>LTRIM(str)</td><td>去掉字符串 str 左侧的空格</td></tr><tr><td>RTRIM(str)</td><td>去掉字符串 str 行尾的空格</td></tr><tr><td>REPEAT(str,x)</td><td>返回 str 重复 x 次的结果</td></tr><tr><td>REPLACE(str,a,b)</td><td>用字符串 b 替换字符串 str 中所有出现的字符串 a</td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串 s1 和 s2</td></tr><tr><td>TRIM(str)</td><td>去掉字符串行尾和行头的空格</td></tr><tr><td>SUBSTRING(str,x,y)</td><td>返回从字符串 str x 位置起 y 个字符长度的字串</td></tr></tbody></table><h3 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2.数值函数"></a>2.数值函数</h3><style> </style><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回 x 的绝对值</td></tr><tr><td>CEIL(x)</td><td>返回大于 x 的最大整数值</td></tr><tr><td>FLOOR(x)</td><td>返回小于 x 的最大整数值</td></tr><tr><td>MOD(x，y)</td><td>返回 x/y 的模</td></tr><tr><td>RAND()</td><td>返回 0 到 1 内的随机值</td></tr><tr><td>ROUND(x,y)</td><td>返回参数 x 的四舍五入的有 y 位小数的值</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数字 x 截断为 y 位小数的结果</td></tr></tbody></table><h3 id="3-日期和时间函数"><a href="#3-日期和时间函数" class="headerlink" title="3.日期和时间函数"></a>3.日期和时间函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前的日期和时间</td></tr><tr><td>UNIX_TIMESTAMP(date)</td><td>返回日期 date 的 UNIX 时间戳</td></tr><tr><td>FROM_UNIXTIME</td><td>返回 UNIX 时间戳的日期值</td></tr><tr><td>WEEK(date)</td><td>返回日期 date 为一年中的第几周</td></tr><tr><td>YEAR(date)</td><td>返回日期 date 的年份</td></tr><tr><td>HOUR(time)</td><td>返回 time 的小时值</td></tr><tr><td>MINUTE(time)</td><td>返回 time 的分钟值</td></tr><tr><td>MONTHNAME(date)</td><td>返回 date 的月份名</td></tr><tr><td>DATE_FORMAT(date,fmt)</td><td>返回按字符串 <strong>fmt 格式化日期</strong> date 值</td></tr><tr><td>DATE_ADD(date,<strong>INTERVAL</strong> expr type)</td><td>返回一个日期或时间值加上一个<strong>时间间隔的时间值</strong>，<br>INTERVAL 是间隔类型关键字<br>expr 是一个表达式，这个表达式对应后面的类型<br>type 是间隔类型<br></td></tr><tr><td>DATEDIFF(expr,expr2)</td><td>返回起始时间 expr 和结束时间 expr2 之间的天数</td></tr></tbody></table><p>表： MySQL 中的日期时间格式</p><table><thead><tr><th>格式符</th><th>格式说明</th></tr></thead><tbody><tr><td>%S,%s</td><td>两位数字形式的秒（00,01,…,59）</td></tr><tr><td>%i</td><td>两位数字形式的分（00,01,…,59）</td></tr><tr><td>%H</td><td>两位数字形式的小时，24 小时（00,01,…,23）</td></tr><tr><td>%h,%I</td><td>两位数字形式的小时，12 小时（01,02,…,12）</td></tr><tr><td>%k</td><td>数字形式的小时，24 小时（0,1,…,23）</td></tr><tr><td>%l</td><td>数字形式的小时，12 小时（1,2,…,12）</td></tr><tr><td>%T</td><td>24 小时的时间形式（hh:mm:ss）</td></tr><tr><td>%r</td><td>12 小时的时间形式（hh:mm:ssAM 或 hh:mm:ssPM）</td></tr><tr><td>%p</td><td>AM 或 PM</td></tr><tr><td>%W</td><td>一周中每一天的名称（Sunday,Monday,…,Saturday）</td></tr><tr><td>%a</td><td>一周中每一天名称的缩写（Sun,Mon,…,Sat）</td></tr><tr><td>%d</td><td>两位数字表示月中的天数（00,01,…,31）</td></tr><tr><td>%e</td><td>数字形式表示月中的天数（1,2，…,31）</td></tr><tr><td>%D</td><td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td></tr><tr><td>%w</td><td>以数字形式表示周中的天数（0=Sunday,1=Monday,…,6=Saturday）</td></tr><tr><td>%j</td><td>以 3 位数字表示年中的天数（001,002,…,366）</td></tr><tr><td>%U</td><td>周（0,1,52），其中 Sunday 为周中的第一天</td></tr><tr><td>%u</td><td>周（0,1,52），其中 Monday 为周中的第一天</td></tr><tr><td>%M</td><td>月名（January,February,…,December）</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表：MYSQL中的时间间隔类型</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式类型</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>HOUR</td><td>小时</td><td>hh</td></tr><tr><td>MINUTE</td><td>分</td><td>mm</td></tr><tr><td>SECOND</td><td>秒</td><td>ss</td></tr><tr><td>YEAR</td><td>年</td><td>YY</td></tr><tr><td>MONTH</td><td>月</td><td>MM</td></tr><tr><td>DAY</td><td>日</td><td>DD</td></tr><tr><td>YEAR_MONTH</td><td>年和月</td><td>YY-MM</td></tr><tr><td>DAY_HOUR</td><td>日和小时</td><td>DD hh</td></tr><tr><td>DAY_MINUTE</td><td>日和分钟</td><td>DD hh:mm</td></tr><tr><td>DAY_ SECOND</td><td>日和秒</td><td>DD hh:mm:ss</td></tr><tr><td>HOUR_MINUTE</td><td>小时和分</td><td>hh:mm</td></tr><tr><td>HOUR_SECOND</td><td>小时和秒</td><td>hh:ss</td></tr><tr><td>MINUTE_SECOND</td><td>分钟和秒</td><td>mm:ss</td></tr></tbody></table><h3 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4.流程函数"></a>4.流程函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value,t f)</td><td>如果 value 是真，返回 t；否则返回 f</td></tr><tr><td>IFNULL(value1,value2)</td><td>如果 value1 不为空返回 value1，否则返回 value2</td></tr><tr><td>CASE WHEN [value1]  THEN[result1]…ELSE[default]END</td><td>如果 value1 是真，返回 result1，否则返回 default</td></tr><tr><td>CASE [expr] WHEN [value1]<br>THEN[result1]…ELSE[default]END</td><td>如果 expr 等于 value1，返回 result1，否则返回 default</td></tr></tbody></table><h3 id="5-其他函数"><a href="#5-其他函数" class="headerlink" title="5.其他函数"></a>5.其他函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>DATABASE()</td><td>返回当前数据库名</td></tr><tr><td>VERSION()</td><td>返回当前数据库版本</td></tr><tr><td>USER()</td><td>返回当前登录用户名</td></tr><tr><td>INET_ATON(IP)</td><td>返回 IP 地址的数字表示</td></tr><tr><td>INET_NTOA(num)</td><td>返回数字代表的 IP 地址</td></tr><tr><td>PASSWORD(str)</td><td>返回字符串 str 的加密版本</td></tr><tr><td>MD5()</td><td>返回字符串 str 的 MD5 值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_基础</title>
      <link href="/2019/03/SQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/03/SQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><p>(1) DDL(Data Definition Languages):数据定义语言：不同的数据段、数据库、表、列、索引等数据库对象的定义（create、drop、alter）</p><p>(2) DML (Data Manipulation Language)：数据操纵语句：增删改查(inset、delete、select)</p><p>(3) DCL(Data Control Language) :数据控制语句：数据库、表、字段、用户的访问权限和安全级别。</p><a id="more"></a><h3 id="1-DDL数据定义语句"><a href="#1-DDL数据定义语句" class="headerlink" title="1.DDL数据定义语句"></a>1.DDL数据定义语句</h3><pre><code>对数据库内部的对象进行创建、删除、修改的操作语言。涉及表的定义，结构的修改。</code></pre><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><br><strong>CREATE DATABASE</strong> dbname<br><br></td><td>创建数据库</td></tr><tr><td><br><strong>SHOW databases/tables</strong><br><br></td><td>查看系统存在哪些数据库/数据表</td></tr><tr><td><br><strong>USE</strong> dbname<br><br></td><td>选择数据库</td></tr><tr><td><br><strong>DROP DATABASE</strong> dbname<br><br></td><td>删除数据库</td></tr><tr><td><br><strong>DROP TABLE</strong> tablename<br><br></td><td>删除表</td></tr><tr><td><br><strong>CREATE TABLE</strong> tablename <br> (<br> column_name_1 column_type_1 constraints，<br> column_name_2 column_type_2 constraints ， ……<br> column_name_n column_type_n<br> constraints<br> )<br><br></td><td>创建数据库</td></tr><tr><td><br><strong>DESC</strong> tablename<br><br></td><td>查看表定义</td></tr><tr><td><br><strong>SHOW CREATE TABLE</strong> tablename \G<br><br></td><td>查看更详细的表定义,\G表示使字段按照顺序竖着排列</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename<br>  <strong>MODIFY</strong> [COLUMN] column_definition<br> [FIRST &#124; AFTER col_name]<br><br></td><td>修改表类型</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename<br> <strong>ADD</strong> [COLUMN] column_definition<br> [FIRST &#124; AFTER col_name]<br><br></td><td>增加表字段</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename <br><strong>DROP</strong> [COLUMN] col_name<br><br></td><td>删除表字段</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename<br> <strong>CHANGE</strong> [COLUMN] old_col_name column_definition<br> [FIRST&#124;AFTER col_name]<br><br></td><td>字段改名</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename<br> <strong>RENAME</strong> [TO] new_tablename<br><br></td><td>表改名</td></tr></tbody></table><h3 id="2-DML数据操纵语句"><a href="#2-DML数据操纵语句" class="headerlink" title="2.DML数据操纵语句"></a>2.DML数据操纵语句</h3><pre><code>DML 操作是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select）</code></pre><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><br><strong>INSERT INTO</strong> tablename (field1,field2,……fieldn)<br> <strong>VALUES</strong>(value1,value2,……valuesn);<br><br></td><td>插入记录</td></tr><tr><td><br><strong>UPDATE</strong> tablename<br> <strong>SET</strong> field1=value1，field2.=value2，……fieldn=valuen<br> [WHERE CONDITION]<br><br></td><td>更新记录</td></tr><tr><td><br><strong>DELETE FROM</strong> tablename<br> [<strong>WHERE</strong> CONDITION]<br><br></td><td>删除记录</td></tr><tr><td><br><strong>SELECT * FROM</strong> tablename<br> [<strong>WHERE</strong> CONDITION]<br><br></td><td>查询记录</td></tr><tr><td><br><strong>SELECT DISTINCT</strong> column_name<br>  <strong>FROM</strong> tablename<br> [<strong>WHERE</strong> CONDITION]<br><br></td><td>查询不重复的记录</td></tr><tr><td><br><strong>SELECT * FROM</strong> tablename<br>   [<strong>WHERE</strong> CONDITION]<br> [<strong>ORDER BY</strong><br>        field1 [<strong>DESC &#124; ASC</strong>],<br>        field2[DESC &#124; ASC],<br>  ……fieldn [DESC&#124;ASC]<br> [<strong>LIMIT</strong> offset_start,row_count]<br><br></td><td>排序限制</td></tr><tr><td><br><strong>SELECT</strong> [field1,field2,……fieldn]  fun_name<br><strong>FROM</strong> tablename<br>[<strong>WHERE</strong> where_contition]<br>[<strong>GROUP BY</strong> field1,field2,……fieldn<br>[<strong>WITH ROLLUP</strong>]]<br>[<strong>HAVING</strong> where_contition]<br><br></td><td>聚合操作group by /having</td></tr><tr><td><br><strong>SELECT</strong> ename,deptname<br>  <strong>FROM</strong> dept<br><strong>RIGHT JOIN[LEFT JOIN]</strong> emp<br> <strong>ON</strong> dept.deptno=emp.deptno;<br><br></td><td>右连接right join 左连接left join</td></tr><tr><td><br><strong>in、not in、=、!=、exists、not exists</strong><br></td><td>子查询</td></tr><tr><td><br><strong>SELECT * FROM</strong> t1<br><strong>UNION&#124;UNION ALL</strong><br><strong>SELECT * FROM</strong> t2<br>……<br><strong>UNION&#124;UNION ALL</strong><br><strong>SELECT * FROM</strong> tn;<br><br></td><td>记录联合</td></tr></tbody></table><h3 id="3-DCL数据控制语句"><a href="#3-DCL数据控制语句" class="headerlink" title="3.DCL数据控制语句"></a>3.DCL数据控制语句</h3><pre><code>DCL 语句主要是 DBA 用来管理系统中的对象权限时所使用</code></pre><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><br><strong>grant select,insert</strong> <strong>on</strong><br> sakila.* <strong>to</strong><br> ‘z1‘@’localhost’ identified by ‘123’<br><br></td><td>创建一个数据库用户 z1，具有对 sakila 数据库中所有表的 SELECT/INSERT 权限</td></tr><tr><td><br><strong>revoke insert on</strong> sakila.* from ‘z1‘@’localhost’;<br><br></td><td>将z1 的权限变更，收回 INSERT，只能对数据进行 SELECT 操作</td></tr></tbody></table><h3 id="4-帮助的使用"><a href="#4-帮助的使用" class="headerlink" title="4.帮助的使用"></a>4.帮助的使用</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><strong>？contents</strong></td><td>显示所有可供查询的的分类</td></tr><tr><td>？ data types</td><td>Mysql支持的数据类型</td></tr><tr><td>？ show</td><td>…</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h3 id="5-MYSQL支持的数据类型"><a href="#5-MYSQL支持的数据类型" class="headerlink" title="5.MYSQL支持的数据类型"></a>5.MYSQL支持的数据类型</h3><blockquote><p>(1)数值型</p><pre><code>整数：tinyint  smallint  mediumint  int/integer  bigint 浮点数：float  double 定点数：dec(m,d) decimal(m,d):m表示长度，d表示小数位数位：bit</code></pre><p>(2)字符串类型</p><pre><code>date  datetime  timestamp  time  year</code></pre><p>(3)日期和时间类型</p><pre><code>整数：char   varchar字节：tinyblob   blob   mediumblob   longblob  tinytext   text mediumtext   longtext   varbinary  binary</code></pre></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/sql数值型.png" alt="sql数值型类型"></p><p><img src="https://github.com/qiulig/IMG/raw/master/sql字符串类型.png" alt="sql字符串类型"></p><p><img src="https://github.com/qiulig/IMG/raw/master/sql日期和时间类型.png" alt="日期和时间类型"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sprintboot中的数据库注解</title>
      <link href="/2019/03/sprintboot%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/03/sprintboot%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@Results                 —-表字段与数据库字段映射</p><p>@Entity                    —- 生成表</p><p>@Transient              —-后台与数据库不映射</p><p>@Id                            —-主键</p><p>@Transactional        —-事务</p><a id="more"></a><p>@GeneratedValuestrategy=GenerationType.IDENTITY   —–自增值</p><p>@Table - 映射表名   —– 映射表名</p><p>@Column(name = “dict_name”,columnDefinition=”varchar(100) COMMENT ‘字典名’”)                           —– 字段名、类型、注释</p><p>@Select</p><p>@Update</p><p>@Delete</p><p>@Insert</p><p>@UpdateTimestamp  —— 更新时自动更新时间</p><p>@CreationTimestamp ——创建时自动更新时间</p><p>@Version                       —– 版本号，更新时自动加1</p><h5 id="1-Entity"><a href="#1-Entity" class="headerlink" title="1.@Entity"></a>1.@Entity</h5><p>@Entity说明这个class是实体类，并且使用默认的orm规则，即class名即数据库表中表名，class字段名即表中的字段名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDetail</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String detailId;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal productPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer productQuantity;</span><br><span class="line">    <span class="keyword">private</span> String productIcon;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span>  Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行将对应生成数据库表名为OrderDetail的表，里面字段对应上面的字段。</p><h5 id="2-DynamicUpdate"><a href="#2-DynamicUpdate" class="headerlink" title="2.@DynamicUpdate"></a>2.@DynamicUpdate</h5><p>动态更新表。</p><p>如果我们在更新表时,只想更新某个字段,就不要加 @DynamicUpdate,通常为了更新表时的效率,都是不加的.反之,如果我们更新某个字段时,更新所有的字段,就可以加上 @DynamicUpdate.</p><p>@DynamicUpdate属性:设置为true,设置为true,表示update对象的时候,生成动态的update语句,如果这个字段的值是null就不会被加入到update语句中,默认false。<br>比如只想更新某个属性，但是却把整个对象的属性都更新了，这并不是我们希望的结果，我们希望的结果是：我更改了哪些字段，只要更新我修改的字段就够了。</p><h5 id="3-Table"><a href="#3-Table" class="headerlink" title="3.@Table"></a>3.@Table</h5><p>@Table注解用来标识实体类与数据表的对应关系，默认和类名一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"c_user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Id</span></span><br><span class="line">        <span class="meta">@GeneratedValue</span></span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Column</span>(length = <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Column</span>(length = <span class="number">20</span> , unique = <span class="keyword">true</span>, nullable = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">private</span> Long mobile;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Column</span>(length = <span class="number">20</span> , unique = <span class="keyword">true</span>)</span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Column</span>(columnDefinition=<span class="string">"tinyint"</span>)</span><br><span class="line">        <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickname;</span><br><span class="line">        <span class="keyword">private</span> Integer companyId;</span><br><span class="line">        <span class="keyword">private</span> Integer departmentId;</span><br><span class="line">        <span class="keyword">private</span> Date regTime;</span><br><span class="line">        <span class="keyword">private</span> String regIp;</span><br><span class="line">        <span class="keyword">private</span> Integer loginNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-Column"><a href="#4-Column" class="headerlink" title="4. @Column"></a>4. @Column</h5><p>@Column注解来标识实体类中属性与数据表中字段的对应关系。共有10个属性，这10个属性均为可选属性：</p><ul><li>name属性定义了被标注字段在数据库表中所对应字段的名称；</li><li>unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。</li><li>nullable属性表示该字段是否可以为null值，默认为true。如果属性里使用了验证类里的@NotNull注释，这个属性可以不写。</li><li>insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。</li><li>updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。</li><li>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。若不指定该属性，通常使用默认的类型建表，若此时需要自定义建表的类型时，可在该属性中设置。（也就是说，如果DB中表已经建好，该属性没有必要使用。）</li><li>table属性定义了包含当前字段的表名。</li><li>length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。</li><li>precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。</li></ul><h5 id="5-Transactional-事务"><a href="#5-Transactional-事务" class="headerlink" title="5.@Transactional 事务"></a>5.@Transactional 事务</h5><h5 id="Transactional-注解的属性信息"><a href="#Transactional-注解的属性信息" class="headerlink" title="@Transactional 注解的属性信息"></a>@Transactional 注解的属性信息</h5><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td></tr><tr><td>propagation</td><td>事务的传播行为，默认值为 REQUIRED。</td></tr><tr><td>isolation</td><td>事务的隔离度，默认值采用 DEFAULT。</td></tr><tr><td>timeout</td><td>事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td>read-only</td><td>指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td></tr><tr><td>rollback-for</td><td>用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td></tr><tr><td>no-rollback- for</td><td>抛出 no-rollback-for 指定的异常类型，不回滚事务。</td></tr></tbody></table><h5 id="6-Transient"><a href="#6-Transient" class="headerlink" title="6.@Transient"></a>6.@Transient</h5><p>@Transient是希望该属性不会在数据表中产生字段，但又可以在程序中使用它。</p><h5 id="7-Results"><a href="#7-Results" class="headerlink" title="7.@Results"></a>7.@Results</h5><p>(1)当数据库字段名与实体类对应的属性名不一致时，可以使用@Results映射来将其对应起来。column为数据库字段名，porperty为实体类属性名，jdbcType为数据库字段数据类型，id为是否为主键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>(2)@ResultMap的用法。当这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student where id = #&#123;id&#125;"</span>&#125;)</span><br><span class="line"><span class="meta">@ResultMap</span>(value=<span class="string">"studentMap"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">selectById</span><span class="params">(integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>(3)@One的用法。当我们需要通过查询到的一个字段值作为参数，去执行另外一个方法来查询关联的内容，而且两者是一对一关系时，可以使用@One注解来便捷的实现。比如当我们需要查询学生信息以及其所属班级信息时，需要以查询到的class_id为参数，来执行ClassesMapper中的selectById方法，从而获得学生所属的班级信息。可以使用如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Select(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"myClass"</span>, javaType=MyClass.class,</span><br><span class="line"> one=<span class="meta">@One</span>(select=<span class="string">"com.mapper.MyClassMapper.selectById"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAllAndClassMsg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>（4）@Many的用法。与@One类似，只不过如果使用@One查询到的结果是多行，会抛出TooManyResultException异常，这种时候应该使用的是@Many注解，实现一对多的查询。比如在需要查询学生信息和每次考试的成绩信息时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"gradeList"</span>, javaType=List.class,</span><br><span class="line"> many=<span class="meta">@Many</span>(select=<span class="string">"com.example.demo.mapper.GradeMapper.selectByStudentId"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAllAndGrade</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>（5）传递多个参数。首先我们给这张表增加age（年龄）和gender（性别）两个参数。当我们需要根据age和gender查询学生的午餐，这时需要改写column属性的格式。等号左侧的age和gender对应java接口的参数，右侧的对应数据库字段名。即将查到的my_student表中age和gender字段的值，分别赋给getLunchByAgeAndGender方法中的age和gender参数，去查询对应的name（午餐名）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select id, name, age, gender from my_student"</span>)</span><br><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"&#123;age=age,gender=gender&#125;"</span>, property=<span class="string">"lunch"</span>,</span><br><span class="line"> one=<span class="meta">@One</span>(select=<span class="string">"com.example.demo.mapper.StudentMapper.getLunchByAgeAndGender"</span>)),</span><br><span class="line"> &#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAllAndLunch</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select name from lunch where student_age = #&#123;age&#125; and student_gender = #&#123;gender&#125;"</span>)</span><br><span class="line"><span class="function">String <span class="title">getLunchByAgeAndGender</span><span class="params">(@Param(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age, @<span class="title">Param</span><span class="params">(<span class="string">"gender"</span>)</span> <span class="keyword">int</span> gender)</span>;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis_数据的持久化</title>
      <link href="/2019/03/redis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2019/03/redis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><a id="more"></a><h5 id="1-RDB-持久化"><a href="#1-RDB-持久化" class="headerlink" title="1.RDB 持久化"></a>1.RDB 持久化</h5><p>RDB是redis默认的持久化机制。RDB相当于快照，保存的是一种状态。默认文件名是dump.rdb。</p><blockquote><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p></blockquote><h5 id="2-AOF-持久化"><a href="#2-AOF-持久化" class="headerlink" title="2.AOF 持久化"></a>2.AOF 持久化</h5><p>由于快照方式是在一定时间间隔内做一次，所以如果redis意外down掉，就会丢失最后一次快照所有的修改，如果应用要求不能丢失任何修改的话，可以采用AOF。</p><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table><thead><tr><th>选项</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个写命令都同步</td></tr><tr><td>everysec</td><td>每秒同步一次</td></tr><tr><td>no</td><td>让操作系统来决定何时同步</td></tr></tbody></table><p>always 选项会严重减低服务器的性能；</p><p>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</p><p>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</p><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis.数据的淘汰机制</title>
      <link href="/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis 具体有 6 种淘汰策略：<a id="more"></a></p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td>allkeys-lru</td><td>从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据集中任意选择数据进行淘汰</td></tr><tr><td>noeviction</td><td>禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis与memcached</title>
      <link href="/2019/03/redis%E4%B8%8Ememcached/"/>
      <url>/2019/03/redis%E4%B8%8Ememcached/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Memcached介绍"><a href="#Memcached介绍" class="headerlink" title="Memcached介绍"></a>Memcached介绍</h3><p>Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。<a id="more"></a></p><p>memcached作为高速运行的分布式缓存服务器，具有以下的特点。</p><ul><li>协议简单</li><li>基于libevent的事件处理</li><li>内置内存存储方式</li><li>memcached不互相通信的分布式</li></ul><p>与数据库协同合作的过程：</p><blockquote><p>   1.检查用户请求的数据是缓存中是否有存在，如果有存在的话，只需要直接把请求的数据返回，无需查询数据库. </p><p>2.如果请求的数据在缓存中找不到，这时候再去查询数据库。返回请求数据的同时，把数据存储到缓存中一份。<br>   3.保持缓存的“新鲜性”，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据.</p></blockquote><h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。</p><p>区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。</p><p>Redis作为一个高性能的key-value数据库具有以下特征：  </p><ul><li>多样的数据模型</li><li>持久化</li><li>基于内存存储方式</li><li>主从同步</li></ul><p><strong>综合结论</strong></p><p>应该说Memcached和Redis都能很好的满足解决我们的问题，它们性能都很高，总的来说，可以把Redis理解为是对Memcached的拓展，是更加重量级的实现，提供了更多更强大的功能。</p><p>两者都是非关系型内存键值数据库，主要有以下不同：</p><h3 id="Memcached与redis区别"><a href="#Memcached与redis区别" class="headerlink" title="Memcached与redis区别"></a>Memcached与redis区别</h3><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h4><blockquote><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p></blockquote><h5 id="2-数据持久化"><a href="#2-数据持久化" class="headerlink" title="2.数据持久化"></a>2.数据持久化</h5><blockquote><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p></blockquote><h5 id="3-分布式"><a href="#3-分布式" class="headerlink" title="3.分布式"></a>3.分布式</h5><blockquote><p>Memcached 不支持分布式，只能通过在<strong>客户端</strong>使用<strong>一致性哈希</strong>来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis则在<strong>服务器端</strong>构建分布式存储。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，各个节点地位一致，具有线性可伸缩的功能。其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个 key的数值域分成16384个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是16384。</p></blockquote><h5 id="4-内存管理机制"><a href="#4-内存管理机制" class="headerlink" title="4.内存管理机制"></a>4.内存管理机制</h5><blockquote><p>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，这样能保证数据的持久性。而 Memcached 的数据则会一直在内存中(断电会挂掉，数据不能超过内存)。</p></blockquote><h5 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h5><blockquote><p>Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息)</p><p>Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据类型</title>
      <link href="/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型<a id="more"></a></h3><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th style="text-align:center">操作</th><th></th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td style="text-align:center">对整个字符串或者字符串的其中一部分执行操作</td><td>对整数和浮点数执行自增或者自减操作</td></tr><tr><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td>LIST</td><td>列表</td><td style="text-align:center">从两端压入或者弹出元素</td><td>对单个或者多个元素，进行修剪，只保留一个范围内的元素</td></tr><tr><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td>SET</td><td>无序集合</td><td style="text-align:center">添加、获取、移除单个元素</td><td>检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td></tr><tr><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td style="text-align:center">添加、获取、移除单个键值对</td><td>获取所有键值对；检查某个键是否存在</td></tr><tr><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td>ZSET</td><td>有序集合</td><td style="text-align:center">添加、获取、删除元素</td><td>根据分值范围或者成员来获取元素；计算一个键的排名</td></tr></tbody></table><h3 id="1-1Redis的键Key"><a href="#1-1Redis的键Key" class="headerlink" title="1.1Redis的键Key"></a>1.1Redis的键Key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; DEL key            删除键</span><br><span class="line">&gt; EXISTS key         判断key是否存在</span><br><span class="line">&gt; DUMP key           序列化key</span><br><span class="line">&gt; EXPIRE key seconds 给key设置过期时间</span><br><span class="line">&gt; TTL key            key的生存剩余时间（秒为单位）</span><br><span class="line">&gt; PTTL key           key的生存剩余时间(毫秒单位)</span><br><span class="line">&gt; PERSIST key        移除key的过期时间，将持久保留</span><br><span class="line">&gt; KEYS pattern       查找所有符合给定模式的key(* 所有 ？一个字符)</span><br><span class="line">&gt; RANDOM key         从当前数据库随机返回一个key</span><br><span class="line">&gt; RENAME key newkey  修改key名称</span><br><span class="line">&gt; MOVE key db        当前数据库移动到给定数据库中</span><br></pre></td></tr></table></figure><h5 id="key的应用场景"><a href="#key的应用场景" class="headerlink" title="key的应用场景"></a>key的应用场景</h5><blockquote><p>(1)限时的活动信息</p><p>(2)网站的数据缓存(对于一些要定时更新的数据如积分排行榜)</p><p>(3)手机验证码</p><p>(4)限制网站的访问频率</p></blockquote><h3 id="1-2-Redis的值value"><a href="#1-2-Redis的值value" class="headerlink" title="1.2 Redis的值value"></a>1.2 Redis的值value</h3><h3 id="1-2-1-String类型"><a href="#1-2-1-String类型" class="headerlink" title="1.2.1 String类型"></a>1.2.1 String类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET key_name value       设置给定key的值(key存在则覆盖，不存在则新建)</span><br><span class="line">&gt; SETNX key_name value     设置给定key的值(key不存在时)</span><br><span class="line">&gt; GET key_name             取值</span><br><span class="line">&gt; GETRANGE key start end   字符串截取</span><br><span class="line">&gt; GETBIT key offset        对key所存储的字符串值，获取指定偏移量上的位</span><br><span class="line">&gt; MGET key1 [key2..]       获取一个或多个key的值</span><br><span class="line">&gt; GETSET key_name value    设置key值，并返回key的旧值</span><br><span class="line">&gt; STRLEN key               获取长度</span><br><span class="line">&gt; DEL key_name             删除</span><br><span class="line">&gt; INCR key_name            自增</span><br><span class="line">&gt; DECR key_name            自减 </span><br><span class="line">&gt; APPEND key_name value    字符串拼接</span><br></pre></td></tr></table></figure><h5 id="string应用场景"><a href="#string应用场景" class="headerlink" title="string应用场景"></a>string应用场景</h5><blockquote><p>1.String通常用于<strong>保存单个字符串或JSON字符串数据</strong></p><p>2.因string是二进制安全的，所以你完全可以把一个<strong>图片文件</strong>的内容作为字符串来<strong>存储</strong></p><p>3.<strong>计数器</strong>(常规key-value缓存应用。(常规计数:微博数,粉丝数)</p><p>INCR等指令本身就具有<strong>原子操作</strong>的特性,所以我们完全可以利用redis的INCR.INCRBY.DECR，DECRBY等指令来实现原子计数的效果。不少网站都利用redis的这个特性来<strong>实现业务上的统计计数需求</strong>。</p></blockquote><h3 id="1-2-2-List类型"><a href="#1-2-2-List类型" class="headerlink" title="1.2.2 List类型"></a>1.2.2 List类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; LPUSH key value1[value2]  将一个或多个值插入列表头部</span><br><span class="line">&gt; RPUSH key value1[value2]  将一个或多个值插入列表尾部</span><br><span class="line">&gt; LPUSHX key value          将一个或多个值插入列表头部，列表不存在则操作无效             </span><br><span class="line">&gt; RPUSHX key value          将一个或多个值插入列表尾部，列表不存在则操作无效</span><br><span class="line">&gt; LLEN key                  获取列表长度</span><br><span class="line">&gt; LINDEX key index          通过索引获取列表元素</span><br><span class="line">&gt; LRANGE key start stop     获取列表指定范围内的元素</span><br><span class="line">&gt; LPOP key                  左移除</span><br><span class="line">&gt; RPOP key                  右移除</span><br><span class="line">&gt; BLPOP key1[key2] timeout  移除并获取列表的第一个元素，没有元素就会阻塞队列    </span><br><span class="line">                            直到等待超时或发现可弹出元素</span><br></pre></td></tr></table></figure><h5 id="list应用场景"><a href="#list应用场景" class="headerlink" title="list应用场景"></a>list应用场景</h5><blockquote><p>1、<strong>对数据量大的集合数据删减 </strong></p><p>列表数据显示<strong>关注列表、粉丝列表、留言评价等. .分页、热点新闻(Top5)等</strong> 利用LRANGE还可以很方便的实现分页的功能,在博客系统中，每片博文的评论也可以用到。</p><p>2、<strong>任务队列 </strong></p><p>(list通常用来实现一个消息队列,而且可以确保先后顺序,不必像MySQL那样还需要通过ORDERBY来进行排序)</p><p>任务队列介绍(生产者和消费者模式):</p><p>在处理Web客户端发送的命令请求时,某些操作的执行时间可能会比我们预期的更长一些，通过将待执行任务的相关信息放入队列里面，并在之后对队列进行处理,用户可以推迟执行那些需要一段时间才能能完成的操作,这种将工作交给任务处理器来执行的做法被称为任务队列(task queue)。</p><p><strong>RPOPLPUSH source destination </strong></p><p>移除列表的最后一个元素，并将该元素添加到另一个列表并返回示例描述:</p><p>常用案例:订单系统的下单流程、用户系统登录注册短信等</p></blockquote><h3 id="1-2-3-Hash类型"><a href="#1-2-3-Hash类型" class="headerlink" title="1.2.3 Hash类型"></a>1.2.3 Hash类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; HSET key field value                 为指定的key,设定field/value</span><br><span class="line">&gt; HMSET key field value[field1,value]  同时将多个field-value 设到key中</span><br><span class="line">&gt; HGET key field                       根据field等待value </span><br><span class="line">&gt; HMGET key field[field1]              获取key所有给定字段的值</span><br><span class="line">&gt; HGETALL key                          返回hash表所有字段和值</span><br><span class="line">&gt; HKEYS key                            获取哈希表中的字段</span><br><span class="line">&gt; HLEN key                             获取哈希表中字段的数量</span><br><span class="line">&gt; HDEL key field[field2]               删除一个或多个hash表字段</span><br><span class="line">&gt; HSETNX key field value               只有在字段不存在时，设置字段值</span><br><span class="line">&gt; HINCRBY key field increment          key中指定字段的整数值加增量</span><br><span class="line">&gt; HINCRBYFLOAT key field increment     指定字段的浮点数加增量</span><br><span class="line">&gt; HEXISTS key field                    指定字段是否存在</span><br></pre></td></tr></table></figure><h5 id="hash应用场景"><a href="#hash应用场景" class="headerlink" title="hash应用场景"></a>hash应用场景</h5><blockquote><p>Hash的应用场景:(存储个用户信息对象数据)</p><p>1、 <strong>常用于存储一个对象 </strong></p><p>2、 <strong>为什么不用string存储一个对象? </strong></p><p>hash是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。</p><p>用户ID为查找的key,存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式:</p><p><code>(1)用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时, 需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</code></p><p><code>(2)这个用户信息对象有多少成员就存成多少个key-value对,用用户ID+对应属性的名称作为唯一标识来取得对应属性的值,虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是不可观的。</code></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><p>Redis提供的Hash很好的解决了这个问题，Redis 的Hash实际是内部存储的Value为一个Hashmap,并提供了直接存取这个Map成员的接口</p></blockquote><h3 id="1-2-4-Set类型"><a href="#1-2-4-Set类型" class="headerlink" title="1.2.4 Set类型"></a>1.2.4 Set类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">赋值语句</span><br><span class="line">&gt; SADD key member1[member2]        添加一个或多个成员</span><br><span class="line">取值语句</span><br><span class="line">&gt; SCARD key                           获取成员数</span><br><span class="line">&gt; SMEMBERS key                        返回集合中的所有成员</span><br><span class="line">&gt; SISMEMBER key member                判断是否存在</span><br><span class="line">&gt; SRANDMEMBER key [count]             返回集合中一个或多个随机数</span><br><span class="line">删除语句</span><br><span class="line">&gt; SREM key member                     移除一个或多个</span><br><span class="line">&gt; SPOP key[count]                     移除并返回集合中的一个随机元素</span><br><span class="line">&gt; SMOVE source destination member     将member从source移到destination</span><br><span class="line">差集语句</span><br><span class="line">&gt; SDIFF key1[key2]                    返回给定集合的差集(左侧)</span><br><span class="line">&gt; SDIFFSTORE destination key1[key2]   返回差集并存到destina.</span><br><span class="line">交集语句</span><br><span class="line">&gt; SINTER key1 [key2]                  返回给定集合的交集</span><br><span class="line">&gt; SINTERSTORE destination key1[key2]  返回交集并存到destination</span><br><span class="line">并集</span><br><span class="line">&gt; SUNION key1[key2]                    返回并集</span><br><span class="line">&gt; SUNIONSTORE destination key1[key2]  返回并集并存储在destination</span><br></pre></td></tr></table></figure><h5 id="set应用场景"><a href="#set应用场景" class="headerlink" title="set应用场景"></a>set应用场景</h5><blockquote><p>常应用于:对两个集合间的数据[计算]进行交集、并集、差集运算</p><p><code>1、以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作,你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。</code></p><p><code>2、利用唯一性，可以统计访问网站的所有独立IP</code></p></blockquote><h3 id="1-2-5-Zset类型"><a href="#1-2-5-Zset类型" class="headerlink" title="1.2.5 Zset类型"></a>1.2.5 Zset类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">赋值语句</span><br><span class="line">&gt; ZADD key score1 member1[score member2]  添加一个或多个成员</span><br><span class="line">取值语句</span><br><span class="line">&gt; ZCARD key                               获取成员数</span><br><span class="line">&gt; ZCOUNT key min max                      计算集合中指定区间分数的成员数</span><br><span class="line">&gt; ZRANK key member                        返回有序集合中指定成员索引</span><br><span class="line">&gt; ZRANGE key start stop[WITHSCORES]       返回指定区间内成员[低到高]</span><br><span class="line">&gt; ZREVRANGE key start stop[WITHSCORES]    返回指定区间内成员[高到低]</span><br><span class="line">删除语句</span><br><span class="line">&gt; ZREM key member[member...]              移除有序集合中的一个或多个成员</span><br></pre></td></tr></table></figure><h5 id="Zset应用场景"><a href="#Zset应用场景" class="headerlink" title="Zset应用场景"></a>Zset应用场景</h5><blockquote><p>常应用于:<code>排行榜</code></p><p>1)比如twitter的public timeline可以以发表时间作为score来存储,这样获取时就是自动按时间排好序的。</p><p>2)比如一个存储全班同学成绩的Sorted Set, 其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。</p><p>3还可以用Sorted Set来做带权重的队列，比如普通消息的score为1,重要消息的score为2,然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p></blockquote><table><thead><tr><th>字符</th><th>重新定义的ASCII码</th><th>字符</th><th>重新定义的ASCII码</th><th>字符</th><th>重新定义的ASCII码</th></tr></thead><tbody><tr><td>A</td><td>32</td><td>L</td><td>54</td><td>v</td><td>75</td></tr><tr><td>a</td><td>33</td><td>l</td><td>55</td><td>W</td><td>76</td></tr><tr><td>B</td><td>34</td><td>M</td><td>56</td><td>w</td><td>77</td></tr><tr><td>b</td><td>35</td><td>m</td><td>57</td><td>X</td><td>78</td></tr><tr><td>C</td><td>36</td><td>N</td><td>58</td><td>x</td><td>79</td></tr><tr><td>c</td><td>37</td><td>n</td><td>59</td><td>Y</td><td>80</td></tr><tr><td>D</td><td>38</td><td>O</td><td>60</td><td>y</td><td>81</td></tr><tr><td>d</td><td>39</td><td>o</td><td>61</td><td>Z</td><td>82</td></tr><tr><td>E</td><td>40</td><td>P</td><td>62</td><td>z</td><td>83</td></tr><tr><td>e</td><td>41</td><td>p</td><td>63</td><td>0</td><td>84</td></tr><tr><td>F</td><td>42</td><td>Q</td><td>64</td><td>1</td><td>85</td></tr><tr><td>f</td><td>43</td><td>q</td><td>65</td><td>2</td><td>86</td></tr><tr><td>G</td><td>44</td><td>R</td><td>66</td><td>3</td><td>87</td></tr><tr><td>g</td><td>45</td><td>r</td><td>67</td><td>4</td><td>88</td></tr><tr><td>H</td><td>46</td><td>S</td><td>68</td><td>5</td><td>89</td></tr><tr><td>h</td><td>47</td><td>s</td><td>69</td><td>6</td><td>90</td></tr><tr><td>I</td><td>48</td><td>T</td><td>70</td><td>7</td><td>91</td></tr><tr><td>i</td><td>49</td><td>t</td><td>71</td><td>8</td><td>92</td></tr><tr><td>J</td><td>50</td><td>U</td><td>72</td><td>9</td><td>93</td></tr><tr><td>j</td><td>51</td><td>u</td><td>73</td><td></td><td></td></tr><tr><td>K</td><td>52</td><td>V</td><td>74</td><td></td><td></td></tr><tr><td>k</td><td>53</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis应用场景</title>
      <link href="/2019/03/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/03/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.概述</p><blockquote><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。<a id="more"></a></p></blockquote><blockquote><p><strong>键(key)</strong>的类型只能为<strong>字符串(String)</strong>，<strong>值(value)</strong>支持五种数据类型：<strong>字符串(String)、列表(list)、集合(set)、有序集合(zset)、哈希(hash)。</strong></p></blockquote><blockquote><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p></blockquote><h5 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h5><blockquote><p>（1）<strong>缓存</strong>：Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；</p><p>（2）<strong>排行榜</strong>：利用Redis的SortSet数据结构能够非常方便搞定；</p><p>（3）<strong>计算器/限速器</strong>：利用Redis中<strong>原子性的自增操作</strong>，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有<strong>抢购</strong>时，防止用户疯狂点击带来不必要的压力；</p><p>注：限速器也是对请求限流的一种实现方式。</p><p>（4）<strong>好友关系</strong>：利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；</p><p>（5）<strong>简单消息队列</strong>：除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；不过最好用kafka、RabbitMQ等消息中间件。</p><p>（6）<strong>Session共享</strong>：默认Session是保存在服务器的文件中，即当前服务器，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。</p></blockquote><h5 id="Redis优点："><a href="#Redis优点：" class="headerlink" title="Redis优点："></a>Redis优点：</h5><blockquote><ul><li>速度快，完全基于内存；</li><li>使用C语言实现，网络层使用epoll解决高并发问题；</li><li>单线程模型避免了不必要的上下文切换及竞争条件；</li></ul></blockquote><h5 id="Redis的缺点："><a href="#Redis的缺点：" class="headerlink" title="Redis的缺点："></a>Redis的缺点：</h5><blockquote><p>滥用可能导致系统的不稳定、成本增高等问题。</p><p>比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。</p><p>简单总结就是<strong>数据量太大、数据访问频率非常低的业务都不适合使用Redis</strong>。数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。如果不担心浪费资源，那请忽略。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
