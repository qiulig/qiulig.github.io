<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[volatile介绍]]></title>
    <url>%2F2019%2F05%2Fvolatile%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[并发编程的三大概念：123 (1)原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 (2)可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 (3)有序性：程序执行的顺序按照代码的先后顺序执行。 volatile介绍： 1.volatile是虚拟机提供的最轻量级的同步机制 保证变量对所有线程的可见性但是不保证原子性，需要通过加锁保证原子性。 特例： 1)运算结果并不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值 2)变量不需要与其他状态变量共同参与不变约束 2.禁止指令重排 指令重拍是指CPU采用了允许多条指令不按程序规定的顺序分开发送给各相应电路单元处理，也能得到正确的结果。]]></content>
      <categories>
        <category>JAVA虚拟机</category>
        <category>线程</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【66】机器人的运动范围]]></title>
    <url>%2F2019%2F05%2F66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[1.题目描述 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 2.解题思路 本题使用的方法同样还是回溯法，另外还需要会计算给定整数上的各个位上数之和。 (1)使用一个访问数组记录是否已经经过该格子。机器人从(0,0)开始移动，当它准备进入(i,j)的格子时，通过检查坐标的数位来判断机器人是否能够进入。 (2)如果机器人能进入(i,j)的格子，接着在判断它是否能进入四个相邻的格子(i,j-1),(i,j+1),(i-1,j),(i+1,j)。 因此，可以用回溯法来解决这一问题。 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int movingCount(int threshold, int rows, int cols) &#123; if(rows&lt;1||cols&lt;1||threshold&lt;0) &#123; return 0; &#125; boolean []visit=new boolean[rows*cols]; return count(threshold,rows,cols,visit,0,0); &#125; private static int count(int threshold, int rows, int cols, boolean[] visit, int row, int col) &#123; int res=0; if(check(threshold,rows,cols,visit,row,col)) &#123; visit[row*cols+col]=true; res=1+count(threshold,rows,cols,visit,row,col+1) +count(threshold,rows,cols,visit,row,col-1) +count(threshold,rows,cols,visit,row+1,col) +count(threshold,rows,cols,visit,row-1,col); &#125; return res; &#125; private static boolean check(int threshold, int rows, int cols, boolean[] visit, int row, int col) &#123; if (row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; visit[row * cols + col] == false &amp;&amp;getNum(col) + getNum(row) &lt;= threshold) &#123; return true; &#125; return false; &#125; //获取位数之和 private static int getNum(int num) &#123; int sum = 0; while (num &gt; 0) &#123; sum += num % 10; num /= 10; &#125; return sum; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【65】矩阵中的路径]]></title>
    <url>%2F2019%2F05%2F65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 * 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 2.解题思路 回溯法 (1)在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。 由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。 需要判断这个矩阵中的每一个结点是否可以走一条路径，在走的过程中，设置一个和矩阵大小相同的整型数组flag表示是否已经访问，如果某个结点访问了，那么该结点的是否访问则为1。每次遍历一个结点的时候，递归的方式分别向左、向右、向上、向下。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; int[] flag = new int[matrix.length]; for(int i = 0; i &lt; rows; i ++)&#123; for(int j = 0; j &lt; cols; j ++)&#123; if(helper(matrix, rows, cols, i, j, str, 0, flag))&#123; return true; &#125; &#125; &#125; return false; &#125; public boolean helper(char[] matrix, int rows, int cols, int i, int j, char[] str, int k, int[] flag)&#123; int index = i * cols + j; if(i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || matrix[index] != str[k] || flag[index] == 1)&#123; /// /下标不符合，index对应的值不为和字符数组中的不一致，或者该index已经被访问，这些情况只要有符合的就返回false // 只有上面的所有情况都不符合，也就是值相等，且没有访问过，下标不符合 return false; &#125; if(k == str.length - 1)&#123; return true; &#125; flag[index] = 1; if(helper(matrix, rows, cols, i - 1, j, str, k + 1, flag)//左 ||helper(matrix, rows, cols, i + 1, j, str, k + 1, flag)//右 ||helper(matrix, rows, cols, i, j - 1, str, k + 1, flag)//上 ||helper(matrix, rows, cols, i , j + 1, str, k + 1, flag))//下 &#123; return true; &#125; flag[index] = 0; return false; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【64】滑动窗口的最大值]]></title>
    <url>%2F2019%2F05%2F64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。 输入描述：{2,3,4,2,6,2,5,1} ，3 输出描述：{4,4,6,6,6,5} 解析： 存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 2.解题思路 我们可以使用双向队列（Linklist），队列中只存放当前元素的下标， (1)设新来的元素为k，如果前面的元素比k小，直接把前面的删除（因为不可能成为后面窗口的最大值） (2)如果前面的元素比k大，判断是否还在窗口范围内，不在则移除 以数组{2,3,4,2,6,2,5,1}为例数组的第一个数字是2，把它存入队列中。 第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。 第三个数字是4，比3大，同样的删3存4。 此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。 第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。 第五个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。 3.代码12345678910111213141516171819202122232425public static ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); if (num==null) return arr; if (num.length&lt;size||size&lt;=0) return arr; Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i&lt;num.length; i++)&#123; //如果前面的数比插入的数小，直接把前面删除(因为不可能成为后面窗口的最大值) while (!queue.isEmpty()&amp;&amp;num[i]&gt;=num[queue.getLast()]) queue.pollLast(); //如果前面的元素比k大，判断是否还在窗口范围内，不在则移除 //(i-(size-1))即滑动窗口最左侧的坐标索引 while (!queue.isEmpty()&amp;&amp;queue.getFirst()&lt;i-(size-1)) queue.pollFirst(); //加入队尾 queue.offerLast(i); if (i+1&gt;=size) arr.add(num[queue.getFirst()]); &#125; return arr;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【63】数据流中的中位数]]></title>
    <url>%2F2019%2F05%2F63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 2.解题思路 用一个list存储插入的数，然后对其进行排序 (1) size == 0 , 返回 null; (2) size是偶数 , 返回 数值排序之后中间两个数的平均值; (3) size是奇数，返回 list.get(size/2); 3.代码1234567891011121314151617181920212223242526import java.util.*;public class Solution &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //添加操作 public void Insert(Integer num) &#123; list.add(num); &#125; //获取中位数 public Double GetMedian() &#123; int size = list.size(); if(size!=0)&#123; Collections.sort(list); if(size%2==0)&#123; return (list.get(size/2)+list.get(size/2-1))/2.0; &#125;else &#123; return list.get(size/2)*1.0; &#125; &#125;else &#123; return null; &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【62】二叉搜索树的第K个结点]]></title>
    <url>%2F2019%2F05%2F62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 2.解题思路方法1： 用PriorityQueue将所有结点放到queue中，再依次弹出里面的数据（队首数据依次弹出），弹出的第k个数据就是要求的数值，再将它构建成TreeNode即可。 方法2： 根据二叉搜索树的特点，左子树上的点小于该点，右子树上的点大于该点。所以按照中序遍历的方法得到的序列即是从小到大的序列。 3.代码方法1： 123456789101112131415161718192021222324252627282930313233/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.*;public class Solution &#123; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); TreeNode KthNode(TreeNode pRoot, int k) &#123; preOrderRec(pRoot); if(queue.size()&lt;k ||k &lt;=0) return null; for(int i = 0;i&lt;k-1;i++)&#123; queue.poll(); &#125; return new TreeNode( queue.poll()); &#125; public void preOrderRec(TreeNode root)&#123; if(root!=null)&#123; queue.add(root.val); preOrderRec(root.left); preOrderRec(root.right); &#125; &#125;&#125; 方法2： 123456789101112131415161718192021public class Solution &#123; int index=0; TreeNode node=null; TreeNode KthNode(TreeNode pRoot, int k) &#123; if(k==0||pRoot==null) return node; KthNode(pRoot.left,k); index++; if(k==index) &#123; node=pRoot; return node; &#125; KthNode(pRoot.right,k); return node; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSR303参数校验和全局异常处理]]></title>
    <url>%2F2019%2F05%2FJSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。故引出使用JSR303来做参数校验。参数校验的实现: 手机号和密码字段自定义注解 为了让客户端显示更加友好 需要自定义异常拦截器 1. 添加依赖123456&lt;!--JSR303参数检验+全局异常处理器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解1234567891011@Controller@RequestMapping("/login")public class LoginController &#123; @RequestMapping("/do_login") @ResponseBody public Result&lt;String&gt; doLogin(HttpServletResponse response, @Valid LoginVo loginVo)&#123; logger.info(loginVo.toString()); &#125;&#125; 12345678910@Datapublic class LoginVo &#123; @NotNull @IsMobile private String mobile; @NotNull @Length(min = 32) private String password;&#125; 3. IsMobile注解的编写[可参考@NotNull]12345678910111213141516171819202122@Target(&#123; ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint( validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile &#123; boolean required() default true; String message() default "电话号码格式错误"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; 4.指定校验器的实现[IsMobileValidator.class]1234567891011121314151617181920212223public class IsMobileValidator implements ConstraintValidator&lt;IsMobile,String&gt; &#123; private boolean required = false; @Override //初始化方法拿到注解，可以定义一个字符为空 public void initialize(IsMobile constraintAnnotation) &#123; constraintAnnotation.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //值是必须的 if(required)&#123; return ValidatorUtil.isMobile(value); &#125;else&#123; if(StringUtils.isEmpty(value))&#123; return true; &#125;else&#123; return ValidatorUtil.isMobile(value); &#125; &#125; &#125;&#125; 5.自定义异常拦截器 当校验不通过时，会抛出异常。这时如果没有定义全局异常处理器进行处理（对异常进行封装和返回）。则会发生400错误（即只有请求的发起，却没有收到正常的响应（response），因为还没有来得及return就抛出了异常（这种异常没有被处理））。 1234567891011121314151617181920212223@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public Result&lt;String&gt; exceptionHandler(HttpServletRequest request,Exception e)&#123; e.printStackTrace(); if(e instanceof GlobalException) &#123; GlobalException ex = (GlobalException) e; return Result.Error(ex.getCm()); &#125;else if(e instanceof BindException)&#123; BindException ex = (BindException) e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); //为了方便起见，只取第一个错误 ObjectError error = errors.get(0); String msg = error.getDefaultMessage(); return Result.Error(CodeMsg.BIND_ERROR.fillArgs(msg)); &#125;else&#123; return Result.Error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用缓存key]]></title>
    <url>%2F2019%2F05%2F%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key%2F</url>
    <content type="text"><![CDATA[通用缓存key的作用当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。方法：利用一个前缀来规定不同模块的缓存的key,这样不同模块之间就不会重复。 通用缓存key采用模板模式：接口-&gt;抽象类-&gt;实现类 1. 接口12345678public interface KeyPrefix &#123; //过期时间 public int expireSeconds(); //前缀 public String getPrefix();&#125; 2. 抽象类1234567891011121314151617181920212223242526272829public abstract class BasePrefix implements KeyPrefix&#123; private int expireSeconds; private String prefix; //无过期时间的构造函数 public BasePrefix(String prefix) &#123; this(0, prefix); &#125; //含有过期时间的构造函数 public BasePrefix( int expireSeconds, String prefix) &#123; this.expireSeconds = expireSeconds; this.prefix = prefix; &#125; public int expireSeconds() &#123; return expireSeconds; &#125; //获取前缀，前缀为 className：prefix public String getPrefix() &#123; String className = getClass().getSimpleName(); return className+":" + prefix; &#125;&#125; 3. 实现类12345678910public class MiaoshaKey extends BasePrefix&#123; //继承父类的无过期时间的构造函数 public MiaoshaKey(String prefix) &#123; super(prefix); &#125; //设置她这个类的前缀是className:go public static MiaoshaKey isGoodsOver = new MiaoshaKey("go");&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitMQ实现消息缓冲]]></title>
    <url>%2F2019%2F05%2FrabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[RabbitMQ主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是AMQP协议，它是一种二进制协议。默认启动端口5672` rabbitMQ的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，生产者producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。 Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key, 根据key全文匹配去寻找队列 Topic：按规则转发消息（最灵活）转发消息主要是根据通配符 Headers：设置 header attribute 参数类型的交换机 Fanout：转发消息到所有绑定队列(广播方式) 下面介绍4种交换机与springboot的集成添加依赖包amqp,统一配置application.properties 123456&lt;!--rabbitMQ依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 12345678910111213141516171819##rabbitMQspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/#消费者数量spring.rabbitmq.listener.simple.concurrency= 10spring.rabbitmq.listener.simple.max-concurrency= 10#消费者每次从队列获取的消息数量spring.rabbitmq.listener.simple.prefetch= 1#消费者自动启动spring.rabbitmq.listener.simple.auto-startup=true#消费失败，自动重新入队spring.rabbitmq.listener.simple.default-requeue-rejected= true#启用发送重试spring.rabbitmq.template.retry.enabled=true spring.rabbitmq.template.retry.initial-interval=1000spring.rabbitmq.template.retry.max-attempts=3 1. Direct交换机制 一个队列会和一个交换机绑定，除此之外再绑定一个routing_key，当消息被发送的时候，需要指定一个binding_key，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个binding_key也是支持应用到多个队列中的。 这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。 1.1 编写config12345678910@Configurationpublic class MQconfig &#123; public static final String QUEUE ="queue"; @Bean public Queue queue()&#123; return new Queue(QUEUE,true); &#125; &#125; 1.2 创建消息发送者1234567891011121314@Servicepublic class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); public void send(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.Queue,message); &#125;&#125; 1.3 创建消息接收者12345678910@Servicepublic class MQreceiver &#123; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); //监听了queue的队列 @RabbitListener(queues = MQconfig.Queue) public void receive(String message)&#123; log.info("receive message"+message); &#125;&#125; 1.4 编写controller测试123456789101112@Controllerpublic class HelloController &#123; @Autowired MQsender sender; @RequestMapping("/mq") @ResponseBody public Result&lt;Boolean&gt; mq()&#123; sender.send("hello"); return Result.success(true); &#125; &#125; 2. Fanout交换机制 扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。 2.1 编写config1234567891011121314151617181920@Configuration public class MQconfig &#123; public static final String FANOUT_EXCHANGE ="fanoutxchage"; @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE); &#125; @Bean public Binding fanoutBinding()&#123; return BindingBuilder.bind(topticQueue2()).to(fanoutExchange()); &#125; 2.2 创建消息发送者12345678910111213@Service public class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; public void sendFanout(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.FANOUT_EXCHANGE,"",msg); &#125;&#125; 2.3 创建消息接收者1234@Service public class MQreceiver &#123; //fanout 广播模式都接受故不需要listener &#125; 2.4 编写controller测试123456789@Controller public class HelloController &#123; @RequestMapping("/mq/fanout") @ResponseBody public Result&lt;String&gt; fanout()&#123; sender.sendFanout("hellommxx"); return Result.success("hello xuanzi");&#125; &#125; 3. topic交换机制 通配符交换机，exchange会把消息发送到一个或者多个满足通配符规则的routing-key的queue。其中表号匹配一个word，#匹配多个word和路径，路径之间通过.隔开。如满足a..c的routing-key有a.hello.c；满足#.hello的routing-key有a.b.c.helo。 1.1 编写config1234567891011121314151617181920212223242526272829@Configuration public class MQconfig &#123; public static final String TOPIC_QUEUE1 ="topic.queue1"; public static final String TOPIC_QUEUE2 ="topic.queue2"; public static final String TOPIC_EXCHANGE ="topicExchange" @Bean public Queue topticQueue1()&#123; return new Queue(TOPIC_QUEUE1,true); &#125; @Bean public Queue topicQueue2()&#123; return new Queue(TOPIC_QUEUE2,true); &#125; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; @Bean public Binding topicBinding1()&#123; return BindingBuilder.bind(topticQueue1()).to(topicExchange()).with("topic.key1"); &#125; @Bean public Binding topicBinding2()&#123; return BindingBuilder.bind(topticQueue2()).to(topicExchange()).with("topic.#"); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendTopic(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key1",msg+"1"); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key2",msg+"2");&#125;&#125; 1.3 创建消息接收者12345678910111213@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.TOPIC_QUEUE1) public void receiveTopic1(String message)&#123; log.info("receive topic queue1 message"+message); &#125; @RabbitListener(queues = MQconfig.TOPIC_QUEUE2) public void receiveTopic2(String message)&#123; log.info("receive topic queue2 message"+message); &#125; &#125; 1.4 编写controller测试12345678@Controller public class HelloController &#123; @RequestMapping("/mq/topic") @ResponseBody public Result&lt;String&gt; topic()&#123; sender.sendTopic("hellommxx"); return Result.success("hello xuanzi"); &#125; 4. header交换机制 header exchange(头交换机)和主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据。主题交换机路由键只有是字符串,而头交换机可以是整型和哈希值 1.1 编写config123456789101112131415161718192021222324252627282930313233343536@Configuration public class MQconfig &#123; public static final String HEADER_QUEUE ="header.queue"; @Bean public HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE); &#125; @Bean public Queue headerQueue()&#123; return new Queue(HEADER_QUEUE,true); &#125; @Bean public Binding headerBinding()&#123; Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); map.put("header1","value1"); map.put("header2","value2"); return BindingBuilder.bind(headerQueue()).to(headersExchange()) .whereAll(map).match(); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendheader(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); MessageProperties properties = new MessageProperties(); properties.setHeader("header1","value1"); properties.setHeader("header2","value2"); Message obj = new Message(msg.getBytes(),properties); amqpTemplate.convertAndSend(MQconfig.HEADERS_EXCHANGE,"",obj); &#125;&#125; 1.3 创建消息接收者123456789@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.HEADER_QUEUE) public void receiveHeader(byte[] message)&#123; log.info("receive header queue message"+message); &#125; &#125; 1.4 编写controller测试12345678910111213@Controller public class HelloController &#123; @RequestMapping("/mq/header") @ResponseBody public Result&lt;String&gt; header()&#123; sender.sendheader("hellommxx"); return Result.success("hello xuanzi"); &#125; &#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis缓存java端实现]]></title>
    <url>%2F2019%2F05%2FRedis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 1. 引入redis依赖1234&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; 2.在application.properties添加redis配置文件12345678#redisredis.host=127.0.0.1redis.port=6379redis.timeout=3redis.password=2966redis.poolMaxTotal=10 //资源池中最大连接数redis.poolMaxIdle=10 //允许的最大空闲的连接数redis.poolMaxWait=3 3.定义redis的类，引入redis的配置12345678910111213@Component@ConfigurationProperties(prefix="redis")@Datapublic class RedisConfig &#123; private String host; private int port; private int timeout;//秒 private String password; private int poolMaxTotal; private int poolMaxIdle; private int poolMaxWait;//秒&#125; 4.RedisPoolFactory类，用于返回一个redis池12345678910111213141516171819202122232425262728@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisPoolFactory() &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); //允许最大空闲的连接数 poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); //资源池中最大连接数 poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); //最大等待毫秒数 poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(), redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125;&#125; 5.编写RedisService类12345678910111213141516@Servicepublic class RedisService &#123; @Autowired JedisPool jedisPool; //里面编写redis操作：增删改查 private void returnToPool(Jedis jedis) &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125;&#125; 5.1 获取单个对象(get)1234567891011121314151617181920212223242526272829303132333435363738//相当于redis里面的get key public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key,之前设置通用缓存key时的key设为className:key String realKey = prefix.getPrefix() + key; //跟redis里面的获取一个key操作一致 String str = jedis.get(realKey); //将结果转换成一个java对象 T t = stringToBean(str, clazz); return t; &#125;finally &#123; //关闭池资源 returnToPool(jedis); &#125; &#125;//json转换为java对象public static &lt;T&gt; T stringToBean(String str, Class&lt;T&gt; clazz) &#123; if(str == null || str.length() &lt;= 0 || clazz == null) &#123; return null; &#125; //判断类型 if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(str); &#125;else if(clazz == String.class) &#123; return (T)str; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(str); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(str), clazz); &#125; &#125; 5.2 设置对象(set)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//相当于redis里面的set key valuepublic &lt;T&gt; boolean set(KeyPrefix prefix, String key, T value) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //对象转换为json字符串 String str = beanToString(value); if(str == null || str.length() &lt;= 0) &#123; return false; &#125; //生成真正的key String realKey = prefix.getPrefix() + key; //获取过期时间 int seconds = prefix.expireSeconds(); if(seconds &lt;= 0) &#123; //永久有效，无过期时间 jedis.set(realKey, str); &#125;else &#123; //为指定的 key 设置值及其过期时间。 jedis.setex(realKey, seconds, str); &#125; return true; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //将对象转化为Json字符串 public static &lt;T&gt; String beanToString(T value) &#123; if(value == null) &#123; return null; &#125; Class&lt;?&gt; clazz = value.getClass(); if(clazz == int.class || clazz == Integer.class) &#123; return ""+value; &#125;else if(clazz == String.class) &#123; return (String)value; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; 5.3 判断key是否存在(exists)123456789101112//想当于redis里面的 exists keypublic &lt;T&gt; boolean exists(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.exists(realKey); &#125;finally &#123; returnToPool(jedis); &#125;&#125; 5.4 增加值(incr)123456789101112//相当于redis里面的incr key_namepublic &lt;T&gt; Long incr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.5 减少值(decr)123456789101112//相当于redis里面的decr key_namepublic &lt;T&gt; Long decr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.6 删除(del)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//相当于redis里面的del key_name //已知key public boolean delete(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; long ret = jedis.del(realKey); return ret &gt; 0; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //通过正则匹配删除 某key public boolean delete(KeyPrefix prefix) &#123; if(prefix == null) &#123; return false; &#125; List&lt;String&gt; keys = scanKeys(prefix.getPrefix()); if(keys==null || keys.size() &lt;= 0) &#123; return true; &#125; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.del(keys.toArray(new String[0])); return true; &#125; catch (final Exception e) &#123; e.printStackTrace(); return false; &#125; finally &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125; &#125; public List&lt;String&gt; scanKeys(String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); List&lt;String&gt; keys = new ArrayList&lt;String&gt;(); String cursor = "0"; //scan搜索 ScanParams sp = new ScanParams(); sp.match("*"+key+"*"); //设置scan的个数 sp.count(100); do&#123; ScanResult&lt;String&gt; ret = jedis.scan(cursor, sp); //返回结果 List&lt;String&gt; result = ret.getResult(); if(result!=null &amp;&amp; result.size() &gt; 0)&#123; //搜索的结果存入list keys.addAll(result); &#125; //再处理cursor，用于返回下次遍历的游标 cursor = ret.getStringCursor(); &#125;while(!cursor.equals("0")); return keys; &#125; finally &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125; &#125; 6.controller层测试123456789101112131415161718@AutowiredRedisService redisService;@RequestMapping("/redis/get")@ResponseBodypublic Result&lt;User&gt; getRedis()&#123; User user = redisService.get(UserKey.getById,"key1",User.class); return Result.success(user);&#125;@RequestMapping("/redis/set")@ResponseBodypublic Result&lt;Boolean&gt; setRedis()&#123; User user = new User(); user.setId(1); user.setName("1111"); redisService.set(UserKey.getById,""+1,user); return Result.success(true);&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【61】序列化二叉树]]></title>
    <url>%2F2019%2F05%2F61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现两个函数，分别用来序列化和反序列化二叉树 2.解题思路 二叉树的序列化 12&gt; 把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。&gt; 序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 先序序列化二叉树——&gt;&gt;&gt;&gt;定义一个stringbuilder保存序列过程中的结果： (1)按照先序遍历方式遍历二叉树，若结点非空则把 “结点值,” append到builder中； (2)若结点空则把 “#,” append到builder中； (3)最后用builder生成字符串就是序列化结果。 二叉树的反序列化 根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 (1)先序序列化结果重构二叉树 (2)String[] nodes=str.split(“,”)；//由每个结点的结束符号划分序列化结果序列，得到各个结点值； (3)然后按照先序遍历的顺序“根左右”的特性，遍历nodes数组建立二叉树： 1)当前遍历元素非 # 则作为一个结点插入树中作为上一结点的左儿子； 2)当前遍历元素为 # 则表示此子树已结束，遍历下一元素作为上一结点的右儿子； 即：遇数作左；遇#变向 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; public int index = -1; //室友递归先序遍历对二叉树进行序列化 String Serialize(TreeNode root) &#123; StringBuffer sb = new StringBuffer(); if(root == null)&#123; sb.append("#,"); return sb.toString(); &#125; //先序遍历根结点 sb.append(root.val + ","); //左子树 sb.append(Serialize(root.left)); //右子树 sb.append(Serialize(root.right)); return sb.toString(); &#125; TreeNode Deserialize(String str) &#123; //特殊输入 if(str==null||str.length()&lt;=0) return null; //将字符串按照","拆分为数组 String[] strr = str.split(","); int len = strr.length; index++; if(index &gt;= len)&#123; return null; &#125; TreeNode node = null; //如果遇到的是#表示空节点，不再建立子树，这个结点null就是子树的根结点返回 if(!strr[index].equals("#"))&#123; node = new TreeNode(Integer.valueOf(strr[index])); //恢复左子树 node.left = Deserialize(str); //恢复右子树 node.right = Deserialize(str); &#125; //建立二叉树完成，返回根节点 return node; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【60】把二叉树打印成多行]]></title>
    <url>%2F2019%2F05%2F60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 2.解题思路 利用层次遍历二叉树的方式，用一个队列进行辅助，每次打印前取n = queue.size()，可以保证逐行打印。 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(pRoot == null) &#123; return res; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); //加入根结点 queue.add(pRoot); while (!queue.isEmpty())&#123; //每遍历一次，就新建一次tmp ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); int count = queue.size(); for(int i = 0;i&lt;count;i++)&#123; if(queue.peek().left!=null)&#123; //加入左结点 queue.add(queue.peek().left); &#125; if(queue.peek().right!=null)&#123; //加入右结点 queue.add(queue.peek().right); &#125; //删除并返回queue中的头元素，删掉根（上一层结点元素） tmp.add(queue.poll().val); &#125; //将一层的左右结点加入res res.add(tmp); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【59】按之字形顺序打印二叉树]]></title>
    <url>%2F2019%2F05%2F59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 2.解题思路 用一个布尔量控制从左到右还是从右到左的顺序；如果为真则他的左右孩子按照从左到右的顺序放入list中，否则按照从右到左的顺序，当本行结束之后，再把list中的数据放入一个result中。其中用一个null值作为层次的分隔符。 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041public static class Solution &#123; public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (pRoot == null) &#123; return result; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.addLast(null);//层分隔符 queue.addLast(pRoot); boolean leftToRight = true; while (queue.size() != 1) &#123; TreeNode node = queue.removeFirst(); if (node == null) &#123;//到达层分隔符 Iterator&lt;TreeNode&gt; iter = null; if (leftToRight) &#123; iter = queue.iterator();//从前往后遍历 &#125; else &#123; //从后往前遍历 iter = queue.descendingIterator(); &#125; leftToRight = !leftToRight; while (iter.hasNext()) &#123; TreeNode temp = (TreeNode) iter.next(); list.add(temp.val); &#125; result.add(new ArrayList&lt;Integer&gt;(list)); list.clear(); queue.addLast(null);//添加层分隔符 continue;//一定要continue &#125; if (node.left != null) &#123; queue.addLast(node.left); &#125; if (node.right != null) &#123; queue.addLast(node.right); &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【58】对称的二叉树]]></title>
    <url>%2F2019%2F05%2F58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 2.解题思路 【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。 【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。 【分析3】根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到 ① 如果Root和Root&apos;均为空，则返回true； ② 如果Root为空或者Root&apos;为空，则返回false； ③ 如果Root对应的值与Root&apos;对应的值不相等，则返回false。 3.代码12345678910111213141516171819202122public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; if(pRoot==null || pRoot.left==null&amp;&amp;pRoot.right==null) return true; return Symmetrical(pRoot.left,pRoot.right); &#125; boolean Symmetrical(TreeNode left,TreeNode right) &#123; if(left==null&amp;&amp;right==null) return true; if(left==null||right==null) return false; if(left.val==right.val) //右子树的左边跟左子树的右边是否对称 return Symmetrical(left.left,right.right) //左子树的右边跟右子树的左边是否对称 &amp;&amp; Symmetrical(left.right,right.left); return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【57】二叉树的下一个结点]]></title>
    <url>%2F2019%2F05%2F57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 2.解题思路 情况1：该节点有右子树： 6 / \ 3 10 / \ / \ 2 5 8 12 中序遍历结果为：2–&gt;3–&gt;5–&gt;6–&gt;8–&gt;10–&gt;12 即它的下一个结点就是它的右子树中最左子结点 情况2.1：该节点无右子树：(为父节点6的左子节点) 6 / \ 3 10 / / \ 2 8 12 2–&gt;3–&gt;6–&gt;8–&gt;10–&gt;12 该节点是父节点的左子节点的这种情况比较简单，直接将父节点返回即可 情况2.2：该节点无右子树：(为父节点6的右子节点) 6 / \ 3 10 / \ / \ 2 5 8 null 2–&gt;3–&gt;6–&gt;8–&gt;10 –&gt;null 如果是父节点的右子节点的话，需要不断的向上移动，直到对应的节点不是父节点的右节点（即左节点），既然他是父节点的左节点，此时将这个节点父节点返回即可，或者遍历到了根节点，返回null； 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/ public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if(pNode == null)&#123; return null; &#125; //该节点有右子树,它的下一个结点就是它的右子树中最左子结点 if(pNode.right != null)&#123; pNode = pNode.right; while(pNode.left != null)&#123; pNode = pNode.left; &#125; return pNode; &#125; //该节点无右子树，父节点不为空 while(pNode.next != null)&#123; //pNode为父节点的左节点为该节点，直接返回父节点 if(pNode.next.left== pNode)&#123; return pNode.next; &#125; //为父节点的右子节点，不断的向上移动，直到对应的节点不是父节点的左子节点 //一直回溯如果遍历到他是父节点的左节点，此时将这个节点父节点返回即可， //或者遍历到了根节点，返回null； pNode = pNode.next; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【56】删除链表中重复的结点]]></title>
    <url>%2F2019%2F05%2F56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 2.解题思路 方法一：重头构建该链表 (1) 新建两个list，一个用于存放只出现一次的数值，一个存放重复的数值 (2) 将只出现过一次的数重头构建成链表 方法二：递归思想 3.代码方法1： 1234567891011121314151617181920212223public static ListNode deleteDuplication(ListNode pHead) &#123; ArrayList&lt;Integer&gt; ss = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; ss2 = new ArrayList&lt;&gt;(); ListNode res = new ListNode(-1); ListNode node = res; while(pHead!=null)&#123; if(!ss.contains(pHead.val) &amp;&amp; !ss2.contains(pHead.val))&#123; ss.add(pHead.val); pHead = pHead.next; &#125;else&#123; ss2.add(pHead.val); ss.remove(Integer.valueOf(pHead.val)); pHead = pHead.next; &#125; &#125; for(int i = 0;i&lt;ss.size();i++)&#123; res.next =new ListNode(ss.get(i)); res = res.next; &#125; return node.next; &#125; 方法2： 123456789101112131415161718192021222324public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; // 只有0个或1个结点，则返回 if (pHead == null || pHead.next == null) &#123; return pHead; &#125; if (pHead.val == pHead.next.val) &#123; // 当前结点是重复结点 ListNode pNode = pHead.next; while (pNode != null &amp;&amp; pNode.val == pHead.val) &#123; // 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点 pNode = pNode.next; &#125; // 从第一个与当前结点不同的结点开始递归 return deleteDuplication(pNode); &#125; else &#123; // 当前结点不是重复结点 // 保留当前结点，从下一个结点开始递归 pHead.next = deleteDuplication(pHead.next); return pHead; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【55】链表中环的入口结点]]></title>
    <url>%2F2019%2F05%2F55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 2.解题思路 方法1： 利用hashSet不存储重复值的思想 方法2： 链表包含环，像数字6的图形。 (1)设置快慢指针，假设快指针在环内与慢指针相遇，设头节点到入口结点的距离为x,入口结点到相遇点为y,相遇点到入口结点距离为z,则有(x+y)*2 = (x+y+z+y),即z = x，即相遇点到入口结点的距离跟头节点到入口结点的距离相等。 (2)这时再设置fast = pHead,一个指针重头走，另一个指针重相遇节点走，当两个点相等时即为入口节点所在。 3.代码方法1： 1234567891011121314public ListNode EntryNodeOfLoop(ListNode pHead)&#123; HashSet&lt;ListNode&gt; hs = new HashSet&lt;ListNode&gt;(); while(pHead!=null)&#123; if(!hs.add(pHead))//如果包含了，那么这个就是入口结点 return pHead; pHead = pHead.next; &#125; return null;&#125; 方法2： 1234567891011121314151617181920212223242526272829303132/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode fast = pHead; ListNode slow = pHead; while(fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast==slow)&#123; fast=pHead; while (fast!=slow)&#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【54】字符流中第一个不重复的字符]]></title>
    <url>%2F2019%2F05%2F54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 2.解题思路桶排序思想 3.代码1234567891011121314151617181920212223//源源不断的有字母放到字符串中，建立一个256个大小的int型数组来代表哈希表public class Solution &#123; String str=""; int[] count=new int[256]; public void Insert(char ch) &#123; if(ch &gt;=256)&#123; return ; &#125;else&#123; str+=ch;//字符放入字符串 count[ch]++;//根据字符，修改数组字符元素的值 &#125; &#125; public char FirstAppearingOnce() &#123; for(char c:str.toCharArray())&#123;// //注意的是，要找第一个出现一次的字符，所以遍历字符串，不能遍历哈希数组 if(count[c]==1)&#123;//如果字符串作为下表的元素值为1，说明该字符出现一次，直接返回该字符 return c; &#125; &#125; return '#'; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【53】表示数值的字符串]]></title>
    <url>%2F2019%2F05%2F53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 2.解题思路 (1) 先判断每个字符是否合法 (2) 正负号的位置和e不能在结尾位置 (3) 小数点只能存在一个 (4)正负号在中间位置时，前面是e后面是数字 (5)e后面不能有小数点 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; public boolean isNumeric(char[] str) &#123; String ss = String.valueOf(str); int len = ss.length(); //先判断每个字符是否合法 for(int i=0; i&lt;len; i++)&#123; char c = ss.charAt(i); if(!((c&gt;='0' &amp;&amp; c &lt;= '9') || c=='e' || c=='E' || c=='+' || c=='-'|| c=='.')) return false; &#125; ////正负号,E不能在末尾 if(ss.charAt(len-1) == '+' || ss.charAt(len-1) == '-' || ss.charAt(len-1) == 'E' || ss.charAt(len-1) == 'e') return false; //判断小数点，只能有一个 if(ss.indexOf(".") != ss.lastIndexOf(".")) return false; //正负号在中间的位置时，前面的是e，E,后面是数字 for(int i=1; i&lt;len-1; i++)&#123; char c = ss.charAt(i); if(c == '+' || c=='-')&#123; if(!(ss.charAt(i-1) == 'e' || ss.charAt(i-1) == 'E') ||!(ss.charAt(i+1)&gt;='0' &amp;&amp; ss.charAt(i+1)&lt;='9')) return false; &#125; &#125; ////e的后面不能有数字12E+4.3 for(int i=1; i&lt;len; i++)&#123; char c = ss.charAt(i); if(c == 'e' || c=='E')&#123; if(i==len-1) return false; if(ss.charAt(i+1) == '+' || ss.charAt(i+1) == '-')&#123; //从i+2开始往后没有小数点.则返回-1 if(ss.indexOf(".", i+2) != -1)&#123; return false; &#125; &#125;else&#123; if(ss.indexOf(".", i+1) != -1)&#123; return false; &#125; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【52】正则表达式匹配]]></title>
    <url>%2F2019%2F05%2F52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配。 2.解题思路 这道题的核心其实在于分析’‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’‘的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。 在每轮匹配中，Patttern第二个字符是’*’时： 1.第一个字符不匹配（’.’与任意字符视作匹配），那么’‘只能代表匹配0次，比如’ba’与’aba’，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式 2.第一个字符匹配，那么’‘可能代表匹配0次，1次，多次，比如’aaa’与’aaaa’、’aba’与’aba’、’aaaba’与’aba’。匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；匹配多次时，字符串往后移动一个字符，模式不变； 而当Patttern第二个字符不是’*’时，情况就简单多了： (1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。 (2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if (str == null || pattern == null) return false; int strIndex = 0,patternIndex = 0; return matchCore(str, strIndex, pattern, patternIndex); &#125; public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) &#123; //有效性检验：str到尾，pattern到尾，匹配成功 if (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123; return true; &#125; //pattern先到尾，匹配失败 if (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123; return false; &#125; //模式第2个是*，且字符串第1个跟模式第1个匹配, //分3种匹配模式；如不匹配，模式后移2位 if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] == '*') &#123; if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return //模式后移2，视为x*匹配0个字符 matchCore(str, strIndex, pattern, patternIndex + 2) //视为模式匹配1个字符 || matchCore(str, strIndex + 1, pattern, patternIndex + 2) //*匹配1个，再匹配str中的下一个 || matchCore(str, strIndex + 1, pattern, patternIndex); &#125; else &#123; return matchCore(str, strIndex, pattern, patternIndex + 2); &#125; &#125; //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return matchCore(str, strIndex + 1, pattern, patternIndex + 1); &#125; return false; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【51】构建乘积数组]]></title>
    <url>%2F2019%2F05%2F51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 2.解题思路 题目的意思就是B[i] = A[0]*A[1]….*A[n-2]*A[n-1] / A[i],但是题目要求不能用除法 创建一个left数组和一个rigth数组，拿n = 3为例 res[i] left[0]*right[0] left[1]*right[1] left[2]*right[2] left[3]*right[3] right数组 A[2]*A[1]*A[0]*1 A[1]*A[0]*1 A[0]*1 1 left数组 1 1*A[0] 1*A[0]*A[1] 1*A[0]*A[1]*A[2] 3.代码123456789101112131415161718192021222324import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; int []res = new int[A.length]; int []left = new int[A.length]; int []right = new int[A.length]; left[0] = 1; for(int i = 1;i&lt;A.length;i++)&#123; left[i] = A[i-1]*left[i-1]; &#125; right[A.length-1] = 1; for(int i = A.length-2;i&gt;=0;i--)&#123; right[i] = right[i+1]*A[i+1]; &#125; //计算结果 for(int i = 0;i&lt;A.length;i++)&#123; res[i] = left[i]*right[i]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【50】数组中重复的数字]]></title>
    <url>%2F2019%2F05%2F50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 2.解题思路 长度为n,数字都在[0,n-1]范围，可以利用桶排序的思想，将numbers[i]的个数存入相应的res索引下，当第一次桶里有2个numbers[i]时，直接返回即找到第一个数组里面的重复数字。 3.代码123456789101112131415161718 public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(length == 0) return false; int res[] = new int [length]; boolean flag = false; for(int i = 0;i&lt;length;i++)&#123; res[numbers[i]]++; //有重复的数 if(res[numbers[i]]&gt;1)&#123; duplication[0] = numbers[i]; flag = true; break; &#125; &#125; return flag;&#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【49】把字符串转换成整数]]></title>
    <url>%2F2019%2F05%2F49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 输入描述:输入一个字符串,包括数字字母符号,可以为空 输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1： 输入+2147483647 1a33 输出2147483647 0 2.解题思路 (1) 首先判断第一个字符是符号‘ + ‘ 或者 ’ - ‘ 还是数字 (2) 首字母为 ’ + ‘，则设flag 为 1，计算[1,len)的数值 (3) 首字母为 ’ - ‘，则设flag为-1，计算[1,len)的数值 (4) 首字母为数字，则计算[0,len)的数值 计算时有个是否溢出判断。 3.代码12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int StrToInt(String str) &#123; if(str.trim().equals(""))&#123; return 0; &#125; int sum = 0; int flag = 1; if(str.charAt(0) =='+'||str.charAt(0)=='-')&#123; if(str.charAt(0)=='-') &#123; flag = -1; &#125; sum = cal(str,1,str.length(),flag); &#125;else&#123; sum = cal(str,0,str.length(),flag); &#125; return sum*flag; &#125; //计算结果 private int cal(String str, int start, int end,int flag) &#123; int sum = 0; for(int i = start;i&lt;end;i++)&#123; if(str.charAt(i)&gt;='0' &amp;&amp;str.charAt(i)&lt;='9')&#123; if(flag == 1 &amp;&amp; sum&gt;Integer.MAX_VALUE) throw new RuntimeException("上溢出"); if(flag == -1 &amp;&amp; sum&lt;Integer.MIN_VALUE) throw new RuntimeException("下溢出"); sum = sum*10+str.charAt(i)-'0'; &#125;else&#123; return 0; &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【48】不用加减乘除做加法]]></title>
    <url>%2F2019%2F05%2F48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 2.解题思路利用&amp;、|、^等运算 (1)定义一个sum和一个进位位carry，sum用来记录二进制的两位数无进位相加得到的值（num1^num2）,进位位carry用来记录需要向哪个位进位（num&amp;num2&lt;&lt;1） (2)将得到的sum和carry重新赋值给num1和num2.循环的结束条件是进位位为0时终止。 3.代码12345678910111213141516171819public class Solution &#123; public int Add(int num1,int num2) &#123; int carry = 0; int sum = 0; do&#123; //异或，相同为0不同为1 ,得到的结果相当于二进制的两个数无进位相加， //相加为2的结果是0.如6和12相异或，即（0110^1100） = 1010 sum = num1 ^ num2; //num1&amp;num2得到该位数需要进位，即向前进位&lt;&lt;1 carry = (num1&amp;num2)&lt;&lt;1; num1 = sum; num2 = carry; &#125;while(num2!=0); //直到无进位结束 return num1; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【47】求1+2+...+n]]></title>
    <url>%2F2019%2F05%2F47-%E6%B1%821-2-n%2F</url>
    <content type="text"><![CDATA[1.题目描述 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 2.解题思路 1.需利用逻辑与的短路特性实现递归终止。 2.当n==0时，(n&gt;0)&amp;&amp;((ans+=Sum_Solution(n-1))&gt;0)只执行前面的判断，不执行后面的递归了，使这条语句为false，并且不往上回溯，可以执行下面return的语句了。然后直接返回ans； 3.当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。 3.代码12345678public class Solution &#123; public int Sum_Solution(int n) &#123; int ans = n; boolean flag = (ans &gt; 0) &amp;&amp; (ans += Sum_Solution(n - 1))&gt;0; return ans; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【46】孩子们的游戏(圆圈中最后剩下的数)]]></title>
    <url>%2F2019%2F05%2F46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[1.题目描述 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 2.解题思路 模拟游戏过程 i一直记录的是小朋友自己最初的的位置[0,n-1] step记录的是报数，报到m-1时array[i]这个小朋友出局，记-1，step重头计数。人数这时减1. 3.代码123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if(n&lt;1||m&lt;1) return -1; int array[] = new int[n]; int i = -1 ; //初始状态 int step = -1; int count = n; //人数 while (count&gt;0)&#123; //游戏开始 //报数，其实报的一直都是自己的位置数，不是[0,m-1],而是[0,n-1] i++; //假如有8人，报数范围是[0,7],轮询一圈后那么第一个人不报8而是报0 if(i&gt;=n) i=0; if(array[i]==-1) continue; //标记为-1即出局，不遍历下边的了 step++; //step用来记录报数报到哪了 if(step==m-1)&#123; //找到喊m-1的小朋友 array[i] = -1; //出局 step = -1; //重头开始记录报数 count--; //人数减1 &#125; &#125; return i; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【45】扑克牌顺子]]></title>
    <url>%2F2019%2F05%2F45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[1.题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 2.解题思路 组成顺子的条件是： (1) 数组长度为5 (2)数组中数不重复 (3)最大值Max减最小值Min&lt;5,其中Max和Min不能为0,即不包括大小王的最大值最小值 3.代码12345678910111213141516171819202122232425262728293031public class Solution &#123; public static boolean isContinuous(int [] numbers) &#123; if(numbers.length&lt;5) return false; int Max = Integer.MIN_VALUE; int Min = Integer.MAX_VALUE; int count[] = new int[14]; //除0以外没有重复的数 for(int i = 0;i&lt;numbers.length;i++)&#123; count[numbers[i]]++; //如果是大小王的话，可以允许多个，直接continue不执行count[numbers[i]&gt;=2的判断,而且最大值最小值的判断也会跳过0 if(numbers[i] == 0)&#123; continue; &#125; if(count[numbers[i]]&gt;=2)&#123; return false; &#125; // if(Max&lt;numbers[i]) &#123; Max = numbers[i]; &#125; if(Min &gt;numbers[i])&#123; Min = numbers[i]; &#125; &#125; if ( Max - Min &lt; 5) &#123; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【44】翻转单词顺序列]]></title>
    <url>%2F2019%2F05%2F44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 2.解题思路 用str.split(“ ”) 去切分子字符串变成str[],然后再拼接。 3.代码123456789101112131415161718192021public class Solution &#123; public String ReverseSentence(String str) &#123; if(str == null)&#123; return null;&#125; //去掉前后空格，避免输入字符串全是空格情况，保证后面的split切分正确 if(str.trim().equals(""))&#123; return str; &#125; String res[] = str.split(" "); StringBuilder ss = new StringBuilder(); //第二个到最后一个数组值后面要加“ ” for(int i = res.length-1;i&gt;0;i--)&#123; ss.append(res[i]+" "); &#125; //第一个就是数组末尾了不需要加“ ”，保持反转后的数组长度跟原来一样 ss.append(res[0]); return ss.toString(); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【43】左旋转字符串]]></title>
    <url>%2F2019%2F05%2F43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1.题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 2.解题思路两个子字符串 拼接就行了。 3.代码1234567public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(n&gt;str.length()) return ""; return str.substring(n,str.length())+str.substring(0,n); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【42】和为s的两个数字]]></title>
    <url>%2F2019%2F05%2F42-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述:对应每个测试案例，输出两个数，小的先输出。 2.解题思路 将数组的数值依次放入list里面，每次放入之前查询list里面是否有（sum-array[i]），如果有,再判断两数乘积是否比之前存的两数乘积小，如果判断成功，则将这两个数放到index1和index2中。最后将这两个index放到list里面返回。 3.代码1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array, int sum) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; ss = new ArrayList&lt;&gt;(); int Min_ = Integer.MAX_VALUE; //index1用于存放比较小的那个数 int index1 = 0; //index2用于存放比较大的数 int index2 = 0; for(int i = 0;i&lt;array.length;i++)&#123; if(res.contains(sum-array[i]))&#123; if(Min_&gt;(sum-array[i])*array[i])&#123; Min_ = (sum-array[i])*array[i]; index1 = array[i]&lt;(sum-array[i])? array[i]:(sum-array[i]); index2 = sum-index1; &#125; &#125;else&#123; res.add(array[i]); &#125; &#125; if(index1!=0||index2!=0)&#123; ss.add(index1); ss.add(index2); &#125; return ss; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【41】和为S的连续正数序列]]></title>
    <url>%2F2019%2F05%2F41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 2.解题思路 滑动窗口移动方法 (1) 求出滑动窗口的累加和，公式为等差数列求和公式 (2)如果累加和等于sum,则将该滑动窗口内的数存到一个list里面，并右移动左指针 (3)如果累加和小于sum,则右移动右指针，加数进来 (4)如果累加和大约sum，则左指针右移动，减数出去 3.代码1234567891011121314151617181920212223242526272829import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; //存放结果 ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = new ArrayList&lt;&gt;(); //两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小 int plow = 1,phigh = 2; while(phigh &gt; plow)&#123; //由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2 int cur = (phigh + plow) * (phigh - plow + 1) / 2; //相等，那么就将窗口范围的所有数添加进结果集 if(cur == sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=plow;i&lt;=phigh;i++)&#123; list.add(i); &#125; result.add(list); plow++; //如果当前窗口内的值之和小于sum，那么右边窗口右移一下 &#125;else if(cur &lt; sum)&#123; phigh++; &#125;else&#123; //如果当前窗口内的值之和大于sum，那么左边窗口右移一下 plow++; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【40】数组中只出现一次的数字]]></title>
    <url>%2F2019%2F05%2F40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 2.解题思路 将数组依次放到list里面，如果list里面含有准备要进去的数值，则remove掉，剩下的两个数组即为该数组中只出现过一次的数字 list.remove要用(Object object)方法而不是list.remove(int index); 3.代码1234567891011121314151617181920212223//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果import java.util.*;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; if(array.length&lt;2)&#123; return ; &#125; ArrayList&lt;Integer&gt; res = new ArrayList(); for(int i = 0;i&lt;array.length;i++)&#123; if(res.contains(array[i]))&#123; //这里remove掉的是里面的数array[i]，而不是array[i]索引对应的数 res.remove(Integer.valueOf(array[i])); &#125;else&#123; res.add(array[i]); &#125; &#125; num1[0] = res.get(0); num2[0] = res.get(1); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【39】平衡二叉树]]></title>
    <url>%2F2019%2F05%2F39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 2.解题思路预备知识：平衡二叉树是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 思想：从根节点开始，先判断左右子树的高度差是否超过1，然后接着判断左右子树是否是平衡二叉树。这边用到了递归思想。 代码如下： 3.代码123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if( root == null) &#123; //一棵空树就是平衡二叉树 return true; &#125; if( Math.abs(getDepth(root.left) - getDepth(root.right)) &lt;= 1 ) &#123; //满足左右子树高度差小于等于1,那就接着判断左右子树是不是二叉树 return (IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right)); &#125; else &#123; //不满足左右子树高度差小于等于1,那这棵树肯定不是平衡二叉树啦 return false; &#125; &#125; //递归求二叉树深度 public int getDepth(TreeNode root) &#123; if( root == null ) return 0; int left = getDepth(root.left); int right = getDepth(root.right); return ( left &gt; right ? left : right ) + 1; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【38】二叉树的深度]]></title>
    <url>%2F2019%2F05%2F38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 2.解题思路 ①如果一棵树只有一个结点，它的深度为1。 ②如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。 ③如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。 3.代码12345678910111213141516171819202122232425/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;*/public class Solution &#123; public int TreeDepth(TreeNode root) &#123; //----递归求二叉树深度---- if(root == null)&#123; return 0; &#125; int left = TreeDepth(root.left); int right = TreeDepth(root.right); return (left&gt;right)?(left+1):(right+1); &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【37】数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F05%2F37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述统计一个数字在排序数组中出现的次数。 2.解题思路排序数组嘛，找到数组里面第一个等于k的，一直res++直到数组值不等于k。 3.代码123456789101112131415public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; int res = 0; if (array == null || array.length == 0) return res; for(int i = 0;i&lt;array.length;i++)&#123; if(array[i] == k)&#123; res++; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【36】两个链表的第一个公共结点]]></title>
    <url>%2F2019%2F05%2F36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述输入两个链表，找出它们的第一个公共结点。 2.解题思路两个链表有公共点，考虑Y型的两链表相连，先计算出两个链表的长度，然后长的链表先走差值步，之后同步走，当遇到cur1==cur2时说明两链表相遇。直接返回即可。 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindFirstCommonNode(ListNode head1, ListNode head2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; ListNode cur1 = head1; ListNode cur2 = head2; int n = 0; //得到差值步（head1.length-head2.length） while (cur1.next != null) &#123; n++; cur1 = cur1.next; &#125; while (cur2.next != null) &#123; n--; cur2 = cur2.next; &#125; //相交为Y型则最后一个结点应该相同 if (cur1 != cur2) &#123; return null; &#125; cur1 = n &gt; 0 ? head1 : head2; cur2 = cur1 == head1 ? head2 : head1; n = Math.abs(n);//差值步 //走差值步 while (n != 0) &#123; n--; cur1 = cur1.next; &#125; //相等时则为相交点 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[争吵问题.md]]></title>
    <url>%2F2019%2F05%2F%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md%2F</url>
    <content type="text"><![CDATA[1. 题目描述有一个队列，每个人要么朝左边（L表示）,要么朝右边(R表示)，因为每个人都讨厌其他任何人，只要两人面对面就会发生争吵。争吵结果是胜者留在队列中，败的人移除队中。如果序列中有多对争吵，可以任选一对，胜者留在队中，败者出局，求最后队列最少人数是多少。 例子： LRRLRL 输出：2 Hint 一种可能的变化情况是：LRRLRL -&gt; LRLRL -&gt; LRRL -&gt; LRL -&gt; LR 2.解题思路由题意可知，如果真的吵架就只有RL（两人面对面）情况，像LL,RR,LR就不会争吵。 如果吵架前面是R，则吵架结果应该是L胜利. 如果吵架前面是L，则吵架结果为R胜利 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.List;public class test &#123; public static void main(String[] args) &#123; String arr ="LRRLRL"; String res = solut(arr); System.out.println(res.length()); System.out.println(res); &#125; public static String solut(String arr) &#123; //获取第一次争吵得到的结果 String str = solution(arr); //如果还存在第二次争吵，则继续，否则得到结果 while (str.contains("RL"))&#123; str = solution(str); &#125; return str; &#125; public static String solution(String arr)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;arr.length()-1;i++)&#123; //争吵 if(arr.charAt(i)=='R'&amp;&amp;arr.charAt(i+1)=='L')&#123; if(i==0) &#123; list.add('R'); i++; &#125; else&#123; if(list.get(list.size()-1)=='L') &#123; &#123; list.add('R'); i++; &#125; &#125;else&#123; &#123; list.add('L'); i++; &#125; &#125; &#125; &#125;else &#123; //没有争吵，下一次争吵中还有该人 list.add(arr.charAt(i)); &#125; &#125; //将list转换成String String str = ""; for(int i = 0;i&lt;list.size();i++)&#123; str = str+list.get(i); &#125; return str; &#125;&#125;]]></content>
      <categories>
        <category>讯飞科技笔试</category>
      </categories>
      <tags>
        <tag>讯飞科技笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【34】第一个只出现一次的字符位置]]></title>
    <url>%2F2019%2F05%2F34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.题目描述 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 2.解题思路 1.用两个list,一个list用来存放只出现一次的字符，一个用来存放出现多次的字符 2.依次遍历str里面的字符，如果list1和list2里面都没有，则说明这个字符是第一次出现，将其添加到list1，否则说明之前出现过该字符，将其移除list1并添加到list2里面 3.最后判断list里面是否有值，有则返回list里面的第一个值在str出现的第一次的位置，即为第一次出现的字符位置。 3.代码1234567891011121314151617181920212223242526272829public static int FirstNotRepeatingChar(String str) &#123; if (str.length() == 0 || str == null) return -1; //list1存放str中出现1次的字符 ArrayList&lt;Character&gt; list1 = new ArrayList&lt;Character&gt;(); //list2用来存放多次出现的字符 ArrayList&lt;Character&gt; list2 = new ArrayList&lt;Character&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); //两个list里面都没有这个字符 if (!list1.contains(ch) &amp;&amp; !list2.contains(ch)) &#123; //将字符放到list1中 list1.add(Character.valueOf(ch)); &#125; else &#123; //将list1之前加入的删掉（此时出现了相同字符，删掉相同字符） list1.remove(Character.valueOf(ch)); //将str中含有的相同字符存入list2 list2.add(Character.valueOf(ch)); &#125; &#125; if (list1.size() &lt; 0) &#123; return -1; &#125; return str.indexOf(list1.get(0)); &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【35】数组中的逆序对]]></title>
    <url>%2F2019%2F05%2F35.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 题目保证输入的数组中没有的相同的数字 数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 例子数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}； 2.解题思路方法1：暴力破解:时间超时 考察每一位，判断从这一位往后有多少小于该位的，结果累加，得到最后结果。 方法2：归并算法 3.代码方法1(超时)： 1234567891011121314151617181920212223public class Solution &#123; public static void main(String[]args) &#123; int []array=&#123;7,5,6,4&#125;; int num=InversePairs(array); System.out.println(num); &#125; public static int InversePairs(int [] array) &#123; int count=0; for(int i=0;i&lt;array.length-1;i++) &#123; for(int j=i+1;j&lt;array.length;j++) &#123; if(array[i]&gt;array[j]) &#123; count++; continue; &#125; &#125; &#125; return count%1000000007; &#125;&#125; 方法2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;public class Solution &#123; public int InversePairs(int [] array) &#123; if(array==null||array.length==0) &#123; return 0; &#125; int[] copy = new int[array.length]; for(int i=0;i&lt;array.length;i++) &#123; copy[i] = array[i]; &#125; int count = InversePairsCore(array,copy,0,array.length-1);//数值过大求余 return count; &#125; private int InversePairsCore(int[] array,int[] copy,int low,int high) &#123; if(low==high) &#123; return 0; &#125; int mid = (low+high)&gt;&gt;1; int leftCount= InversePairsCore(array,copy,low,mid)%1000000007; int rightCount = InversePairsCore(array,copy,mid+1,high)%1000000007; int count = 0; int i=mid; int j=high; int locCopy = high; while(i&gt;=low&amp;&amp;j&gt;mid) &#123; if(array[i]&gt;array[j]) &#123; count += j-mid; copy[locCopy--] = array[i--]; if(count&gt;=1000000007)//数值过大求余 &#123; count%=1000000007; &#125; &#125; else &#123; copy[locCopy--] = array[j--]; &#125; &#125; for(;i&gt;=low;i--) &#123; copy[locCopy--]=array[i]; &#125; for(;j&gt;mid;j--) &#123; copy[locCopy--]=array[j]; &#125; for(int s=low;s&lt;=high;s++) &#123; array[s] = copy[s]; &#125; return (leftCount+rightCount+count)%1000000007; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【33】丑数]]></title>
    <url>%2F2019%2F05%2F33-%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 2.解题思路 丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an 所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2a1, 2a2, 2*a3 ….. 包含3的有序丑数序列:3a1, 3a2, 3a3 ….. 包含5的有序丑数序列:5a1, 5a2, 5a3 ….. 以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可 3.代码1234567891011121314151617181920212223242526272829import java.util.*;public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; int []arr=new int[index]; if(index==0) return 0; arr[0]=1; //第一个丑数为1，放入数组的第一个元素 int t2=0; int t3=0; int t5=0; for(int i=1;i&lt;index;i++) &#123; //寻找3个序列中最小的那个数 arr[i]=Math.min(arr[t2]*2,Math.min(arr[t3]*3,arr[t5]*5)); //最小的那个数的序列值加1 if(arr[t2]*2==arr[i]) t2++; if(arr[t3]*3==arr[i]) t3++; if(arr[t5]*5==arr[i]) t5++; &#125; return arr[index-1]; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【32】把数组排成最小的数]]></title>
    <url>%2F2019%2F05%2F32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 2.解题思路 方法1： (1) 求出数组里面最大的数的位数，然后其他的数位数不够的进行补位 (2) 补位原则：如数组{3,32,321},最大位数为3，所以3进行补位变成333，补的两位为str[i]数组里面的最后一个charAt[str[i].length()-1];所以32补位变成322 (3) 对数组{333，322，321}进行从小到大排序，然后根据索引把字符串拼接即可得到答案。即从小到大排序为{321，322，333}，这三个数对应原数组的{321，32，3}，最后答案即为321323. 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.*;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; if(numbers.length&lt;=0||numbers == null) return ""; //排序，可得到最大的数为numbers[len-1] Arrays.sort(numbers); //求位数 int count = 0; int Max_ = numbers[numbers.length-1]; //得到最大的数的位数 while(Max_&gt;0) &#123; count++; Max_ = Max_/10; &#125; //将数组变成字符串数组 String str[] = new String[numbers.length]; for(int i = 0;i&lt;numbers.length;i++)&#123; str[i] = ""+numbers[i]; &#125; //补位 for(int i = 0;i&lt;numbers.length;i++)&#123; //得到补位要填充的数 String tmp ="" +str[i].charAt(str[i].length()-1); //原数组的位数 int len =str[i].length(); //补足到相同的位数 for(int j = 0;j&lt;count-len;j++) &#123; str[i] = str[i]+tmp; &#125; &#125; //排序 ArrayList&lt;Integer&gt; ss= new ArrayList&lt;&gt;(); //该数组的索引对应着numbers的索引 String strcopy[] = str.clone(); //将其进行从小到大的排序 Arrays.sort(str); //得到从小到大排序后原数组所在的索引 for(int i = 0;i&lt;numbers.length;i++)&#123; for(int j = 0;j&lt;numbers.length;j++)&#123; if(str[i].equals(strcopy[j]))&#123; ss.add(j); &#125; &#125; &#125; //将索引进行拼接得到结果 String res = ""; for(int i = 0;i&lt;numbers.length;i++)&#123; res = res +numbers[ss.get(i)]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【31】整数中1出现的次数]]></title>
    <url>%2F2019%2F05%2F31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 2.解题思路 方法1： 将每个数变成string,然后将string里面的1替换成”“,长度的减少就是这个string里面1的个数，但是这个方法中String是不可变字符串，故占用内存过多。 方法2： 依次计算出每个数中包含1的个数 3.代码123456789101112public static int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; String s = ""; for(int i = 1;i&lt;=n;i++)&#123; s = i+""; count += s.length()-s.replaceAll("1", "").length(); &#125; return count; &#125; 方法2: 1234567891011121314151617181920212223242526272829public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; if(n&lt;1) return 0; else &#123; int sum=0; for(int i=1;i&lt;=n;i++) sum+=NumberOf1(i); return sum; &#125; &#125; public int NumberOf1(int n) &#123; int count=0; while(n!=0) &#123; if(n%10==1)//求余 &#123; count++; &#125; n=n/10; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【30】连续子数组的最大和]]></title>
    <url>%2F2019%2F05%2F30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 2.解题思路用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。 当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令cur = 0.表示从下一个数开始累加。 当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最大值即可。 3.代码123456789101112131415import java.util.*;public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; if(array == null || array.length == 0) return 0; int res = Integer.MIN_VALUE; int cur = 0; for(int i = 0;i&lt;array.length;i++)&#123; cur += array[i]; res = Math.max(res,cur); cur = cur &lt; 0 ? 0 : cur; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【29】最小的K个数]]></title>
    <url>%2F2019%2F05%2F29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 2.解题思路 排序问题，本次使用快排，快排思想即： “挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(input.length&lt;k) return res; quicksort(input, 0, input.length - 1); for (int i = 0; i &lt; k; i++) &#123; res.add(input[i]); &#125; return res; &#125; public void quicksort(int arr[], int low, int high) &#123; if(low &lt; high) &#123; int position = partition(arr, low, high); quicksort(arr, low, position - 1); quicksort(arr, position + 1, high); &#125; &#125; public int partition(int arr[], int low, int high) &#123; //设置基准值 int key = arr[low]; while(low &lt; high)&#123; //从右到左，直到找到一个小于key的值 while(low &lt; high &amp;&amp; arr[high] &gt;= key) --high; //将该值填入前的坑 arr[low] = arr[high]; //从左到右，直到找到一个大于key的值 while(low &lt; high &amp;&amp; arr[low] &lt;= key) ++low; //将该值填入前一个坑 arr[high] = arr[low]; &#125; //将基准值填入最后一个坑 arr[low] = key; //最后一个坑划分了左边小于该值，右边大于该值 return low; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【28】数组中出现次数超过一半的数字]]></title>
    <url>%2F2019%2F05%2F28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 2.解题思路利用一个hashmap用来存储数组里面每个数出现的次数，然后遍历map，比较每个数的value是否超过数组的一半 3.代码12345678910111213141516171819import java.util.*;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int res = 0; for(int i = 0;i&lt;array.length;i++)&#123; if(map.containsKey(array[i]))&#123; map.put(array[i],map.get(array[i])+1); &#125;else&#123; map.put(array[i],1); &#125; &#125; for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123; if(entry.getValue()&gt;array.length/2) res = entry.getKey(); &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【27】字符串的排列]]></title>
    <url>%2F2019%2F05%2F27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 2.解题思路 算法思路：（递归实现）(1)n个元素的全排列=（n-1个元素的全排列）+（另一个元素作为前缀）；(2)出口：如果只有一个元素的全排列，则说明已经排完，则输出数组； (3)不断将每个元素放作第一个元素，然后将这个元素作为前缀，并将其余元素继续全排列，等到出口，出口出去后还需要还原数组； 以字符串abc为例： a 作为开头 -&gt; 求 bc 全排列 -&gt; 得到 bc 和 cb -&gt; 与 a 合并 -&gt; 得到 abc 和 acb b 作为开头 -&gt; 求 ac 全排列 -&gt; 得到 ac 和 ca -&gt; 与 b 合并 -&gt; 得到 bac 和 bca c 作为开头 -&gt; 求 ab 全排列 -&gt; 得到 ab 和 ba -&gt; 与 c 合并 -&gt; 得到 cab 和 cba 3.代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; //用于排序输出 ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); if(str==null||str.length()==0)&#123; return res; &#125; //将字符串转化成字符数组 char[] chars = str.toCharArray(); //从第0个字符开始全排列 res=Permu(chars,0,res); return res ; &#125; public ArrayList&lt;String&gt; Permu(char[] str, int start, ArrayList&lt;String&gt; list) &#123; if (str == null) &#123; return null; &#125; //设置递归的出口,即当需要全排列的范围只有一个元素，则全排结束 if (start == str.length - 1) &#123; //去除重复的字符串 if (list.contains(String.valueOf(str))) &#123; return null; &#125; else&#123; list.add(String.valueOf(str)); &#125; &#125; else &#123; //for循环将start~len-1每一个数放到start位置中去，并实现全排列 //str[start]-----str[len-1]的全排列 for (int j = start; j &lt; str.length; j++) &#123; //取出第j个字符作为第一个字符 swap(str,j,start); //求出str[start+1]----str[len-1]的全排列 Permu(str, start+ 1, list); //恢复原数组 swap(str,j,start); &#125; &#125; //生成字典序 Collections.sort(list); return list; &#125; public void swap(char[] chars,int a,int b)&#123; if(a==b)&#123;//因为会出现原位置与原位置交换，直接空即可 &#125;else&#123; char temp = chars[a]; chars[a]=chars[b]; chars[b]=temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【26】二叉搜索树与双向链表]]></title>
    <url>%2F2019%2F05%2F26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1. 题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 二叉树如 10 / \ 6 14 / \ / \ 4 8 12 16 转化成双向链表 4 6 8 10 12 1416 2.解题思路 (1)二叉搜索树中，每个结点都有两个分别指向其左、右子树的指针，左子树结点的值总是小于父结点的值，右子树结点的值总是大于父结点的值。 (2)双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。所以这两种数据结构的结点是一致 为了减少指针的变换次数，并让操作更加简单，在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。 链表是有序的，可以借助二叉树中序遍历，因为中序遍历算法的特点就是从小到大访问结点。当遍历访问到根结点时，假设根结点的左侧已经处理好，只需将根结点与上次访问的最近结点（左子树中最大值结点）的指针连接好即可。进而更新当前链表的最后一个结点指针。同时中序遍历过程正好是转换成链表的过程，可采用递归方法处理 思想：把左子树、右子树都转换成排序的双向链表之后在和根结点链接起来，整个二叉树也变成了排序的双向链表。 3. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeNode Convert(TreeNode root) &#123; if(root==null)&#123;//假如根节点为空，返回空 return null; &#125; if(root.left==null&amp;&amp;root.right==null)&#123;//假如只有一个根节点，则返回根节点 return root; &#125; //1、将左子树构造成双链表，并返回该链表头结点left TreeNode left=Convert(root.left); //2、定位到左子树链表的最后一个节点（左子树最右边的节点） //创建一个临时节点P,用来遍历找到左链表的最后一个节点(左子树最右边的节点)，p初始化指向做左子树的根节点， TreeNode p=left; while(p!=null&amp;&amp;p.right!=null)&#123; //最终p为左子树最右边的节点 p=p.right; &#125; //3、如果左子树链表不为空，将当前root追加到左子树链表后 if(left!=null)&#123;//左子树链表不为空 //左子树链表的最后一个节点p（左子树最右边节点）的右指针指向当前root节点 p.right=root; //当前root节点的左指针指向左子树链表的最后一个节点p（左子树最右边节点） root.left=p; &#125; //4、将右子树构造成双链表，并返回该链表的头结点right TreeNode right=Convert(root.right); //5、如果右子树链表不为空，将右子树链表追加到当前root后 if(right!=null)&#123;//右子树链表不为空 right.left=root;//右子树链表的头结点right的左指针指向当前root root.right=right;//当前root的右指针指向右子树链表的头结点right &#125; return left!=null?left:root;//根据左子树链表是否为空返回整个双向链表的头指针。 &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【25】复杂链表的复制]]></title>
    <url>%2F2019%2F05%2F25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 2.解题思路3.代码123456789101112131415161718192021222324252627282930313233/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if (pHead == null) return null; RandomListNode head = new RandomListNode(pHead.label); RandomListNode ans = head; if (pHead.random != null) &#123; head.random = new RandomListNode(pHead.random.label); &#125; while (pHead.next != null) &#123; pHead = pHead.next; head.next = new RandomListNode(pHead.label); if (pHead.random != null) &#123; head.next.random = new RandomListNode(pHead.random.label); &#125; head = head.next; &#125; return ans; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null) &#123; return null; &#125; RandomListNode currentNode = pHead; //1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面； while(currentNode != null)&#123; RandomListNode cloneNode = new RandomListNode(currentNode.label); RandomListNode nextNode = currentNode.next; currentNode.next = cloneNode; cloneNode.next = nextNode; currentNode = nextNode; &#125; currentNode = pHead; //2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next; while(currentNode != null) &#123; currentNode.next.random = currentNode.random==null?null:currentNode.random.next; currentNode = currentNode.next.next; &#125; //3、拆分链表，将链表拆分为原链表和复制后的链表 currentNode = pHead; RandomListNode pCloneHead = pHead.next; while(currentNode != null) &#123; RandomListNode cloneNode = currentNode.next; currentNode.next = cloneNode.next; cloneNode.next = cloneNode.next==null?null:cloneNode.next.next; currentNode = currentNode.next; &#125; return pCloneHead; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【24】二叉树中和为某值的路径]]></title>
    <url>%2F2019%2F05%2F24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一棵二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 2.解题思路整个过程可以采用先序遍历方式的DFS，即根节点—–&gt;左子树—–&gt;右子树。 随后考虑一次遍历完成后的处理， (1)当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点； (2)如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。 (3)考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; //创建一个类型为ArrayList&lt;Integer&gt;的list ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathlist=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); //创建一个list,用于存放遍历的值 ArrayList&lt;Integer&gt; path=new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; //如果树为空，则返回空的pathlist if(root==null) return pathlist; //将root值放入list path.add(root.val); //如果根的左子树、右子树、目标值=根值，则返回path if(root.left==null&amp;&amp;root.right==null&amp;&amp;target==root.val) &#123; pathlist.add(new ArrayList&lt;Integer&gt;(path)); &#125; //如果此时根值小于目标值并且含有左子树 if(root.val&lt;=target&amp;&amp;root.left!=null) &#123; //将遍历左子树，将根设为左子树并且此时的target=target-遍历过的root值 FindPath(root.left,target-root.val); &#125; //如果此时根值小于目标值并且含有右子树 if(root.val&lt;=target&amp;&amp;root.right!=null) &#123; //将遍历右子树，将根设为右子树并且此时的target=target-遍历过的root值 FindPath(root.right,target-root.val); &#125; //不论路径的值是否等于输入整数值，都要回退， //即使用remove函数移除路径上的最后一个节点。 path.remove(path.size()-1); return pathlist; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【23】二叉搜索树的后序遍历序列]]></title>
    <url>%2F2019%2F05%2F23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 2.解题思路二叉搜索树后序遍历为：左子树—-&gt;右子树—-&gt;根，且左子树值&lt;根值&lt;右子树值 如二叉搜索树： 10 / \ 6 12 / \ / \ 3 7 11 20 后序遍历结果为：3 7 6 11 20 12 10 对于一个数组sequence，最后一个元素是sequence[len-1] （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于sequence[len-1] ，后一段（右子树）大于sequence[len-1] ，且这两段（子树）都是合法的后序序列 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.*;public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence==null||sequence.length&lt;=0) &#123; return false; &#125; int len=sequence.length; //数组长度 int root=sequence[len-1]; //数组的最后一个数为根 int i=0; for(;i&lt;len-1;i++) &#123; if(root&lt;=sequence[i]) //左子树的数值都小于根 break; &#125; //此时的j即为划分出来的左子树部分和右子树部分的分界 int j=i; for(;j&lt;=len-1;j++) &#123; //j到len-1都都为右子树，数值都大于root,如果root大于他们，则返回false if(root&gt;sequence[j]) &#123; return false; &#125; &#125; //递归判断左子树 boolean leftflag=true; if(i&gt;0) &#123; leftflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,0,i)); &#125; //递归判断右子树 boolean rightflag=true; if (i&lt;len-1) &#123; rightflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,sequence.length-1)); &#125; return leftflag &amp;&amp; rightflag; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【22】从上到下打印二叉树]]></title>
    <url>%2F2019%2F05%2F22-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 2.解题思路使用两个队列一个存放节点treelist，一个存放值intlist。 先将根节点root加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来,并将root值存入intlist,遍历结束条件是i值到达treelist.size-1 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; //创建一个列表用来存储节点 ArrayList&lt;TreeNode&gt; treelist=new ArrayList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; intlist=new ArrayList&lt;Integer&gt;(); if(root==null) //没有节点 return intlist; //1.先存入根节点 treelist.add(root); //2.循环遍历列表，一开始列表里存了root for(int i=0;i&lt;treelist.size();i++) &#123; TreeNode node=treelist.get(i); //3.如果左子节点不为空，则将节点加入列表 if(node.left!=null) treelist.add(node.left); //3、如果右子节点不为空，则将右子节点加入到列表中，这时列表的size加1 if(node.right!=null) treelist.add(node.right); intlist.add(node.val); //4、因为执行上面操作后会增加列表的si //因此可以继续循环下一个节点，直到循环完所有节点 &#125; return intlist; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【21】栈的压入、弹出]]></title>
    <url>%2F2019%2F05%2F21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 2.解题思路 依次入栈pushA数组中的数,直到pushA[i] =popA[index],此时将栈顶这个相等的值弹出。 判断栈中是否还有值，如果没有返回true,如果有并且index！=popA.length,依次弹出栈中数值，并与popA[index++]比较,两个不相等返回false,到栈为空时没执行false则返回true 3.代码12345678910111213141516171819202122232425public boolean IsPopOrder(int [] pushA,int [] popA) &#123; //用于pushA入栈 Stack&lt;Integer&gt; a = new Stack(); int index = 0; for(int i = 0;i&lt;pushA.length;i++)&#123; a.push(pushA[i]); //当遇到与popA[index]相等的数时，弹出该数 if(pushA[i] == popA[index])&#123; if(index++ == popA.length-1)&#123; return true; &#125; a.pop(); &#125; &#125; //栈中还有值，index还没到达popA尾部，依次弹出与popA比较 while (!a.isEmpty())&#123; if(a.pop()!=popA[index++])&#123; return false; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【20】包含min函数的栈]]></title>
    <url>%2F2019%2F05%2F20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[1.题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 2.解题思路 解题思路：利用辅助栈来存储现有栈的最小值。在入栈和出栈的时候将现有栈和最小值栈进行比较。(1)入栈时，若新值比最小值栈的栈顶还小，则将该值同时push到最小值栈； (2)出栈时，若现有栈的栈顶和最小值栈栈顶一致，则同时出栈，(3)否则，仅仅现有栈pop；通过这一操作，最小值栈的栈顶将永远是现有栈元素中的最小值。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; // 用于存储所有的数据，压入push,弹出pop Stack&lt;Integer&gt; data_stack =new Stack&lt;&gt;(); //用于存储栈最小的值 Stack&lt;Integer&gt; min_stack = new Stack&lt;&gt;(); public void push(int node) &#123; //如果最小值栈为空或者栈顶值比新入的node值大 if(min_stack.isEmpty()||min_stack.peek()&gt;=node)&#123; //压入node，保持栈顶为栈的最小值 min_stack.push(node); &#125;else &#123; //否则再次压入栈顶值 min_stack.push(min_stack.peek()); &#125; //数据都压入data_stack data_stack.push(node); &#125; //出栈 public void pop() &#123; if(data_stack.empty()||min_stack.empty()) &#123; return; &#125; //弹出数据 data_stack.pop(); //弹出min栈顶，此时min_stack的栈顶为弹出某数剩下数的最小值 min_stack.pop(); &#125; //查看栈的栈顶元素 public int top() &#123; if(!data_stack.isEmpty()) &#123; return data_stack.peek(); &#125; return 0; &#125; //查看最小的元素，即min_stack的栈顶 public int min() &#123; if(!min_stack.empty()) &#123; return min_stack.peek(); &#125; return 0; &#125; &#125; 补充stack.peek:获取栈顶元素，返回栈顶元素但是不移除它 stack.add:向栈中添加元素，成功返回true stack.push:向栈中添加元素，返回结果是当前添加的元素 stack.pop:移除并返回栈顶元素 stack.isEmpty:检查是否为空栈 stack.search(“value”):查看某元素再栈中的位置，计算从1开始]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【19】顺时针打印矩阵]]></title>
    <url>%2F2019%2F04%2F19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 2.解题思路 打印分为四步：循环的次数即打印的圈速，即 rows&gt;start*2&amp;&amp;column&gt;start*2 (1) 从左到右打印一行: 开始于[start,start]，结束于[start,col-start-1] (2) 从上到下打印一行, 开始于[start+1,col-start-1],结束于[col-start-1,col-start-1] (3) 从右到左打印一行 开始于[col-start-1,col-start-2],结束于[col-start-1,start] (4) 从下到上打印一行 开始于[col-start-2,start],结束于[start+1,start] 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; // 矩阵行数 int rows = matrix.length; // 矩阵列数 int columns = matrix[0].length; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 让循环继续的条件是当前行数大于该圈循环开始的行数的两倍以及当前列数大于 //该圈循环开始的列数的两倍（每圈循环开始的行数、列数相同） int start = 0; // 从(0,0)开始循环,圈数：start=0第一圈，start=1第二圈...以此类推 while (rows &gt; start * 2 &amp;&amp; columns &gt; start * 2)&#123; // 每一圈最后一行下标 int endRow = rows - 1 - start; // 每一圈最后一列下标 int endColumn = columns - 1 - start; // 开始一圈圈打印，每打印一圈分为四步，从左到右、从上到下、从右到左、从下到上 // 从左到右，第一步一定会走 for (int i = start; i &lt;= endColumn; i++) list.add(matrix[start][i]); // 从上到下，最后一行大于开始行 if (endRow &gt; start)&#123; for (int i = start + 1; i &lt;= endRow; i++) list.add(matrix[i][endColumn]); &#125; // 从右到左，最后一行大于开始行，最后一列大于开始列 if (endRow &gt; start &amp;&amp; endColumn &gt; start)&#123; for (int i = endColumn - 1; i &gt;= start; i--) list.add(matrix[endRow][i]); &#125; // 从下到上,至少是三行两列，也就是最后一行大于开始行加2，最后一列大于开始列 if (endRow &gt;= start + 2 &amp;&amp; endColumn &gt; start)&#123; for (int i = endRow - 1; i &gt; start; i--) list.add(matrix[i][start]); &#125; // 继续打印下一圈 start++; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【18】二叉树的镜像]]></title>
    <url>%2F2019%2F04%2F18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[1.题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 二叉树的镜像定义： 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 2.解题思路(1)镜像即左右子树交换位置，故交换左子树右子树位置 (2)交换后的左右子树的节点保持原来的顺序，故要交换左右子树自己的左右子树 (3)终止条件为root==null || root.left==null ||root.right == null 3.代码123456789101112131415161718192021222324252627282930313233/* public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125; */ public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root!=null&amp;&amp;(root.left!=null||root.right!=null))&#123; //这三句是左子树跟右子树交换 TreeNode tem=root.left; root.left=root.right; root.right=tem; //然后将根节点换成root.left Mirror(root.left); //然后将根节点换成root.right Mirror(root.right); &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【17】树的子结构]]></title>
    <url>%2F2019%2F04%2F17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 2.解题思路 大体思路是首先判断B的根节点和A的根节点是否相同（这里的相同是指节点的值相同并且左右子节点相同），如果相同比较他们的左右子节点，这一步骤是相同的，可以用递归完成，直到B遍历到每个尾节点，如果这一过程比较的所有节点是相同的，则证明B是A的子结构。如果B的根节点和A的根节点不同，则A向他的左右子节点滑动，然后继续跟B的子节点比较，步骤同上。 (1) 如果root1.val==root2.val,那个就以这个为起点判断是否A包含B (2) 如果没找到，就以root1.left作为起点继续判断A是否包含B (3) 如果没找到，再以root1.right作为起点判断A是否包含B 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false if (root2 != null &amp;&amp; root1 != null) &#123; //如果找到了对应Tree2的根节点的点 if(root1.val == root2.val)&#123; //以这个根节点为为起点判断是否包含Tree2 result = doesTree1HaveTree(root1,root2); &#125; //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.left,root2); &#125; //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.right,root2); &#125; &#125; //返回结果 return result; &#125;public boolean doesTree1HaveTree(TreeNode node1, TreeNode node2) &#123; //如果Tree2已经遍历完了都能对应的上，返回true if (node2 == null) &#123; return true; &#125; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if (node1 == null) &#123; return false; &#125; //如果其中有一个点没有对应上，返回false if (node1.val != node2.val) &#123; return false; &#125; //如果根节点对应的上，那么就分别去子节点里面匹配 return doesTree1HaveTree(node1.left,node2.left) &amp;&amp; doesTree1HaveTree(node1.right,node2.right); &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【16】合并两个排序的链表]]></title>
    <url>%2F2019%2F04%2F16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 例： 链表1： 1 ----&gt; 3 ----&gt; 5 ----&gt; 8 链表2： 2 ----&gt; 4 ----&gt; 6 ----&gt; 7 合并结果： 1 ----&gt; 2 ----&gt; 3 ----&gt; 4 ----&gt; 5 ----&gt; 6 ----&gt; 7 ----&gt; 8 2.解题思路 判断有没有ListNode是空的，如果有则返回另一个 递归实现，如果List1.val&lt;list2.val,pMergeHead = list1,否则pMergeHead = list2，递归直到两个ListNode都为空 3.代码123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1==null)&#123; return list2; &#125;else if(list2==null)&#123; return list1; &#125; ListNode pMergeHead = null; if(list1.val&lt;list2.val)&#123; pMergeHead = list1; pMergeHead.next = Merge(list1.next,list2); &#125;else&#123; pMergeHead = list2; pMergeHead.next = Merge(list1,list2.next); &#125; return pMergeHead; &#125;&#125;i]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【15】反转链表]]></title>
    <url>%2F2019%2F04%2F15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，反转链表后，输出新链表的表头。 2.解题思路 用一个栈stack依次存储ListNode里面的值，因为stack的特点是先进后出，故依次弹出即为反转链表 用一个链表temp依次存储弹出的值，依次next存入下一个链表值，链表res指向这个temp的头节点 反转链表的结果为res.next,因为我们之前设temp的头节点为-1（自己设的）。 3.代码123456789101112131415161718192021222324252627 /* public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; */import java.util.*; public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (head!=null)&#123; stack.push(head.val); head = head.next; &#125; ListNode temp = new ListNode(-1); ListNode res = temp; while(stack.size()!=0)&#123; temp.next = new ListNode(stack.pop()); temp = temp.next; &#125; return res.next; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【14】链表中倒数第K个结点]]></title>
    <url>%2F2019%2F04%2F14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，输出该链表中倒数第k个结点。 2.解题思路 先用一个count计算出链表的长度，如果count&lt;k，返回null 链表的倒数第K个即为链表的正数（count-k+1）个,一个for循环，将指针轮询到那个点，然后再将起后面截断（head.next = null）即可。 3.代码123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode root = head; int count = 0; while(root!=null)&#123; count ++; root = root.next; &#125; if(count&lt;k)&#123; return null; &#125; //倒数第K个即正数第（count-k+1）个 for(int i = 1;i&lt;(count-k+1);i++)&#123; head = head.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【13】调整数值顺序使奇数位于偶数前面]]></title>
    <url>%2F2019%2F04%2F13-%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 2.解题思路依次遍历array数组，遇到奇数存到原来的array数组前面，遇到偶数放到res数组，然后将两个数组拼接即可。 3.代码1234567891011121314151617181920public class Solution &#123; public void reOrderArray(int [] array) &#123; int []res = new int[array.length]; int count = 0; int count2 = 0; for(int i = 0;i&lt;array.length;i++)&#123; //如果是奇数，则放在数组前面 if(array[i]%2 != 0)&#123; array[count++] = array[i]; &#125;else&#123; //偶数放在另一个数组里 res[count2++] = array[i]; &#125; &#125; int j = 0; for(int i = count;i&lt;array.length;i++)&#123; array[i] = res[j++]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【12】数值的整数次方]]></title>
    <url>%2F2019%2F04%2F12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方 2.解题思路 （1）exponent &gt; 0,如2^3,则可以直接运算得出结果 （2）exponent &lt; 0,如2^-3,则结果为（1/2）^3 （3）exponent = 0,如2^0,则结果为1 3.代码123456789101112131415161718192021public class Solution &#123; public double Power(double base, int exponent) &#123; if(exponent&lt;0)&#123; return powCal(1.0/base,-1*exponent); &#125;else if(exponent&gt;0)&#123; return powCal(base,exponent); &#125;else&#123; return 1; &#125; &#125; //计算base的exponent次方 public double powCal(double base, int exponent) &#123; double res = 1; for(int i = 0;i&lt;exponent;i++)&#123; res = res*base; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【11】二进制中1的个数]]></title>
    <url>%2F2019%2F04%2F11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 2.解题思路 方法1：直接将其转成二进制数组 方法2：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。 3.代码方法1： 1234567891011121314public class Solution &#123; public int NumberOf1(int n) &#123; int count=0; char []a=Integer.toBinaryString(n).toCharArray(); for(int i=0;i&lt;a.length;i++) &#123; if(a[i]=='1') &#123; count++; &#125; &#125; return count; &#125;&#125; 方法2： 123456789101112131415public class Solution &#123; public static int NumberOf(int n) &#123; int count = 0; while (n &gt; 0) &#123; count++; n = (n - 1) &amp; n; &#125; return count; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【10】矩形覆盖]]></title>
    <url>%2F2019%2F04%2F10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[1.题目描述 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 2.解题思路类似于青蛙跳台阶 当 n = 1时，只有一种横向排列的方式 当 n = 2时，有两种选择，横向或者竖向 当 n = 3时，如果选择竖向，则还剩下2*2的排列，如果选择横向，只有一种选择方案(剩下的一个横向一个竖向) 递推可得F(2 * n) = F(2 * (n-1))+F(2 * (n-2) ) , n&gt;=3 3.代码1234567891011public class Solution &#123; public int RectCover(inttarget) &#123; if(target &lt;=0)&#123; return0; &#125; elseif(target ==1|| target == 2)&#123; returntarget; &#125; return(RectCover(target-1)+RectCover(target-2)); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【9】变态跳台阶]]></title>
    <url>%2F2019%2F04%2F9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[1.题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 2.解题思路123456789101112131415161718//f(0) = 0//f(1) = 1//f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。//f(3) = f(3-1) + f(3-2) + f(3-3) ...//f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)/*说明：1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。2）n = 1时，只有1种跳法，f(1) = 13) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1)6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： f(n-1) =f(0)+f(1)+f(2)+f(3)+...+f((n-1)-1) =f(0)+f(1)+f(2)+f(3)+...+f(n-2) f(n) =f(0)+f(1)+f(2)+f(3)+...+f(n-2)+f(n-1)=f(n-1)+f(n-1)可以得出：f(n) = 2*f(n-1)*/ 3.代码1234567891011public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;=0)&#123; return 0; &#125;else if(target==1)&#123; return 1; &#125;else&#123; return 2*JumpFloorII(target-1); &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【8】跳台阶]]></title>
    <url>%2F2019%2F04%2F8-%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[1.题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 2.解题思路 把n级台阶的跳的次数看成是n的函数,即为f(n),当n&gt;2时,第一次跳有两种跳法, 第一次跳1级,则该次跳法数目为后面剩下的n-1级台阶的跳法数目f(n-1)。 第一次跳2级,则该次跳法数目为后面剩下的n-2级台阶的跳法数目f(n-2)。 所以f(n)=f(n-1)+f(n-2),即相当于斐波那契数列。` 即该题跟斐波那契数列是相似的，青蛙跳台阶的公式为 F(n) = F(n-1)+F(n-2),n&gt;=3 3.代码1234567891011121314151617181920public class Solution &#123; public int JumpFloor(int target) &#123; if(target&lt;=2) &#123; return target; &#125; int one_=1; //第一次跳台阶的方法数 int two_=2; //第二次跳台阶的方法数 int finN=0; for(int i=3;i&lt;=target;i++) &#123; finN=one_+two_; one_=two_; two_=finN; &#125; return finN; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【7】斐波那契数组]]></title>
    <url>%2F2019%2F04%2F7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1.题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 斐波那契数列：1 1 2 3 5 8 13 21 34 …. 2.解题思路 斐波那契数列：从第三项开始，每一项都等于前两项之和。通项公式为 F(n) = F(n-1)+F(n-2),n&gt;=3 方法1：通过递归实现，但是时间复杂度和空间复杂度都会很大 方法2：依次F(n-1)和F(n-2)值，求F(n)就很简单啦 3.代码方法一： 1234567891011public class Solution &#123; public int Fibonacci(int n) &#123; if(n==0) return 0; else if(n==1 || n==2) return 1; else return (Fibonacci(n-1)+Fibonacci(n-2)); &#125;&#125; 方法2： 1234567891011121314151617181920212223public class Solution &#123; public int Fibonacci(int n) &#123; if (n==0) return 0; if(n==1||n==2) return 1; int one_ = 1; //用于存储f(n-2) int two_ =1; //用于存储f(n-1) int fin = 0; for(int i = 3;i&lt;=n;i++)&#123; fin = one_+two_; //向前递推 one_ = two_; //下一次的f(n-2)为 上一次结果的f(n-1) two_ = fin; //下一次的f(n-1)为 上一次结果的fin &#125; return fin; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【6】旋转数组的最小数字]]></title>
    <url>%2F2019%2F04%2F6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1. 题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 2.解题思路 方法1：重头到尾遍历，找到数组的最小值，时间复杂度为O(N) 方法2：二分遍历查找 mid = low +(high-low)/2; 需要考虑三种情况： arr[mid] &gt; arr[high],如[3,4,5,1,2]说明最小数字在mid的右边，缩小范围，low = mid+1; arr[mid]&lt;arr[high],如[1,2,3,4,5]说明最小数字在mid的左边，high = mid-1; arr[mid] = arr[high],如[0,1,1,1,1]或者[1,1,1,0,1],一步步缩小范围，high = high-1; 3.代码123456789101112131415161718192021222324252627import java.util.ArrayList;public class Solution &#123; public static int minNumberInRotateArray(int[] arr)&#123; int low = 0; int high = arr.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(arr[mid] &gt; arr[high])&#123; low = mid + 1; &#125;else if(arr[mid] == arr[high])&#123; high = high - 1; &#125;else&#123; high = mid; &#125; &#125; return arr[low]; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【5】两个栈实现队列]]></title>
    <url>%2F2019%2F04%2F5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1. 题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 2. 解题思路 栈的规则是先进后出，队列的规则是先进先出 stack1一直维持着栈底–栈顶是队列的入队顺序 stack2一直维持着栈顶–栈尾为队列的入队顺序 当执行队列的入队（push）时，如果stack2为空，则直接插入到stack1,stack1从栈底到栈顶的顺序为入队顺序，如果stack2不为空，则将stack2的元素倒入（栈顶—栈尾）stack1,然后再插入数据 4- 当执行队列的出队(pop)操作时，应该出的是stack1的栈底元素，故将stack1依次倒入stack2,这时stack2的栈顶就是要出队的数值，此时stack1为空，stack2从（栈顶–栈尾）为入队顺序 3. 代码12345678910111213141516171819202122232425262728public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //队列的入队 public void push(int node) &#123; //将stack2倒入stack1 while (!stack2.empty()) &#123; stack1.push(stack2.pop()); &#125; //将元素插入stack1 stack1.push(node); &#125; //队列的出队 public int pop() &#123; //将stack1倒入stack2 while (!stack1.empty()) &#123; stack2.push(stack1.pop()); &#125; //stack2的栈顶就是出队数值 return stack2.pop(); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【4】重建二叉树]]></title>
    <url>%2F2019%2F04%2F4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 2.解题思路 先序遍历为：根-&gt;左子树-&gt;右子树，中序遍历为左子树-&gt;根-&gt;右子树 先找到根结点，为先序遍历的第一个数值 根据这个数值，可以划分中序中的左子树和右子树范围 递归构建左子树和右子树 3.代码12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Arrays;//** * Definition for binary tree public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length==0 || in.length==0) return null; TreeNode node = new TreeNode(pre[0]); //根结点 for(int i=0;i&lt;pre.length;i++)&#123; //找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点 if(pre[0] == in[i])&#123; //递归构建左子树，此时前序的范围缩小为[1,i+1),中序缩小为[0,i) node.left =reConstructBinaryTree(Arrays.copyOfRange (pre,1,i+1),Arrays.copyOfRange(in,0,i)); //递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len) node.right = reConstructBinaryTree(Arrays.copyOfRange (pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length)); break; &#125; &#125; return node; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【3】从尾到头打印链表]]></title>
    <url>%2F2019%2F04%2F3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 2.解题思路 先用一个栈stack存储从头到尾的链表数值 再依次弹出，因为栈是先进后出的，故弹出的结果为从尾到头 将弹出的结果放入list返回 3.代码12345678910111213141516171819202122232425262728public class Main_3 &#123; public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; public static class Solution &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); public static ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) &#123; list.add(stack.pop()); &#125; return list; &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-15:三数之和]]></title>
    <url>%2F2019%2F04%2Fleetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述：给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 2.解题思路 首先按升序排序；然后定义下标变量i,j,k，因为是三元组，所以要三个变量如果简单的遍历，那么跟是否有序没有关系，其时间复杂度将达到O(n^3)。仔细想想：如果当前选择了a、b、c三个数，如果其和小于目标target，那么需要将其中一个数用更大的数替换；反之亦然。但究竟替换三个数中的哪个数？无法确定就只能先固定两个变量，让其第三个变化（替换）。一种办法是：固定前两个数i,j，然后让k在一个范围中二分变化（二分查找思想） 3.代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); List&lt;Integer&gt; targets = new ArrayList&lt;&gt;(); // 用于去重 if((nums.length&gt;0 &amp;&amp; nums.length&lt;3) ||(nums.length&gt;0 &amp;&amp;nums[0]&gt;0)) return list; for(int i = 0;i&lt;=nums.length-3;i++) &#123; int target = 0 - nums[i]; if (!targets.contains(target)) &#123; //用于去重 targets.add(target); int k = i + 1; int j = nums.length - 1; while (k &lt; j) &#123; if (nums[k] + nums[j] == target) &#123; List&lt;Integer&gt; li = new ArrayList(); li.add(nums[i]); li.add(nums[k]); li.add(nums[j]); list.add(li); while (k &lt; j &amp;&amp; nums[k] == nums[k + 1]) ++k; while (k &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j; k++; j--; &#125; else if (nums[k] + nums[j] &lt; target) &#123; k++; &#125; else &#123; j--; &#125; &#125; &#125; &#125; return list; &#125;&#125; 4.我的提交记录]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【2】空格替换]]></title>
    <url>%2F2019%2F04%2F2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1. 题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 2. 解题思路 方法1：利用函数replaceAll完成 方法2： **先计算需要多少的空间 **从后向前依次插入 3.代码方法1： 12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll(" ", "%20"); &#125;&#125; 方法2： 12345678910111213141516171819202122232425262728public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int spacenum = 0;//spacenum为计算空格数 for(int i=0;i&lt;str.length();i++)&#123; if(str.charAt(i)==' ') spacenum++; &#125; //indexold为为替换前的str下标 int indexold = str.length()-1; //计算空格转换成%20之后的str长度 int newlength = str.length() + spacenum*2; //indexold为为把空格替换为%20后的str下标 int indexnew = newlength-1; //使str的长度扩大到转换成%20之后的长度,防止下标越界 str.setLength(newlength); for(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; if(str.charAt(indexold) == ' ')&#123; str.setCharAt(indexnew--, '0'); str.setCharAt(indexnew--, '2'); str.setCharAt(indexnew--, '%'); &#125;else&#123; str.setCharAt(indexnew--, str.charAt(indexold)); &#125; &#125; return str.toString(); &#125;&#125; 补充1：String和StringBuffer的转换String转换成StringBuffer 12String str = "abc";StringBuffer b=new StringBuffer(str); StringBuffer转换成String 12StringBuffer a=new StringBuffer();String b=a.toString(） 补充2：String、StringBuffer、StringBuilder 1）运行速度StringBuilder&gt;StringBuffer&gt;String 2）String是字符串常量，String对象一旦创建就不能更改。StringBuffer为 字符串变量，可更改 3） String适用于少量的字符串操作，StringBuffer适用于多线程下字符缓冲区进行大量操作的情况。 4） StringBuffer 与 StringBuilder 中的方法和功能完全是等价的， 5） 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 6） 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而StringBuffer则每次都需要判断锁，效率相对更低。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【1】二维数组的查找]]></title>
    <url>%2F2019%2F04%2F1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[1.题目描述： 在一个二维数组中（每个一维数组的长度相同），如数组 1 2 3 4 5 6 7 8 9 每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 2.解题思路 选择右上角的数字作为开始点 如果array[row][col]&gt;target,则向左查找，col–； 如果array[row][col]&lt;target,则向下查找，row++； 3.代码123456789101112131415161718public class Solution &#123; public boolean Find(int target, int [][] array) &#123; boolean res = false; int row = 0; int col = array[0].length-1; while(row&lt;=array.length-1&amp;&amp;col&gt;=0)&#123; if(array[row][col]&gt;target)&#123; col--; &#125;else if(array[row][col]&lt;target)&#123; row++; &#125;else&#123; res = true; break; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_线程TLAB局部缓存区域]]></title>
    <url>%2F2019%2F04%2Fjvm-%E7%BA%BF%E7%A8%8BTLAB%E5%B1%80%E9%83%A8%E7%BC%93%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[1.对象内存分配的两种方法Ø 指针碰撞 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞” Ø 空闲列表 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表” 问题： 多线程执行时，一个线程正在给A对象分配内存，指针还没有来的及修改，其它为B对象分配内存的线程，而且还是引用这之前的指针指向。就出现问题了 2.TLAB线程本地分配缓存区概念：线程本地分配缓存区,这是一个线程专用的内存分配区域。 由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步（虚拟机采用CAS配上失败重试的方式保证更新操作的原子性），而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。 划重点：1.堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的 2.Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer）， 其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配 3.JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB。默认设定为占用Eden Space的1%。TLAB上的分配由于是线程私有所以没有锁开销。 4.TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。 5.所有新创建的Object 都将会存储在新生代Yong Generation中。 如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_内存分配和回收策略]]></title>
    <url>%2F2019%2F04%2FJVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[1.内存分配1.对象优先在eden分配 对象先在新生代Eden区分配，当Eden区没有足够空间进行分配，虚拟机将发起 Minor GC 2.大对象直接进入老年代 大对象指的是需要大量的连续内存空间的java对象。如很长的字符串或者数组 -XX:PretenureSizeThreshold:大于该值直接在老年代分配 3.长期存活的对象直接进入老年代 12设置对象年龄计数器，GC一遍没死年龄加1,默认老年阈值为15-XX:MaxTenuringThreshold:老年代年龄设置 动态对象年龄判定survivor空间中相同年龄的对象大小总和&gt;survivor的一半，该年龄进入老年代，无需等到MaxTenuringThreshold设定的年龄。 2.回收策略空间分配担保：老年代最大可用空间&gt;新生代所有对象总空间，Minor GC 确保安全。 如果允许，继续比较 老年代最大可用空间&gt;晋升到老年代对象的平均大小，如果大于进行Minor GC,否则进行Full GC. Full GC 和Minor GC 对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，与Minor GC对应的是Major GC、Full GC。 (1)Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。 (2)Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。 (3)Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。 Minor GC 触发条件当Eden区满时，触发Minor GC。 Full GC 触发条件(1) 调用System.gc (2) 老年代空间不足 新生代对象转入及创建为大对象、大数组时出现不足的现象 (3) 永久代空间不足 永久代中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。 (4) gc担保失败 老年代最大可用空间&lt;新生代所有对象总空间,继续比较老年代最大可用空间&lt;晋升到老年代对象的平均大小 (5) CMS清理阶段，发现有新的垃圾，而老年代没有足够空间]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_对象已死]]></title>
    <url>%2F2019%2F04%2FJVM-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%2F</url>
    <content type="text"><![CDATA[垃圾收集器再对堆进行回收前，第一个要做的事就是确定对象是否还存活，判断方法有2种 1)引用计数法 2)可达性分析 1.引用计数法 给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。 缺点：很难解决对象之间的相互循环引用问题，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器收集它们。 2.可达性分析 通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。 GC Roots对象:(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。 (2). 方法区中的类静态属性引用的对象。static对象 (3). 方法区中常量引用的对象。final对象 (4). 本地方法栈中JNI(Native方法)引用的对象。 扩展：引用 (1) 强引用 ：只要强引用还存在，垃圾收集器就永远不会回收该对象 Object obj = new Object(); (2) 软引用 :软引用关联的对象，在系统发生内存溢出异常前，会将这些对象进行第二次回收。如果第二次回收还没有足够内存才抛出内存溢出异常。 (3) 弱引用：描述非必需对象。关联的对象只能生存到下一次垃圾回收前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉它们。 (4) 虚引用 ：无法通过虚引用来取得一个对象实例。唯一目的是能在这个对象被收集器回收时收到一个系统通知。 死亡过程 可达性分析没有发现与GCRoots的引用链 1.如果不可达，则标记筛选（条件是对象是否有必要执行finalize） 1)没必要，对象没有覆盖finalize方法或者finalize已经被虚拟机调用 2)有必要。放置在F-Queue队列中。这时候二次标记。如果重新与对象建立连接则不会被回收。 方法区的回收 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类 1.废弃常量 没有在其他地方引用则回收2.无用的类 (1) 类的实例已被回收 (2) 加载该类的classloader已被回收 (3) 该类对应的class没有被引用，也无反射访问。]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_垃圾收集器]]></title>
    <url>%2F2019%2F04%2FJVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[垃圾收集器一共有7种，如果说收集算法是内存回收的方法，那个垃圾收集器就是垃圾回收的具体实现。 以中间绿线为界，上边三个用于年轻代，下边三个用在年老代，而G1则老少通吃，**黑线**线表示两个回收器可搭配使用，**红线**则表示两者可以在同一区域交替使用。由于G1在JDK1.7才达到商用级别，而且目前线上环境也很少使用。 名称 区域 算法 适用情况 Serial 串行 年轻代 复制 单CPU（或CPU较少）、小型客户端应用 Parallel Scavenge 并行 年轻代 复制 多CPU、吞吐量优先（后台处理、科学计算） ParNew 并行 年轻代 复制 多CPU、响应优先（web服务器等） CMS 并发 年老代 标记-清除 响应优先（web服务器等） Serial Old 串行 年老代 标记-整理 单CPU、小型客户端应用 Parallel Old 并行 年老代 标记-整理 多CPU、吞吐量优先（后台处理、科学计算） 1.Serial收集器 从名字就能看出是串行的意思，该回收器是最早实现的，基于单线程， 优点： 实现简单且效率高， 缺点： 进行垃圾回收是会造成“Stop-the-World”(STW)，当回收内存区域较大时，就会造成程序响应时间变长。 STW：在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。 2.ParNew收集器 全名Parallel New Generation，也就是并行新生代垃圾收集器，该回收器实现与Serial基本上一样，只是采用多线程执行回收。是运行在服务端模式下首选的新生代收集器。 3.Parallel Scavenge收集器 Parallel Scavenge则侧重于吞吐量的控制，又名”吞吐量优先”回收器 (吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）； 停顿时间：适合需要与用户交互的程序，良好的响应速度能提升用户体验 高吞吐量：高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多的交互任务。 自适应调节策略：虚拟机会根据当前系统的运行监控信息，动态调整参数以提供最合适的停顿时间或者最大吞吐量。 该回收器与ParNew的最大区别在于ParNew通常与CMS搭配。 4.CMS收集器 Concurrent Mark Sweep，是一个并发回收器，旨在减少垃圾回收的停顿时间。集中应用于B/S系统的服务端，尤其注重服务的响应速度 CMS运作操作流程 (1)初始标记：标记GCRoots能直接关联到的对象 (2)并发标记：GCRoot开始对堆中对象进行可达性分析 (3)重新标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录 (4)并发清除：回收标记的垃圾 CMS缺点： （1）对CPU资源非常敏感 （2）无法处理浮动垃圾：CMS在并发清除阶段用户线程还在运行，会产生新的垃圾。这部分垃圾出现在标记之后，要等待下次GC才能清理掉 （3）基于标记-清除算法，会产生大量的内存碎片。 5.Serial Old收集器 标记-整理算法实现的，相当于Serial的年老代版。 （1）可以与Parallel Scavenge收集器搭配使用 （2）作为CMS收集器的后备预案 6.Paraller Old收集器 标记-整理算法实现，相当于Parallel Scavenge的年老代版。 在注重吞吐量以及CPU资源敏感的场合：Parallel Old + Parallel Scavengr 7.G1收集器 G1是一款面向服务端应用的垃圾收集器。具备以下特点： (1)并行与并发 并行即使用多个CPU来缩端STW停顿的时间，还可以通过并发方式让java程序继续执行。 (2)分代收集 可以不需要其他收集器配合就能独立管理整个GC堆 (3)空间整合 标记整理算法实现，在运行期间不会产生内存空间碎片，收集后可以提供规整的可用内存。 (4)可预测停顿 除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上时间不超过N秒。 G1收集器运作流程： (1)初始标记：标记GCRoots能直接关联到的对象 (2)并发标记：GCRoot开始对堆中对象进行可达性分析 (3)最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录 (4)筛选回收：回收标记的垃圾]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_垃圾回收算法]]></title>
    <url>%2F2019%2F04%2FJVM-%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[垃圾回收算法有4种 标记-清除算法 复制算法 标记-整理算法 分代收集算法 1.复制算法可用的内存空间分为大小相等的两块，每次只是用其中的一块，当这一块被用完的时候，就将还存活的对象复制到另一块中，然后把原已使用过的那一块内存空间一次回收掉。这个算法常用于新生代的垃圾回收。 优点 复制算法解决了标记-清除算法的效率问题，以空间换时间。 缺点 但是当存活对象非常多的时候，复制操作效率将会变低，而且每次只能使用一半的内存空间，利用率不高。 应用场景 应用于新生代 Serial、ParNew、Parallel Scavenge 垃圾收集器应用的算法 2. 标记-清除算法先标记出所有需要被回收的对象，然后在标记完成后统一回收掉所有被标记的对象。 缺点效率问题：标记与清除两个过程的效率都不高 空间问题：产生大量不连续的内存碎片，碎片太多会导致再程序运行过程中需要分配较大对象时，找不到足够的连续内存尔不得不提前触发垃圾回收动作。 应用场景应用于老年代的垃圾回收 CMS垃圾收集器应用的算法 3.标记-整理算法这个算法分为三部分： 标记出所有需要被回收的对象； 把所有存活的对象都向一端移动； 把所有存活对象边界以外的内存空间都回收掉。 优点 标记-整理算法解决了复制算法多复制效率低、空间利用率低的问题， 解决了内存碎片的问题。 应用场景 Serial Old、Parallel Old 垃圾收集器应用的算法 主要应用于老年代 4.分代收集算法 根据对象生存周期的不同将内存空间划分为不同的块，然后对不同的块使用不同的回收算法。一般把Java堆分为新生代和老年代，新生代中对象的存活周期短，只有少量存活的对象，所以可以使用复制算法，而老年代中对象存活时间长，而且对象比较多，所以可以采用标记-清除和标记-整理算法。]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sprintboot中的数据库注解]]></title>
    <url>%2F2019%2F03%2Fsprintboot%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@Results —-表字段与数据库字段映射 @Entity —- 生成表 @Transient —-后台与数据库不映射 @Id —-主键 @Transactional —-事务 @GeneratedValuestrategy=GenerationType.IDENTITY —–自增值 @Table - 映射表名 —– 映射表名 @Column(name = “dict_name”,columnDefinition=”varchar(100) COMMENT ‘字典名’”) —– 字段名、类型、注释 @Select @Update @Delete @Insert @UpdateTimestamp —— 更新时自动更新时间 @CreationTimestamp ——创建时自动更新时间 @Version —– 版本号，更新时自动加1 1.@Entity@Entity说明这个class是实体类，并且使用默认的orm规则，即class名即数据库表中表名，class字段名即表中的字段名 12345678910111213141516@Entity@DynamicUpdate@Datapublic class OrderDetail &#123; @Id private String detailId; private String orderId; private String productId; private String productName; private BigDecimal productPrice; private Integer productQuantity; private String productIcon; private Date createTime; private Date updateTime;&#125; 运行将对应生成数据库表名为OrderDetail的表，里面字段对应上面的字段。 2.@DynamicUpdate动态更新表。 如果我们在更新表时,只想更新某个字段,就不要加 @DynamicUpdate,通常为了更新表时的效率,都是不加的.反之,如果我们更新某个字段时,更新所有的字段,就可以加上 @DynamicUpdate. @DynamicUpdate属性:设置为true,设置为true,表示update对象的时候,生成动态的update语句,如果这个字段的值是null就不会被加入到update语句中,默认false。比如只想更新某个属性，但是却把整个对象的属性都更新了，这并不是我们希望的结果，我们希望的结果是：我更改了哪些字段，只要更新我修改的字段就够了。 3.@Table@Table注解用来标识实体类与数据表的对应关系，默认和类名一致。 123456789101112131415161718192021222324252627282930@Entity@Table(name="c_user")public class User &#123; @Id @GeneratedValue private Long id; @NotNull @Column(length = 50) private String userName; @NotNull @Column(length = 20 , unique = true, nullable = false) private Long mobile; @Column(length = 20 , unique = true) private String email; @NotNull @Column(columnDefinition="tinyint") private Integer status; private String password; private String nickname; private Integer companyId; private Integer departmentId; private Date regTime; private String regIp; private Integer loginNum;&#125; 4. @Column@Column注解来标识实体类中属性与数据表中字段的对应关系。共有10个属性，这10个属性均为可选属性： name属性定义了被标注字段在数据库表中所对应字段的名称； unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。 nullable属性表示该字段是否可以为null值，默认为true。如果属性里使用了验证类里的@NotNull注释，这个属性可以不写。 insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。 updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。 columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。若不指定该属性，通常使用默认的类型建表，若此时需要自定义建表的类型时，可在该属性中设置。（也就是说，如果DB中表已经建好，该属性没有必要使用。） table属性定义了包含当前字段的表名。 length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。 precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。 5.@Transactional 事务@Transactional 注解的属性信息 属性名 说明 name 当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。 propagation 事务的传播行为，默认值为 REQUIRED。 isolation 事务的隔离度，默认值采用 DEFAULT。 timeout 事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。 read-only 指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。 rollback-for 用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。 no-rollback- for 抛出 no-rollback-for 指定的异常类型，不回滚事务。 6.@Transient@Transient是希望该属性不会在数据表中产生字段，但又可以在程序中使用它。 7.@Results(1)当数据库字段名与实体类对应的属性名不一致时，可以使用@Results映射来将其对应起来。column为数据库字段名，porperty为实体类属性名，jdbcType为数据库字段数据类型，id为是否为主键。 12345678@Select(&#123;"select id, name, class_id from my_student"&#125;)@Results(&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="name", property="name", jdbcType=JdbcType.VARCHAR), @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER)&#125;)List&lt;Student&gt; selectAll(); (2)@ResultMap的用法。当这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码。 123456789101112@Select(&#123;"select id, name, class_id from my_student"&#125;)@Results(id="studentMap", value=&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER)&#125;)List&lt;Student&gt; selectAll();@Select(&#123;"select id, name, class_id from my_student where id = #&#123;id&#125;"&#125;)@ResultMap(value="studentMap")Student selectById(integer id); (3)@One的用法。当我们需要通过查询到的一个字段值作为参数，去执行另外一个方法来查询关联的内容，而且两者是一对一关系时，可以使用@One注解来便捷的实现。比如当我们需要查询学生信息以及其所属班级信息时，需要以查询到的class_id为参数，来执行ClassesMapper中的selectById方法，从而获得学生所属的班级信息。可以使用如下代码。 1234567Select(&#123;"select id, name, class_id from my_student"&#125;)@Results(id="studentMap", value=&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="class_id", property="myClass", javaType=MyClass.class, one=@One(select="com.mapper.MyClassMapper.selectById"))&#125;)List&lt;Student&gt; selectAllAndClassMsg(); （4）@Many的用法。与@One类似，只不过如果使用@One查询到的结果是多行，会抛出TooManyResultException异常，这种时候应该使用的是@Many注解，实现一对多的查询。比如在需要查询学生信息和每次考试的成绩信息时。 12345678@Select(&#123;"select id, name, class_id from my_student"&#125;)@Results(id="studentMap", value=&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER), @Result(column="id", property="gradeList", javaType=List.class, many=@Many(select="com.example.demo.mapper.GradeMapper.selectByStudentId"))&#125;)List&lt;Student&gt; selectAllAndGrade(); （5）传递多个参数。首先我们给这张表增加age（年龄）和gender（性别）两个参数。当我们需要根据age和gender查询学生的午餐，这时需要改写column属性的格式。等号左侧的age和gender对应java接口的参数，右侧的对应数据库字段名。即将查到的my_student表中age和gender字段的值，分别赋给getLunchByAgeAndGender方法中的age和gender参数，去查询对应的name（午餐名）。 1234567891011@Select("select id, name, age, gender from my_student")@Results(&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER), @Result(column="&#123;age=age,gender=gender&#125;", property="lunch", one=@One(select="com.example.demo.mapper.StudentMapper.getLunchByAgeAndGender")), &#125;)List&lt;Student&gt; selectAllAndLunch();@Select("select name from lunch where student_age = #&#123;age&#125; and student_gender = #&#123;gender&#125;")String getLunchByAgeAndGender(@Param("age") int age, @Param("gender") int gender);]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis数据的持久化]]></title>
    <url>%2F2019%2F03%2Fredis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[持久化Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 1.RDB 持久化RDB是redis默认的持久化机制。RDB相当于快照，保存的是一种状态。默认文件名是dump.rdb。 将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量很大，保存快照的时间会很长。 2.AOF 持久化由于快照方式是在一定时间间隔内做一次，所以如果redis意外down掉，就会丢失最后一次快照所有的修改，如果应用要求不能丢失任何修改的话，可以采用AOF。 将写命令添加到 AOF 文件（Append Only File）的末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项： 选项 同步频率 always 每个写命令都同步 everysec 每秒同步一次 no 让操作系统来决定何时同步 always 选项会严重减低服务器的性能； everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响； no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis.数据的淘汰机制]]></title>
    <url>%2F2019%2F03%2Fredis-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。 Redis 具体有 6 种淘汰策略： 策略 描述 volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random 从已设置过期时间的数据集中任意选择数据淘汰 allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰 allkeys-random 从所有数据集中任意选择数据进行淘汰 noeviction 禁止驱逐数据 作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。 使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。 Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis与memcached]]></title>
    <url>%2F2019%2F03%2Fredis%E4%B8%8Ememcached%2F</url>
    <content type="text"><![CDATA[Memcached介绍Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。 memcached作为高速运行的分布式缓存服务器，具有以下的特点。 协议简单 基于libevent的事件处理 内置内存存储方式 memcached不互相通信的分布式 与数据库协同合作的过程： 1.检查用户请求的数据是缓存中是否有存在，如果有存在的话，只需要直接把请求的数据返回，无需查询数据库. 2.如果请求的数据在缓存中找不到，这时候再去查询数据库。返回请求数据的同时，把数据存储到缓存中一份。 3.保持缓存的“新鲜性”，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据. Redis介绍redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。 区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。 Redis作为一个高性能的key-value数据库具有以下特征： 多样的数据模型 持久化 基于内存存储方式 主从同步 综合结论 应该说Memcached和Redis都能很好的满足解决我们的问题，它们性能都很高，总的来说，可以把Redis理解为是对Memcached的拓展，是更加重量级的实现，提供了更多更强大的功能。 两者都是非关系型内存键值数据库，主要有以下不同： Memcached与redis区别1.数据类型 Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。 2.数据持久化 Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 3.分布式 Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis则在服务器端构建分布式存储。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，各个节点地位一致，具有线性可伸缩的功能。其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个 key的数值域分成16384个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是16384。 4.内存管理机制 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，这样能保证数据的持久性。而 Memcached 的数据则会一直在内存中(断电会挂掉，数据不能超过内存)。 5.应用场景 Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息) Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis数据类型]]></title>
    <url>%2F2019%2F03%2Fredis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 LIST 列表 从两端压入或者弹出元素 对单个或者多个元素 进行修剪，只保留一个范围内的元素 SET 无序集合 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 ZSET 有序集合 添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名 What Redis data structures look like 1.1Redis的键Key1234567891011&gt; DEL key 删除键&gt; EXISTS key 判断key是否存在&gt; DUMP key 序列化key&gt; EXPIRE key seconds 给key设置过期时间&gt; TTL key key的生存剩余时间（秒为单位）&gt; PTTL key key的生存剩余时间(毫秒单位)&gt; PERSIST key 移除key的过期时间，将持久保留&gt; KEYS pattern 查找所有符合给定模式的key(* 所有 ？一个字符)&gt; RANDOM key 从当前数据库随机返回一个key&gt; RENAME key newkey 修改key名称&gt; MOVE key db 当前数据库移动到给定数据库中 key的应用场景 (1)限时的活动信息 (2)网站的数据缓存(对于一些要定时更新的数据如积分排行榜) (3)手机验证码 (4)限制网站的访问频率 1.2 Redis的值value1.2.1 String类型123456789101112&gt; SET key_name value 设置给定key的值(key存在则覆盖，不存在则新建)&gt; SETNX key_name value 设置给定key的值(key不存在时)&gt; GET key_name 取值&gt; GETRANGE key start end 字符串截取&gt; GETBIT key offset 对key所存储的字符串值，获取指定偏移量上的位&gt; MGET key1 [key2..] 获取一个或多个key的值&gt; GETSET key_name value 设置key值，并返回key的旧值&gt; STRLEN key 获取长度&gt; DEL key_name 删除&gt; INCR key_name 自增&gt; DECR key_name 自减 &gt; APPEND key_name value 字符串拼接 string应用场景 1.String通常用于保存单个字符串或JSON字符串数据 2.因string是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储 3.计数器(常规key-value缓存应用。(常规计数:微博数,粉丝数) INCR等指令本身就具有原子操作的特性,所以我们完全可以利用redis的INCR.INCRBY.DECR，DECRBY等指令来实现原子计数的效果。不少网站都利用redis的这个特性来实现业务上的统计计数需求。 1.2.2 List类型1234567891011&gt; LPUSH key value1[value2] 将一个或多个值插入列表头部&gt; RPUSH key value1[value2] 将一个或多个值插入列表尾部&gt; LPUSHX key value 将一个或多个值插入列表头部，列表不存在则操作无效 &gt; RPUSHX key value 将一个或多个值插入列表尾部，列表不存在则操作无效&gt; LLEN key 获取列表长度&gt; LINDEX key index 通过索引获取列表元素&gt; LRANGE key start stop 获取列表指定范围内的元素&gt; LPOP key 左移除&gt; RPOP key 右移除&gt; BLPOP key1[key2] timeout 移除并获取列表的第一个元素，没有元素就会阻塞队列 直到等待超时或发现可弹出元素 list应用场景 1、对数据量大的集合数据删减 列表数据显示关注列表、粉丝列表、留言评价等. .分页、热点新闻(Top5)等 利用LRANGE还可以很方便的实现分页的功能,在博客系统中，每片博文的评论也可以用到。 2、任务队列 (list通常用来实现一个消息队列,而且可以确保先后顺序,不必像MySQL那样还需要通过ORDERBY来进行排序) 任务队列介绍(生产者和消费者模式): 在处理Web客户端发送的命令请求时,某些操作的执行时间可能会比我们预期的更长一些，通过将待执行任务的相关信息放入队列里面，并在之后对队列进行处理,用户可以推迟执行那些需要一段时间才能能完成的操作,这种将工作交给任务处理器来执行的做法被称为任务队列(task queue)。 RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回示例描述: 常用案例:订单系统的下单流程、用户系统登录注册短信等 1.2.3 Hash类型123456789101112&gt; HSET key field value 为指定的key,设定field/value&gt; HMSET key field value[field1,value] 同时将多个field-value 设到key中&gt; HGET key field 根据field等待value &gt; HMGET key field[field1] 获取key所有给定字段的值&gt; HGETALL key 返回hash表所有字段和值&gt; HKEYS key 获取哈希表中的字段&gt; HLEN key 获取哈希表中字段的数量&gt; HDEL key field[field2] 删除一个或多个hash表字段&gt; HSETNX key field value 只有在字段不存在时，设置字段值&gt; HINCRBY key field increment key中指定字段的整数值加增量&gt; HINCRBYFLOAT key field increment 指定字段的浮点数加增量&gt; HEXISTS key field 指定字段是否存在 hash应用场景 Hash的应用场景:(存储个用户信息对象数据) 1、 常用于存储一个对象 2、 为什么不用string存储一个对象? hash是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。 用户ID为查找的key,存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式: (1)用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时, 需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。 (2)这个用户信息对象有多少成员就存成多少个key-value对,用用户ID+对应属性的名称作为唯一标识来取得对应属性的值,虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是不可观的。 总结:Redis提供的Hash很好的解决了这个问题，Redis 的Hash实际是内部存储的Value为一个Hashmap,并提供了直接存取这个Map成员的接口 1.2.4 Set类型1234567891011121314151617181920赋值语句&gt; SADD key member1[member2] 添加一个或多个成员取值语句&gt; SCARD key 获取成员数&gt; SMEMBERS key 返回集合中的所有成员&gt; SISMEMBER key member 判断是否存在&gt; SRANDMEMBER key [count] 返回集合中一个或多个随机数删除语句&gt; SREM key member 移除一个或多个&gt; SPOP key[count] 移除并返回集合中的一个随机元素&gt; SMOVE source destination member 将member从source移到destination差集语句&gt; SDIFF key1[key2] 返回给定集合的差集(左侧)&gt; SDIFFSTORE destination key1[key2] 返回差集并存到destina.交集语句&gt; SINTER key1 [key2] 返回给定集合的交集&gt; SINTERSTORE destination key1[key2] 返回交集并存到destination并集&gt; SUNION key1[key2] 返回并集&gt; SUNIONSTORE destination key1[key2] 返回并集并存储在destination set应用场景 常应用于:对两个集合间的数据[计算]进行交集、并集、差集运算 1、以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作,你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。 2、利用唯一性，可以统计访问网站的所有独立IP 1.2.5 Zset类型12345678910赋值语句&gt; ZADD key score1 member1[score member2] 添加一个或多个成员取值语句&gt; ZCARD key 获取成员数&gt; ZCOUNT key min max 计算集合中指定区间分数的成员数&gt; ZRANK key member 返回有序集合中指定成员索引&gt; ZRANGE key start stop[WITHSCORES] 返回指定区间内成员[低到高]&gt; ZREVRANGE key start stop[WITHSCORES] 返回指定区间内成员[高到低]删除语句&gt; ZREM key member[member...] 移除有序集合中的一个或多个成员 Zset应用场景 常应用于:排行榜 1)比如twitter的public timeline可以以发表时间作为score来存储,这样获取时就是自动按时间排好序的。 2)比如一个存储全班同学成绩的Sorted Set, 其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。 3还可以用Sorted Set来做带权重的队列，比如普通消息的score为1,重要消息的score为2,然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis应用场景]]></title>
    <url>%2F2019%2F03%2Fredis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[1.概述 Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键(key)的类型只能为字符串(String)，值(value)支持五种数据类型：字符串(String)、列表(list)、集合(set)、有序集合(zset)、哈希(hash)。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 Redis的使用场景 （1）缓存：Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效； （2）排行榜：利用Redis的SortSet数据结构能够非常方便搞定； （3）计算器/限速器：利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力； 注：限速器也是对请求限流的一种实现方式。 （4）好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能； （5）简单消息队列：除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；不过最好用kafka、RabbitMQ等消息中间件。 （6）Session共享：默认Session是保存在服务器的文件中，即当前服务器，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。 Redis优点： 速度快，完全基于内存； 使用C语言实现，网络层使用epoll解决高并发问题； 单线程模型避免了不必要的上下文切换及竞争条件； Redis的缺点： 滥用可能导致系统的不稳定、成本增高等问题。 比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。 简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用Redis。数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。如果不担心浪费资源，那请忽略。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
