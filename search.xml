<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer_【66】机器人的运动范围</title>
      <link href="/2019/05/66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
      <url>/2019/05/66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>本题使用的方法同样还是回溯法，另外还需要会计算给定整数上的各个位上数之和。</p><pre><code>(1)使用一个访问数组记录是否已经经过该格子。机器人从(0,0)开始移动，当它准备进入(i,j)的格子时，通过检查坐标的数位来判断机器人是否能够进入。(2)如果机器人能进入(i,j)的格子，接着在判断它是否能进入四个相邻的格子(i,j-1),(i,j+1),(i-1,j),(i+1,j)。</code></pre><p>因此，可以用回溯法来解决这一问题。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rows&lt;<span class="number">1</span>||cols&lt;<span class="number">1</span>||threshold&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">boolean</span> []visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</span><br><span class="line">        <span class="keyword">return</span> count(threshold,rows,cols,visit,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span>[] visit, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(threshold,rows,cols,visit,row,col))</span><br><span class="line">        &#123;</span><br><span class="line">            visit[row*cols+col]=<span class="keyword">true</span>;</span><br><span class="line">            res=<span class="number">1</span>+count(threshold,rows,cols,visit,row,col+<span class="number">1</span>)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row,col-<span class="number">1</span>)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row+<span class="number">1</span>,col)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row-<span class="number">1</span>,col);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[] visit, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">                     &amp;&amp; visit[row * cols + col] == <span class="keyword">false</span> &amp;&amp;getNum(col) + getNum(row) &lt;= threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取位数之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【65】矩阵中的路径</title>
      <link href="/2019/05/65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/05/65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 * 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>回溯法</p><p>(1)在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。<br>　　由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。<br>　　需要判断这个矩阵中的每一个结点是否可以走一条路径，在走的过程中，设置一个和矩阵大小相同的整型数组flag表示是否已经访问，如果某个结点访问了，那么该结点的是否访问则为1。每次遍历一个结点的时候，递归的方式分别向左、向右、向上、向下。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(helper(matrix, rows, cols, i, j, str, <span class="number">0</span>, flag))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> k, <span class="keyword">int</span>[] flag)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = i * cols + j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols </span><br><span class="line">                || matrix[index] != str[k] || flag[index] == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// /下标不符合，index对应的值不为和字符数组中的不一致，或者该index已经被访问，这些情况只要有符合的就返回false</span></span><br><span class="line">            <span class="comment">// 只有上面的所有情况都不符合，也就是值相等，且没有访问过，下标不符合</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == str.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">if</span>(helper(matrix, rows, cols, i - <span class="number">1</span>, j, str, k + <span class="number">1</span>, flag)<span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        ||helper(matrix, rows, cols, i + <span class="number">1</span>, j, str, k + <span class="number">1</span>, flag)<span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">        ||helper(matrix, rows, cols, i, j - <span class="number">1</span>, str, k + <span class="number">1</span>, flag)<span class="comment">//上</span></span><br><span class="line"></span><br><span class="line">      ||helper(matrix, rows, cols, i , j + <span class="number">1</span>, str, k + <span class="number">1</span>, flag))<span class="comment">//下  </span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【64】滑动窗口的最大值</title>
      <link href="/2019/05/64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2019/05/64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。<a id="more"></a></p><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>{2,3,4,2,6,2,5,1} ，3</p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>{4,4,6,6,6,5}</p><h6 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h6><p> 存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}；</p><p> 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： </p><pre><code>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</code></pre></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>我们可以使用双向队列（Linklist），队列中只存放当前元素的下标，</p><pre><code>(1)设新来的元素为k，如果前面的元素比k小，直接把前面的删除（因为不可能成为后面窗口的最大值）(2)如果前面的元素比k大，判断是否还在窗口范围内，不在则移除</code></pre><h6 id="以数组-2-3-4-2-6-2-5-1-为例"><a href="#以数组-2-3-4-2-6-2-5-1-为例" class="headerlink" title="以数组{2,3,4,2,6,2,5,1}为例"></a>以数组{2,3,4,2,6,2,5,1}为例</h6><pre><code>数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。第五个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (num==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">if</span> (num.length&lt;size||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num.length; i++)&#123;</span><br><span class="line">     <span class="comment">//如果前面的数比插入的数小，直接把前面删除(因为不可能成为后面窗口的最大值)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()&amp;&amp;num[i]&gt;=num[queue.getLast()])</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        <span class="comment">//如果前面的元素比k大，判断是否还在窗口范围内，不在则移除</span></span><br><span class="line">        <span class="comment">//(i-(size-1))即滑动窗口最左侧的坐标索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()&amp;&amp;queue.getFirst()&lt;i-(size-<span class="number">1</span>))</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        <span class="comment">//加入队尾</span></span><br><span class="line"></span><br><span class="line">        queue.offerLast(i);</span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>&gt;=size)</span><br><span class="line">            arr.add(num[queue.getFirst()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【63】数据流中的中位数</title>
      <link href="/2019/05/63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/05/63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用一个list存储插入的数，然后对其进行排序</p><p>(1) size == 0 , 返回 null;</p><p>(2) size是偶数 , 返回 数值排序之后中间两个数的平均值;</p><p>(3) size是奇数，返回 list.get(size/2);</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//添加操作</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">            list.add(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">if</span>(size!=<span class="number">0</span>)&#123;</span><br><span class="line">               </span><br><span class="line">                Collections.sort(list);</span><br><span class="line">                <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> (list.get(size/<span class="number">2</span>)+list.get(size/<span class="number">2</span>-<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> list.get(size/<span class="number">2</span>)*<span class="number">1.0</span>;                  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【62】二叉搜索树的第K个结点</title>
      <link href="/2019/05/62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>方法1：</p><blockquote><p>用PriorityQueue将所有结点放到queue中，再依次弹出里面的数据（队首数据依次弹出），弹出的第k个数据就是要求的数值，再将它构建成TreeNode即可。</p></blockquote><p>方法2：</p><blockquote><p>根据二叉搜索树的特点，左子树上的点小于该点，右子树上的点大于该点。所以按照中序遍历的方法得到的序列即是从小到大的序列。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">     <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        preOrderRec(pRoot);</span><br><span class="line">        <span class="keyword">if</span>(queue.size()&lt;k ||k &lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode( queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderRec</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(root.val);</span><br><span class="line">            preOrderRec(root.left);</span><br><span class="line">            preOrderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    TreeNode node=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>||pRoot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        KthNode(pRoot.left,k);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(k==index)</span><br><span class="line">        &#123; node=pRoot;</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        KthNode(pRoot.right,k);</span><br><span class="line">        <span class="keyword">return</span> node;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSR303参数校验和全局异常处理</title>
      <link href="/2019/05/JSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2019/05/JSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。故引出使用JSR303来做参数校验。参数校验的实现: <a id="more"></a></p><ul><li><p>手机号和密码字段自定义注解</p></li><li><p>为了让客户端显示更加友好 </p></li><li><p>需要自定义异常拦截器</p></li></ul></blockquote><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--JSR303参数检验+全局异常处理器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2-在需要验证的类前加-Valid并在该类内需要参数检查的成员上加自定义注解"><a href="#2-在需要验证的类前加-Valid并在该类内需要参数检查的成员上加自定义注解" class="headerlink" title="2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解"></a>2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/do_login"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">doLogin</span><span class="params">(HttpServletResponse  response,                                             </span></span></span><br><span class="line"><span class="function"><span class="params">                               @Valid LoginVo loginVo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(loginVo.toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginVo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@IsMobile</span></span><br><span class="line">    <span class="keyword">private</span>  String mobile;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-IsMobile注解的编写-可参考-NotNull"><a href="#3-IsMobile注解的编写-可参考-NotNull" class="headerlink" title="3. IsMobile注解的编写[可参考@NotNull]"></a>3. IsMobile注解的编写[可参考@NotNull]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">            ElementType.METHOD,</span><br><span class="line">            ElementType.FIELD, </span><br><span class="line">            ElementType.ANNOTATION_TYPE, </span><br><span class="line">            ElementType.CONSTRUCTOR,</span><br><span class="line">            ElementType.PARAMETER, </span><br><span class="line">            ElementType.TYPE_USE</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(</span><br><span class="line">        validatedBy = &#123;IsMobileValidator.class&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IsMobile &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "电话号码格式错误"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-指定校验器的实现-IsMobileValidator-class"><a href="#4-指定校验器的实现-IsMobileValidator-class" class="headerlink" title="4.指定校验器的实现[IsMobileValidator.class]"></a>4.指定校验器的实现[IsMobileValidator.class]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsMobileValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">IsMobile</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> required = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//初始化方法拿到注解，可以定义一个字符为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IsMobile constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        constraintAnnotation.required();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//值是必须的</span></span><br><span class="line">        <span class="keyword">if</span>(required)&#123;</span><br><span class="line">            <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-自定义异常拦截器"><a href="#5-自定义异常拦截器" class="headerlink" title="5.自定义异常拦截器"></a>5.自定义异常拦截器</h4><blockquote><p>当校验不通过时，会抛出异常。这时如果没有定义全局异常处理器进行处理（对异常进行封装和返回）。则会发生400错误（即只有请求的发起，却没有收到正常的响应（response），因为还没有来得及return就抛出了异常（这种异常没有被处理））。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">exceptionHandler</span><span class="params">(HttpServletRequest request,Exception e)</span></span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> GlobalException) &#123;</span><br><span class="line">            GlobalException ex = (GlobalException) e;</span><br><span class="line">            <span class="keyword">return</span> Result.Error(ex.getCm());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> BindException)&#123;</span><br><span class="line">            BindException ex = (BindException) e;</span><br><span class="line">            List&lt;ObjectError&gt; errors = ex.getAllErrors();</span><br><span class="line">            <span class="comment">//为了方便起见，只取第一个错误</span></span><br><span class="line"></span><br><span class="line">            ObjectError error = errors.get(<span class="number">0</span>);</span><br><span class="line">            String msg = error.getDefaultMessage();</span><br><span class="line">            <span class="keyword">return</span> Result.Error(CodeMsg.BIND_ERROR.fillArgs(msg));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.Error(CodeMsg.SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用缓存key</title>
      <link href="/2019/05/%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key/"/>
      <url>/2019/05/%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="通用缓存key的作用"><a href="#通用缓存key的作用" class="headerlink" title="通用缓存key的作用"></a>通用缓存key的作用</h2><h5 id="当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id-订单Id，用户id等-此时若是id出现重复，将给系统带来错误。"><a href="#当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id-订单Id，用户id等-此时若是id出现重复，将给系统带来错误。" class="headerlink" title="当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。"></a>当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。<a id="more"></a></h5><p>方法：利用一个前缀来规定不同模块的缓存的key,这样不同模块之间就不会重复。</p><p>通用缓存key采用模板模式：接口-&gt;抽象类-&gt;实现类</p><h5 id="1-接口"><a href="#1-接口" class="headerlink" title="1. 接口"></a>1. 接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyPrefix</span> </span>&#123;</span><br><span class="line">    <span class="comment">//过期时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expireSeconds</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//前缀</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePrefix</span> <span class="keyword">implements</span> <span class="title">KeyPrefix</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expireSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="comment">//无过期时间的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePrefix</span><span class="params">(String prefix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>(<span class="number">0</span>, prefix);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//含有过期时间的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePrefix</span><span class="params">( <span class="keyword">int</span> expireSeconds, String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expireSeconds = expireSeconds;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expireSeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> expireSeconds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取前缀，前缀为 className：prefix</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String className = getClass().getSimpleName();</span><br><span class="line">        <span class="keyword">return</span> className+<span class="string">":"</span> + prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-实现类"><a href="#3-实现类" class="headerlink" title="3. 实现类"></a>3. 实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaKey</span> <span class="keyword">extends</span> <span class="title">BasePrefix</span></span>&#123;</span><br><span class="line">    <span class="comment">//继承父类的无过期时间的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiaoshaKey</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置她这个类的前缀是className:go</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MiaoshaKey isGoodsOver = <span class="keyword">new</span> MiaoshaKey(<span class="string">"go"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitMQ实现消息缓冲</title>
      <link href="/2019/05/rabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2019/05/rabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>RabbitMQ主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是AMQP协议，它是一种二进制协议。默认启动端口5672`</p></blockquote><a id="more"></a><p>rabbitMQ的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，生产者producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。</p><ul><li><p><strong>Direct</strong>：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个       routing_key, 根据key全文匹配去寻找队列</p></li><li><p><strong>Topic</strong>：按规则转发消息（最灵活）<em>转发消息主要是根据通配符</em></p></li><li><p><strong>Headers</strong>：设置 header attribute 参数类型的交换机</p></li><li><p><strong>Fanout</strong>：转发消息到所有绑定队列(广播方式)</p><p><img src="https://github.com/qiulig/IMG/raw/master/rabbitMQ.png" alt="rabbitMQ原理"></p></li></ul><h3 id="下面介绍4种交换机与springboot的集成"><a href="#下面介绍4种交换机与springboot的集成" class="headerlink" title="下面介绍4种交换机与springboot的集成"></a>下面介绍4种交换机与springboot的集成</h3><p>添加依赖包amqp,统一配置application.properties</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--rabbitMQ依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">##rabbitMQ</span><br><span class="line">spring.rabbitmq.host=127.0.0.1</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br><span class="line">#消费者数量</span><br><span class="line">spring.rabbitmq.listener.simple.concurrency= 10</span><br><span class="line">spring.rabbitmq.listener.simple.max-concurrency= 10</span><br><span class="line">#消费者每次从队列获取的消息数量</span><br><span class="line">spring.rabbitmq.listener.simple.prefetch= 1</span><br><span class="line">#消费者自动启动</span><br><span class="line">spring.rabbitmq.listener.simple.auto-startup=true</span><br><span class="line">#消费失败，自动重新入队</span><br><span class="line">spring.rabbitmq.listener.simple.default-requeue-rejected= true</span><br><span class="line">#启用发送重试</span><br><span class="line">spring.rabbitmq.template.retry.enabled=true </span><br><span class="line">spring.rabbitmq.template.retry.initial-interval=1000</span><br><span class="line">spring.rabbitmq.template.retry.max-attempts=3</span><br></pre></td></tr></table></figure><h4 id="1-Direct交换机制"><a href="#1-Direct交换机制" class="headerlink" title="1. Direct交换机制"></a>1. Direct交换机制</h4><blockquote><p>一个队列会和一个交换机绑定，除此之外再绑定一个routing_key，当消息被发送的时候，需要指定一个binding_key，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个binding_key也是支持应用到多个队列中的。 这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。</p></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/direct.png" alt="direct原理"></p><h5 id="1-1-编写config"><a href="#1-1-编写config" class="headerlink" title="1.1 编写config"></a>1.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  QUEUE =<span class="string">"queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-创建消息发送者"><a href="#1-2-创建消息发送者" class="headerlink" title="1.2 创建消息发送者"></a>1.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate  amqpTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(MQreceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">        String msg = redisService.beanToString(message);</span><br><span class="line">        log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">        amqpTemplate.convertAndSend(MQconfig.Queue,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-创建消息接收者"><a href="#1-3-创建消息接收者" class="headerlink" title="1.3 创建消息接收者"></a>1.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(MQreceiver.class);</span><br><span class="line">    <span class="comment">//监听了queue的队列</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQconfig.Queue)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive message"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-编写controller测试"><a href="#1-4-编写controller测试" class="headerlink" title="1.4 编写controller测试"></a>1.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123; <span class="meta">@Autowired</span></span><br><span class="line">    MQsender sender;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/mq"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Result&lt;Boolean&gt; <span class="title">mq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sender.send(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-Fanout交换机制"><a href="#2-Fanout交换机制" class="headerlink" title="2. Fanout交换机制"></a>2. Fanout交换机制</h4><ul><li><p>扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。</p><p><img src="https://github.com/qiulig/IMG/raw/master/fanout.png" alt="Fanout原理"></p></li></ul><h5 id="2-1-编写config"><a href="#2-1-编写config" class="headerlink" title="2.1 编写config"></a>2.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  FANOUT_EXCHANGE =<span class="string">"fanoutxchage"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span>       </span><br><span class="line">          BindingBuilder.bind(topticQueue2()).to(fanoutExchange());</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-创建消息发送者"><a href="#2-2-创建消息发送者" class="headerlink" title="2.2 创建消息发送者"></a>2.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> AmqpTemplate amqpTemplate;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> RedisService redisService;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFanout</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String msg = redisService.beanToString(message);</span><br><span class="line">    log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">    amqpTemplate.convertAndSend(MQconfig.FANOUT_EXCHANGE,<span class="string">""</span>,msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-创建消息接收者"><a href="#2-3-创建消息接收者" class="headerlink" title="2.3 创建消息接收者"></a>2.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">     <span class="comment">//fanout 广播模式都接受故不需要listener</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-编写controller测试"><a href="#2-4-编写controller测试" class="headerlink" title="2.4 编写controller测试"></a>2.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(<span class="string">"/mq/fanout"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Result&lt;String&gt; <span class="title">fanout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sender.sendFanout(<span class="string">"hellommxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">"hello xuanzi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-topic交换机制"><a href="#3-topic交换机制" class="headerlink" title="3. topic交换机制"></a>3. topic交换机制</h4><blockquote><p>通配符交换机，exchange会把消息发送到一个或者多个满足通配符规则的<code>routing-key</code>的queue。其中<em>表号匹配一个word，#匹配多个word和路径，路径之间通过.隔开。如满足a.</em>.c的routing-key有a.hello.c；满足#.hello的routing-key有a.b.c.helo。</p></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/topic.png" alt="topic原理"></p><h5 id="1-1-编写config-1"><a href="#1-1-编写config-1" class="headerlink" title="1.1 编写config"></a>1.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  TOPIC_QUEUE1 =<span class="string">"topic.queue1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  TOPIC_QUEUE2 =<span class="string">"topic.queue2"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  TOPIC_EXCHANGE =<span class="string">"topicExchange"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topticQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE1,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE2,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPIC_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topticQueue1()).to(topicExchange()).with(<span class="string">"topic.key1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topticQueue2()).to(topicExchange()).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-创建消息发送者-1"><a href="#1-2-创建消息发送者-1" class="headerlink" title="1.2 创建消息发送者"></a>1.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTopic</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">    String msg = redisService.beanToString(message);</span><br><span class="line">    log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">  amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE,</span><br><span class="line">                                <span class="string">"topic.key1"</span>,msg+<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE,</span><br><span class="line">                                <span class="string">"topic.key2"</span>,msg+<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-创建消息接收者-1"><a href="#1-3-创建消息接收者-1" class="headerlink" title="1.3 创建消息接收者"></a>1.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQconfig.TOPIC_QUEUE1)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveTopic1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive topic queue1 message"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQconfig.TOPIC_QUEUE2)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveTopic2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive topic queue2 message"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-编写controller测试-1"><a href="#1-4-编写controller测试-1" class="headerlink" title="1.4 编写controller测试"></a>1.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(<span class="string">"/mq/topic"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Result&lt;String&gt; <span class="title">topic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sender.sendTopic(<span class="string">"hellommxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">"hello xuanzi"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-header交换机制"><a href="#4-header交换机制" class="headerlink" title="4. header交换机制"></a>4. header交换机制</h4><blockquote><p>header exchange(头交换机)和主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据。<br>主题交换机路由键只有是字符串,而头交换机可以是整型和哈希值</p></blockquote><h5 id="1-1-编写config-2"><a href="#1-1-编写config-2" class="headerlink" title="1.1 编写config"></a>1.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  HEADER_QUEUE =<span class="string">"header.queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeadersExchange <span class="title">headersExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeadersExchange(HEADERS_EXCHANGE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">headerQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Queue(HEADER_QUEUE,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Binding <span class="title">headerBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Map&lt;String,Object&gt; map =<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">       map.put(<span class="string">"header1"</span>,<span class="string">"value1"</span>);</span><br><span class="line"></span><br><span class="line">       map.put(<span class="string">"header2"</span>,<span class="string">"value2"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> </span><br><span class="line">         BindingBuilder.bind(headerQueue()).to(headersExchange())</span><br><span class="line">                                           .whereAll(map).match();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-创建消息发送者-2"><a href="#1-2-创建消息发送者-2" class="headerlink" title="1.2 创建消息发送者"></a>1.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendheader</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String msg = redisService.beanToString(message);</span><br><span class="line">    log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">    MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">    properties.setHeader(<span class="string">"header1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    properties.setHeader(<span class="string">"header2"</span>,<span class="string">"value2"</span>);</span><br><span class="line">    Message obj = <span class="keyword">new</span> Message(msg.getBytes(),properties);</span><br><span class="line">    amqpTemplate.convertAndSend(MQconfig.HEADERS_EXCHANGE,<span class="string">""</span>,obj);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-创建消息接收者-2"><a href="#1-3-创建消息接收者-2" class="headerlink" title="1.3 创建消息接收者"></a>1.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RabbitListener</span>(queues = MQconfig.HEADER_QUEUE)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveHeader</span><span class="params">(<span class="keyword">byte</span>[] message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          log.info(<span class="string">"receive header queue message"</span>+message);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-编写controller测试-2"><a href="#1-4-编写controller测试-2" class="headerlink" title="1.4 编写controller测试"></a>1.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">      <span class="meta">@RequestMapping</span>(<span class="string">"/mq/header"</span>)</span><br><span class="line">      <span class="meta">@ResponseBody</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span>  Result&lt;String&gt; <span class="title">header</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          sender.sendheader(<span class="string">"hellommxx"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> Result.success(<span class="string">"hello xuanzi"</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存java端实现</title>
      <link href="/2019/05/Redis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/Redis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>redis是一个key-value<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">存储系统</a>。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(<a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">链表</a>)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">数据类型</a>都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。<a id="more"></a></p><h5 id="1-引入redis依赖"><a href="#1-引入redis依赖" class="headerlink" title="1. 引入redis依赖"></a>1. 引入redis依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="2-在application-properties添加redis配置文件"><a href="#2-在application-properties添加redis配置文件" class="headerlink" title="2.在application.properties添加redis配置文件"></a>2.在application.properties添加redis配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#redis</span><br><span class="line">redis.host=127.0.0.1</span><br><span class="line">redis.port=6379</span><br><span class="line">redis.timeout=3</span><br><span class="line">redis.password=2966</span><br><span class="line">redis.poolMaxTotal=10   //资源池中最大连接数</span><br><span class="line">redis.poolMaxIdle=10   //允许的最大空闲的连接数</span><br><span class="line">redis.poolMaxWait=3</span><br></pre></td></tr></table></figure><h5 id="3-定义redis的类，引入redis的配置"><a href="#3-定义redis的类，引入redis的配置" class="headerlink" title="3.定义redis的类，引入redis的配置"></a>3.定义redis的类，引入redis的配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"redis"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String host;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> timeout;<span class="comment">//秒</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> poolMaxTotal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> poolMaxIdle;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> poolMaxWait;<span class="comment">//秒</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-RedisPoolFactory类，用于返回一个redis池"><a href="#4-RedisPoolFactory类，用于返回一个redis池" class="headerlink" title="4.RedisPoolFactory类，用于返回一个redis池"></a>4.RedisPoolFactory类，用于返回一个redis池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPoolFactory</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   RedisConfig redisConfig;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisPool <span class="title">JedisPoolFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">      <span class="comment">//允许最大空闲的连接数</span></span><br><span class="line"></span><br><span class="line">      poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());</span><br><span class="line">      <span class="comment">//资源池中最大连接数</span></span><br><span class="line"></span><br><span class="line">      poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());</span><br><span class="line">      <span class="comment">//最大等待毫秒数</span></span><br><span class="line"></span><br><span class="line">      poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * <span class="number">1000</span>);</span><br><span class="line">      JedisPool jp = <span class="keyword">new</span> JedisPool(poolConfig,</span><br><span class="line">                                   redisConfig.getHost(),                                                                                                                                                                                                                                                    </span><br><span class="line">                                   redisConfig.getPort(),</span><br><span class="line"></span><br><span class="line">                                   redisConfig.getTimeout()*<span class="number">1000</span>,          </span><br><span class="line"></span><br><span class="line">                                   redisConfig.getPassword(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> jp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-编写RedisService类"><a href="#5-编写RedisService类" class="headerlink" title="5.编写RedisService类"></a>5.编写RedisService类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line">    <span class="comment">//里面编写redis操作：增删改查</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">returnToPool</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">             jedis.close();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-1-获取单个对象-get"><a href="#5-1-获取单个对象-get" class="headerlink" title="5.1 获取单个对象(get)"></a>5.1 获取单个对象(get)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的get key </span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(KeyPrefix prefix, String key,  Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">             <span class="comment">//生成真正的key,之前设置通用缓存key时的key设为className:key</span></span><br><span class="line"></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">             <span class="comment">//跟redis里面的获取一个key操作一致 </span></span><br><span class="line"></span><br><span class="line">             String  str = jedis.get(realKey);</span><br><span class="line">             <span class="comment">//将结果转换成一个java对象</span></span><br><span class="line"></span><br><span class="line">             T t =  stringToBean(str, clazz);</span><br><span class="line">             <span class="keyword">return</span> t;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">//关闭池资源</span></span><br><span class="line"></span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//json转换为java对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; <span class="function">T <span class="title">stringToBean</span><span class="params">(String str, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span> || clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span>.class || clazz == Integer.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> (T)Integer.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> (T)str;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span>.class || clazz == Long.class) &#123;</span><br><span class="line">            <span class="keyword">return</span>  (T)Long.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJavaObject(JSON.parseObject(str), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-2-设置对象-set"><a href="#5-2-设置对象-set" class="headerlink" title="5.2 设置对象(set)"></a>5.2 设置对象(set)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的set key value</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">set</span><span class="params">(KeyPrefix prefix, String key,  T value)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">             <span class="comment">//对象转换为json字符串</span></span><br><span class="line"></span><br><span class="line">             String str = beanToString(value);</span><br><span class="line">             <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">             <span class="comment">//获取过期时间</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">int</span> seconds =  prefix.expireSeconds();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//永久有效，无过期时间</span></span><br><span class="line"></span><br><span class="line">                 jedis.set(realKey, str);</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//为指定的 key 设置值及其过期时间。</span></span><br><span class="line"></span><br><span class="line">                 jedis.setex(realKey, seconds, str);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象转化为Json字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; <span class="function">String <span class="title">beanToString</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; clazz = value.getClass();</span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span>.class || clazz == Integer.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> (String)value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span>.class || clazz == Long.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-3-判断key是否存在-exists"><a href="#5-3-判断key是否存在-exists" class="headerlink" title="5.3 判断key是否存在(exists)"></a>5.3 判断key是否存在(exists)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想当于redis里面的 exists key</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">     Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         jedis =  jedisPool.getResource();</span><br><span class="line">        <span class="comment">//生成真正的key</span></span><br><span class="line">         String realKey  = prefix.getPrefix() + key;</span><br><span class="line">        <span class="keyword">return</span>  jedis.exists(realKey);</span><br><span class="line">     &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          returnToPool(jedis);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-4-增加值-incr"><a href="#5-4-增加值-incr" class="headerlink" title="5.4 增加值(incr)"></a>5.4 增加值(incr)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的incr key_name</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Long <span class="title">incr</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">return</span>  jedis.incr(realKey);</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-5-减少值-decr"><a href="#5-5-减少值-decr" class="headerlink" title="5.5 减少值(decr)"></a>5.5 减少值(decr)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的decr key_name</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Long <span class="title">decr</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">return</span>  jedis.decr(realKey);</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-6-删除-del"><a href="#5-6-删除-del" class="headerlink" title="5.6 删除(del)"></a>5.6 删除(del)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的del key_name</span></span><br><span class="line">    <span class="comment">//已知key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">            String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">long</span> ret  = jedis.del(realKey);</span><br><span class="line">            <span class="keyword">return</span> ret &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            returnToPool(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过正则匹配删除 某key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(KeyPrefix prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; keys = scanKeys(prefix.getPrefix());</span><br><span class="line">        <span class="keyword">if</span>(keys==<span class="keyword">null</span> || keys.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.del(keys.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">scanKeys</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            String cursor = <span class="string">"0"</span>;</span><br><span class="line">            <span class="comment">//scan搜索</span></span><br><span class="line"></span><br><span class="line">            ScanParams sp = <span class="keyword">new</span> ScanParams();</span><br><span class="line">            sp.match(<span class="string">"*"</span>+key+<span class="string">"*"</span>);</span><br><span class="line">            <span class="comment">//设置scan的个数</span></span><br><span class="line"></span><br><span class="line">            sp.count(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                ScanResult&lt;String&gt; ret = jedis.scan(cursor, sp);</span><br><span class="line">                <span class="comment">//返回结果</span></span><br><span class="line"></span><br><span class="line">                List&lt;String&gt; result = ret.getResult();</span><br><span class="line">                <span class="keyword">if</span>(result!=<span class="keyword">null</span> &amp;&amp; result.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//搜索的结果存入list</span></span><br><span class="line"></span><br><span class="line">                    keys.addAll(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//再处理cursor，用于返回下次遍历的游标</span></span><br><span class="line"></span><br><span class="line">                cursor = ret.getStringCursor();</span><br><span class="line">            &#125;<span class="keyword">while</span>(!cursor.equals(<span class="string">"0"</span>));</span><br><span class="line">            <span class="keyword">return</span> keys;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="6-controller层测试"><a href="#6-controller层测试" class="headerlink" title="6.controller层测试"></a>6.controller层测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis/get"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Result&lt;User&gt; <span class="title">getRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">   User user = redisService.get(UserKey.getById,<span class="string">"key1"</span>,User.class);</span><br><span class="line">    <span class="keyword">return</span> Result.success(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis/set"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Result&lt;Boolean&gt; <span class="title">setRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">"1111"</span>);</span><br><span class="line">    redisService.set(UserKey.getById,<span class="string">""</span>+<span class="number">1</span>,user);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【61】序列化二叉树</title>
      <link href="/2019/05/61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树 <a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>二叉树的序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>先序序列化二叉树——&gt;&gt;&gt;&gt;定义一个stringbuilder保存序列过程中的结果：</p><p>(1)按照先序遍历方式遍历二叉树，若结点非空则把 “结点值,” append到builder中；</p><p>(2)若结点空则把 “#,” append到builder中；</p><p>(3)最后用builder生成字符串就是序列化结果。</p><p>二叉树的反序列化</p><pre><code>根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</code></pre><p>(1)先序序列化结果重构二叉树</p><p>(2)String[] nodes=str.split(“,”)；//由每个结点的结束符号划分序列化结果序列，得到各个结点值；</p><p>(3)然后按照先序遍历的顺序“根左右”的特性，遍历nodes数组建立二叉树：</p><p>  1)当前遍历元素非 # 则作为一个结点插入树中作为上一结点的左儿子；</p><p>  2)当前遍历元素为 # 则表示此子树已结束，遍历下一元素作为上一结点的右儿子；</p><p>即：<strong>遇数作左；遇#变向</strong></p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;    </span><br><span class="line">        TreeNode left = <span class="keyword">null</span>;    </span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">this</span>.val = val;    </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index = -<span class="number">1</span>;  </span><br><span class="line">    <span class="comment">//室友递归先序遍历对二叉树进行序列化</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;        </span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;            </span><br><span class="line">            sb.append(<span class="string">"#,"</span>);            </span><br><span class="line">            <span class="keyword">return</span> sb.toString();        </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="comment">//先序遍历根结点</span></span><br><span class="line">        sb.append(root.val + <span class="string">","</span>);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        sb.append(Serialize(root.left));   </span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        sb.append(Serialize(root.right));        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//特殊输入</span></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()&lt;=<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将字符串按照","拆分为数组</span></span><br><span class="line">        String[] strr = str.split(<span class="string">","</span>);        </span><br><span class="line">        <span class="keyword">int</span> len = strr.length;        </span><br><span class="line">        index++;        </span><br><span class="line">        <span class="keyword">if</span>(index &gt;= len)&#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="comment">//如果遇到的是#表示空节点，不再建立子树，这个结点null就是子树的根结点返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!strr[index].equals(<span class="string">"#"</span>))&#123;            </span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(Integer.valueOf(strr[index]));            </span><br><span class="line">            <span class="comment">//恢复左子树</span></span><br><span class="line">            node.left = Deserialize(str);            </span><br><span class="line">            <span class="comment">//恢复右子树</span></span><br><span class="line">            node.right = Deserialize(str);       </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//建立二叉树完成，返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> node;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【60】把二叉树打印成多行</title>
      <link href="/2019/05/60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/"/>
      <url>/2019/05/60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 <a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>利用层次遍历二叉树的方式，用一个队列进行辅助，每次打印前取n = queue.size()，可以保证逐行打印。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="comment">//加入根结点</span></span><br><span class="line">       queue.add(pRoot);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//每遍历一次，就新建一次tmp</span></span><br><span class="line">           ArrayList&lt;Integer&gt;  tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(queue.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//加入左结点</span></span><br><span class="line">                   queue.add(queue.peek().left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(queue.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//加入右结点</span></span><br><span class="line">                   queue.add(queue.peek().right);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//删除并返回queue中的头元素，删掉根（上一层结点元素）</span></span><br><span class="line">               tmp.add(queue.poll().val);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将一层的左右结点加入res</span></span><br><span class="line">           res.add(tmp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【59】按之字形顺序打印二叉树</title>
      <link href="/2019/05/59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用一个布尔量控制从左到右还是从右到左的顺序；如果为真则他的左右孩子按照从左到右的顺序放入list中，否则按照从右到左的顺序，当本行结束之后，再把list中的数据放入一个result中。其中用一个null值作为层次的分隔符。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">      ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.addLast(<span class="keyword">null</span>);<span class="comment">//层分隔符</span></span><br><span class="line">       queue.addLast(pRoot);</span><br><span class="line">       <span class="keyword">boolean</span> leftToRight = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">           TreeNode node = queue.removeFirst();</span><br><span class="line">           <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;<span class="comment">//到达层分隔符</span></span><br><span class="line">               Iterator&lt;TreeNode&gt; iter = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (leftToRight) &#123;</span><br><span class="line">                      iter = queue.iterator();<span class="comment">//从前往后遍历</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">//从后往前遍历</span></span><br><span class="line"></span><br><span class="line">                       iter = queue.descendingIterator();</span><br><span class="line">                   &#125;</span><br><span class="line">               leftToRight = !leftToRight;</span><br><span class="line">               <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                       TreeNode temp = (TreeNode) iter.next();</span><br><span class="line">                       list.add(temp.val);</span><br><span class="line">                   &#125;</span><br><span class="line">               result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">               list.clear();</span><br><span class="line">               queue.addLast(<span class="keyword">null</span>);<span class="comment">//添加层分隔符</span></span><br><span class="line">               <span class="keyword">continue</span>;<span class="comment">//一定要continue</span></span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.addLast(node.left);</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.addLast(node.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【58】对称的二叉树</title>
      <link href="/2019/05/58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p> 【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。</p><p>【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。</p><p>【分析3】根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到</p><pre><code>① 如果Root和Root&apos;均为空，则返回true；② 如果Root为空或者Root&apos;为空，则返回false；③ 如果Root对应的值与Root&apos;对应的值不相等，则返回false。</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span> || pRoot.left==<span class="keyword">null</span>&amp;&amp;pRoot.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetrical(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">Symmetrical</span><span class="params">(TreeNode left,TreeNode right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val==right.val)</span><br><span class="line">                    <span class="comment">//右子树的左边跟左子树的右边是否对称</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>    Symmetrical(left.left,right.right)</span><br><span class="line">                   <span class="comment">//左子树的右边跟右子树的左边是否对称</span></span><br><span class="line">                   &amp;&amp; Symmetrical(left.right,right.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【57】二叉树的下一个结点</title>
      <link href="/2019/05/57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>情况1：该节点有右子树：</p><pre><code>         6     /      \   3         10 /   \      /    \2     5    8      12</code></pre><p>中序遍历结果为：2–&gt;3–&gt;5–&gt;<strong>6–&gt;8</strong>–&gt;10–&gt;12</p><p>即它的下一个结点就是它的右子树中<strong>最左子结点</strong></p></blockquote><blockquote><p>情况2.1：该节点无右子树：(为父节点6的左子节点)</p><pre><code>        6     /     \   3        10  /        /    \2         8      12</code></pre><p>2–&gt;<strong>3–&gt;6</strong>–&gt;8–&gt;10–&gt;12</p><p>该节点是父节点的左子节点的这种情况比较简单，直接将父节点返回即可</p></blockquote><blockquote><p>情况2.2：该节点无右子树：(为父节点6的右子节点)</p><pre><code>          6       /    \     3        10  /     \     /   \2       5    8    null</code></pre><p>   2–&gt;3–&gt;6–&gt;8–&gt;<strong>10 –&gt;null</strong></p><p>如果是父节点的右子节点的话，需要不断的向上移动，直到对应的节点不是父节点的右节点（即左节点），既然他是父节点的左节点，此时将这个节点父节点返回即可，或者遍历到了根节点，返回null；</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该节点有右子树,它的下一个结点就是它的右子树中最左子结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该节点无右子树，父节点不为空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//pNode为父节点的左节点为该节点，直接返回父节点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left== pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">       <span class="comment">//为父节点的右子节点，不断的向上移动，直到对应的节点不是父节点的左子节点                  </span></span><br><span class="line">       <span class="comment">//一直回溯如果遍历到他是父节点的左节点，此时将这个节点父节点返回即可，</span></span><br><span class="line">       <span class="comment">//或者遍历到了根节点，返回null；</span></span><br><span class="line"></span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【56】删除链表中重复的结点</title>
      <link href="/2019/05/56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 <a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>方法一：重头构建该链表</p><p>(1) 新建两个list，一个用于存放只出现一次的数值，一个存放重复的数值</p><p>(2) 将只出现过一次的数重头构建成链表</p><p>方法二：递归思想</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; ss = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           ArrayList&lt;Integer&gt; ss2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">           ListNode node = res;</span><br><span class="line">           <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(!ss.contains(pHead.val)</span><br><span class="line">                      &amp;&amp; !ss2.contains(pHead.val))&#123;</span><br><span class="line"></span><br><span class="line">                   ss.add(pHead.val);</span><br><span class="line">                   pHead = pHead.next;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ss2.add(pHead.val);</span><br><span class="line">                   ss.remove(Integer.valueOf(pHead.val));</span><br><span class="line">                   pHead = pHead.next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ss.size();i++)&#123;</span><br><span class="line">               res.next =<span class="keyword">new</span> ListNode(ss.get(i));</span><br><span class="line">               res = res.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> node.next;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有0个或1个结点，则返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pHead.val == pHead.next.val) &#123; <span class="comment">// 当前结点是重复结点</span></span><br><span class="line">            ListNode pNode = pHead.next;</span><br><span class="line">            <span class="keyword">while</span> (pNode != <span class="keyword">null</span> &amp;&amp; pNode.val == pHead.val) &#123;</span><br><span class="line">              <span class="comment">// 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点</span></span><br><span class="line"></span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从第一个与当前结点不同的结点开始递归</span></span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(pNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前结点不是重复结点</span></span><br><span class="line">            <span class="comment">// 保留当前结点，从下一个结点开始递归</span></span><br><span class="line"></span><br><span class="line">            pHead.next = deleteDuplication(pHead.next); </span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【55】链表中环的入口结点</title>
      <link href="/2019/05/55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>方法1：</p><pre><code>利用hashSet不存储重复值的思想</code></pre><p>方法2：</p><p>链表包含环，像数字6的图形。</p><p>(1)设置快慢指针，假设快指针在环内与慢指针相遇，设头节点到入口结点的距离为x,入口结点到相遇点为y,相遇点到入口结点距离为z,则有(x+y)*2 = (x+y+z+y),即z = x，即相遇点到入口结点的距离跟头节点到入口结点的距离相等。</p><p>(2)这时再设置fast = pHead,一个指针重头走，另一个指针重相遇节点走，当两个点相等时即为入口节点所在。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">         HashSet&lt;ListNode&gt; hs = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">         <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(!hs.add(pHead))<span class="comment">//如果包含了，那么这个就是入口结点</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">             pHead = pHead.next;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                fast=pHead;</span><br><span class="line">                <span class="keyword">while</span> (fast!=slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【54】字符流中第一个不重复的字符</title>
      <link href="/2019/05/54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2019/05/54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>桶排序思想</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源源不断的有字母放到字符串中，建立一个256个大小的int型数组来代表哈希表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String str=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;=<span class="number">256</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str+=ch;<span class="comment">//字符放入字符串</span></span><br><span class="line">            count[ch]++;<span class="comment">//根据字符，修改数组字符元素的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:str.toCharArray())&#123;<span class="comment">// //注意的是，要找第一个出现一次的字符，所以遍历字符串，不能遍历哈希数组</span></span><br><span class="line">            <span class="keyword">if</span>(count[c]==<span class="number">1</span>)&#123;<span class="comment">//如果字符串作为下表的元素值为1，说明该字符出现一次，直接返回该字符</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【53】表示数值的字符串</title>
      <link href="/2019/05/53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/05/53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>(1) 先判断每个字符是否合法</p><p>(2) 正负号的位置和e不能在结尾位置</p><p>(3) 小数点只能存在一个</p><p>(4)正负号在中间位置时，前面是e后面是数字</p><p>(5)e后面不能有小数点</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;      </span><br><span class="line">        String ss = String.valueOf(str);    </span><br><span class="line">        <span class="keyword">int</span> len = ss.length();</span><br><span class="line">        <span class="comment">//先判断每个字符是否合法  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;            </span><br><span class="line">            <span class="keyword">char</span> c = ss.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!((c&gt;=<span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c==<span class="string">'e'</span> || c==<span class="string">'E'</span></span><br><span class="line">                                  || c==<span class="string">'+'</span> || c==<span class="string">'-'</span>|| c==<span class="string">'.'</span>))          </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////正负号,E不能在末尾      </span></span><br><span class="line">        <span class="keyword">if</span>(ss.charAt(len-<span class="number">1</span>) == <span class="string">'+'</span> || ss.charAt(len-<span class="number">1</span>) == <span class="string">'-'</span> </span><br><span class="line">           || ss.charAt(len-<span class="number">1</span>) == <span class="string">'E'</span> || ss.charAt(len-<span class="number">1</span>) == <span class="string">'e'</span>)        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断小数点，只能有一个       </span></span><br><span class="line">        <span class="keyword">if</span>(ss.indexOf(<span class="string">"."</span>) != ss.lastIndexOf(<span class="string">"."</span>))  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;       </span><br><span class="line">         </span><br><span class="line">        <span class="comment">//正负号在中间的位置时，前面的是e，E,后面是数字      </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len-<span class="number">1</span>; i++)&#123;         </span><br><span class="line">            <span class="keyword">char</span> c = ss.charAt(i);          </span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'+'</span> || c==<span class="string">'-'</span>)&#123;             </span><br><span class="line">               <span class="keyword">if</span>(!(ss.charAt(i-<span class="number">1</span>) == <span class="string">'e'</span> || ss.charAt(i-<span class="number">1</span>) == <span class="string">'E'</span>)   </span><br><span class="line">                   ||!(ss.charAt(i+<span class="number">1</span>)&gt;=<span class="string">'0'</span> &amp;&amp; ss.charAt(i+<span class="number">1</span>)&lt;=<span class="string">'9'</span>))</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;               </span><br><span class="line">                &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////e的后面不能有数字12E+4.3        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;            </span><br><span class="line">            <span class="keyword">char</span> c = ss.charAt(i);          </span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'e'</span> || c==<span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==len-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;               </span><br><span class="line">                <span class="keyword">if</span>(ss.charAt(i+<span class="number">1</span>) == <span class="string">'+'</span> || ss.charAt(i+<span class="number">1</span>) == <span class="string">'-'</span>)&#123;</span><br><span class="line">                    <span class="comment">//从i+2开始往后没有小数点.则返回-1</span></span><br><span class="line">                    <span class="keyword">if</span>(ss.indexOf(<span class="string">"."</span>, i+<span class="number">2</span>) != -<span class="number">1</span>)&#123;                     </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;                   </span><br><span class="line">                      &#125;               </span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ss.indexOf(<span class="string">"."</span>, i+<span class="number">1</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【52】正则表达式匹配</title>
      <link href="/2019/05/52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/05/52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>这道题的核心其实在于分析’<em>‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’</em>‘的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。</p><p>在每轮匹配中，<strong>Patttern第二个字符是’*’时：</strong></p><p>1.第一个字符不匹配（’.’与任意字符视作匹配），那么’<em>‘只能代表匹配0次，比如’ba’与’a</em>ba’，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式</p><p>2.第一个字符匹配，那么’<em>‘可能代表匹配0次，1次，多次，比如’aaa’与’a</em>aaa’、’aba’与’a<em>ba’、’aaaba’与’a</em>ba’。匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；匹配多次时，字符串往后移动一个字符，模式不变；</p><p>而当<strong>Patttern第二个字符不是’*’时</strong>，情况就简单多了<strong>：</strong></p><p>(1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。</p><p>(2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> strIndex = <span class="number">0</span>,patternIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[]   </span></span></span><br><span class="line"><span class="function"><span class="params">                                      pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功   </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strIndex == str.length</span><br><span class="line">                               &amp;&amp; patternIndex == pattern.length) &#123;       </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">        &#125;   </span><br><span class="line">       <span class="comment">//pattern先到尾，匹配失败   </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strIndex != str.length</span><br><span class="line">                               &amp;&amp; patternIndex == pattern.length) &#123;       </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,</span></span><br><span class="line">        <span class="comment">//分3种匹配模式；如不匹配，模式后移2位   </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length </span><br><span class="line">                            &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;       </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((strIndex != str.length</span><br><span class="line">                         &amp;&amp; pattern[patternIndex] == str[strIndex]) </span><br><span class="line">                         || (pattern[patternIndex] == <span class="string">'.'</span></span><br><span class="line">                         &amp;&amp; strIndex != str.length)) &#123;           </span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> </span><br><span class="line">              <span class="comment">//模式后移2，视为x*匹配0个字符</span></span><br><span class="line">              matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)</span><br><span class="line">              <span class="comment">//视为模式匹配1个字符</span></span><br><span class="line"></span><br><span class="line">         || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)</span><br><span class="line">         <span class="comment">//*匹配1个，再匹配str中的下一个                 </span></span><br><span class="line"></span><br><span class="line">         || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;           </span><br><span class="line">           <span class="keyword">return</span> </span><br><span class="line">              matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);       </span><br><span class="line"></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false   </span></span><br><span class="line">        <span class="keyword">if</span> ((strIndex != str.length</span><br><span class="line">           &amp;&amp; pattern[patternIndex] == str[strIndex]) </span><br><span class="line">           || (pattern[patternIndex] == <span class="string">'.'</span> </span><br><span class="line">           &amp;&amp; strIndex != str.length)) &#123;       </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, </span><br><span class="line">                             patternIndex + <span class="number">1</span>);   </span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【51】构建乘积数组</title>
      <link href="/2019/05/51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2019/05/51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。<strong>不能使用除法</strong>。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>题目的意思就是B[i] = A[0]*A[1]….*A[n-2]*A[n-1]  / A[i],但是题目要求不能用除法</p><p>创建一个left数组和一个rigth数组，拿n = 3为例               </p></blockquote><table><thead><tr><th>res[i]</th><th>left[0]*right[0]</th><th>left[1]*right[1]</th><th>left[2]*right[2]</th><th>left[3]*right[3]</th></tr></thead><tbody><tr><td>right数组</td><td>A[2]*A[1]*A[0]*1</td><td>A[1]*A[0]*1</td><td>A[0]*1</td><td>1</td></tr><tr><td>left数组</td><td>1</td><td>1*A[0]</td><td>1*A[0]*A[1]</td><td>1*A[0]*A[1]*A[2]</td></tr></tbody></table><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> []res = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> []left = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> []right = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            left[i] = A[i-<span class="number">1</span>]*left[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right[A.length-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>]*A[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            res[i] = left[i]*right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【50】数组中重复的数字</title>
      <link href="/2019/05/50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>在一个<strong>长度为n</strong>的数组里的所有数字都在<strong>0到n-1的范围</strong>内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>长度为n,数字都在[0,n-1]范围，可以利用桶排序的思想，将numbers[i]的个数存入相应的res索引下，当第一次桶里有2个numbers[i]时，直接返回即找到第一个数组里面的重复数字。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span> [length];</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">           res[numbers[i]]++;</span><br><span class="line">            <span class="comment">//有重复的数</span></span><br><span class="line">            <span class="keyword">if</span>(res[numbers[i]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">              duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">               flag = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【49】把字符串转换成整数</title>
      <link href="/2019/05/49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
      <url>/2019/05/49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<a id="more"></a></p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h6><p>输入一个字符串,包括数字字母符号,可以为空</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h6><p>如果是合法的数值表达则返回该数字，否则返回0</p><p>示例1：</p><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>+2147483647<br>    1a33</p><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><p>2147483647<br>    0</p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>(1) 首先判断第一个字符是符号‘ + ‘ 或者 ’ - ‘ 还是数字</p><p>(2) 首字母为 ’ + ‘，则设flag 为 1，计算[1,len)的数值</p><p>(3) 首字母为 ’  -  ‘，则设flag为-1，计算[1,len)的数值</p><p>(4) 首字母为数字，则计算[0,len)的数值</p><p>计算时有个是否溢出判断。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.trim().equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) ==<span class="string">'+'</span>||str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>) &#123;</span><br><span class="line">                flag = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = cal(str,<span class="number">1</span>,str.length(),flag);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum = cal(str,<span class="number">0</span>,str.length(),flag);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum*flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">int</span> <span class="title">cal</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end,<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span> &amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span> &amp;&amp; sum&gt;Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"上溢出"</span>);</span><br><span class="line">                <span class="keyword">if</span>(flag == -<span class="number">1</span> &amp;&amp; sum&lt;Integer.MIN_VALUE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"下溢出"</span>);</span><br><span class="line">                sum = sum*<span class="number">10</span>+str.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【48】不用加减乘除做加法</title>
      <link href="/2019/05/48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
      <url>/2019/05/48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>利用&amp;、|、^等运算</p><p>(1)定义一个sum和一个进位位carry，sum用来记录二进制的两位数无进位相加得到的值（num1^num2）,进位位carry用来记录需要向哪个位进位（num&amp;num2&lt;&lt;1）</p><p>(2)将得到的sum和carry重新赋值给num1和num2.循环的结束条件是进位位为0时终止。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//异或，相同为0不同为1 ,得到的结果相当于二进制的两个数无进位相加，         </span></span><br><span class="line">            <span class="comment">//相加为2的结果是0.如6和12相异或，即（0110^1100） = 1010</span></span><br><span class="line"></span><br><span class="line">            sum = num1 ^ num2;</span><br><span class="line">            <span class="comment">//num1&amp;num2得到该位数需要进位，即向前进位&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line">            carry = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 = sum;  </span><br><span class="line"></span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num2!=<span class="number">0</span>);  <span class="comment">//直到无进位结束</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【47】求1+2+...+n</title>
      <link href="/2019/05/47-%E6%B1%821-2-n/"/>
      <url>/2019/05/47-%E6%B1%821-2-n/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>1.需利用逻辑与的短路特性实现递归终止。 </p><p>2.当n==0时，(n&gt;0)&amp;&amp;((ans+=Sum_Solution(n-1))&gt;0)只执行前面的判断，不执行后面的递归了，使这条语句为false，并且不往上回溯，可以执行下面return的语句了。然后直接返回ans；</p><p>3.当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="keyword">boolean</span> flag = (ans &gt; <span class="number">0</span>) &amp;&amp; (ans += Sum_Solution(n - <span class="number">1</span>))&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【46】孩子们的游戏(圆圈中最后剩下的数)</title>
      <link href="/2019/05/46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/05/46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) <a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>模拟游戏过程</p><p>i一直记录的是小朋友自己最初的的位置[0,n-1]</p><p>step记录的是报数，报到m-1时array[i]这个小朋友出局，记-1，step重头计数。人数这时减1.</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span> ;  <span class="comment">//初始状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = n;  <span class="comment">//人数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count&gt;<span class="number">0</span>)&#123;  <span class="comment">//游戏开始</span></span><br><span class="line">            <span class="comment">//报数，其实报的一直都是自己的位置数，不是[0,m-1],而是[0,n-1]</span></span><br><span class="line"></span><br><span class="line">            i++; </span><br><span class="line">            <span class="comment">//假如有8人，报数范围是[0,7],轮询一圈后那么第一个人不报8而是报0 </span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=n)  </span><br><span class="line"></span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==-<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//标记为-1即出局，不遍历下边的了</span></span><br><span class="line"></span><br><span class="line">            step++;   <span class="comment">//step用来记录报数报到哪了</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(step==m-<span class="number">1</span>)&#123;  <span class="comment">//找到喊m-1的小朋友</span></span><br><span class="line"></span><br><span class="line">                array[i] = -<span class="number">1</span>; <span class="comment">//出局</span></span><br><span class="line"></span><br><span class="line">                step = -<span class="number">1</span>;     <span class="comment">//重头开始记录报数</span></span><br><span class="line"></span><br><span class="line">                count--;   <span class="comment">//人数减1</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【45】扑克牌顺子</title>
      <link href="/2019/05/45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/"/>
      <url>/2019/05/45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>组成顺子的条件是：</p><p>(1) 数组长度为5</p><p>(2)数组中数不重复</p><p>(3)最大值Max减最小值Min&lt;5,其中Max和Min不能为0,即不包括大小王的最大值最小值</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length&lt;<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> Max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> Min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> count[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">14</span>];</span><br><span class="line">        <span class="comment">//除0以外没有重复的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            count[numbers[i]]++;</span><br><span class="line">            <span class="comment">//如果是大小王的话，可以允许多个，直接continue不执行count[numbers[i]&gt;=2的判断,而且最大值最小值的判断也会跳过0</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count[numbers[i]]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(Max&lt;numbers[i]) &#123;</span><br><span class="line">                Max = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Min &gt;numbers[i])&#123;</span><br><span class="line">                Min = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( Max - Min &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【44】翻转单词顺序列</title>
      <link href="/2019/05/44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用str.split(“ ”) 去切分子字符串变成str[],然后再拼接。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)&#123; <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="comment">//去掉前后空格，避免输入字符串全是空格情况，保证后面的split切分正确</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(str.trim().equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        String res[] = str.split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder ss = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//第二个到最后一个数组值后面要加“ ” </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = res.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ss.append(res[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个就是数组末尾了不需要加“ ”，保持反转后的数组长度跟原来一样</span></span><br><span class="line"></span><br><span class="line">        ss.append(res[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ss.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【43】左旋转字符串</title>
      <link href="/2019/05/43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/05/43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>两个子字符串 拼接就行了。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(n&gt;str.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> str.substring(n,str.length())+str.substring(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【42】和为s的两个数字</title>
      <link href="/2019/05/42-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/42-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h6><p>对应每个测试案例，输出两个数，小的先输出。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>将数组的数值依次放入list里面，每次放入之前查询list里面是否有（sum-array[i]），如果有,再判断两数乘积是否比之前存的两数乘积小，如果判断成功，则将这两个数放到index1和index2中。最后将这两个index放到list里面返回。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ss = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> Min_ = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//index1用于存放比较小的那个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//index2用于存放比较大的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(sum-array[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Min_&gt;(sum-array[i])*array[i])&#123;</span><br><span class="line">                    Min_ = (sum-array[i])*array[i];</span><br><span class="line">                    index1 = array[i]&lt;(sum-array[i])?</span><br><span class="line">                                           array[i]:(sum-array[i]);</span><br><span class="line"></span><br><span class="line">                    index2 = sum-index1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index1!=<span class="number">0</span>||index2!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">               ss.add(index1);</span><br><span class="line">               ss.add(index2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【41】和为S的连续正数序列</title>
      <link href="/2019/05/41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>滑动窗口移动方法</p><p>(1) 求出滑动窗口的累加和，公式为等差数列求和公式</p><p>(2)如果累加和等于sum,则将该滑动窗口内的数存到一个list里面，并右移动左指针</p><p>(3)如果累加和小于sum,则右移动右指针，加数进来</p><p>(4)如果累加和大约sum，则左指针右移动，减数出去</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小</span></span><br><span class="line">        <span class="keyword">int</span> plow = <span class="number">1</span>,phigh = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(phigh &gt; plow)&#123;</span><br><span class="line">            <span class="comment">//由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2</span></span><br><span class="line">            <span class="keyword">int</span> cur = (phigh + plow) * (phigh - plow + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//相等，那么就将窗口范围的所有数添加进结果集</span></span><br><span class="line">            <span class="keyword">if</span>(cur == sum)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=plow;i&lt;=phigh;i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                plow++;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和小于sum，那么右边窗口右移一下</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; sum)&#123;</span><br><span class="line">                phigh++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和大于sum，那么左边窗口右移一下</span></span><br><span class="line">                plow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【40】数组中只出现一次的数字</title>
      <link href="/2019/05/40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>将数组依次放到list里面，如果list里面含有准备要进去的数值，则remove掉，剩下的两个数组即为该数组中只出现过一次的数字</p></blockquote><p>list.remove要用(Object object)方法而不是list.remove(int index);</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">         ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(array[i]))&#123;</span><br><span class="line">            <span class="comment">//这里remove掉的是里面的数array[i]，而不是array[i]索引对应的数</span></span><br><span class="line"></span><br><span class="line">                res.remove(Integer.valueOf(array[i]));</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = res.get(<span class="number">0</span>);</span><br><span class="line">        num2[<span class="number">0</span>] = res.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【39】平衡二叉树</title>
      <link href="/2019/05/39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>预备知识：平衡二叉树是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>思想：从根节点开始，先判断左右子树的高度差是否超过1，然后接着判断左右子树是否是平衡二叉树。这边用到了递归思想。</p><p>代码如下：</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span>) &#123; <span class="comment">//一棵空树就是平衡二叉树</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( Math.abs(getDepth(root.left)  - getDepth(root.right)) &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//满足左右子树高度差小于等于1,那就接着判断左右子树是不是二叉树</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不满足左右子树高度差小于等于1,那这棵树肯定不是平衡二叉树啦</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归求二叉树深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ( left &gt; right ? left : right ) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【38】二叉树的深度</title>
      <link href="/2019/05/38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
      <url>/2019/05/38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><a id="more"></a></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>①如果一棵树只有一个结点，它的深度为1。</p><p>②如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。</p><p>③如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//----递归求二叉树深度----</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> (left&gt;right)?(left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【37】数字在排序数组中出现的次数</title>
      <link href="/2019/05/37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2019/05/37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>统计一个数字在<strong>排序数组</strong>中出现的次数。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>排序数组嘛，找到数组里面第一个等于k的，一直res++直到数组值不等于k。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(array[i] == k)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【36】两个链表的第一个公共结点</title>
      <link href="/2019/05/36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入两个链表，找出它们的第一个公共结点。 <a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>两个链表有公共点，考虑Y型的两链表相连，先计算出两个链表的长度，然后长的链表先走差值步，之后同步走，当遇到cur1==cur2时说明两链表相遇。直接返回即可。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode cur1 = head1;</span><br><span class="line">            ListNode cur2 = head2;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//得到差值步（head1.length-head2.length）</span></span><br><span class="line">            <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相交为Y型则最后一个结点应该相同</span></span><br><span class="line">            <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">            n = Math.abs(n);<span class="comment">//差值步</span></span><br><span class="line">            <span class="comment">//走差值步</span></span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相等时则为相交点</span></span><br><span class="line">            <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>争吵问题.md</title>
      <link href="/2019/05/%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md/"/>
      <url>/2019/05/%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h5><p>有一个队列，每个人要么朝左边（L表示）,要么朝右边(R表示)，因为每个人都讨厌其他任何人，只要两人面对面就会发生争吵。争吵结果是胜者留在队列中，败的人移除队中。如果序列中有多对争吵，可以任选一对，胜者留在队中，败者出局，求最后队列最少人数是多少。<a id="more"></a></p><p>例子：</p><p>LRRLRL</p><p>输出：2</p><p><strong>Hint</strong></p><p>一种可能的变化情况是：LRRLRL -&gt; LRLRL -&gt; LRRL -&gt; LRL -&gt; LR</p><h5 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h5><p>由题意可知，如果真的吵架就只有RL（两人面对面）情况，像LL,RR,LR就不会争吵。</p><ul><li><p>如果吵架前面是R，则吵架结果应该是L胜利.</p></li><li><p>如果吵架前面是L，则吵架结果为R胜利</p></li></ul><h5 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String arr =<span class="string">"LRRLRL"</span>;</span><br><span class="line">        String res = solut(arr);</span><br><span class="line">        System.out.println(res.length());</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String  <span class="title">solut</span><span class="params">(String arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取第一次争吵得到的结果</span></span><br><span class="line">       String str = solution(arr);</span><br><span class="line">       <span class="comment">//如果还存在第二次争吵，则继续，否则得到结果</span></span><br><span class="line">        <span class="keyword">while</span> (str.contains(<span class="string">"RL"</span>))&#123;</span><br><span class="line">            str = solution(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">solution</span><span class="params">(String arr)</span></span>&#123;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//争吵</span></span><br><span class="line">            <span class="keyword">if</span>(arr.charAt(i)==<span class="string">'R'</span>&amp;&amp;arr.charAt(i+<span class="number">1</span>)==<span class="string">'L'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(<span class="string">'R'</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.get(list.size()-<span class="number">1</span>)==<span class="string">'L'</span>) &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        list.add(<span class="string">'R'</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        list.add(<span class="string">'L'</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有争吵，下一次争吵中还有该人</span></span><br><span class="line">                list.add(arr.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将list转换成String</span></span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            str = str+list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 讯飞科技笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讯飞科技笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【34】第一个只出现一次的字符位置</title>
      <link href="/2019/05/34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE/"/>
      <url>/2019/05/34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>1.用两个list,一个list用来存放只出现一次的字符，一个用来存放出现多次的字符</p><p>2.依次遍历str里面的字符，如果list1和list2里面都没有，则说明这个字符是第一次出现，将其添加到list1，否则说明之前出现过该字符，将其移除list1并添加到list2里面</p><p>3.最后判断list里面是否有值，有则返回list里面的第一个值在str出现的第一次的位置，即为第一次出现的字符位置。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str.length() == <span class="number">0</span> || str == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//list1存放str中出现1次的字符</span></span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Character&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">        <span class="comment">//list2用来存放多次出现的字符</span></span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Character&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">           <span class="comment">//两个list里面都没有这个字符</span></span><br><span class="line">           <span class="keyword">if</span> (!list1.contains(ch) &amp;&amp; !list2.contains(ch)) &#123;</span><br><span class="line">               <span class="comment">//将字符放到list1中</span></span><br><span class="line">               list1.add(Character.valueOf(ch));</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//将list1之前加入的删掉（此时出现了相同字符，删掉相同字符）</span></span><br><span class="line">               list1.remove(Character.valueOf(ch));</span><br><span class="line">               <span class="comment">//将str中含有的相同字符存入list2</span></span><br><span class="line">               list2.add(Character.valueOf(ch));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (list1.size() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> str.indexOf(list1.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【35】数组中的逆序对</title>
      <link href="/2019/05/35.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2019/05/35.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<a id="more"></a></p><p>题目保证输入的数组中没有的相同的数字</p><p>数据范围：</p><ol><li><p>对于%50的数据,size&lt;=10^4 </p></li><li><p>对于%75的数据,size&lt;=10^5</p></li><li><p>对于%100的数据,size&lt;=2*10^5</p></li></ol><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><pre><code>数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；</code></pre><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>方法1：暴力破解:时间超时</p><p>考察每一位，判断从这一位往后有多少小于该位的，结果累加，得到最后结果。</p><p>方法2：归并算法</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1(超时)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []array=&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> num=InversePairs(array);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;array.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i]&gt;array[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = InversePairsCore(array,copy,<span class="number">0</span>,array.length-<span class="number">1</span>);<span class="comment">//数值过大求余</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">int</span> <span class="title">InversePairsCore</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] copy,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low==high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftCount=</span><br><span class="line">                   InversePairsCore(array,copy,low,mid)%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightCount = </span><br><span class="line">                InversePairsCore(array,copy,mid+<span class="number">1</span>,high)%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=mid;</span><br><span class="line">        <span class="keyword">int</span> j=high;</span><br><span class="line">        <span class="keyword">int</span> locCopy = high;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=low&amp;&amp;j&gt;mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                count += j-mid;</span><br><span class="line">                copy[locCopy--] = array[i--];</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">1000000007</span>)<span class="comment">//数值过大求余</span></span><br><span class="line">                &#123;</span><br><span class="line">                    count%=<span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                copy[locCopy--] = array[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=low;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[locCopy--]=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;mid;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[locCopy--]=array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=low;s&lt;=high;s++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[s] = copy[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (leftCount+rightCount+count)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【33】丑数</title>
      <link href="/2019/05/33-%E4%B8%91%E6%95%B0/"/>
      <url>/2019/05/33-%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an</p><p>所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2<em>a1, 2</em>a2, 2*a3 …..</p><p>包含3的有序丑数序列:3<em>a1, 3</em>a2, 3<em>a3 ….. 包含5的有序丑数序列:5</em>a1, 5<em>a2, 5</em>a3 …..</p><p>以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr=<span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//第一个丑数为1，放入数组的第一个元素</span></span><br><span class="line">        <span class="keyword">int</span> t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t3=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//寻找3个序列中最小的那个数</span></span><br><span class="line">          arr[i]=Math.min(arr[t2]*<span class="number">2</span>,Math.min(arr[t3]*<span class="number">3</span>,arr[t5]*<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最小的那个数的序列值加1</span></span><br><span class="line">            <span class="keyword">if</span>(arr[t2]*<span class="number">2</span>==arr[i])</span><br><span class="line">                t2++;</span><br><span class="line">            <span class="keyword">if</span>(arr[t3]*<span class="number">3</span>==arr[i])</span><br><span class="line">                t3++;</span><br><span class="line">            <span class="keyword">if</span>(arr[t5]*<span class="number">5</span>==arr[i])</span><br><span class="line">                t5++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[index-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【32】把数组排成最小的数</title>
      <link href="/2019/05/32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2019/05/32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>方法1：</p><p>(1) 求出数组里面最大的数的位数，然后其他的数位数不够的进行补位</p><p>(2) 补位原则：如数组{3,32,321},最大位数为3，所以3进行补位变成333，补的两位为str[i]数组里面的最后一个charAt[str[i].length()-1];所以32补位变成322</p><p>(3) 对数组{333，322，321}进行从小到大排序，然后根据索引把字符串拼接即可得到答案。即从小到大排序为{321，322，333}，这三个数对应原数组的{321，32，3}，最后答案即为321323.</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(numbers.length&lt;=<span class="number">0</span>||numbers == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//排序，可得到最大的数为numbers[len-1]</span></span><br><span class="line"></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="comment">//求位数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Max_ = numbers[numbers.length-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//得到最大的数的位数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Max_&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            Max_ = Max_/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数组变成字符串数组</span></span><br><span class="line"></span><br><span class="line">        String str[] = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            str[i] = <span class="string">""</span>+numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//补位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="comment">//得到补位要填充的数</span></span><br><span class="line"></span><br><span class="line">            String tmp =<span class="string">""</span> +str[i].charAt(str[i].length()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//原数组的位数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len =str[i].length(); </span><br><span class="line">            <span class="comment">//补足到相同的位数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;count-len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                str[i] = str[i]+tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ss= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//该数组的索引对应着numbers的索引</span></span><br><span class="line"></span><br><span class="line">        String strcopy[] = str.clone();</span><br><span class="line">        <span class="comment">//将其进行从小到大的排序</span></span><br><span class="line"></span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        <span class="comment">//得到从小到大排序后原数组所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;numbers.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i].equals(strcopy[j]))&#123;</span><br><span class="line">                    ss.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将索引进行拼接得到结果</span></span><br><span class="line"></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            res = res +numbers[ss.get(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【31】整数中1出现的次数</title>
      <link href="/2019/05/31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2019/05/31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>方法1：</p><p>将每个数变成string,然后将string里面的1替换成”“,长度的减少就是这个string里面1的个数，但是这个方法中String是不可变字符串，故占用内存过多。</p></li><li><p>方法2：</p><p>依次计算出每个数中包含1的个数</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       String s = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           s = i+<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">           count += s.length()-s.replaceAll(<span class="string">"1"</span>, <span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">               sum+=NumberOf1(i);</span><br><span class="line">           <span class="keyword">return</span> sum;</span><br><span class="line">       &#125;    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">10</span>==<span class="number">1</span>)<span class="comment">//求余</span></span><br><span class="line">            &#123;</span><br><span class="line">               count++; </span><br><span class="line">            &#125;</span><br><span class="line">            n=n/<span class="number">10</span>;     </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【30】连续子数组的最大和</title>
      <link href="/2019/05/30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2019/05/30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？<a id="more"></a>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。</p><ul><li><p>当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令cur = 0.表示从下一个数开始累加。</p></li><li><p>当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最大值即可。</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                cur += array[i];</span><br><span class="line">                res = Math.max(res,cur);</span><br><span class="line">                cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【29】最小的K个数</title>
      <link href="/2019/05/29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/05/29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>排序问题，本次使用快排，快排思想即：</p><p>“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input.length&lt;k)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        quicksort(input, <span class="number">0</span>, input.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> position = partition(arr, low, high);</span><br><span class="line">            quicksort(arr, low, position - <span class="number">1</span>);</span><br><span class="line">            quicksort(arr, position + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//设置基准值</span></span><br><span class="line">            <span class="keyword">int</span> key = arr[low];</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="comment">//从右到左，直到找到一个小于key的值</span></span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= key) --high;</span><br><span class="line">                <span class="comment">//将该值填入前的坑</span></span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                <span class="comment">//从左到右，直到找到一个大于key的值</span></span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= key) ++low;</span><br><span class="line">                <span class="comment">//将该值填入前一个坑</span></span><br><span class="line">                arr[high] = arr[low];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将基准值填入最后一个坑</span></span><br><span class="line">            arr[low] = key;</span><br><span class="line">            <span class="comment">//最后一个坑划分了左边小于该值，右边大于该值</span></span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【28】数组中出现次数超过一半的数字</title>
      <link href="/2019/05/28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>利用一个hashmap用来存储数组里面每个数出现的次数，然后遍历map，比较每个数的value是否超过数组的一半</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">            HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(array[i]))&#123;</span><br><span class="line">                    map.put(array[i],map.get(array[i])+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(array[i],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(entry.getValue()&gt;array.length/<span class="number">2</span>)</span><br><span class="line">                        res = entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【27】字符串的排列</title>
      <link href="/2019/05/27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2019/05/27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>算法思路：（递归实现）<br>(1)n个元素的全排列=（n-1个元素的全排列）+（另一个元素作为前缀）；<br>(2)出口：如果只有一个元素的全排列，则说明已经排完，则输出数组；</p><p>(3)不断将每个元素放作第一个元素，然后将这个元素作为前缀，并将其余元素继续全排列，等到出口，出口出去后还需要还原数组； </p><p>以字符串abc为例：</p><ul><li>a 作为开头 -&gt; 求 bc 全排列 -&gt; 得到 bc 和 cb -&gt; 与 a 合并 -&gt; 得到 abc 和 acb</li><li>b 作为开头 -&gt; 求 ac 全排列 -&gt; 得到 ac 和 ca -&gt; 与 b 合并 -&gt; 得到 bac 和 bca</li><li>c 作为开头 -&gt; 求 ab 全排列 -&gt; 得到 ab 和 ba -&gt; 与 c 合并 -&gt; 得到 cab 和 cba</li></ul></blockquote><ol><li><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//用于排序输出</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将字符串转化成字符数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">//从第0个字符开始全排列      </span></span><br><span class="line"></span><br><span class="line">        res=Permu(chars,<span class="number">0</span>,res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permu</span><span class="params">(<span class="keyword">char</span>[] str,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> start, ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置递归的出口,即当需要全排列的范围只有一个元素，则全排结束</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == str.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//去除重复的字符串</span></span><br><span class="line">            <span class="keyword">if</span> (list.contains(String.valueOf(str))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(String.valueOf(str));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//for循环将start~len-1每一个数放到start位置中去，并实现全排列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//str[start]-----str[len-1]的全排列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; str.length; j++) &#123;</span><br><span class="line">                <span class="comment">//取出第j个字符作为第一个字符</span></span><br><span class="line">                swap(str,j,start);</span><br><span class="line">                <span class="comment">//求出str[start+1]----str[len-1]的全排列</span></span><br><span class="line"></span><br><span class="line">                Permu(str, start+ <span class="number">1</span>, list);</span><br><span class="line">                <span class="comment">//恢复原数组</span></span><br><span class="line"></span><br><span class="line">                swap(str,j,start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成字典序</span></span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;<span class="comment">//因为会出现原位置与原位置交换，直接空即可</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[a];</span><br><span class="line">            chars[a]=chars[b];</span><br><span class="line">            chars[b]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【26】二叉搜索树与双向链表</title>
      <link href="/2019/05/26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/05/26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个<strong>排序</strong>的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<a id="more"></a></p><p>二叉树如</p><pre><code>             10         /        \      6            14   /     \       /      \4         8    12        16</code></pre><p>转化成双向链表    4 <----> 6  <----> 8  <----> 10  <---->12 <---->14<---->16</----></----></----></----></----></----></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>(1)二叉搜索树中，每个结点都有两个分别指向其左、右子树的指针，左子树结点的值总是小于父结点的值，右子树结点的值总是大于父结点的值。</p><p>(2)双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。所以这两种数据结构的结点是一致<br>    为了减少指针的变换次数，并让操作更加简单，在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。</p><p>链表是有序的，可以借助二叉树<strong>中序遍历</strong>，因为中序遍历算法的特点就是从小到大访问结点。当遍历访问到根结点时，假设根结点的左侧已经处理好，只需将根结点与上次访问的最近结点（左子树中最大值结点）的指针连接好即可。进而更新当前链表的最后一个结点指针。同时中序遍历过程正好是转换成链表的过程，可采用递归方法处理</p><p>思想：<em>把左子树、右子树都转换成排序的双向链表之后在和根结点链接起来，整个二叉树也变成了排序的双向链表。</em></p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="comment">//假如根节点为空，返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;<span class="comment">//假如只有一个根节点，则返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1、将左子树构造成双链表，并返回该链表头结点left</span></span><br><span class="line">    TreeNode left=Convert(root.left);</span><br><span class="line">    <span class="comment">//2、定位到左子树链表的最后一个节点（左子树最右边的节点）</span></span><br><span class="line">    <span class="comment">//创建一个临时节点P,用来遍历找到左链表的最后一个节点(左子树最右边的节点)，p初始化指向做左子树的根节点，</span></span><br><span class="line">    TreeNode p=left;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//最终p为左子树最右边的节点</span></span><br><span class="line">        p=p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、如果左子树链表不为空，将当前root追加到左子树链表后 </span></span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="keyword">null</span>)&#123;<span class="comment">//左子树链表不为空</span></span><br><span class="line">       <span class="comment">//左子树链表的最后一个节点p（左子树最右边节点）的右指针指向当前root节点</span></span><br><span class="line">        p.right=root;</span><br><span class="line">       <span class="comment">//当前root节点的左指针指向左子树链表的最后一个节点p（左子树最右边节点）</span></span><br><span class="line">        root.left=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、将右子树构造成双链表，并返回该链表的头结点right</span></span><br><span class="line">    TreeNode right=Convert(root.right);</span><br><span class="line">    <span class="comment">//5、如果右子树链表不为空，将右子树链表追加到当前root后</span></span><br><span class="line">    <span class="keyword">if</span>(right!=<span class="keyword">null</span>)&#123;<span class="comment">//右子树链表不为空</span></span><br><span class="line">        right.left=root;<span class="comment">//右子树链表的头结点right的左指针指向当前root</span></span><br><span class="line">        root.right=right;<span class="comment">//当前root的右指针指向右子树链表的头结点right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left!=<span class="keyword">null</span>?left:root;<span class="comment">//根据左子树链表是否为空返回整个双向链表的头指针。    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【25】复杂链表的复制</title>
      <link href="/2019/05/25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/05/25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode head = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">        RandomListNode ans = head;</span><br><span class="line">        <span class="keyword">if</span> (pHead.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.random = <span class="keyword">new</span> RandomListNode(pHead.random.label);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">            head.next = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">            <span class="keyword">if</span> (pHead.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                head.next.random = <span class="keyword">new</span> </span><br><span class="line">                                RandomListNode(pHead.random.label);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomListNode currentNode = pHead;</span><br><span class="line">        <span class="comment">//1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123; </span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(currentNode.label);</span><br><span class="line">            RandomListNode nextNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode;</span><br><span class="line">            cloneNode.next = nextNode;</span><br><span class="line">            currentNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        <span class="comment">//2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode.next.random = currentNode.random==<span class="keyword">null</span>?<span class="keyword">null</span>:currentNode.random.next;</span><br><span class="line">            currentNode = currentNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode.next;</span><br><span class="line">            cloneNode.next = cloneNode.next==<span class="keyword">null</span>?<span class="keyword">null</span>:cloneNode.next.next;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【24】二叉树中和为某值的路径</title>
      <link href="/2019/05/24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/05/24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一棵二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>整个过程可以采用先序遍历方式的DFS，即根节点—–&gt;左子树—–&gt;右子树。 </p><blockquote><p>随后考虑一次遍历完成后的处理，</p><p>(1)当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点；</p><p>(2)如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。 </p><p>(3)考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 </p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个类型为ArrayList&lt;Integer&gt;的list</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathlist=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//创建一个list,用于存放遍历的值</span></span><br><span class="line">    ArrayList&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果树为空，则返回空的pathlist</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> pathlist;</span><br><span class="line">        <span class="comment">//将root值放入list</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//如果根的左子树、右子树、目标值=根值，则返回path</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>&amp;&amp;target==root.val)</span><br><span class="line">        &#123;</span><br><span class="line">            pathlist.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此时根值小于目标值并且含有左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;=target&amp;&amp;root.left!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//将遍历左子树，将根设为左子树并且此时的target=target-遍历过的root值</span></span><br><span class="line">            FindPath(root.left,target-root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此时根值小于目标值并且含有右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;=target&amp;&amp;root.right!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//将遍历右子树，将根设为右子树并且此时的target=target-遍历过的root值</span></span><br><span class="line">            FindPath(root.right,target-root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不论路径的值是否等于输入整数值，都要回退，</span></span><br><span class="line">        <span class="comment">//即使用remove函数移除路径上的最后一个节点。</span></span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pathlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【23】二叉搜索树的后序遍历序列</title>
      <link href="/2019/05/23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>二叉搜索树后序遍历为：左子树—-&gt;右子树—-&gt;根，且左子树值&lt;根值&lt;右子树值</p><blockquote><p>如二叉搜索树：</p><pre><code>           10        /       \    6              12 /    \           /   \3      7        11     20</code></pre><p>后序遍历结果为：3   7    6   11  20   12  10</p><p>对于一个数组sequence，最后一个元素是sequence[len-1] （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于sequence[len-1] ，后一段（右子树）大于sequence[len-1] ，且这两段（子树）都是合法的后序序列 </p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span>||sequence.length&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=sequence.length;  <span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">int</span> root=sequence[len-<span class="number">1</span>];  <span class="comment">//数组的最后一个数为根</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root&lt;=sequence[i])   <span class="comment">//左子树的数值都小于根</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的j即为划分出来的左子树部分和右子树部分的分界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=len-<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">       <span class="comment">//j到len-1都都为右子树，数值都大于root,如果root大于他们，则返回false</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root&gt;sequence[j])  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> leftflag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           leftflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,<span class="number">0</span>,i));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> rightflag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;len-<span class="number">1</span>) &#123;</span><br><span class="line">            rightflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,sequence.length-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftflag &amp;&amp; rightflag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【22】从上到下打印二叉树</title>
      <link href="/2019/05/22-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/22-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>使用两个队列一个存放节点treelist，一个存放值intlist。</p><blockquote><p>先将根节点root加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来,并将root值存入intlist,遍历结束条件是i值到达treelist.size-1</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//创建一个列表用来存储节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; treelist=<span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; intlist=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)  <span class="comment">//没有节点</span></span><br><span class="line">            <span class="keyword">return</span> intlist;</span><br><span class="line">        <span class="comment">//1.先存入根节点</span></span><br><span class="line">        treelist.add(root);</span><br><span class="line">        <span class="comment">//2.循环遍历列表，一开始列表里存了root</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;treelist.size();i++)</span><br><span class="line">        &#123; </span><br><span class="line">            TreeNode node=treelist.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.如果左子节点不为空，则将节点加入列表</span></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                treelist.add(node.left);</span><br><span class="line">            <span class="comment">//3、如果右子节点不为空，则将右子节点加入到列表中，这时列表的size加1</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                treelist.add(node.right);</span><br><span class="line"></span><br><span class="line">            intlist.add(node.val);</span><br><span class="line">            <span class="comment">//4、因为执行上面操作后会增加列表的si</span></span><br><span class="line">            <span class="comment">//因此可以继续循环下一个节点，直到循环完所有节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intlist;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【21】栈的压入、弹出</title>
      <link href="/2019/05/21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA/"/>
      <url>/2019/05/21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>依次入栈pushA数组中的数,直到pushA[i] =popA[index],此时将栈顶这个相等的值弹出。</p></li><li><p>判断栈中是否还有值，如果没有返回true,如果有并且index！=popA.length,依次弹出栈中数值，并与popA[index++]比较,两个不相等返回false,到栈为空时没执行false则返回true</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//用于pushA入栈</span></span><br><span class="line"></span><br><span class="line">           Stack&lt;Integer&gt; a = <span class="keyword">new</span> Stack();</span><br><span class="line">           <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">               a.push(pushA[i]);</span><br><span class="line">               <span class="comment">//当遇到与popA[index]相等的数时，弹出该数</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(pushA[i] == popA[index])&#123;</span><br><span class="line">                   <span class="keyword">if</span>(index++ == popA.length-<span class="number">1</span>)&#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   a.pop();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//栈中还有值，index还没到达popA尾部，依次弹出与popA比较</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (!a.isEmpty())&#123;</span><br><span class="line">               <span class="keyword">if</span>(a.pop()!=popA[index++])&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【20】包含min函数的栈</title>
      <link href="/2019/05/20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2019/05/20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>解题思路：利用辅助栈来存储现有栈的最小值。在入栈和出栈的时候将现有栈和最小值栈进行比较。<br>(1)入栈时，若新值比最小值栈的栈顶还小，则将该值同时push到最小值栈；  (2)出栈时，若现有栈的栈顶和最小值栈栈顶一致，则同时出栈，<br>(3)否则，仅仅现有栈pop；通过这一操作，最小值栈的栈顶将永远是现有栈元素中的最小值。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于存储所有的数据，压入push,弹出pop</span></span><br><span class="line">        Stack&lt;Integer&gt; data_stack =<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储栈最小的值</span></span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; min_stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果最小值栈为空或者栈顶值比新入的node值大</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(min_stack.isEmpty()||min_stack.peek()&gt;=node)&#123;</span><br><span class="line">                <span class="comment">//压入node，保持栈顶为栈的最小值</span></span><br><span class="line"></span><br><span class="line">                min_stack.push(node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则再次压入栈顶值</span></span><br><span class="line"></span><br><span class="line">                min_stack.push(min_stack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数据都压入data_stack</span></span><br><span class="line"></span><br><span class="line">            data_stack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出栈</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data_stack.empty()||min_stack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出数据</span></span><br><span class="line"></span><br><span class="line">            data_stack.pop();</span><br><span class="line">            <span class="comment">//弹出min栈顶，此时min_stack的栈顶为弹出某数剩下数的最小值</span></span><br><span class="line"></span><br><span class="line">            min_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看栈的栈顶元素</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!data_stack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> data_stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看最小的元素，即min_stack的栈顶</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!min_stack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>stack.peek:获取栈顶元素，返回栈顶元素但是不移除它</p><p>stack.add:向栈中添加元素，成功返回true</p><p>stack.push:向栈中添加元素，返回结果是当前添加的元素</p><p>stack.pop:移除并返回栈顶元素</p><p>stack.isEmpty:检查是否为空栈</p><p>stack.search(“value”):查看某元素再栈中的位置，计算从1开始</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【19】顺时针打印矩阵</title>
      <link href="/2019/04/19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/04/19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>打印分为四步：循环的次数即打印的圈速，即</p><p>  rows&gt;start*2&amp;&amp;column&gt;start*2</p><p>(1) 从左到右打印一行:</p><p>  开始于[start,start]，结束于[start,col-start-1]</p><p>(2) 从上到下打印一行,               </p><p>开始于[start+1,col-start-1],结束于[col-start-1,col-start-1]</p><p>(3) 从右到左打印一行</p><p> 开始于[col-start-1,col-start-2],结束于[col-start-1,start]</p><p>(4) 从下到上打印一行</p><p> 开始于[col-start-2,start],结束于[start+1,start]</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 矩阵行数     </span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;      </span><br><span class="line">        <span class="comment">// 矩阵列数    </span></span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;        </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();        </span><br><span class="line">      <span class="comment">// 让循环继续的条件是当前行数大于该圈循环开始的行数的两倍以及当前列数大于</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//该圈循环开始的列数的两倍（每圈循环开始的行数、列数相同）     </span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从(0,0)开始循环,圈数：start=0第一圈，start=1第二圈...以此类推    </span></span><br><span class="line">        <span class="keyword">while</span> (rows &gt; start * <span class="number">2</span> &amp;&amp; columns &gt; start * <span class="number">2</span>)&#123;         </span><br><span class="line">            <span class="comment">// 每一圈最后一行下标           </span></span><br><span class="line">            <span class="keyword">int</span> endRow = rows - <span class="number">1</span> - start;</span><br><span class="line">            <span class="comment">// 每一圈最后一列下标           </span></span><br><span class="line">            <span class="keyword">int</span> endColumn = columns - <span class="number">1</span> - start;           </span><br><span class="line">   <span class="comment">// 开始一圈圈打印，每打印一圈分为四步，从左到右、从上到下、从右到左、从下到上           </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左到右，第一步一定会走        </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endColumn; i++)            </span><br><span class="line">                list.add(matrix[start][i]);</span><br><span class="line">            <span class="comment">// 从上到下，最后一行大于开始行          </span></span><br><span class="line">            <span class="keyword">if</span> (endRow &gt; start)&#123;            </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endRow; i++)                   </span><br><span class="line">                    list.add(matrix[i][endColumn]);        </span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="comment">// 从右到左，最后一行大于开始行，最后一列大于开始列        </span></span><br><span class="line">            <span class="keyword">if</span> (endRow &gt; start &amp;&amp; endColumn &gt; start)&#123;            </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endColumn - <span class="number">1</span>; i &gt;= start; i--)                </span><br><span class="line">                    list.add(matrix[endRow][i]);           </span><br><span class="line">            &#125;          </span><br><span class="line">    <span class="comment">// 从下到上,至少是三行两列，也就是最后一行大于开始行加2，最后一列大于开始列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endRow &gt;= start + <span class="number">2</span> &amp;&amp; endColumn &gt; start)&#123;               </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endRow - <span class="number">1</span>; i &gt; start; i--)                </span><br><span class="line">                    list.add(matrix[i][start]);        </span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="comment">// 继续打印下一圈         </span></span><br><span class="line">            start++;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【18】二叉树的镜像</title>
      <link href="/2019/04/18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2019/04/18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像。<a id="more"></a></p><p>二叉树的镜像定义：</p><pre><code>        8     /      \   6         10 /   \     /    \5     7    9     11   </code></pre><p>镜像二叉树</p><pre><code>           8       /       \    10             6  /    \         /    \11      9       7       5</code></pre><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>(1)镜像即左右子树交换位置，故交换左子树右子树位置</p><p>(2)交换后的左右子树的节点保持原来的顺序，故要交换左右子树自己的左右子树</p><p>(3)终止条件为root==null || root.left==null ||root.right == null</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   int val = 0;</span></span><br><span class="line"><span class="comment">   TreeNode left = null;</span></span><br><span class="line"><span class="comment">   TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">   this.val = val;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(root!=<span class="keyword">null</span>&amp;&amp;(root.left!=<span class="keyword">null</span>||root.right!=<span class="keyword">null</span>))&#123;</span><br><span class="line">              <span class="comment">//这三句是左子树跟右子树交换</span></span><br><span class="line">              TreeNode tem=root.left;  </span><br><span class="line"></span><br><span class="line">              root.left=root.right;</span><br><span class="line">              root.right=tem;</span><br><span class="line">              <span class="comment">//然后将根节点换成root.left</span></span><br><span class="line"></span><br><span class="line">              Mirror(root.left);</span><br><span class="line">              <span class="comment">//然后将根节点换成root.right</span></span><br><span class="line"></span><br><span class="line">              Mirror(root.right);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【17】树的子结构</title>
      <link href="/2019/04/17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2019/04/17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>大体思路是首先判断B的根节点和A的根节点是否相同（这里的相同是指节点的值相同并且左右子节点相同），如果相同比较他们的左右子节点，这一步骤是相同的，可以用递归完成，直到B遍历到每个尾节点，如果这一过程比较的所有节点是相同的，则证明B是A的子结构。如果B的根节点和A的根节点不同，则A向他的左右子节点滑动，然后继续跟B的子节点比较，步骤同上。 </p><pre><code>(1) 如果root1.val==root2.val,那个就以这个为起点判断是否A包含B (2) 如果没找到，就以root1.left作为起点继续判断A是否包含B(3) 如果没找到，再以root1.right作为起点判断A是否包含B</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">          <span class="keyword">if</span> (root2 != <span class="keyword">null</span> &amp;&amp; root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//如果找到了对应Tree2的根节点的点</span></span><br><span class="line">              <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                  <span class="comment">//以这个根节点为为起点判断是否包含Tree2</span></span><br><span class="line">                  result = doesTree1HaveTree(root1,root2);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                  result = HasSubtree(root1.left,root2);</span><br><span class="line">              &#125;</span><br><span class="line">        <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                  result = HasSubtree(root1.right,root2);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//返回结果</span></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doesTree1HaveTree</span><span class="params">(TreeNode node1, TreeNode node2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;        <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">          <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">          <span class="keyword">if</span> (node1.val != node2.val) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">          <span class="keyword">return</span> doesTree1HaveTree(node1.left,node2.left) &amp;&amp;  </span><br><span class="line">                 doesTree1HaveTree(node1.right,node2.right);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【16】合并两个排序的链表</title>
      <link href="/2019/04/16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<a id="more"></a></p><p>例：</p><pre><code>链表1：  1  ----&gt;  3  ----&gt;  5  ----&gt; 8链表2：  2  ----&gt;  4 ----&gt;   6 ----&gt;  7</code></pre><p>合并结果：</p><pre><code>1 ----&gt; 2 ----&gt; 3 ----&gt; 4 ----&gt; 5 ----&gt; 6 ----&gt; 7  ----&gt; 8</code></pre></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>判断有没有ListNode是空的，如果有则返回另一个</p></li><li><p>递归实现，如果List1.val&lt;list2.val,pMergeHead = list1,否则pMergeHead = list2，递归直到两个ListNode都为空</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pMergeHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">            pMergeHead = list1;</span><br><span class="line">            pMergeHead.next = Merge(list1.next,list2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pMergeHead = list2;</span><br><span class="line">            pMergeHead.next = Merge(list1,list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pMergeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【15】反转链表</title>
      <link href="/2019/04/15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>用一个栈stack依次存储ListNode里面的值，因为stack的特点是先进后出，故依次弹出即为反转链表</p></li><li><p>用一个链表temp依次存储弹出的值，依次next存入下一个链表值，链表res指向这个temp的头节点</p></li><li><p>反转链表的结果为res.next,因为我们之前设temp的头节点为-1（自己设的）。</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* public static class ListNode &#123;</span></span><br><span class="line"><span class="comment">        int val;</span></span><br><span class="line"><span class="comment">        ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">            this.val = val;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode temp = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            ListNode res = temp;</span><br><span class="line">            <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp.next  = <span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【14】链表中倒数第K个结点</title>
      <link href="/2019/04/14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/04/14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>先用一个count计算出链表的长度，如果count&lt;k，返回null</p></li><li><p>链表的倒数第K个即为链表的正数（count-k+1）个,一个for循环，将指针轮询到那个点，然后再将起后面截断（head.next = null）即可。</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            ListNode root = head;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">                root = root.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//倒数第K个即正数第（count-k+1）个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;(count-k+<span class="number">1</span>);i++)&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【13】调整数值顺序使奇数位于偶数前面</title>
      <link href="/2019/04/13-%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
      <url>/2019/04/13-%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>依次遍历array数组，遇到奇数存到原来的array数组前面，遇到偶数放到res数组，然后将两个数组拼接即可。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> []res = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count2  = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                <span class="comment">//如果是奇数，则放在数组前面</span></span><br><span class="line">                <span class="keyword">if</span>(array[i]%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                    array[count++] = array[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//偶数放在另一个数组里</span></span><br><span class="line">                    res[count2++] = array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = count;i&lt;array.length;i++)&#123;</span><br><span class="line">                array[i] = res[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【12】数值的整数次方</title>
      <link href="/2019/04/12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
      <url>/2019/04/12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>（1）exponent &gt; 0,如2^3,则可以直接运算得出结果</p></li><li><p>（2）exponent &lt; 0,如2^-3,则结果为（1/2）^3</p></li><li><p>（3）exponent = 0,如2^0,则结果为1</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> powCal(<span class="number">1.0</span>/base,-<span class="number">1</span>*exponent);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> powCal(base,exponent);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//计算base的exponent次方</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">powCal</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;exponent;i++)&#123;</span><br><span class="line">               res  = res*base;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【11】二进制中1的个数</title>
      <link href="/2019/04/11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/04/11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>方法1：直接将其转成二进制数组</p></li><li><p>方法2：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> []a=Integer.toBinaryString(n).toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                 count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【10】矩形覆盖</title>
      <link href="/2019/04/10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
      <url>/2019/04/10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><a id="more"></a></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>类似于青蛙跳台阶</p><ul><li><p>当 n = 1时，只有一种横向排列的方式</p></li><li><p>当 n = 2时，有两种选择，横向或者竖向</p></li><li><p>当 n = 3时，如果选择竖向，则还剩下2*2的排列，如果选择横向，只有一种选择方案(剩下的一个横向一个竖向)</p></li><li><p>递推可得F(2 * n) = F(2 * (n-1))+F(2 * (n-2) ) , n&gt;=3</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(inttarget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            return0;</span><br><span class="line">        &#125;</span><br><span class="line">         elseif(target ==<span class="number">1</span>|| target == <span class="number">2</span>)&#123;</span><br><span class="line">             returntarget;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span>(RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【9】变态跳台阶</title>
      <link href="/2019/04/9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/04/9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f(0) = 0</span></span><br><span class="line"><span class="comment">//f(1) = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。</span></span><br><span class="line"><span class="comment">//f(3) = f(3-1) + f(3-2) + f(3-3) ...</span></span><br><span class="line"><span class="comment">//f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)</span></span><br><span class="line"><span class="comment">/*说明：</span></span><br><span class="line"><span class="comment">1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。</span></span><br><span class="line"><span class="comment">2）n = 1时，只有1种跳法，f(1) = 1</span></span><br><span class="line"><span class="comment">3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)</span></span><br><span class="line"><span class="comment">4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)</span></span><br><span class="line"><span class="comment">5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1)</span></span><br><span class="line"><span class="comment">6) 由以上已经是一种结论，但是为了简单，我们可以继续简化：</span></span><br><span class="line"><span class="comment">    f(n-1) =f(0)+f(1)+f(2)+f(3)+...+f((n-1)-1)        </span></span><br><span class="line"><span class="comment">           =f(0)+f(1)+f(2)+f(3)+...+f(n-2) </span></span><br><span class="line"><span class="comment">      f(n) =f(0)+f(1)+f(2)+f(3)+...+f(n-2)+f(n-1)=f(n-1)+f(n-1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以得出：f(n) = 2*f(n-1)*/</span></span><br></pre></td></tr></table></figure><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【8】跳台阶</title>
      <link href="/2019/04/8-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/04/8-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>把n级台阶的跳的次数看成是n的函数,即为f(n),当n&gt;2时,第一次跳有两种跳法,</p><p>第一次跳1级,则该次跳法数目为后面剩下的n-1级台阶的跳法数目f(n-1)。</p><p>第一次跳2级,则该次跳法数目为后面剩下的n-2级台阶的跳法数目f(n-2)。</p><p>所以f(n)=f(n-1)+f(n-2),即相当于斐波那契数列。`</p></li></ol><p>即该题跟斐波那契数列是相似的，青蛙跳台阶的公式为</p><pre><code>F(n) = F(n-1)+F(n-2),n&gt;=3</code></pre><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> one_=<span class="number">1</span>; <span class="comment">//第一次跳台阶的方法数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> two_=<span class="number">2</span>; <span class="comment">//第二次跳台阶的方法数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> finN=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=target;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            finN=one_+two_;</span><br><span class="line">            one_=two_;</span><br><span class="line">            two_=finN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【7】斐波那契数组</title>
      <link href="/2019/04/7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E7%BB%84/"/>
      <url>/2019/04/7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p><ul><li><p>斐波那契数列：1     1     2     3     5     8     13     21     34  ….</p><a id="more"></a></li></ul><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>斐波那契数列：从第三项开始，每一项都等于前两项之和。通项公式为</p><pre><code>F(n) = F(n-1)+F(n-2),n&gt;=3</code></pre></li></ul><p>方法1：通过递归实现，但是时间复杂度和空间复杂度都会很大</p><p>方法2：依次F(n-1)和F(n-2)值，求F(n)就很简单啦</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> (Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>));   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> one_ = <span class="number">1</span>;  <span class="comment">//用于存储f(n-2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> two_ =<span class="number">1</span>;   <span class="comment">//用于存储f(n-1)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">             fin = one_+two_;</span><br><span class="line">             <span class="comment">//向前递推</span></span><br><span class="line"></span><br><span class="line">             one_ = two_;   <span class="comment">//下一次的f(n-2)为 上一次结果的f(n-1)</span></span><br><span class="line"></span><br><span class="line">             two_ = fin;    <span class="comment">//下一次的f(n-1)为 上一次结果的fin </span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【6】旋转数组的最小数字</title>
      <link href="/2019/04/6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2019/04/6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>方法1：重头到尾遍历，找到数组的最小值，时间复杂度为O(N)</p></blockquote><blockquote><p>方法2：二分遍历查找</p></blockquote><ul><li><p>mid = low +(high-low)/2;</p></li><li><p>需要考虑三种情况：</p><ul><li><p>arr[mid] &gt; arr[high],如[3,4,5,1,2]说明最小数字在mid的右边，缩小范围，low = mid+1;</p></li><li><p>arr[mid]&lt;arr[high],如[1,2,3,4,5]说明最小数字在mid的左边，high = mid-1;</p></li><li><p>arr[mid] = arr[high],如[0,1,1,1,1]或者[1,1,1,0,1],一步步缩小范围，high = high-1;</p></li></ul></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; arr[high])&#123;</span><br><span class="line"></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] == arr[high])&#123;</span><br><span class="line"></span><br><span class="line">                high = high - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[low];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【5】两个栈实现队列</title>
      <link href="/2019/04/5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2019/04/5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h4><ul><li style="list-style: none"><input type="checkbox"> 栈的规则是先进后出，队列的规则是先进先出</li></ul><ol><li><p>stack1一直维持着栈底–栈顶是队列的入队顺序</p></li><li><p>stack2一直维持着栈顶–栈尾为队列的入队顺序</p></li><li><p>当执行队列的入队（push）时，如果stack2为空，则直接插入到stack1,stack1从栈底到栈顶的顺序为入队顺序，如果stack2不为空，则将stack2的元素倒入（栈顶—栈尾）stack1,然后再插入数据</p></li></ol><p>4- 当执行队列的出队(pop)操作时，应该出的是stack1的栈底元素，故将stack1依次倒入stack2,这时stack2的栈顶就是要出队的数值，此时stack1为空，stack2从（栈顶–栈尾）为入队顺序</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//队列的入队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将stack2倒入stack1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将元素插入stack1</span></span><br><span class="line"></span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列的出队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将stack1倒入stack2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stack2的栈顶就是出队数值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【4】重建二叉树</title>
      <link href="/2019/04/4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/04/4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>先序遍历为：根-&gt;左子树-&gt;右子树，中序遍历为左子树-&gt;根-&gt;右子树</p></li><li><p>先找到根结点，为先序遍历的第一个数值</p></li><li><p>根据这个数值，可以划分中序中的左子树和右子树范围</p></li><li><p>递归构建左子树和右子树</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//** * Definition for binary tree </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> val; </span><br><span class="line"></span><br><span class="line">     TreeNode left; </span><br><span class="line"></span><br><span class="line">     TreeNode right; </span><br><span class="line"></span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span> || in.length==<span class="number">0</span>)               </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;           </span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);    <span class="comment">//根结点       </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre.length;i++)&#123;      </span><br><span class="line">        <span class="comment">//找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点         </span></span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == in[i])&#123;    </span><br><span class="line">        <span class="comment">//递归构建左子树，此时前序的范围缩小为[1,i+1),中序缩小为[0,i)              </span></span><br><span class="line"></span><br><span class="line">             node.left =reConstructBinaryTree(Arrays.copyOfRange</span><br><span class="line">                         (pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">        <span class="comment">//递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len)                   </span></span><br><span class="line"></span><br><span class="line">             node.right = reConstructBinaryTree(Arrays.copyOfRange</span><br><span class="line">        (pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));                   </span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;               </span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;           </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【3】从尾到头打印链表</title>
      <link href="/2019/04/3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>先用一个栈stack存储从头到尾的链表数值</p></li><li><p>再依次弹出，因为栈是先进后出的，故弹出的结果为从尾到头</p></li><li><p>将弹出的结果放入list返回</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(listNode.val);</span><br><span class="line">                listNode = listNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                list.add(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-15:三数之和</title>
      <link href="/2019/04/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/04/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述："><a href="#1-题目描述：" class="headerlink" title="1.题目描述："></a>1.题目描述：</h3><h5 id="给定一个包含-n-个整数的数组-nums，判断-nums-中是否存在三个元素-a，b，c-，使得-a-b-c-0-？找出所有满足条件且不重复的三元组。"><a href="#给定一个包含-n-个整数的数组-nums，判断-nums-中是否存在三个元素-a，b，c-，使得-a-b-c-0-？找出所有满足条件且不重复的三元组。" class="headerlink" title="给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。"></a>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。<a id="more"></a></h5><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><blockquote><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p></blockquote><blockquote><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><ul><li>首先按升序排序；然后定义下标变量i,j,k，因为是三元组，所以要三个变量如果简单的遍历，那么跟是否有序没有关系，其时间复杂度将达到O(n^3)。仔细想想：如果当前选择了a、b、c三个数，如果其和小于目标target，那么需要将其中一个数用更大的数替换；反之亦然。但究竟替换三个数中的哪个数？无法确定就只能先固定两个变量，让其第三个变化（替换）。一种办法是：固定前两个数i,j，然后让k在一个范围中二分变化（二分查找思想）</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;Integer&gt; targets = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 用于去重</span></span><br><span class="line">        <span class="keyword">if</span>((nums.length&gt;<span class="number">0</span> &amp;&amp; nums.length&lt;<span class="number">3</span>) ||(nums.length&gt;<span class="number">0</span> &amp;&amp;nums[<span class="number">0</span>]&gt;<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=nums.length-<span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (!targets.contains(target)) &#123; <span class="comment">//用于去重</span></span><br><span class="line">                targets.add(target);</span><br><span class="line">                <span class="keyword">int</span> k = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[k] + nums[j] == target) &#123;</span><br><span class="line">                        List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                        li.add(nums[i]);</span><br><span class="line">                        li.add(nums[k]);</span><br><span class="line">                        li.add(nums[j]);</span><br><span class="line">                        list.add(li);</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; j &amp;&amp; nums[k] == nums[k + <span class="number">1</span>])</span><br><span class="line">                            ++k;</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                            --j;</span><br><span class="line">                        k++;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] + nums[j] &lt; target) &#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-我的提交记录"><a href="#4-我的提交记录" class="headerlink" title="4.我的提交记录"></a>4.我的提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/15.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【2】空格替换</title>
      <link href="/2019/04/2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2/"/>
      <url>/2019/04/2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><a id="more"></a></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h4><ul><li><p>方法1：利用函数replaceAll完成</p></li><li><p>方法2：</p><pre><code>**先计算需要多少的空间**从后向前依次插入</code></pre></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> str.toString().replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> spacenum = <span class="number">0</span>;<span class="comment">//spacenum为计算空格数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</span><br><span class="line">                spacenum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//indexold为为替换前的str下标</span></span><br><span class="line">        <span class="keyword">int</span> indexold = str.length()-<span class="number">1</span>; </span><br><span class="line">        <span class="comment">//计算空格转换成%20之后的str长度</span></span><br><span class="line">        <span class="keyword">int</span> newlength = str.length() + spacenum*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//indexold为为把空格替换为%20后的str下标</span></span><br><span class="line">        <span class="keyword">int</span> indexnew = newlength-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//使str的长度扩大到转换成%20之后的长度,防止下标越界</span></span><br><span class="line">        str.setLength(newlength);</span><br><span class="line">        <span class="keyword">for</span>(;indexold&gt;=<span class="number">0</span> &amp;&amp; indexold&lt;newlength;--indexold)&#123; </span><br><span class="line">                <span class="keyword">if</span>(str.charAt(indexold) == <span class="string">' '</span>)&#123;  </span><br><span class="line"></span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'%'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    str.setCharAt(indexnew--, str.charAt(indexold));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充1：String和StringBuffer的转换"><a href="#补充1：String和StringBuffer的转换" class="headerlink" title="补充1：String和StringBuffer的转换"></a>补充1：String和StringBuffer的转换</h4><p>String转换成StringBuffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">StringBuffer b=<span class="keyword">new</span> StringBuffer(str);</span><br></pre></td></tr></table></figure><p>StringBuffer转换成String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer a=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">String b=a.toString(）</span><br></pre></td></tr></table></figure><h4 id="补充2：String、StringBuffer、StringBuilder"><a href="#补充2：String、StringBuffer、StringBuilder" class="headerlink" title="补充2：String、StringBuffer、StringBuilder"></a>补充2：String、StringBuffer、StringBuilder</h4><blockquote><p>1）运行速度StringBuilder&gt;StringBuffer&gt;String</p></blockquote><blockquote><p>2）String是字符串常量，String对象一旦创建就不能更改。StringBuffer为 字符串变量，可更改</p></blockquote><blockquote><p>3） String适用于少量的字符串操作，StringBuffer适用于多线程下字符缓冲区进行大量操作的情况。 </p><p>4） StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，</p></blockquote><blockquote><p>5） 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。</p><p>6） 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而StringBuffer则每次都需要判断锁，效率相对更低。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【1】二维数组的查找</title>
      <link href="/2019/04/1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/04/1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述："><a href="#1-题目描述：" class="headerlink" title="1.题目描述："></a>1.题目描述：</h3><blockquote><p> 在一个二维数组中（每个一维数组的长度相同），如数组</p><p>1       2       3</p><p>4       5       6 </p><p>7       8       9</p><p>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<a id="more"></a></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><ol><li><p>选择右上角的数字作为开始点</p></li><li><p>如果array[row][col]&gt;target,则向左查找，col–；</p></li><li><p>如果array[row][col]&lt;target,则向下查找，row++；</p></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;=array.length-<span class="number">1</span>&amp;&amp;col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[row][col]&gt;target)&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[row][col]&lt;target)&#123;</span><br><span class="line">                  row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据的持久化</title>
      <link href="/2019/03/redis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2019/03/redis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h5 id="1-RDB-持久化"><a href="#1-RDB-持久化" class="headerlink" title="1.RDB 持久化"></a>1.RDB 持久化</h5><p>RDB是redis默认的持久化机制。RDB相当于快照，保存的是一种状态。默认文件名是dump.rdb。</p><blockquote><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p></blockquote><h5 id="2-AOF-持久化"><a href="#2-AOF-持久化" class="headerlink" title="2.AOF 持久化"></a>2.AOF 持久化</h5><p>由于快照方式是在一定时间间隔内做一次，所以如果redis意外down掉，就会丢失最后一次快照所有的修改，如果应用要求不能丢失任何修改的话，可以采用AOF。</p><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table><thead><tr><th>选项</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个写命令都同步</td></tr><tr><td>everysec</td><td>每秒同步一次</td></tr><tr><td>no</td><td>让操作系统来决定何时同步</td></tr></tbody></table><p>always 选项会严重减低服务器的性能；</p><p>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</p><p>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</p><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis.数据的淘汰机制</title>
      <link href="/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis 具体有 6 种淘汰策略：</p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td>allkeys-lru</td><td>从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据集中任意选择数据进行淘汰</td></tr><tr><td>noeviction</td><td>禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis与memcached</title>
      <link href="/2019/03/redis%E4%B8%8Ememcached/"/>
      <url>/2019/03/redis%E4%B8%8Ememcached/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Memcached介绍"><a href="#Memcached介绍" class="headerlink" title="Memcached介绍"></a>Memcached介绍</h3><p>Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。<a id="more"></a></p><p>memcached作为高速运行的分布式缓存服务器，具有以下的特点。</p><ul><li>协议简单</li><li>基于libevent的事件处理</li><li>内置内存存储方式</li><li>memcached不互相通信的分布式</li></ul><p>与数据库协同合作的过程：</p><blockquote><p>   1.检查用户请求的数据是缓存中是否有存在，如果有存在的话，只需要直接把请求的数据返回，无需查询数据库. </p><p>2.如果请求的数据在缓存中找不到，这时候再去查询数据库。返回请求数据的同时，把数据存储到缓存中一份。<br>   3.保持缓存的“新鲜性”，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据.</p></blockquote><h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。</p><p>区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。</p><p>Redis作为一个高性能的key-value数据库具有以下特征：  </p><ul><li>多样的数据模型</li><li>持久化</li><li>基于内存存储方式</li><li>主从同步</li></ul><p><strong>综合结论</strong></p><p>应该说Memcached和Redis都能很好的满足解决我们的问题，它们性能都很高，总的来说，可以把Redis理解为是对Memcached的拓展，是更加重量级的实现，提供了更多更强大的功能。</p><p>两者都是非关系型内存键值数据库，主要有以下不同：</p><h3 id="Memcached与redis区别"><a href="#Memcached与redis区别" class="headerlink" title="Memcached与redis区别"></a>Memcached与redis区别</h3><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h4><blockquote><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p></blockquote><h5 id="2-数据持久化"><a href="#2-数据持久化" class="headerlink" title="2.数据持久化"></a>2.数据持久化</h5><blockquote><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p></blockquote><h5 id="3-分布式"><a href="#3-分布式" class="headerlink" title="3.分布式"></a>3.分布式</h5><blockquote><p>Memcached 不支持分布式，只能通过在<strong>客户端</strong>使用<strong>一致性哈希</strong>来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis则在<strong>服务器端</strong>构建分布式存储。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，各个节点地位一致，具有线性可伸缩的功能。其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个 key的数值域分成16384个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是16384。</p></blockquote><h5 id="4-内存管理机制"><a href="#4-内存管理机制" class="headerlink" title="4.内存管理机制"></a>4.内存管理机制</h5><blockquote><p>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，这样能保证数据的持久性。而 Memcached 的数据则会一直在内存中(断电会挂掉，数据不能超过内存)。</p></blockquote><h5 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h5><blockquote><p>Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息)</p><p>Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据类型</title>
      <link href="/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型<a id="more"></a></h3><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作</td></tr><tr><td>对整数和浮点数执行自增或者自减操作</td><td></td><td></td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素</td></tr><tr><td>对单个或者多个元素</td><td></td><td></td></tr><tr><td>进行修剪，只保留一个范围内的元素</td><td></td><td></td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素</td></tr><tr><td>检查一个元素是否存在于集合中</td><td></td><td></td></tr><tr><td>计算交集、并集、差集</td><td></td><td></td></tr><tr><td>从集合里面随机获取元素</td><td></td><td></td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对</td></tr><tr><td>获取所有键值对</td><td></td><td></td></tr><tr><td>检查某个键是否存在</td><td></td><td></td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素</td></tr><tr><td>根据分值范围或者成员来获取元素</td><td></td><td></td></tr><tr><td>计算一个键的排名</td><td></td><td>What Redis data structures look like</td></tr></tbody></table><h3 id="1-1Redis的键Key"><a href="#1-1Redis的键Key" class="headerlink" title="1.1Redis的键Key"></a>1.1Redis的键Key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; DEL key            删除键</span><br><span class="line">&gt; EXISTS key         判断key是否存在</span><br><span class="line">&gt; DUMP key           序列化key</span><br><span class="line">&gt; EXPIRE key seconds 给key设置过期时间</span><br><span class="line">&gt; TTL key            key的生存剩余时间（秒为单位）</span><br><span class="line">&gt; PTTL key           key的生存剩余时间(毫秒单位)</span><br><span class="line">&gt; PERSIST key        移除key的过期时间，将持久保留</span><br><span class="line">&gt; KEYS pattern       查找所有符合给定模式的key(* 所有 ？一个字符)</span><br><span class="line">&gt; RANDOM key         从当前数据库随机返回一个key</span><br><span class="line">&gt; RENAME key newkey  修改key名称</span><br><span class="line">&gt; MOVE key db        当前数据库移动到给定数据库中</span><br></pre></td></tr></table></figure><h5 id="key的应用场景"><a href="#key的应用场景" class="headerlink" title="key的应用场景"></a>key的应用场景</h5><blockquote><p>(1)限时的活动信息</p><p>(2)网站的数据缓存(对于一些要定时更新的数据如积分排行榜)</p><p>(3)手机验证码</p><p>(4)限制网站的访问频率</p></blockquote><h3 id="1-2-Redis的值value"><a href="#1-2-Redis的值value" class="headerlink" title="1.2 Redis的值value"></a>1.2 Redis的值value</h3><h3 id="1-2-1-String类型"><a href="#1-2-1-String类型" class="headerlink" title="1.2.1 String类型"></a>1.2.1 String类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET key_name value       设置给定key的值(key存在则覆盖，不存在则新建)</span><br><span class="line">&gt; SETNX key_name value     设置给定key的值(key不存在时)</span><br><span class="line">&gt; GET key_name             取值</span><br><span class="line">&gt; GETRANGE key start end   字符串截取</span><br><span class="line">&gt; GETBIT key offset        对key所存储的字符串值，获取指定偏移量上的位</span><br><span class="line">&gt; MGET key1 [key2..]       获取一个或多个key的值</span><br><span class="line">&gt; GETSET key_name value    设置key值，并返回key的旧值</span><br><span class="line">&gt; STRLEN key               获取长度</span><br><span class="line">&gt; DEL key_name             删除</span><br><span class="line">&gt; INCR key_name            自增</span><br><span class="line">&gt; DECR key_name            自减 </span><br><span class="line">&gt; APPEND key_name value    字符串拼接</span><br></pre></td></tr></table></figure><h5 id="string应用场景"><a href="#string应用场景" class="headerlink" title="string应用场景"></a>string应用场景</h5><blockquote><p>1.String通常用于<strong>保存单个字符串或JSON字符串数据</strong></p><p>2.因string是二进制安全的，所以你完全可以把一个<strong>图片文件</strong>的内容作为字符串来<strong>存储</strong></p><p>3.<strong>计数器</strong>(常规key-value缓存应用。(常规计数:微博数,粉丝数)</p><p>INCR等指令本身就具有<strong>原子操作</strong>的特性,所以我们完全可以利用redis的INCR.INCRBY.DECR，DECRBY等指令来实现原子计数的效果。不少网站都利用redis的这个特性来<strong>实现业务上的统计计数需求</strong>。</p></blockquote><h3 id="1-2-2-List类型"><a href="#1-2-2-List类型" class="headerlink" title="1.2.2 List类型"></a>1.2.2 List类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; LPUSH key value1[value2]  将一个或多个值插入列表头部</span><br><span class="line">&gt; RPUSH key value1[value2]  将一个或多个值插入列表尾部</span><br><span class="line">&gt; LPUSHX key value          将一个或多个值插入列表头部，列表不存在则操作无效             </span><br><span class="line">&gt; RPUSHX key value          将一个或多个值插入列表尾部，列表不存在则操作无效</span><br><span class="line">&gt; LLEN key                  获取列表长度</span><br><span class="line">&gt; LINDEX key index          通过索引获取列表元素</span><br><span class="line">&gt; LRANGE key start stop     获取列表指定范围内的元素</span><br><span class="line">&gt; LPOP key                  左移除</span><br><span class="line">&gt; RPOP key                  右移除</span><br><span class="line">&gt; BLPOP key1[key2] timeout  移除并获取列表的第一个元素，没有元素就会阻塞队列    </span><br><span class="line">                            直到等待超时或发现可弹出元素</span><br></pre></td></tr></table></figure><h5 id="list应用场景"><a href="#list应用场景" class="headerlink" title="list应用场景"></a>list应用场景</h5><blockquote><p>1、<strong>对数据量大的集合数据删减 </strong></p><p>列表数据显示<strong>关注列表、粉丝列表、留言评价等. .分页、热点新闻(Top5)等</strong> 利用LRANGE还可以很方便的实现分页的功能,在博客系统中，每片博文的评论也可以用到。</p><p>2、<strong>任务队列 </strong></p><p>(list通常用来实现一个消息队列,而且可以确保先后顺序,不必像MySQL那样还需要通过ORDERBY来进行排序)</p><p>任务队列介绍(生产者和消费者模式):</p><p>在处理Web客户端发送的命令请求时,某些操作的执行时间可能会比我们预期的更长一些，通过将待执行任务的相关信息放入队列里面，并在之后对队列进行处理,用户可以推迟执行那些需要一段时间才能能完成的操作,这种将工作交给任务处理器来执行的做法被称为任务队列(task queue)。</p><p><strong>RPOPLPUSH source destination </strong></p><p>移除列表的最后一个元素，并将该元素添加到另一个列表并返回示例描述:</p><p>常用案例:订单系统的下单流程、用户系统登录注册短信等</p></blockquote><h3 id="1-2-3-Hash类型"><a href="#1-2-3-Hash类型" class="headerlink" title="1.2.3 Hash类型"></a>1.2.3 Hash类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; HSET key field value                 为指定的key,设定field/value</span><br><span class="line">&gt; HMSET key field value[field1,value]  同时将多个field-value 设到key中</span><br><span class="line">&gt; HGET key field                       根据field等待value </span><br><span class="line">&gt; HMGET key field[field1]              获取key所有给定字段的值</span><br><span class="line">&gt; HGETALL key                          返回hash表所有字段和值</span><br><span class="line">&gt; HKEYS key                            获取哈希表中的字段</span><br><span class="line">&gt; HLEN key                             获取哈希表中字段的数量</span><br><span class="line">&gt; HDEL key field[field2]               删除一个或多个hash表字段</span><br><span class="line">&gt; HSETNX key field value               只有在字段不存在时，设置字段值</span><br><span class="line">&gt; HINCRBY key field increment          key中指定字段的整数值加增量</span><br><span class="line">&gt; HINCRBYFLOAT key field increment     指定字段的浮点数加增量</span><br><span class="line">&gt; HEXISTS key field                    指定字段是否存在</span><br></pre></td></tr></table></figure><h5 id="hash应用场景"><a href="#hash应用场景" class="headerlink" title="hash应用场景"></a>hash应用场景</h5><blockquote><p>Hash的应用场景:(存储个用户信息对象数据)</p><p>1、 <strong>常用于存储一个对象 </strong></p><p>2、 <strong>为什么不用string存储一个对象? </strong></p><p>hash是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。</p><p>用户ID为查找的key,存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式:</p><p><code>(1)用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时, 需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</code></p><p><code>(2)这个用户信息对象有多少成员就存成多少个key-value对,用用户ID+对应属性的名称作为唯一标识来取得对应属性的值,虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是不可观的。</code></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><p>Redis提供的Hash很好的解决了这个问题，Redis 的Hash实际是内部存储的Value为一个Hashmap,并提供了直接存取这个Map成员的接口</p></blockquote><h3 id="1-2-4-Set类型"><a href="#1-2-4-Set类型" class="headerlink" title="1.2.4 Set类型"></a>1.2.4 Set类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">赋值语句</span><br><span class="line">&gt; SADD key member1[member2]        添加一个或多个成员</span><br><span class="line">取值语句</span><br><span class="line">&gt; SCARD key                           获取成员数</span><br><span class="line">&gt; SMEMBERS key                        返回集合中的所有成员</span><br><span class="line">&gt; SISMEMBER key member                判断是否存在</span><br><span class="line">&gt; SRANDMEMBER key [count]             返回集合中一个或多个随机数</span><br><span class="line">删除语句</span><br><span class="line">&gt; SREM key member                     移除一个或多个</span><br><span class="line">&gt; SPOP key[count]                     移除并返回集合中的一个随机元素</span><br><span class="line">&gt; SMOVE source destination member     将member从source移到destination</span><br><span class="line">差集语句</span><br><span class="line">&gt; SDIFF key1[key2]                    返回给定集合的差集(左侧)</span><br><span class="line">&gt; SDIFFSTORE destination key1[key2]   返回差集并存到destina.</span><br><span class="line">交集语句</span><br><span class="line">&gt; SINTER key1 [key2]                  返回给定集合的交集</span><br><span class="line">&gt; SINTERSTORE destination key1[key2]  返回交集并存到destination</span><br><span class="line">并集</span><br><span class="line">&gt; SUNION key1[key2]                    返回并集</span><br><span class="line">&gt; SUNIONSTORE destination key1[key2]  返回并集并存储在destination</span><br></pre></td></tr></table></figure><h5 id="set应用场景"><a href="#set应用场景" class="headerlink" title="set应用场景"></a>set应用场景</h5><blockquote><p>常应用于:对两个集合间的数据[计算]进行交集、并集、差集运算</p><p><code>1、以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作,你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。</code></p><p><code>2、利用唯一性，可以统计访问网站的所有独立IP</code></p></blockquote><h3 id="1-2-5-Zset类型"><a href="#1-2-5-Zset类型" class="headerlink" title="1.2.5 Zset类型"></a>1.2.5 Zset类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">赋值语句</span><br><span class="line">&gt; ZADD key score1 member1[score member2]  添加一个或多个成员</span><br><span class="line">取值语句</span><br><span class="line">&gt; ZCARD key                               获取成员数</span><br><span class="line">&gt; ZCOUNT key min max                      计算集合中指定区间分数的成员数</span><br><span class="line">&gt; ZRANK key member                        返回有序集合中指定成员索引</span><br><span class="line">&gt; ZRANGE key start stop[WITHSCORES]       返回指定区间内成员[低到高]</span><br><span class="line">&gt; ZREVRANGE key start stop[WITHSCORES]    返回指定区间内成员[高到低]</span><br><span class="line">删除语句</span><br><span class="line">&gt; ZREM key member[member...]              移除有序集合中的一个或多个成员</span><br></pre></td></tr></table></figure><h5 id="Zset应用场景"><a href="#Zset应用场景" class="headerlink" title="Zset应用场景"></a>Zset应用场景</h5><blockquote><p>常应用于:<code>排行榜</code></p><p>1)比如twitter的public timeline可以以发表时间作为score来存储,这样获取时就是自动按时间排好序的。</p><p>2)比如一个存储全班同学成绩的Sorted Set, 其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。</p><p>3还可以用Sorted Set来做带权重的队列，比如普通消息的score为1,重要消息的score为2,然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis应用场景</title>
      <link href="/2019/03/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/03/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.概述</p><blockquote><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。<a id="more"></a></p></blockquote><blockquote><p><strong>键(key)</strong>的类型只能为<strong>字符串(String)</strong>，<strong>值(value)</strong>支持五种数据类型：<strong>字符串(String)、列表(list)、集合(set)、有序集合(zset)、哈希(hash)。</strong></p></blockquote><blockquote><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p></blockquote><h5 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h5><blockquote><p>（1）<strong>缓存</strong>：Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；</p><p>（2）<strong>排行榜</strong>：利用Redis的SortSet数据结构能够非常方便搞定；</p><p>（3）<strong>计算器/限速器</strong>：利用Redis中<strong>原子性的自增操作</strong>，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有<strong>抢购</strong>时，防止用户疯狂点击带来不必要的压力；</p><p>注：限速器也是对请求限流的一种实现方式。</p><p>（4）<strong>好友关系</strong>：利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；</p><p>（5）<strong>简单消息队列</strong>：除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；不过最好用kafka、RabbitMQ等消息中间件。</p><p>（6）<strong>Session共享</strong>：默认Session是保存在服务器的文件中，即当前服务器，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。</p></blockquote><h5 id="Redis优点："><a href="#Redis优点：" class="headerlink" title="Redis优点："></a>Redis优点：</h5><blockquote><ul><li>速度快，完全基于内存；</li><li>使用C语言实现，网络层使用epoll解决高并发问题；</li><li>单线程模型避免了不必要的上下文切换及竞争条件；</li></ul></blockquote><h5 id="Redis的缺点："><a href="#Redis的缺点：" class="headerlink" title="Redis的缺点："></a>Redis的缺点：</h5><blockquote><p>滥用可能导致系统的不稳定、成本增高等问题。</p><p>比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。</p><p>简单总结就是<strong>数据量太大、数据访问频率非常低的业务都不适合使用Redis</strong>。数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。如果不担心浪费资源，那请忽略。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_垃圾收集器</title>
      <link href="/2019/03/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2019/03/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>垃圾收集器一共有7种，如果说收集算法是内存回收的方法，那个垃圾收集器就是垃圾回收的具体实现。</p><p><img src="https://github.com/qiulig/IMG/raw/master/垃圾收集器.png" alt="垃圾收集器"></p><p><code>以中间绿线为界，上边三个用于年轻代，下边三个用在年老代，而G1则老少通吃，**黑线**线表示两个回收器可搭配使用，**红线**则表示两者可以在同一区域交替使用。由于G1在JDK1.7才达到商用级别，而且目前线上环境也很少使用。</code></p><table><thead><tr><th>名称</th><th></th><th>区域</th><th>算法</th><th>适用情况</th></tr></thead><tbody><tr><td>Serial</td><td>串行</td><td>年轻代</td><td>复制</td><td>单CPU（或CPU较少）、小型客户端应用</td></tr><tr><td>Parallel Scavenge</td><td>并行</td><td>年轻代</td><td>复制</td><td>多CPU、吞吐量优先（后台处理、科学计算）</td></tr><tr><td>ParNew</td><td>并行</td><td>年轻代</td><td>复制</td><td>多CPU、响应优先（web服务器等）</td></tr><tr><td>CMS</td><td>并发</td><td>年老代</td><td>标记-清除</td><td>响应优先（web服务器等）</td></tr><tr><td>Serial Old</td><td>串行</td><td>年老代</td><td>标记-整理</td><td>单CPU、小型客户端应用</td></tr><tr><td>Parallel Old</td><td>并行</td><td>年老代</td><td>标记-整理</td><td>多CPU、吞吐量优先（后台处理、科学计算）</td></tr></tbody></table><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h3><blockquote><p>从名字就能看出是串行的意思，该回收器是最早实现的，<strong>基于单线程</strong>，</p><p>优点：</p><pre><code>实现简单且效率高，</code></pre><p>缺点：</p><pre><code>进行垃圾回收是会造成“Stop-the-World”(STW)，当回收内存区域较大时，就会造成程序响应时间变长。  </code></pre><p>STW：在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。</p></blockquote><h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h3><blockquote><p>全名Parallel New Generation，也就是<strong>并行新生代垃圾收集</strong>器，该回收器实现与Serial基本上一样，只是采用多线程执行回收。是运行在<strong>服务端模式</strong>下首选的新生代收集器。</p></blockquote><h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h3><blockquote><p>Parallel Scavenge则<strong>侧重于吞吐量的控制</strong>，又名”吞吐量优先”回收器</p><p>(吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）；</p><p><strong>停顿时间</strong>：适合需要与用户交互的程序，良好的响应速度能提升用户体验</p><p><strong>高吞吐量</strong>：高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多的交互任务。</p><p>自适应调节策略：虚拟机会根据当前系统的运行监控信息，动态调整参数以提供最合适的停顿时间或者最大吞吐量。</p><p>该回收器与ParNew的最大区别在于ParNew通常与CMS搭配。</p></blockquote><h3 id="4-CMS收集器"><a href="#4-CMS收集器" class="headerlink" title="4.CMS收集器"></a>4.CMS收集器</h3><blockquote><p>Concurrent Mark Sweep，是一个并发回收器，旨在减少<strong>垃圾回收的停顿时间</strong>。集中应用于<strong>B/S系统的服务端</strong>，尤其注重服务的响应速度</p></blockquote><h6 id="CMS运作操作流程"><a href="#CMS运作操作流程" class="headerlink" title="CMS运作操作流程"></a>CMS运作操作流程</h6><blockquote><p>(1)初始标记：标记GCRoots能直接关联到的对象</p><p>(2)并发标记：GCRoot开始对堆中对象进行可达性分析</p><p>(3)重新标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录</p><p>(4)并发清除：回收标记的垃圾</p></blockquote><h6 id="CMS缺点："><a href="#CMS缺点：" class="headerlink" title="CMS缺点："></a>CMS缺点：</h6><blockquote><p>（1）对CPU资源非常敏感</p><p>（2）无法处理浮动垃圾：CMS在并发清除阶段用户线程还在运行，会产生新的垃圾。这部分垃圾出现在标记之后，要等待下次GC才能清理掉</p><p>（3）基于标记-清除算法，会产生大量的内存碎片。</p></blockquote><h3 id="5-Serial-Old收集器"><a href="#5-Serial-Old收集器" class="headerlink" title="5.Serial Old收集器"></a>5.Serial Old收集器</h3><blockquote><p>   标记-整理算法实现的，相当于Serial的年老代版。</p><p>（1）可以与Parallel Scavenge收集器搭配使用</p><p>（2）作为CMS收集器的后备预案</p></blockquote><h3 id="6-Paraller-Old收集器"><a href="#6-Paraller-Old收集器" class="headerlink" title="6.Paraller Old收集器"></a>6.Paraller Old收集器</h3><blockquote><p>标记-整理算法实现，相当于Parallel Scavenge的年老代版。</p><p>在注重吞吐量以及CPU资源敏感的场合：Parallel Old + Parallel Scavengr </p></blockquote><h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h3><blockquote><p>G1是一款面向服务端应用的垃圾收集器。具备以下特点：</p><p>(1)并行与并发</p><pre><code>并行即使用多个CPU来缩端STW停顿的时间，还可以通过并发方式让java程序继续执行。</code></pre><p> (2)分代收集</p><pre><code>可以不需要其他收集器配合就能独立管理整个GC堆</code></pre><p> (3)空间整合</p><pre><code>标记整理算法实现，在运行期间不会产生内存空间碎片，收集后可以提供规整的可用内存。</code></pre><p> (4)可预测停顿</p><pre><code>除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上时间不超过N秒。</code></pre></blockquote><h6 id="G1收集器运作流程："><a href="#G1收集器运作流程：" class="headerlink" title="G1收集器运作流程："></a>G1收集器运作流程：</h6><blockquote><p>(1)初始标记：标记GCRoots能直接关联到的对象</p><p>(2)并发标记：GCRoot开始对堆中对象进行可达性分析</p><p>(3)最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录</p><p>(4)筛选回收：回收标记的垃圾</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_垃圾回收算法</title>
      <link href="/2019/03/JVM-%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/JVM-%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>垃圾回收算法有4种</p><ol><li><p>标记-清除算法</p></li><li><p>复制算法</p></li><li><p>标记-整理算法</p></li><li><p>分代收集算法</p></li></ol><h2 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1.复制算法"></a>1.复制算法</h2><p><code>可用的内存空间分为大小相等的两块，每次只是用其中的一块，当这一块被用完的时候，就将还存活的对象复制到另一块中，然后把原已使用过的那一块内存空间一次回收掉。这个算法常用于新生代的垃圾回收。</code></p><p><img src="https://github.com/qiulig/IMG/raw/master/复制算法.jpg" alt="复制算法"></p><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ol><li>复制算法解决了标记-清除算法的效率问题，以空间换时间。</li></ol><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ol><li>但是当存活对象非常多的时候，复制操作效率将会变低，而且每次只能使用一半的内存空间，利用率不高。</li></ol><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ol><li><p>应用于新生代</p></li><li><p>Serial、ParNew、Parallel Scavenge 垃圾收集器应用的算法</p></li></ol><h2 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记-清除算法"></a>2. 标记-清除算法</h2><p><code>先标记出所有需要被回收的对象，然后在标记完成后统一回收掉所有被标记的对象。</code></p><p><img src="https://github.com/qiulig/IMG/raw/master/标记清除算法.png" alt="标记清除算法"></p><h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><pre><code>效率问题：标记与清除两个过程的效率都不高空间问题：产生大量不连续的内存碎片，碎片太多会导致再程序运行过程中需要分配较大对象时，找不到足够的连续内存尔不得不提前触发垃圾回收动作。</code></pre><h6 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h6><pre><code>应用于老年代的垃圾回收CMS垃圾收集器应用的算法</code></pre><h2 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h2><p>这个算法分为三部分：</p><blockquote><p>标记出所有需要被回收的对象；</p><p>把所有存活的对象都向一端移动；</p><p>把所有存活对象边界以外的内存空间都回收掉。</p></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/标记整理算法.png" alt="标记整理算法"></p><h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><blockquote><p>标记-整理算法解决了复制算法多复制效率低、空间利用率低的问题，</p><p>解决了内存碎片的问题。</p></blockquote><h6 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h6><blockquote><p>Serial Old、Parallel Old 垃圾收集器应用的算法</p><p>主要应用于老年代</p></blockquote><h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><blockquote><p>根据对象生存周期的不同将内存空间划分为不同的块，然后对不同的块使用不同的回收算法。一般把Java堆分为新生代和老年代，新生代中对象的存活周期短，只有少量存活的对象，所以可以使用复制算法，而老年代中对象存活时间长，而且对象比较多，所以可以采用标记-清除和标记-整理算法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
