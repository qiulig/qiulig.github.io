<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer_【56】删除链表中重复的结点]]></title>
    <url>%2F2019%2F05%2F56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 2.解题思路 方法一：重头构建该链表 (1) 新建两个list，一个用于存放只出现一次的数值，一个存放重复的数值 (2) 将只出现过一次的数重头构建成链表 方法二：递归思想 3.代码方法1： 1234567891011121314151617181920212223public static ListNode deleteDuplication(ListNode pHead) &#123; ArrayList&lt;Integer&gt; ss = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; ss2 = new ArrayList&lt;&gt;(); ListNode res = new ListNode(-1); ListNode node = res; while(pHead!=null)&#123; if(!ss.contains(pHead.val) &amp;&amp; !ss2.contains(pHead.val))&#123; ss.add(pHead.val); pHead = pHead.next; &#125;else&#123; ss2.add(pHead.val); ss.remove(Integer.valueOf(pHead.val)); pHead = pHead.next; &#125; &#125; for(int i = 0;i&lt;ss.size();i++)&#123; res.next =new ListNode(ss.get(i)); res = res.next; &#125; return node.next; &#125; 方法2： 123456789101112131415161718192021222324public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; // 只有0个或1个结点，则返回 if (pHead == null || pHead.next == null) &#123; return pHead; &#125; if (pHead.val == pHead.next.val) &#123; // 当前结点是重复结点 ListNode pNode = pHead.next; while (pNode != null &amp;&amp; pNode.val == pHead.val) &#123; // 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点 pNode = pNode.next; &#125; // 从第一个与当前结点不同的结点开始递归 return deleteDuplication(pNode); &#125; else &#123; // 当前结点不是重复结点 // 保留当前结点，从下一个结点开始递归 pHead.next = deleteDuplication(pHead.next); return pHead; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSR303参数校验和全局异常处理]]></title>
    <url>%2F2019%2F05%2FJSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。故引出使用JSR303来做参数校验。参数校验的实现: 手机号和密码字段自定义注解 为了让客户端显示更加友好 需要自定义异常拦截器 1. 添加依赖123456&lt;!--JSR303参数检验+全局异常处理器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解1234567891011@Controller@RequestMapping("/login")public class LoginController &#123; @RequestMapping("/do_login") @ResponseBody public Result&lt;String&gt; doLogin(HttpServletResponse response, @Valid LoginVo loginVo)&#123; logger.info(loginVo.toString()); &#125;&#125; 12345678910@Datapublic class LoginVo &#123; @NotNull @IsMobile private String mobile; @NotNull @Length(min = 32) private String password;&#125; 3. IsMobile注解的编写[可参考@NotNull]12345678910111213141516171819202122@Target(&#123; ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint( validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile &#123; boolean required() default true; String message() default "电话号码格式错误"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; 4.指定校验器的实现[IsMobileValidator.class]1234567891011121314151617181920212223public class IsMobileValidator implements ConstraintValidator&lt;IsMobile,String&gt; &#123; private boolean required = false; @Override //初始化方法拿到注解，可以定义一个字符为空 public void initialize(IsMobile constraintAnnotation) &#123; constraintAnnotation.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //值是必须的 if(required)&#123; return ValidatorUtil.isMobile(value); &#125;else&#123; if(StringUtils.isEmpty(value))&#123; return true; &#125;else&#123; return ValidatorUtil.isMobile(value); &#125; &#125; &#125;&#125; 5.自定义异常拦截器 当校验不通过时，会抛出异常。这时如果没有定义全局异常处理器进行处理（对异常进行封装和返回）。则会发生400错误（即只有请求的发起，却没有收到正常的响应（response），因为还没有来得及return就抛出了异常（这种异常没有被处理））。 1234567891011121314151617181920212223@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public Result&lt;String&gt; exceptionHandler(HttpServletRequest request,Exception e)&#123; e.printStackTrace(); if(e instanceof GlobalException) &#123; GlobalException ex = (GlobalException) e; return Result.Error(ex.getCm()); &#125;else if(e instanceof BindException)&#123; BindException ex = (BindException) e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); //为了方便起见，只取第一个错误 ObjectError error = errors.get(0); String msg = error.getDefaultMessage(); return Result.Error(CodeMsg.BIND_ERROR.fillArgs(msg)); &#125;else&#123; return Result.Error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用缓存key]]></title>
    <url>%2F2019%2F05%2F%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key%2F</url>
    <content type="text"><![CDATA[通用缓存key的作用当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。方法：利用一个前缀来规定不同模块的缓存的key,这样不同模块之间就不会重复。 通用缓存key采用模板模式：接口-&gt;抽象类-&gt;实现类 1. 接口12345678public interface KeyPrefix &#123; //过期时间 public int expireSeconds(); //前缀 public String getPrefix();&#125; 2. 抽象类1234567891011121314151617181920212223242526272829public abstract class BasePrefix implements KeyPrefix&#123; private int expireSeconds; private String prefix; //无过期时间的构造函数 public BasePrefix(String prefix) &#123; this(0, prefix); &#125; //含有过期时间的构造函数 public BasePrefix( int expireSeconds, String prefix) &#123; this.expireSeconds = expireSeconds; this.prefix = prefix; &#125; public int expireSeconds() &#123; return expireSeconds; &#125; //获取前缀，前缀为 className：prefix public String getPrefix() &#123; String className = getClass().getSimpleName(); return className+":" + prefix; &#125;&#125; 3. 实现类12345678910public class MiaoshaKey extends BasePrefix&#123; //继承父类的无过期时间的构造函数 public MiaoshaKey(String prefix) &#123; super(prefix); &#125; //设置她这个类的前缀是className:go public static MiaoshaKey isGoodsOver = new MiaoshaKey("go");&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitMQ实现消息缓冲]]></title>
    <url>%2F2019%2F05%2FrabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[RabbitMQ主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是AMQP协议，它是一种二进制协议。默认启动端口5672` rabbitMQ的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，生产者producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。 Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key, 根据key全文匹配去寻找队列 Topic：按规则转发消息（最灵活）转发消息主要是根据通配符 Headers：设置 header attribute 参数类型的交换机 Fanout：转发消息到所有绑定队列(广播方式) 下面介绍4种交换机与springboot的集成添加依赖包amqp,统一配置application.properties 123456&lt;!--rabbitMQ依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 12345678910111213141516171819##rabbitMQspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/#消费者数量spring.rabbitmq.listener.simple.concurrency= 10spring.rabbitmq.listener.simple.max-concurrency= 10#消费者每次从队列获取的消息数量spring.rabbitmq.listener.simple.prefetch= 1#消费者自动启动spring.rabbitmq.listener.simple.auto-startup=true#消费失败，自动重新入队spring.rabbitmq.listener.simple.default-requeue-rejected= true#启用发送重试spring.rabbitmq.template.retry.enabled=true spring.rabbitmq.template.retry.initial-interval=1000spring.rabbitmq.template.retry.max-attempts=3 1. Direct交换机制 一个队列会和一个交换机绑定，除此之外再绑定一个routing_key，当消息被发送的时候，需要指定一个binding_key，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个binding_key也是支持应用到多个队列中的。 这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。 1.1 编写config12345678910@Configurationpublic class MQconfig &#123; public static final String QUEUE ="queue"; @Bean public Queue queue()&#123; return new Queue(QUEUE,true); &#125; &#125; 1.2 创建消息发送者1234567891011121314@Servicepublic class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); public void send(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.Queue,message); &#125;&#125; 1.3 创建消息接收者12345678910@Servicepublic class MQreceiver &#123; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); //监听了queue的队列 @RabbitListener(queues = MQconfig.Queue) public void receive(String message)&#123; log.info("receive message"+message); &#125;&#125; 1.4 编写controller测试123456789101112@Controllerpublic class HelloController &#123; @Autowired MQsender sender; @RequestMapping("/mq") @ResponseBody public Result&lt;Boolean&gt; mq()&#123; sender.send("hello"); return Result.success(true); &#125; &#125; 2. Fanout交换机制 扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。 2.1 编写config1234567891011121314151617181920@Configuration public class MQconfig &#123; public static final String FANOUT_EXCHANGE ="fanoutxchage"; @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE); &#125; @Bean public Binding fanoutBinding()&#123; return BindingBuilder.bind(topticQueue2()).to(fanoutExchange()); &#125; 2.2 创建消息发送者12345678910111213@Service public class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; public void sendFanout(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.FANOUT_EXCHANGE,"",msg); &#125;&#125; 2.3 创建消息接收者1234@Service public class MQreceiver &#123; //fanout 广播模式都接受故不需要listener &#125; 2.4 编写controller测试123456789@Controller public class HelloController &#123; @RequestMapping("/mq/fanout") @ResponseBody public Result&lt;String&gt; fanout()&#123; sender.sendFanout("hellommxx"); return Result.success("hello xuanzi");&#125; &#125; 3. topic交换机制 通配符交换机，exchange会把消息发送到一个或者多个满足通配符规则的routing-key的queue。其中表号匹配一个word，#匹配多个word和路径，路径之间通过.隔开。如满足a..c的routing-key有a.hello.c；满足#.hello的routing-key有a.b.c.helo。 1.1 编写config1234567891011121314151617181920212223242526272829@Configuration public class MQconfig &#123; public static final String TOPIC_QUEUE1 ="topic.queue1"; public static final String TOPIC_QUEUE2 ="topic.queue2"; public static final String TOPIC_EXCHANGE ="topicExchange" @Bean public Queue topticQueue1()&#123; return new Queue(TOPIC_QUEUE1,true); &#125; @Bean public Queue topicQueue2()&#123; return new Queue(TOPIC_QUEUE2,true); &#125; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; @Bean public Binding topicBinding1()&#123; return BindingBuilder.bind(topticQueue1()).to(topicExchange()).with("topic.key1"); &#125; @Bean public Binding topicBinding2()&#123; return BindingBuilder.bind(topticQueue2()).to(topicExchange()).with("topic.#"); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendTopic(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key1",msg+"1"); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key2",msg+"2");&#125;&#125; 1.3 创建消息接收者12345678910111213@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.TOPIC_QUEUE1) public void receiveTopic1(String message)&#123; log.info("receive topic queue1 message"+message); &#125; @RabbitListener(queues = MQconfig.TOPIC_QUEUE2) public void receiveTopic2(String message)&#123; log.info("receive topic queue2 message"+message); &#125; &#125; 1.4 编写controller测试12345678@Controller public class HelloController &#123; @RequestMapping("/mq/topic") @ResponseBody public Result&lt;String&gt; topic()&#123; sender.sendTopic("hellommxx"); return Result.success("hello xuanzi"); &#125; 4. header交换机制 header exchange(头交换机)和主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据。主题交换机路由键只有是字符串,而头交换机可以是整型和哈希值 1.1 编写config123456789101112131415161718192021222324252627282930313233343536@Configuration public class MQconfig &#123; public static final String HEADER_QUEUE ="header.queue"; @Bean public HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE); &#125; @Bean public Queue headerQueue()&#123; return new Queue(HEADER_QUEUE,true); &#125; @Bean public Binding headerBinding()&#123; Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); map.put("header1","value1"); map.put("header2","value2"); return BindingBuilder.bind(headerQueue()).to(headersExchange()) .whereAll(map).match(); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendheader(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); MessageProperties properties = new MessageProperties(); properties.setHeader("header1","value1"); properties.setHeader("header2","value2"); Message obj = new Message(msg.getBytes(),properties); amqpTemplate.convertAndSend(MQconfig.HEADERS_EXCHANGE,"",obj); &#125;&#125; 1.3 创建消息接收者123456789@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.HEADER_QUEUE) public void receiveHeader(byte[] message)&#123; log.info("receive header queue message"+message); &#125; &#125; 1.4 编写controller测试12345678910111213@Controller public class HelloController &#123; @RequestMapping("/mq/header") @ResponseBody public Result&lt;String&gt; header()&#123; sender.sendheader("hellommxx"); return Result.success("hello xuanzi"); &#125; &#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis缓存java端实现]]></title>
    <url>%2F2019%2F05%2FRedis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 1. 引入redis依赖1234&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; 2.在application.properties添加redis配置文件12345678#redisredis.host=127.0.0.1redis.port=6379redis.timeout=3redis.password=2966redis.poolMaxTotal=10 //资源池中最大连接数redis.poolMaxIdle=10 //允许的最大空闲的连接数redis.poolMaxWait=3 3.定义redis的类，引入redis的配置12345678910111213@Component@ConfigurationProperties(prefix="redis")@Datapublic class RedisConfig &#123; private String host; private int port; private int timeout;//秒 private String password; private int poolMaxTotal; private int poolMaxIdle; private int poolMaxWait;//秒&#125; 4.RedisPoolFactory类，用于返回一个redis池12345678910111213141516171819202122232425262728@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisPoolFactory() &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); //允许最大空闲的连接数 poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); //资源池中最大连接数 poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); //最大等待毫秒数 poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(), redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125;&#125; 5.编写RedisService类12345678910111213141516@Servicepublic class RedisService &#123; @Autowired JedisPool jedisPool; //里面编写redis操作：增删改查 private void returnToPool(Jedis jedis) &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125;&#125; 5.1 获取单个对象(get)1234567891011121314151617181920212223242526272829303132333435363738//相当于redis里面的get key public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key,之前设置通用缓存key时的key设为className:key String realKey = prefix.getPrefix() + key; //跟redis里面的获取一个key操作一致 String str = jedis.get(realKey); //将结果转换成一个java对象 T t = stringToBean(str, clazz); return t; &#125;finally &#123; //关闭池资源 returnToPool(jedis); &#125; &#125;//json转换为java对象public static &lt;T&gt; T stringToBean(String str, Class&lt;T&gt; clazz) &#123; if(str == null || str.length() &lt;= 0 || clazz == null) &#123; return null; &#125; //判断类型 if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(str); &#125;else if(clazz == String.class) &#123; return (T)str; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(str); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(str), clazz); &#125; &#125; 5.2 设置对象(set)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//相当于redis里面的set key valuepublic &lt;T&gt; boolean set(KeyPrefix prefix, String key, T value) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //对象转换为json字符串 String str = beanToString(value); if(str == null || str.length() &lt;= 0) &#123; return false; &#125; //生成真正的key String realKey = prefix.getPrefix() + key; //获取过期时间 int seconds = prefix.expireSeconds(); if(seconds &lt;= 0) &#123; //永久有效，无过期时间 jedis.set(realKey, str); &#125;else &#123; //为指定的 key 设置值及其过期时间。 jedis.setex(realKey, seconds, str); &#125; return true; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //将对象转化为Json字符串 public static &lt;T&gt; String beanToString(T value) &#123; if(value == null) &#123; return null; &#125; Class&lt;?&gt; clazz = value.getClass(); if(clazz == int.class || clazz == Integer.class) &#123; return ""+value; &#125;else if(clazz == String.class) &#123; return (String)value; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; 5.3 判断key是否存在(exists)123456789101112//想当于redis里面的 exists keypublic &lt;T&gt; boolean exists(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.exists(realKey); &#125;finally &#123; returnToPool(jedis); &#125;&#125; 5.4 增加值(incr)123456789101112//相当于redis里面的incr key_namepublic &lt;T&gt; Long incr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.5 减少值(decr)123456789101112//相当于redis里面的decr key_namepublic &lt;T&gt; Long decr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.6 删除(del)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//相当于redis里面的del key_name //已知key public boolean delete(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; long ret = jedis.del(realKey); return ret &gt; 0; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //通过正则匹配删除 某key public boolean delete(KeyPrefix prefix) &#123; if(prefix == null) &#123; return false; &#125; List&lt;String&gt; keys = scanKeys(prefix.getPrefix()); if(keys==null || keys.size() &lt;= 0) &#123; return true; &#125; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.del(keys.toArray(new String[0])); return true; &#125; catch (final Exception e) &#123; e.printStackTrace(); return false; &#125; finally &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125; &#125; public List&lt;String&gt; scanKeys(String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); List&lt;String&gt; keys = new ArrayList&lt;String&gt;(); String cursor = "0"; //scan搜索 ScanParams sp = new ScanParams(); sp.match("*"+key+"*"); //设置scan的个数 sp.count(100); do&#123; ScanResult&lt;String&gt; ret = jedis.scan(cursor, sp); //返回结果 List&lt;String&gt; result = ret.getResult(); if(result!=null &amp;&amp; result.size() &gt; 0)&#123; //搜索的结果存入list keys.addAll(result); &#125; //再处理cursor，用于返回下次遍历的游标 cursor = ret.getStringCursor(); &#125;while(!cursor.equals("0")); return keys; &#125; finally &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125; &#125; 6.controller层测试123456789101112131415161718@AutowiredRedisService redisService;@RequestMapping("/redis/get")@ResponseBodypublic Result&lt;User&gt; getRedis()&#123; User user = redisService.get(UserKey.getById,"key1",User.class); return Result.success(user);&#125;@RequestMapping("/redis/set")@ResponseBodypublic Result&lt;Boolean&gt; setRedis()&#123; User user = new User(); user.setId(1); user.setName("1111"); redisService.set(UserKey.getById,""+1,user); return Result.success(true);&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【59】按之字形顺序打印二叉树]]></title>
    <url>%2F2019%2F05%2F59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 2.解题思路 用一个布尔量控制从左到右还是从右到左的顺序；如果为真则他的左右孩子按照从左到右的顺序放入list中，否则按照从右到左的顺序，当本行结束之后，再把list中的数据放入一个result中。其中用一个null值作为层次的分隔符。 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041public static class Solution &#123; public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (pRoot == null) &#123; return result; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.addLast(null);//层分隔符 queue.addLast(pRoot); boolean leftToRight = true; while (queue.size() != 1) &#123; TreeNode node = queue.removeFirst(); if (node == null) &#123;//到达层分隔符 Iterator&lt;TreeNode&gt; iter = null; if (leftToRight) &#123; iter = queue.iterator();//从前往后遍历 &#125; else &#123; //从后往前遍历 iter = queue.descendingIterator(); &#125; leftToRight = !leftToRight; while (iter.hasNext()) &#123; TreeNode temp = (TreeNode) iter.next(); list.add(temp.val); &#125; result.add(new ArrayList&lt;Integer&gt;(list)); list.clear(); queue.addLast(null);//添加层分隔符 continue;//一定要continue &#125; if (node.left != null) &#123; queue.addLast(node.left); &#125; if (node.right != null) &#123; queue.addLast(node.right); &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【58】对称的二叉树]]></title>
    <url>%2F2019%2F05%2F58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 2.解题思路 【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。 【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。 【分析3】根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到 ① 如果Root和Root&apos;均为空，则返回true； ② 如果Root为空或者Root&apos;为空，则返回false； ③ 如果Root对应的值与Root&apos;对应的值不相等，则返回false。 3.代码12345678910111213141516171819202122public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; if(pRoot==null || pRoot.left==null&amp;&amp;pRoot.right==null) return true; return Symmetrical(pRoot.left,pRoot.right); &#125; boolean Symmetrical(TreeNode left,TreeNode right) &#123; if(left==null&amp;&amp;right==null) return true; if(left==null||right==null) return false; if(left.val==right.val) //右子树的左边跟左子树的右边是否对称 return Symmetrical(left.left,right.right) //左子树的右边跟右子树的左边是否对称 &amp;&amp; Symmetrical(left.right,right.left); return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【57】二叉树的下一个结点]]></title>
    <url>%2F2019%2F05%2F57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 2.解题思路 情况1：该节点有右子树： 6 / \ 3 10 / \ / \ 2 5 8 12 中序遍历结果为：2–&gt;3–&gt;5–&gt;6–&gt;8–&gt;10–&gt;12 即它的下一个结点就是它的右子树中最左子结点 情况2.1：该节点无右子树：(为父节点6的左子节点) 6 / \ 3 10 / / \ 2 8 12 2–&gt;3–&gt;6–&gt;8–&gt;10–&gt;12 该节点是父节点的左子节点的这种情况比较简单，直接将父节点返回即可 情况2.2：该节点无右子树：(为父节点6的右子节点) 6 / \ 3 10 / \ / \ 2 5 8 null 2–&gt;3–&gt;6–&gt;8–&gt;10 –&gt;null 如果是父节点的右子节点的话，需要不断的向上移动，直到对应的节点不是父节点的右节点（即左节点），既然他是父节点的左节点，此时将这个节点父节点返回即可，或者遍历到了根节点，返回null； 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/ public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if(pNode == null)&#123; return null; &#125; //该节点有右子树,它的下一个结点就是它的右子树中最左子结点 if(pNode.right != null)&#123; pNode = pNode.right; while(pNode.left != null)&#123; pNode = pNode.left; &#125; return pNode; &#125; //该节点无右子树，父节点不为空 while(pNode.next != null)&#123; //pNode为父节点的左节点为该节点，直接返回父节点 if(pNode.next.left== pNode)&#123; return pNode.next; &#125; //为父节点的右子节点，不断的向上移动，直到对应的节点不是父节点的左子节点 //一直回溯如果遍历到他是父节点的左节点，此时将这个节点父节点返回即可， //或者遍历到了根节点，返回null； pNode = pNode.next; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【55】链表中环的入口结点]]></title>
    <url>%2F2019%2F05%2F55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 2.解题思路 方法1： 利用hashSet不存储重复值的思想 方法2： 链表包含环，像数字6的图形。 (1)设置快慢指针，假设快指针在环内与慢指针相遇，设头节点到入口结点的距离为x,入口结点到相遇点为y,相遇点到入口结点距离为z,则有(x+y)*2 = (x+y+z+y),即z = x，即相遇点到入口结点的距离跟头节点到入口结点的距离相等。 (2)这时再设置fast = pHead,一个指针重头走，另一个指针重相遇节点走，当两个点相等时即为入口节点所在。 3.代码方法1： 1234567891011121314public ListNode EntryNodeOfLoop(ListNode pHead)&#123; HashSet&lt;ListNode&gt; hs = new HashSet&lt;ListNode&gt;(); while(pHead!=null)&#123; if(!hs.add(pHead))//如果包含了，那么这个就是入口结点 return pHead; pHead = pHead.next; &#125; return null;&#125; 方法2： 1234567891011121314151617181920212223242526272829303132/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode fast = pHead; ListNode slow = pHead; while(fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast==slow)&#123; fast=pHead; while (fast!=slow)&#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【54】字符流中第一个不重复的字符]]></title>
    <url>%2F2019%2F05%2F54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 2.解题思路桶排序思想 3.代码1234567891011121314151617181920212223//源源不断的有字母放到字符串中，建立一个256个大小的int型数组来代表哈希表public class Solution &#123; String str=""; int[] count=new int[256]; public void Insert(char ch) &#123; if(ch &gt;=256)&#123; return ; &#125;else&#123; str+=ch;//字符放入字符串 count[ch]++;//根据字符，修改数组字符元素的值 &#125; &#125; public char FirstAppearingOnce() &#123; for(char c:str.toCharArray())&#123;// //注意的是，要找第一个出现一次的字符，所以遍历字符串，不能遍历哈希数组 if(count[c]==1)&#123;//如果字符串作为下表的元素值为1，说明该字符出现一次，直接返回该字符 return c; &#125; &#125; return '#'; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【53】表示数值的字符串]]></title>
    <url>%2F2019%2F05%2F53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 2.解题思路 (1) 先判断每个字符是否合法 (2) 正负号的位置和e不能在结尾位置 (3) 小数点只能存在一个 (4)正负号在中间位置时，前面是e后面是数字 (5)e后面不能有小数点 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; public boolean isNumeric(char[] str) &#123; String ss = String.valueOf(str); int len = ss.length(); //先判断每个字符是否合法 for(int i=0; i&lt;len; i++)&#123; char c = ss.charAt(i); if(!((c&gt;='0' &amp;&amp; c &lt;= '9') || c=='e' || c=='E' || c=='+' || c=='-'|| c=='.')) return false; &#125; ////正负号,E不能在末尾 if(ss.charAt(len-1) == '+' || ss.charAt(len-1) == '-' || ss.charAt(len-1) == 'E' || ss.charAt(len-1) == 'e') return false; //判断小数点，只能有一个 if(ss.indexOf(".") != ss.lastIndexOf(".")) return false; //正负号在中间的位置时，前面的是e，E,后面是数字 for(int i=1; i&lt;len-1; i++)&#123; char c = ss.charAt(i); if(c == '+' || c=='-')&#123; if(!(ss.charAt(i-1) == 'e' || ss.charAt(i-1) == 'E') ||!(ss.charAt(i+1)&gt;='0' &amp;&amp; ss.charAt(i+1)&lt;='9')) return false; &#125; &#125; ////e的后面不能有数字12E+4.3 for(int i=1; i&lt;len; i++)&#123; char c = ss.charAt(i); if(c == 'e' || c=='E')&#123; if(i==len-1) return false; if(ss.charAt(i+1) == '+' || ss.charAt(i+1) == '-')&#123; //从i+2开始往后没有小数点.则返回-1 if(ss.indexOf(".", i+2) != -1)&#123; return false; &#125; &#125;else&#123; if(ss.indexOf(".", i+1) != -1)&#123; return false; &#125; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【52】正则表达式匹配]]></title>
    <url>%2F2019%2F05%2F52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配。 2.解题思路 这道题的核心其实在于分析’‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’‘的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。 在每轮匹配中，Patttern第二个字符是’*’时： 1.第一个字符不匹配（’.’与任意字符视作匹配），那么’‘只能代表匹配0次，比如’ba’与’aba’，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式 2.第一个字符匹配，那么’‘可能代表匹配0次，1次，多次，比如’aaa’与’aaaa’、’aba’与’aba’、’aaaba’与’aba’。匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；匹配多次时，字符串往后移动一个字符，模式不变； 而当Patttern第二个字符不是’*’时，情况就简单多了： (1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。 (2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if (str == null || pattern == null) return false; int strIndex = 0,patternIndex = 0; return matchCore(str, strIndex, pattern, patternIndex); &#125; public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) &#123; //有效性检验：str到尾，pattern到尾，匹配成功 if (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123; return true; &#125; //pattern先到尾，匹配失败 if (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123; return false; &#125; //模式第2个是*，且字符串第1个跟模式第1个匹配, //分3种匹配模式；如不匹配，模式后移2位 if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] == '*') &#123; if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return //模式后移2，视为x*匹配0个字符 matchCore(str, strIndex, pattern, patternIndex + 2) //视为模式匹配1个字符 || matchCore(str, strIndex + 1, pattern, patternIndex + 2) //*匹配1个，再匹配str中的下一个 || matchCore(str, strIndex + 1, pattern, patternIndex); &#125; else &#123; return matchCore(str, strIndex, pattern, patternIndex + 2); &#125; &#125; //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return matchCore(str, strIndex + 1, pattern, patternIndex + 1); &#125; return false; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【51】构建乘积数组]]></title>
    <url>%2F2019%2F05%2F51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 2.解题思路 题目的意思就是B[i] = A[0]*A[1]….*A[n-2]*A[n-1] / A[i],但是题目要求不能用除法 创建一个left数组和一个rigth数组，拿n = 3为例 res[i] left[0]*right[0] left[1]*right[1] left[2]*right[2] left[3]*right[3] right数组 A[2]*A[1]*A[0]*1 A[1]*A[0]*1 A[0]*1 1 left数组 1 1*A[0] 1*A[0]*A[1] 1*A[0]*A[1]*A[2] 3.代码123456789101112131415161718192021222324import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; int []res = new int[A.length]; int []left = new int[A.length]; int []right = new int[A.length]; left[0] = 1; for(int i = 1;i&lt;A.length;i++)&#123; left[i] = A[i-1]*left[i-1]; &#125; right[A.length-1] = 1; for(int i = A.length-2;i&gt;=0;i--)&#123; right[i] = right[i+1]*A[i+1]; &#125; //计算结果 for(int i = 0;i&lt;A.length;i++)&#123; res[i] = left[i]*right[i]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【50】数组中重复的数字]]></title>
    <url>%2F2019%2F05%2F50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 2.解题思路 长度为n,数字都在[0,n-1]范围，可以利用桶排序的思想，将numbers[i]的个数存入相应的res索引下，当第一次桶里有2个numbers[i]时，直接返回即找到第一个数组里面的重复数字。 3.代码123456789101112131415161718 public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(length == 0) return false; int res[] = new int [length]; boolean flag = false; for(int i = 0;i&lt;length;i++)&#123; res[numbers[i]]++; //有重复的数 if(res[numbers[i]]&gt;1)&#123; duplication[0] = numbers[i]; flag = true; break; &#125; &#125; return flag;&#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【49】把字符串转换成整数]]></title>
    <url>%2F2019%2F05%2F49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 输入描述:输入一个字符串,包括数字字母符号,可以为空 输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1： 输入+2147483647 1a33 输出2147483647 0 2.解题思路 (1) 首先判断第一个字符是符号‘ + ‘ 或者 ’ - ‘ 还是数字 (2) 首字母为 ’ + ‘，则设flag 为 1，计算[1,len)的数值 (3) 首字母为 ’ - ‘，则设flag为-1，计算[1,len)的数值 (4) 首字母为数字，则计算[0,len)的数值 计算时有个是否溢出判断。 3.代码12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int StrToInt(String str) &#123; if(str.trim().equals(""))&#123; return 0; &#125; int sum = 0; int flag = 1; if(str.charAt(0) =='+'||str.charAt(0)=='-')&#123; if(str.charAt(0)=='-') &#123; flag = -1; &#125; sum = cal(str,1,str.length(),flag); &#125;else&#123; sum = cal(str,0,str.length(),flag); &#125; return sum*flag; &#125; //计算结果 private int cal(String str, int start, int end,int flag) &#123; int sum = 0; for(int i = start;i&lt;end;i++)&#123; if(str.charAt(i)&gt;='0' &amp;&amp;str.charAt(i)&lt;='9')&#123; if(flag == 1 &amp;&amp; sum&gt;Integer.MAX_VALUE) throw new RuntimeException("上溢出"); if(flag == -1 &amp;&amp; sum&lt;Integer.MIN_VALUE) throw new RuntimeException("下溢出"); sum = sum*10+str.charAt(i)-'0'; &#125;else&#123; return 0; &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【48】不用加减乘除做加法]]></title>
    <url>%2F2019%2F05%2F48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 2.解题思路利用&amp;、|、^等运算 (1)定义一个sum和一个进位位carry，sum用来记录二进制的两位数无进位相加得到的值（num1^num2）,进位位carry用来记录需要向哪个位进位（num&amp;num2&lt;&lt;1） (2)将得到的sum和carry重新赋值给num1和num2.循环的结束条件是进位位为0时终止。 3.代码12345678910111213141516171819public class Solution &#123; public int Add(int num1,int num2) &#123; int carry = 0; int sum = 0; do&#123; //异或，相同为0不同为1 ,得到的结果相当于二进制的两个数无进位相加， //相加为2的结果是0.如6和12相异或，即（0110^1100） = 1010 sum = num1 ^ num2; //num1&amp;num2得到该位数需要进位，即向前进位&lt;&lt;1 carry = (num1&amp;num2)&lt;&lt;1; num1 = sum; num2 = carry; &#125;while(num2!=0); //直到无进位结束 return num1; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【47】求1+2+...+n]]></title>
    <url>%2F2019%2F05%2F47-%E6%B1%821-2-n%2F</url>
    <content type="text"><![CDATA[1.题目描述 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 2.解题思路 1.需利用逻辑与的短路特性实现递归终止。 2.当n==0时，(n&gt;0)&amp;&amp;((ans+=Sum_Solution(n-1))&gt;0)只执行前面的判断，不执行后面的递归了，使这条语句为false，并且不往上回溯，可以执行下面return的语句了。然后直接返回ans； 3.当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。 3.代码12345678public class Solution &#123; public int Sum_Solution(int n) &#123; int ans = n; boolean flag = (ans &gt; 0) &amp;&amp; (ans += Sum_Solution(n - 1))&gt;0; return ans; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【46】孩子们的游戏(圆圈中最后剩下的数)]]></title>
    <url>%2F2019%2F05%2F46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[1.题目描述 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 2.解题思路 模拟游戏过程 i一直记录的是小朋友自己最初的的位置[0,n-1] step记录的是报数，报到m-1时array[i]这个小朋友出局，记-1，step重头计数。人数这时减1. 3.代码123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if(n&lt;1||m&lt;1) return -1; int array[] = new int[n]; int i = -1 ; //初始状态 int step = -1; int count = n; //人数 while (count&gt;0)&#123; //游戏开始 //报数，其实报的一直都是自己的位置数，不是[0,m-1],而是[0,n-1] i++; //假如有8人，报数范围是[0,7],轮询一圈后那么第一个人不报8而是报0 if(i&gt;=n) i=0; if(array[i]==-1) continue; //标记为-1即出局，不遍历下边的了 step++; //step用来记录报数报到哪了 if(step==m-1)&#123; //找到喊m-1的小朋友 array[i] = -1; //出局 step = -1; //重头开始记录报数 count--; //人数减1 &#125; &#125; return i; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【45】扑克牌顺子]]></title>
    <url>%2F2019%2F05%2F45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[1.题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 2.解题思路 组成顺子的条件是： (1) 数组长度为5 (2)数组中数不重复 (3)最大值Max减最小值Min&lt;5,其中Max和Min不能为0,即不包括大小王的最大值最小值 3.代码12345678910111213141516171819202122232425262728293031public class Solution &#123; public static boolean isContinuous(int [] numbers) &#123; if(numbers.length&lt;5) return false; int Max = Integer.MIN_VALUE; int Min = Integer.MAX_VALUE; int count[] = new int[14]; //除0以外没有重复的数 for(int i = 0;i&lt;numbers.length;i++)&#123; count[numbers[i]]++; //如果是大小王的话，可以允许多个，直接continue不执行count[numbers[i]&gt;=2的判断,而且最大值最小值的判断也会跳过0 if(numbers[i] == 0)&#123; continue; &#125; if(count[numbers[i]]&gt;=2)&#123; return false; &#125; // if(Max&lt;numbers[i]) &#123; Max = numbers[i]; &#125; if(Min &gt;numbers[i])&#123; Min = numbers[i]; &#125; &#125; if ( Max - Min &lt; 5) &#123; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【44】翻转单词顺序列]]></title>
    <url>%2F2019%2F05%2F44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 2.解题思路 用str.split(“ ”) 去切分子字符串变成str[],然后再拼接。 3.代码123456789101112131415161718192021public class Solution &#123; public String ReverseSentence(String str) &#123; if(str == null)&#123; return null;&#125; //去掉前后空格，避免输入字符串全是空格情况，保证后面的split切分正确 if(str.trim().equals(""))&#123; return str; &#125; String res[] = str.split(" "); StringBuilder ss = new StringBuilder(); //第二个到最后一个数组值后面要加“ ” for(int i = res.length-1;i&gt;0;i--)&#123; ss.append(res[i]+" "); &#125; //第一个就是数组末尾了不需要加“ ”，保持反转后的数组长度跟原来一样 ss.append(res[0]); return ss.toString(); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【43】左旋转字符串]]></title>
    <url>%2F2019%2F05%2F43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1.题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 2.解题思路两个子字符串 拼接就行了。 3.代码1234567public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(n&gt;str.length()) return ""; return str.substring(n,str.length())+str.substring(0,n); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【42】和为s的两个数字]]></title>
    <url>%2F2019%2F05%2F42-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述:对应每个测试案例，输出两个数，小的先输出。 2.解题思路 将数组的数值依次放入list里面，每次放入之前查询list里面是否有（sum-array[i]），如果有,再判断两数乘积是否比之前存的两数乘积小，如果判断成功，则将这两个数放到index1和index2中。最后将这两个index放到list里面返回。 3.代码1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array, int sum) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; ss = new ArrayList&lt;&gt;(); int Min_ = Integer.MAX_VALUE; //index1用于存放比较小的那个数 int index1 = 0; //index2用于存放比较大的数 int index2 = 0; for(int i = 0;i&lt;array.length;i++)&#123; if(res.contains(sum-array[i]))&#123; if(Min_&gt;(sum-array[i])*array[i])&#123; Min_ = (sum-array[i])*array[i]; index1 = array[i]&lt;(sum-array[i])? array[i]:(sum-array[i]); index2 = sum-index1; &#125; &#125;else&#123; res.add(array[i]); &#125; &#125; if(index1!=0||index2!=0)&#123; ss.add(index1); ss.add(index2); &#125; return ss; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【41】和为S的连续正数序列]]></title>
    <url>%2F2019%2F05%2F41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 2.解题思路 滑动窗口移动方法 (1) 求出滑动窗口的累加和，公式为等差数列求和公式 (2)如果累加和等于sum,则将该滑动窗口内的数存到一个list里面，并右移动左指针 (3)如果累加和小于sum,则右移动右指针，加数进来 (4)如果累加和大约sum，则左指针右移动，减数出去 3.代码1234567891011121314151617181920212223242526272829import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; //存放结果 ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = new ArrayList&lt;&gt;(); //两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小 int plow = 1,phigh = 2; while(phigh &gt; plow)&#123; //由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2 int cur = (phigh + plow) * (phigh - plow + 1) / 2; //相等，那么就将窗口范围的所有数添加进结果集 if(cur == sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=plow;i&lt;=phigh;i++)&#123; list.add(i); &#125; result.add(list); plow++; //如果当前窗口内的值之和小于sum，那么右边窗口右移一下 &#125;else if(cur &lt; sum)&#123; phigh++; &#125;else&#123; //如果当前窗口内的值之和大于sum，那么左边窗口右移一下 plow++; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【40】数组中只出现一次的数字]]></title>
    <url>%2F2019%2F05%2F40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 2.解题思路 将数组依次放到list里面，如果list里面含有准备要进去的数值，则remove掉，剩下的两个数组即为该数组中只出现过一次的数字 list.remove要用(Object object)方法而不是list.remove(int index); 3.代码1234567891011121314151617181920212223//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果import java.util.*;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; if(array.length&lt;2)&#123; return ; &#125; ArrayList&lt;Integer&gt; res = new ArrayList(); for(int i = 0;i&lt;array.length;i++)&#123; if(res.contains(array[i]))&#123; //这里remove掉的是里面的数array[i]，而不是array[i]索引对应的数 res.remove(Integer.valueOf(array[i])); &#125;else&#123; res.add(array[i]); &#125; &#125; num1[0] = res.get(0); num2[0] = res.get(1); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【39】平衡二叉树]]></title>
    <url>%2F2019%2F05%2F39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 2.解题思路预备知识：平衡二叉树是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 思想：从根节点开始，先判断左右子树的高度差是否超过1，然后接着判断左右子树是否是平衡二叉树。这边用到了递归思想。 代码如下： 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if( root == null) &#123; //一棵空树就是平衡二叉树 return true; &#125; if( Math.abs(getDepth(root.left) - getDepth(root.right)) &lt;= 1 ) &#123; //满足左右子树高度差小于等于1,那就接着判断左右子树是不是二叉树 return (IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right)); &#125; else &#123; //不满足左右子树高度差小于等于1,那这棵树肯定不是平衡二叉树啦 return false; &#125; &#125; //递归求二叉树深度 public int getDepth(TreeNode root) &#123; if( root == null ) return 0; int left = getDepth(root.left); int right = getDepth(root.right); return ( left &gt; right ? left : right ) + 1; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【38】二叉树的深度]]></title>
    <url>%2F2019%2F05%2F38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 2.解题思路 ①如果一棵树只有一个结点，它的深度为1。 ②如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。 ③如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。 3.代码12345678910111213141516171819202122232425/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;*/public class Solution &#123; public int TreeDepth(TreeNode root) &#123; //----递归求二叉树深度---- if(root == null)&#123; return 0; &#125; int left = TreeDepth(root.left); int right = TreeDepth(root.right); return (left&gt;right)?(left+1):(right+1); &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【37】数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F05%2F37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述统计一个数字在排序数组中出现的次数。 2.解题思路排序数组嘛，找到数组里面第一个等于k的，一直res++直到数组值不等于k。 3.代码123456789101112131415public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; int res = 0; if (array == null || array.length == 0) return res; for(int i = 0;i&lt;array.length;i++)&#123; if(array[i] == k)&#123; res++; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【36】两个链表的第一个公共结点]]></title>
    <url>%2F2019%2F05%2F36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述输入两个链表，找出它们的第一个公共结点。 2.解题思路两个链表有公共点，考虑Y型的两链表相连，先计算出两个链表的长度，然后长的链表先走差值步，之后同步走，当遇到cur1==cur2时说明两链表相遇。直接返回即可。 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindFirstCommonNode(ListNode head1, ListNode head2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; ListNode cur1 = head1; ListNode cur2 = head2; int n = 0; //得到差值步（head1.length-head2.length） while (cur1.next != null) &#123; n++; cur1 = cur1.next; &#125; while (cur2.next != null) &#123; n--; cur2 = cur2.next; &#125; //相交为Y型则最后一个结点应该相同 if (cur1 != cur2) &#123; return null; &#125; cur1 = n &gt; 0 ? head1 : head2; cur2 = cur1 == head1 ? head2 : head1; n = Math.abs(n);//差值步 //走差值步 while (n != 0) &#123; n--; cur1 = cur1.next; &#125; //相等时则为相交点 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[争吵问题.md]]></title>
    <url>%2F2019%2F05%2F%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md%2F</url>
    <content type="text"><![CDATA[1. 题目描述有一个队列，每个人要么朝左边（L表示）,要么朝右边(R表示)，因为每个人都讨厌其他任何人，只要两人面对面就会发生争吵。争吵结果是胜者留在队列中，败的人移除队中。如果序列中有多对争吵，可以任选一对，胜者留在队中，败者出局，求最后队列最少人数是多少。 例子： LRRLRL 输出：2 Hint 一种可能的变化情况是：LRRLRL -&gt; LRLRL -&gt; LRRL -&gt; LRL -&gt; LR 2.解题思路由题意可知，如果真的吵架就只有RL（两人面对面）情况，像LL,RR,LR就不会争吵。 如果吵架前面是R，则吵架结果应该是L胜利. 如果吵架前面是L，则吵架结果为R胜利 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.List;public class test &#123; public static void main(String[] args) &#123; String arr ="LRRLRL"; String res = solut(arr); System.out.println(res.length()); System.out.println(res); &#125; public static String solut(String arr) &#123; //获取第一次争吵得到的结果 String str = solution(arr); //如果还存在第二次争吵，则继续，否则得到结果 while (str.contains("RL"))&#123; str = solution(str); &#125; return str; &#125; public static String solution(String arr)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;arr.length()-1;i++)&#123; //争吵 if(arr.charAt(i)=='R'&amp;&amp;arr.charAt(i+1)=='L')&#123; if(i==0) &#123; list.add('R'); i++; &#125; else&#123; if(list.get(list.size()-1)=='L') &#123; &#123; list.add('R'); i++; &#125; &#125;else&#123; &#123; list.add('L'); i++; &#125; &#125; &#125; &#125;else &#123; //没有争吵，下一次争吵中还有该人 list.add(arr.charAt(i)); &#125; &#125; //将list转换成String String str = ""; for(int i = 0;i&lt;list.size();i++)&#123; str = str+list.get(i); &#125; return str; &#125;&#125;]]></content>
      <categories>
        <category>讯飞科技笔试</category>
      </categories>
      <tags>
        <tag>讯飞科技笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【34】第一个只出现一次的字符位置]]></title>
    <url>%2F2019%2F05%2F34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.题目描述 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 2.解题思路 1.用两个list,一个list用来存放只出现一次的字符，一个用来存放出现多次的字符 2.依次遍历str里面的字符，如果list1和list2里面都没有，则说明这个字符是第一次出现，将其添加到list1，否则说明之前出现过该字符，将其移除list1并添加到list2里面 3.最后判断list里面是否有值，有则返回list里面的第一个值在str出现的第一次的位置，即为第一次出现的字符位置。 3.代码1234567891011121314151617181920212223242526272829public static int FirstNotRepeatingChar(String str) &#123; if (str.length() == 0 || str == null) return -1; //list1存放str中出现1次的字符 ArrayList&lt;Character&gt; list1 = new ArrayList&lt;Character&gt;(); //list2用来存放多次出现的字符 ArrayList&lt;Character&gt; list2 = new ArrayList&lt;Character&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); //两个list里面都没有这个字符 if (!list1.contains(ch) &amp;&amp; !list2.contains(ch)) &#123; //将字符放到list1中 list1.add(Character.valueOf(ch)); &#125; else &#123; //将list1之前加入的删掉（此时出现了相同字符，删掉相同字符） list1.remove(Character.valueOf(ch)); //将str中含有的相同字符存入list2 list2.add(Character.valueOf(ch)); &#125; &#125; if (list1.size() &lt; 0) &#123; return -1; &#125; return str.indexOf(list1.get(0)); &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【35】数组中的逆序对]]></title>
    <url>%2F2019%2F05%2F35.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 题目保证输入的数组中没有的相同的数字 数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 例子数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}； 2.解题思路方法1：暴力破解:时间超时 考察每一位，判断从这一位往后有多少小于该位的，结果累加，得到最后结果。 方法2：归并算法 3.代码方法1(超时)： 1234567891011121314151617181920212223public class Solution &#123; public static void main(String[]args) &#123; int []array=&#123;7,5,6,4&#125;; int num=InversePairs(array); System.out.println(num); &#125; public static int InversePairs(int [] array) &#123; int count=0; for(int i=0;i&lt;array.length-1;i++) &#123; for(int j=i+1;j&lt;array.length;j++) &#123; if(array[i]&gt;array[j]) &#123; count++; continue; &#125; &#125; &#125; return count%1000000007; &#125;&#125; 方法2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;public class Solution &#123; public int InversePairs(int [] array) &#123; if(array==null||array.length==0) &#123; return 0; &#125; int[] copy = new int[array.length]; for(int i=0;i&lt;array.length;i++) &#123; copy[i] = array[i]; &#125; int count = InversePairsCore(array,copy,0,array.length-1);//数值过大求余 return count; &#125; private int InversePairsCore(int[] array,int[] copy,int low,int high) &#123; if(low==high) &#123; return 0; &#125; int mid = (low+high)&gt;&gt;1; int leftCount= InversePairsCore(array,copy,low,mid)%1000000007; int rightCount = InversePairsCore(array,copy,mid+1,high)%1000000007; int count = 0; int i=mid; int j=high; int locCopy = high; while(i&gt;=low&amp;&amp;j&gt;mid) &#123; if(array[i]&gt;array[j]) &#123; count += j-mid; copy[locCopy--] = array[i--]; if(count&gt;=1000000007)//数值过大求余 &#123; count%=1000000007; &#125; &#125; else &#123; copy[locCopy--] = array[j--]; &#125; &#125; for(;i&gt;=low;i--) &#123; copy[locCopy--]=array[i]; &#125; for(;j&gt;mid;j--) &#123; copy[locCopy--]=array[j]; &#125; for(int s=low;s&lt;=high;s++) &#123; array[s] = copy[s]; &#125; return (leftCount+rightCount+count)%1000000007; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【33】丑数]]></title>
    <url>%2F2019%2F05%2F33-%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 2.解题思路 丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an 所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2a1, 2a2, 2*a3 ….. 包含3的有序丑数序列:3a1, 3a2, 3a3 ….. 包含5的有序丑数序列:5a1, 5a2, 5a3 ….. 以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可 3.代码1234567891011121314151617181920212223242526272829import java.util.*;public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; int []arr=new int[index]; if(index==0) return 0; arr[0]=1; //第一个丑数为1，放入数组的第一个元素 int t2=0; int t3=0; int t5=0; for(int i=1;i&lt;index;i++) &#123; //寻找3个序列中最小的那个数 arr[i]=Math.min(arr[t2]*2,Math.min(arr[t3]*3,arr[t5]*5)); //最小的那个数的序列值加1 if(arr[t2]*2==arr[i]) t2++; if(arr[t3]*3==arr[i]) t3++; if(arr[t5]*5==arr[i]) t5++; &#125; return arr[index-1]; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【32】把数组排成最小的数]]></title>
    <url>%2F2019%2F05%2F32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 2.解题思路 方法1： (1) 求出数组里面最大的数的位数，然后其他的数位数不够的进行补位 (2) 补位原则：如数组{3,32,321},最大位数为3，所以3进行补位变成333，补的两位为str[i]数组里面的最后一个charAt[str[i].length()-1];所以32补位变成322 (3) 对数组{333，322，321}进行从小到大排序，然后根据索引把字符串拼接即可得到答案。即从小到大排序为{321，322，333}，这三个数对应原数组的{321，32，3}，最后答案即为321323. 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.*;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; if(numbers.length&lt;=0||numbers == null) return ""; //排序，可得到最大的数为numbers[len-1] Arrays.sort(numbers); //求位数 int count = 0; int Max_ = numbers[numbers.length-1]; //得到最大的数的位数 while(Max_&gt;0) &#123; count++; Max_ = Max_/10; &#125; //将数组变成字符串数组 String str[] = new String[numbers.length]; for(int i = 0;i&lt;numbers.length;i++)&#123; str[i] = ""+numbers[i]; &#125; //补位 for(int i = 0;i&lt;numbers.length;i++)&#123; //得到补位要填充的数 String tmp ="" +str[i].charAt(str[i].length()-1); //原数组的位数 int len =str[i].length(); //补足到相同的位数 for(int j = 0;j&lt;count-len;j++) &#123; str[i] = str[i]+tmp; &#125; &#125; //排序 ArrayList&lt;Integer&gt; ss= new ArrayList&lt;&gt;(); //该数组的索引对应着numbers的索引 String strcopy[] = str.clone(); //将其进行从小到大的排序 Arrays.sort(str); //得到从小到大排序后原数组所在的索引 for(int i = 0;i&lt;numbers.length;i++)&#123; for(int j = 0;j&lt;numbers.length;j++)&#123; if(str[i].equals(strcopy[j]))&#123; ss.add(j); &#125; &#125; &#125; //将索引进行拼接得到结果 String res = ""; for(int i = 0;i&lt;numbers.length;i++)&#123; res = res +numbers[ss.get(i)]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【31】整数中1出现的次数]]></title>
    <url>%2F2019%2F05%2F31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 2.解题思路 方法1： 将每个数变成string,然后将string里面的1替换成”“,长度的减少就是这个string里面1的个数，但是这个方法中String是不可变字符串，故占用内存过多。 方法2： 依次计算出每个数中包含1的个数 3.代码123456789101112public static int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; String s = ""; for(int i = 1;i&lt;=n;i++)&#123; s = i+""; count += s.length()-s.replaceAll("1", "").length(); &#125; return count; &#125; 方法2: 1234567891011121314151617181920212223242526272829public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; if(n&lt;1) return 0; else &#123; int sum=0; for(int i=1;i&lt;=n;i++) sum+=NumberOf1(i); return sum; &#125; &#125; public int NumberOf1(int n) &#123; int count=0; while(n!=0) &#123; if(n%10==1)//求余 &#123; count++; &#125; n=n/10; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【30】连续子数组的最大和]]></title>
    <url>%2F2019%2F05%2F30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 2.解题思路用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。 当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令cur = 0.表示从下一个数开始累加。 当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最大值即可。 3.代码123456789101112131415import java.util.*;public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; if(array == null || array.length == 0) return 0; int res = Integer.MIN_VALUE; int cur = 0; for(int i = 0;i&lt;array.length;i++)&#123; cur += array[i]; res = Math.max(res,cur); cur = cur &lt; 0 ? 0 : cur; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【29】最小的K个数]]></title>
    <url>%2F2019%2F05%2F29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 2.解题思路 排序问题，本次使用快排，快排思想即： “挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(input.length&lt;k) return res; quicksort(input, 0, input.length - 1); for (int i = 0; i &lt; k; i++) &#123; res.add(input[i]); &#125; return res; &#125; public void quicksort(int arr[], int low, int high) &#123; if(low &lt; high) &#123; int position = partition(arr, low, high); quicksort(arr, low, position - 1); quicksort(arr, position + 1, high); &#125; &#125; public int partition(int arr[], int low, int high) &#123; //设置基准值 int key = arr[low]; while(low &lt; high)&#123; //从右到左，直到找到一个小于key的值 while(low &lt; high &amp;&amp; arr[high] &gt;= key) --high; //将该值填入前的坑 arr[low] = arr[high]; //从左到右，直到找到一个大于key的值 while(low &lt; high &amp;&amp; arr[low] &lt;= key) ++low; //将该值填入前一个坑 arr[high] = arr[low]; &#125; //将基准值填入最后一个坑 arr[low] = key; //最后一个坑划分了左边小于该值，右边大于该值 return low; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【28】数组中出现次数超过一半的数字]]></title>
    <url>%2F2019%2F05%2F28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 2.解题思路利用一个hashmap用来存储数组里面每个数出现的次数，然后遍历map，比较每个数的value是否超过数组的一半 3.代码12345678910111213141516171819import java.util.*;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int res = 0; for(int i = 0;i&lt;array.length;i++)&#123; if(map.containsKey(array[i]))&#123; map.put(array[i],map.get(array[i])+1); &#125;else&#123; map.put(array[i],1); &#125; &#125; for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123; if(entry.getValue()&gt;array.length/2) res = entry.getKey(); &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【27】字符串的排列]]></title>
    <url>%2F2019%2F05%2F27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 2.解题思路 算法思路：（递归实现）(1)n个元素的全排列=（n-1个元素的全排列）+（另一个元素作为前缀）；(2)出口：如果只有一个元素的全排列，则说明已经排完，则输出数组； (3)不断将每个元素放作第一个元素，然后将这个元素作为前缀，并将其余元素继续全排列，等到出口，出口出去后还需要还原数组； 以字符串abc为例： a 作为开头 -&gt; 求 bc 全排列 -&gt; 得到 bc 和 cb -&gt; 与 a 合并 -&gt; 得到 abc 和 acb b 作为开头 -&gt; 求 ac 全排列 -&gt; 得到 ac 和 ca -&gt; 与 b 合并 -&gt; 得到 bac 和 bca c 作为开头 -&gt; 求 ab 全排列 -&gt; 得到 ab 和 ba -&gt; 与 c 合并 -&gt; 得到 cab 和 cba 3.代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; //用于排序输出 ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); if(str==null||str.length()==0)&#123; return res; &#125; //将字符串转化成字符数组 char[] chars = str.toCharArray(); //从第0个字符开始全排列 res=Permu(chars,0,res); return res ; &#125; public ArrayList&lt;String&gt; Permu(char[] str, int start, ArrayList&lt;String&gt; list) &#123; if (str == null) &#123; return null; &#125; //设置递归的出口,即当需要全排列的范围只有一个元素，则全排结束 if (start == str.length - 1) &#123; //去除重复的字符串 if (list.contains(String.valueOf(str))) &#123; return null; &#125; else&#123; list.add(String.valueOf(str)); &#125; &#125; else &#123; //for循环将start~len-1每一个数放到start位置中去，并实现全排列 //str[start]-----str[len-1]的全排列 for (int j = start; j &lt; str.length; j++) &#123; //取出第j个字符作为第一个字符 swap(str,j,start); //求出str[start+1]----str[len-1]的全排列 Permu(str, start+ 1, list); //恢复原数组 swap(str,j,start); &#125; &#125; //生成字典序 Collections.sort(list); return list; &#125; public void swap(char[] chars,int a,int b)&#123; if(a==b)&#123;//因为会出现原位置与原位置交换，直接空即可 &#125;else&#123; char temp = chars[a]; chars[a]=chars[b]; chars[b]=temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【26】二叉搜索树与双向链表]]></title>
    <url>%2F2019%2F05%2F26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1. 题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 二叉树如 10 / \ 6 14 / \ / \ 4 8 12 16 转化成双向链表 4 6 8 10 12 1416 2.解题思路 (1)二叉搜索树中，每个结点都有两个分别指向其左、右子树的指针，左子树结点的值总是小于父结点的值，右子树结点的值总是大于父结点的值。 (2)双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。所以这两种数据结构的结点是一致 为了减少指针的变换次数，并让操作更加简单，在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。 链表是有序的，可以借助二叉树中序遍历，因为中序遍历算法的特点就是从小到大访问结点。当遍历访问到根结点时，假设根结点的左侧已经处理好，只需将根结点与上次访问的最近结点（左子树中最大值结点）的指针连接好即可。进而更新当前链表的最后一个结点指针。同时中序遍历过程正好是转换成链表的过程，可采用递归方法处理 思想：把左子树、右子树都转换成排序的双向链表之后在和根结点链接起来，整个二叉树也变成了排序的双向链表。 3. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeNode Convert(TreeNode root) &#123; if(root==null)&#123;//假如根节点为空，返回空 return null; &#125; if(root.left==null&amp;&amp;root.right==null)&#123;//假如只有一个根节点，则返回根节点 return root; &#125; //1、将左子树构造成双链表，并返回该链表头结点left TreeNode left=Convert(root.left); //2、定位到左子树链表的最后一个节点（左子树最右边的节点） //创建一个临时节点P,用来遍历找到左链表的最后一个节点(左子树最右边的节点)，p初始化指向做左子树的根节点， TreeNode p=left; while(p!=null&amp;&amp;p.right!=null)&#123; //最终p为左子树最右边的节点 p=p.right; &#125; //3、如果左子树链表不为空，将当前root追加到左子树链表后 if(left!=null)&#123;//左子树链表不为空 //左子树链表的最后一个节点p（左子树最右边节点）的右指针指向当前root节点 p.right=root; //当前root节点的左指针指向左子树链表的最后一个节点p（左子树最右边节点） root.left=p; &#125; //4、将右子树构造成双链表，并返回该链表的头结点right TreeNode right=Convert(root.right); //5、如果右子树链表不为空，将右子树链表追加到当前root后 if(right!=null)&#123;//右子树链表不为空 right.left=root;//右子树链表的头结点right的左指针指向当前root root.right=right;//当前root的右指针指向右子树链表的头结点right &#125; return left!=null?left:root;//根据左子树链表是否为空返回整个双向链表的头指针。 &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【25】复杂链表的复制]]></title>
    <url>%2F2019%2F05%2F25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 2.解题思路3.代码123456789101112131415161718192021222324252627282930313233/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if (pHead == null) return null; RandomListNode head = new RandomListNode(pHead.label); RandomListNode ans = head; if (pHead.random != null) &#123; head.random = new RandomListNode(pHead.random.label); &#125; while (pHead.next != null) &#123; pHead = pHead.next; head.next = new RandomListNode(pHead.label); if (pHead.random != null) &#123; head.next.random = new RandomListNode(pHead.random.label); &#125; head = head.next; &#125; return ans; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null) &#123; return null; &#125; RandomListNode currentNode = pHead; //1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面； while(currentNode != null)&#123; RandomListNode cloneNode = new RandomListNode(currentNode.label); RandomListNode nextNode = currentNode.next; currentNode.next = cloneNode; cloneNode.next = nextNode; currentNode = nextNode; &#125; currentNode = pHead; //2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next; while(currentNode != null) &#123; currentNode.next.random = currentNode.random==null?null:currentNode.random.next; currentNode = currentNode.next.next; &#125; //3、拆分链表，将链表拆分为原链表和复制后的链表 currentNode = pHead; RandomListNode pCloneHead = pHead.next; while(currentNode != null) &#123; RandomListNode cloneNode = currentNode.next; currentNode.next = cloneNode.next; cloneNode.next = cloneNode.next==null?null:cloneNode.next.next; currentNode = currentNode.next; &#125; return pCloneHead; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【24】二叉树中和为某值的路径]]></title>
    <url>%2F2019%2F05%2F24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 2.解题思路整个过程可以采用先序遍历方式的DFS，即根节点—–&gt;左子树—–&gt;右子树。 随后考虑一次遍历完成后的处理， (1)当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点； (2)如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。 (3)考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; //创建一个类型为ArrayList&lt;Integer&gt;的list ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathlist=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); //创建一个list,用于存放遍历的值 ArrayList&lt;Integer&gt; path=new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath (TreeNode root,int target) &#123; //如果树为空，则返回空的pathlist if(root==null) return pathlist; //将root值放入list path.add(root.val); //如果根的左子树、右子树、目标值=根值，则返回path if(root.left==null&amp;&amp;root.right==null&amp;&amp;target==root.val) &#123; pathlist.add(new ArrayList&lt;Integer&gt;(path)); &#125; //如果此时根值小于目标值并且含有左子树 if(root.val&lt;=target&amp;&amp;root.left!=null) &#123; //将遍历左子树，将根设为左子树并且此时的target=target-遍历过的root值 FindPath(root.left,target-root.val); &#125; //如果此时根值小于目标值并且含有右子树 if(root.val&lt;=target&amp;&amp;root.right!=null) &#123; //将遍历右子树，将根设为右子树并且此时的target=target-遍历过的root值 FindPath(root.right,target-root.val); &#125; //不论路径的值是否等于输入整数值，都要回退， //即使用remove函数移除路径上的最后一个节点。 path.remove(path.size()-1); return pathlist; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【23】二叉搜索树的后序遍历序列]]></title>
    <url>%2F2019%2F05%2F23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 2.解题思路二叉搜索树后序遍历为：左子树—-&gt;右子树—-&gt;根，且左子树值&lt;根值&lt;右子树值 如二叉搜索树： 10 / \ 6 12 / \ / \ 3 7 11 20 后序遍历结果为：3 7 6 11 20 12 10 对于一个数组sequence，最后一个元素是sequence[len-1] （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于sequence[len-1] ，后一段（右子树）大于sequence[len-1] ，且这两段（子树）都是合法的后序序列 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence==null||sequence.length&lt;=0) &#123; return false; &#125; int len=sequence.length; //数组长度 int root=sequence[len-1]; //数组的最后一个数为根 int i=0; for(;i&lt;len-1;i++) &#123; if(root&lt;=sequence[i]) //左子树的数值都小于根 break; &#125; //此时的j即为划分出来的左子树部分和右子树部分的分界 int j=i; for(;j&lt;=len-1;j++) &#123; //j到len-1都都为右子树，数值都大于root,如果root大于他们，则返回false if(root&gt;sequence[j]) &#123; return false; &#125; &#125; //递归判断左子树 boolean leftflag=true; if(i&gt;0) &#123; leftflag=VerifySquenceOfBST( Arrays.copyOfRange(sequence,0,i)); &#125; //递归判断右子树 boolean rightflag=true; if (i&lt;len-1) &#123; rightflag=VerifySquenceOfBST(Arrays.copyOfRange (sequence,i,sequence.length-1)); &#125; return leftflag &amp;&amp; rightflag; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【22】从上到下打印二叉树]]></title>
    <url>%2F2019%2F05%2F22-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 2.解题思路使用两个队列一个存放节点treelist，一个存放值intlist。 先将根节点root加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来,并将root值存入intlist,遍历结束条件是i值到达treelist.size-1 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; //创建一个列表用来存储节点 ArrayList&lt;TreeNode&gt; treelist=new ArrayList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; intlist=new ArrayList&lt;Integer&gt;(); if(root==null) //没有节点 return intlist; //1.先存入根节点 treelist.add(root); //2.循环遍历列表，一开始列表里存了root for(int i=0;i&lt;treelist.size();i++) &#123; TreeNode node=treelist.get(i); //3.如果左子节点不为空，则将节点加入列表 if(node.left!=null) treelist.add(node.left); //3、如果右子节点不为空，则将右子节点加入到列表中，这时列表的size加1 if(node.right!=null) treelist.add(node.right); intlist.add(node.val); //4、因为执行上面操作后会增加列表的si //因此可以继续循环下一个节点，直到循环完所有节点 &#125; return intlist; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【21】栈的压入、弹出]]></title>
    <url>%2F2019%2F05%2F21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 2.解题思路 依次入栈pushA数组中的数,直到pushA[i] =popA[index],此时将栈顶这个相等的值弹出。 判断栈中是否还有值，如果没有返回true,如果有并且index！=popA.length,依次弹出栈中数值，并与popA[index++]比较,两个不相等返回false,到栈为空时没执行false则返回true 3.代码12345678910111213141516171819202122232425public boolean IsPopOrder(int [] pushA,int [] popA) &#123; //用于pushA入栈 Stack&lt;Integer&gt; a = new Stack(); int index = 0; for(int i = 0;i&lt;pushA.length;i++)&#123; a.push(pushA[i]); //当遇到与popA[index]相等的数时，弹出该数 if(pushA[i] == popA[index])&#123; if(index++ == popA.length-1)&#123; return true; &#125; a.pop(); &#125; &#125; //栈中还有值，index还没到达popA尾部，依次弹出与popA比较 while (!a.isEmpty())&#123; if(a.pop()!=popA[index++])&#123; return false; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【20】包含min函数的栈]]></title>
    <url>%2F2019%2F05%2F20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[1.题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 2.解题思路 解题思路：利用辅助栈来存储现有栈的最小值。在入栈和出栈的时候将现有栈和最小值栈进行比较。(1)入栈时，若新值比最小值栈的栈顶还小，则将该值同时push到最小值栈； (2)出栈时，若现有栈的栈顶和最小值栈栈顶一致，则同时出栈，(3)否则，仅仅现有栈pop；通过这一操作，最小值栈的栈顶将永远是现有栈元素中的最下值。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; // 用于存储所有的数据，压入push,弹出pop Stack&lt;Integer&gt; data_stack =new Stack&lt;&gt;(); //用于存储栈最小的值 Stack&lt;Integer&gt; min_stack = new Stack&lt;&gt;(); public void push(int node) &#123; //如果最小值栈为空或者栈顶值比新入的node值大 if(min_stack.isEmpty()||min_stack.peek()&gt;=node)&#123; //压入node，保持栈顶为栈的最小值 min_stack.push(node); &#125;else &#123; //否则再次压入栈顶值 min_stack.push(min_stack.peek()); &#125; //数据都压入data_stack data_stack.push(node); &#125; //出栈 public void pop() &#123; if(data_stack.empty()||min_stack.empty()) &#123; return; &#125; //弹出数据 data_stack.pop(); //弹出min栈顶，此时min_stack的栈顶为弹出某数剩下数的最小值 min_stack.pop(); &#125; //查看栈的栈顶元素 public int top() &#123; if(!data_stack.isEmpty()) &#123; return data_stack.peek(); &#125; return 0; &#125; //查看最小的元素，即min_stack的栈顶 public int min() &#123; if(!min_stack.empty()) &#123; return min_stack.peek(); &#125; return 0; &#125; &#125; 补充stack.peek:获取栈顶元素，返回栈顶元素但是不移除它 stack.add:向栈中添加元素，成功返回true stack.push:向栈中添加元素，返回结果是当前添加的元素 stack.pop:移除并返回栈顶元素 stack.isEmpty:检查是否为空栈 stack.search(“value”):查看某元素再栈中的位置，计算从1开始]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【19】顺时针打印矩阵]]></title>
    <url>%2F2019%2F04%2F19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 2.解题思路 打印分为四步：循环的次数即打印的圈速，即 rows&gt;start*2&amp;&amp;column&gt;start*2 (1) 从左到右打印一行: 开始于[start,start]，结束于[start,col-start-1] (2) 从上到下打印一行, 开始于[start+1,col-start-1],结束于[col-start-1,col-start-1] (3) 从右到左打印一行 开始于[col-start-1,col-start-2],结束于[col-start-1,start] (4) 从下到上打印一行 开始于[col-start-2,start],结束于[start+1,start] 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; // 矩阵行数 int rows = matrix.length; // 矩阵列数 int columns = matrix[0].length; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 让循环继续的条件是当前行数大于该圈循环开始的行数的两倍以及当前列数大于 //该圈循环开始的列数的两倍（每圈循环开始的行数、列数相同） int start = 0; // 从(0,0)开始循环,圈数：start=0第一圈，start=1第二圈...以此类推 while (rows &gt; start * 2 &amp;&amp; columns &gt; start * 2)&#123; // 每一圈最后一行下标 int endRow = rows - 1 - start; // 每一圈最后一列下标 int endColumn = columns - 1 - start; // 开始一圈圈打印，每打印一圈分为四步，从左到右、从上到下、从右到左、从下到上 // 从左到右，第一步一定会走 for (int i = start; i &lt;= endColumn; i++) list.add(matrix[start][i]); // 从上到下，最后一行大于开始行 if (endRow &gt; start)&#123; for (int i = start + 1; i &lt;= endRow; i++) list.add(matrix[i][endColumn]); &#125; // 从右到左，最后一行大于开始行，最后一列大于开始列 if (endRow &gt; start &amp;&amp; endColumn &gt; start)&#123; for (int i = endColumn - 1; i &gt;= start; i--) list.add(matrix[endRow][i]); &#125; // 从下到上,至少是三行两列，也就是最后一行大于开始行加2，最后一列大于开始列 if (endRow &gt;= start + 2 &amp;&amp; endColumn &gt; start)&#123; for (int i = endRow - 1; i &gt; start; i--) list.add(matrix[i][start]); &#125; // 继续打印下一圈 start++; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【18】二叉树的镜像]]></title>
    <url>%2F2019%2F04%2F18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[1.题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 二叉树的镜像定义： 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 2.解题思路(1)镜像即左右子树交换位置，故交换左子树右子树位置 (2)交换后的左右子树的节点保持原来的顺序，故要交换左右子树自己的左右子树 (3)终止条件为root==null || root.left==null ||root.right == null 3.代码123456789101112131415161718192021222324252627282930313233/* public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125; */ public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root!=null&amp;&amp;(root.left!=null||root.right!=null))&#123; //这三句是左子树跟右子树交换 TreeNode tem=root.left; root.left=root.right; root.right=tem; //然后将根节点换成root.left Mirror(root.left); //然后将根节点换成root.right Mirror(root.right); &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【17】树的子结构]]></title>
    <url>%2F2019%2F04%2F17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 2.解题思路大体思路是首先判断B的根节点和A的根节点是否相同（这里的相同是指节点的值相同并且左右子节点相同），如果相同比较他们的左右子节点，这一步骤是相同的，可以用递归完成，直到B遍历到每个尾节点，如果这一过程比较的所有节点是相同的，则证明B是A的子结构。如果B的根节点和A的根节点不同，则A向他的左右子节点滑动，然后继续跟B的子节点比较，步骤同上。 (1) 如果root1.val==root2.val,那个就以这个为起点判断是否A包含B (2) 如果没找到，就以root1.left作为起点继续判断A是否包含B (3) 如果没找到，再以root1.right作为起点判断A是否包含B 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false if (root2 != null &amp;&amp; root1 != null) &#123; //如果找到了对应Tree2的根节点的点 if(root1.val == root2.val)&#123; //以这个根节点为为起点判断是否包含Tree2 result = doesTree1HaveTree(root1,root2); &#125; //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.left,root2); &#125; //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.right,root2); &#125; &#125; //返回结果 return result; &#125;public boolean doesTree1HaveTree(TreeNode node1, TreeNode node2) &#123; //如果Tree2已经遍历完了都能对应的上，返回true if (node2 == null) &#123; return true; &#125; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if (node1 == null) &#123; return false; &#125; //如果其中有一个点没有对应上，返回false if (node1.val != node2.val) &#123; return false; &#125; //如果根节点对应的上，那么就分别去子节点里面匹配 return doesTree1HaveTree(node1.left,node2.left) &amp;&amp; doesTree1HaveTree(node1.right,node2.right); &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【16】合并两个排序的链表]]></title>
    <url>%2F2019%2F04%2F16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 例： 链表1： 1 ----&gt; 3 ----&gt; 5 ----&gt; 8 链表2： 2 ----&gt; 4 ----&gt; 6 ----&gt; 7 合并结果： 1 ----&gt; 2 ----&gt; 3 ----&gt; 4 ----&gt; 5 ----&gt; 6 ----&gt; 7 ----&gt; 8 2.解题思路 判断有没有ListNode是空的，如果有则返回另一个 递归实现，如果List1.val&lt;list2.val,pMergeHead = list1,否则pMergeHead = list2，递归直到两个ListNode都为空 3.代码123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1==null)&#123; return list2; &#125;else if(list2==null)&#123; return list1; &#125; ListNode pMergeHead = null; if(list1.val&lt;list2.val)&#123; pMergeHead = list1; pMergeHead.next = Merge(list1.next,list2); &#125;else&#123; pMergeHead = list2; pMergeHead.next = Merge(list1,list2.next); &#125; return pMergeHead; &#125;&#125;i]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【15】反转链表]]></title>
    <url>%2F2019%2F04%2F15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，反转链表后，输出新链表的表头。 2.解题思路 用一个栈stack依次存储ListNode里面的值，因为stack的特点是先进后出，故依次弹出即为反转链表 用一个链表temp依次存储弹出的值，依次next存入下一个链表值，链表res指向这个temp的头节点 反转链表的结果为res.next,因为我们之前设temp的头节点为-1（自己设的）。 3.代码123456789101112131415161718192021222324252627 /* public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; */import java.util.*; public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (head!=null)&#123; stack.push(head.val); head = head.next; &#125; ListNode temp = new ListNode(-1); ListNode res = temp; while(stack.size()!=0)&#123; temp.next = new ListNode(stack.pop()); temp = temp.next; &#125; return res.next; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【14】链表中倒数第K个结点]]></title>
    <url>%2F2019%2F04%2F14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，输出该链表中倒数第k个结点。 2.解题思路 先用一个count计算出链表的长度，如果count&lt;k，返回null 链表的倒数第K个即为链表的正数（count-k+1）个,一个for循环，将指针轮询倒那个点，然后再将起后面截断（head.next = null）即可。 3.代码1234567891011121314151617181920212223242526272829/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode root = head; int count = 0; while(root!=null)&#123; count ++; root = root.next; &#125; if(count&lt;k)&#123; return null; &#125; //倒数第K个即正数第（count-k+1）个 for(int i = 1;i&lt;(count-k+1);i++)&#123; head = head.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【13】调整数值顺序使奇数位于偶数前面]]></title>
    <url>%2F2019%2F04%2F13-%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 2.解题思路依次遍历array数组，遇到奇数存到原来的array数组前面，遇到偶数放到res数组，然后将两个数组拼接即可。 3.代码1234567891011121314151617181920public class Solution &#123; public void reOrderArray(int [] array) &#123; int []res = new int[array.length]; int count = 0; int count2 = 0; for(int i = 0;i&lt;array.length;i++)&#123; //如果是奇数，则放在数组前面 if(array[i]%2 != 0)&#123; array[count++] = array[i]; &#125;else&#123; //偶数放在另一个数组里 res[count2++] = array[i]; &#125; &#125; int j = 0; for(int i = count;i&lt;array.length;i++)&#123; array[i] = res[j++]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【12】数值的整数次方]]></title>
    <url>%2F2019%2F04%2F12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方 2.解题思路 （1）exponent &gt; 0,如2^3,则可以直接运算得出结果 （2）exponent &lt; 0,如2^-3,则结果为（1/2）^3 （3）exponent = 0,如2^0,则结果为1 3.代码123456789101112131415161718192021public class Solution &#123; public double Power(double base, int exponent) &#123; if(exponent&lt;0)&#123; return powCal(1.0/base,-1*exponent); &#125;else if(exponent&gt;0)&#123; return powCal(base,exponent); &#125;else&#123; return 1; &#125; &#125; //计算base的exponent次方 public double powCal(double base, int exponent) &#123; double res = 1; for(int i = 0;i&lt;exponent;i++)&#123; res = res*base; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【11】二进制中1的个数]]></title>
    <url>%2F2019%2F04%2F11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 2.解题思路 方法1：直接将其转成二进制数组 方法2：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。 3.代码方法1： 1234567891011121314public class Solution &#123; public int NumberOf1(int n) &#123; int count=0; char []a=Integer.toBinaryString(n).toCharArray(); for(int i=0;i&lt;a.length;i++) &#123; if(a[i]=='1') &#123; count++; &#125; &#125; return count; &#125;&#125; 方法2： 123456789101112131415public class Solution &#123; public static int NumberOf(int n) &#123; int count = 0; while (n &gt; 0) &#123; count++; n = (n - 1) &amp; n; &#125; return count; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【10】矩形覆盖]]></title>
    <url>%2F2019%2F04%2F10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[1.题目描述 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 2.解题思路类似于青蛙跳台阶 当 n = 1时，只有一种横向排列的方式 当 n = 2时，有两种选择，横向或者竖向 当 n = 3时，如果选择竖向，则还剩下2*2的排列，如果选择横向，只有一种选择方案(剩下的一个横向一个竖向) 递推可得F(2 * n) = F(2 * (n-1))+F(2 * (n-2) ) , n&gt;=3 3.代码1234567891011public class Solution &#123; public int RectCover(inttarget) &#123; if(target &lt;=0)&#123; return0; &#125; elseif(target ==1|| target == 2)&#123; returntarget; &#125; return(RectCover(target-1)+RectCover(target-2)); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【9】变态跳台阶]]></title>
    <url>%2F2019%2F04%2F9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[1.题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 2.解题思路123456789101112131415161718//f(0) = 0//f(1) = 1//f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。//f(3) = f(3-1) + f(3-2) + f(3-3) ...//f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)/*说明：1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。2）n = 1时，只有1种跳法，f(1) = 13) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1)6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： f(n-1) =f(0)+f(1)+f(2)+f(3)+...+f((n-1)-1) =f(0)+f(1)+f(2)+f(3)+...+f(n-2) f(n) =f(0)+f(1)+f(2)+f(3)+...+f(n-2)+f(n-1)=f(n-1)+f(n-1)可以得出：f(n) = 2*f(n-1)*/ 3.代码1234567891011public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;=0)&#123; return 0; &#125;else if(target==1)&#123; return 1; &#125;else&#123; return 2*JumpFloorII(target-1); &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【8】跳台阶]]></title>
    <url>%2F2019%2F04%2F8-%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[1.题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 2.解题思路 把n级台阶的跳的次数看成是n的函数,即为f(n),当n&gt;2时,第一次跳有两种跳法, 第一次跳1级,则该次跳法数目为后面剩下的n-1级台阶的跳法数目f(n-1)。 第一次跳2级,则该次跳法数目为后面剩下的n-2级台阶的跳法数目f(n-2)。 所以f(n)=f(n-1)+f(n-2),即相当于斐波那契数列。` 即该题跟斐波那契数列是相似的，青蛙跳台阶的公式为 F(n) = F(n-1)+F(n-2),n&gt;=3 3.代码1234567891011121314151617181920public class Solution &#123; public int JumpFloor(int target) &#123; if(target&lt;=2) &#123; return target; &#125; int one_=1; //第一次跳台阶的方法数 int two_=2; //第二次跳台阶的方法数 int finN=0; for(int i=3;i&lt;=target;i++) &#123; finN=one_+two_; one_=two_; two_=finN; &#125; return finN; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【7】斐波那契数组]]></title>
    <url>%2F2019%2F04%2F7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1.题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 斐波那契数列：1 1 2 3 5 8 13 21 34 …. 2.解题思路 斐波那契数列：从第三项开始，每一项都等于前两项之和。通项公式为 F(n) = F(n-1)+F(n-2),n&gt;=3 方法1：通过递归实现，但是时间复杂度和空间复杂度都会很大 方法2：依次F(n-1)和F(n-2)值，求F(n)就很简单啦 3.代码方法一： 1234567891011public class Solution &#123; public int Fibonacci(int n) &#123; if(n==0) return 0; else if(n==1 || n==2) return 1; else return (Fibonacci(n-1)+Fibonacci(n-2)); &#125;&#125; 方法2： 1234567891011121314151617181920212223public class Solution &#123; public int Fibonacci(int n) &#123; if (n==0) return 0; if(n==1||n==2) return 1; int one_ = 1; //用于存储f(n-2) int two_ =1; //用于存储f(n-1) int fin = 0; for(int i = 3;i&lt;=n;i++)&#123; fin = one_+two_; //向前递推 one_ = two_; //下一次的f(n-2)为 上一次结果的f(n-1) two_ = fin; //下一次的f(n-1)为 上一次结果的fin &#125; return fin; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【6】旋转数组的最小数字]]></title>
    <url>%2F2019%2F04%2F6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1. 题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 2.解题思路 方法1：重头到尾遍历，找到数组的最小值，时间复杂度为O(N) 方法2：二分遍历查找 mid = low +(high-low)/2; 需要考虑三种情况： arr[mid] &gt; arr[high],如[3,4,5,1,2]说明最小数字在mid的右边，缩小范围，low = mid+1; arr[mid]&lt;arr[high],如[1,2,3,4,5]说明最小数字在mid的左边，high = mid-1; arr[mid] = arr[high],如[0,1,1,1,1]或者[1,1,1,0,1],一步步缩小范围，high = high-1; 3.代码123456789101112131415161718192021222324252627import java.util.ArrayList;public class Solution &#123; public static int minNumberInRotateArray(int[] arr)&#123; int low = 0; int high = arr.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(arr[mid] &gt; arr[high])&#123; low = mid + 1; &#125;else if(arr[mid] == arr[high])&#123; high = high - 1; &#125;else&#123; high = mid; &#125; &#125; return arr[low]; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【5】两个栈实现队列]]></title>
    <url>%2F2019%2F04%2F5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1. 题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 2. 解题思路 栈的规则是先进后出，队列的规则是先进先出 stack1一直维持着栈底–栈顶是队列的入队顺序 stack2一直维持着栈顶–栈尾为队列的入队顺序 当执行队列的入队（push）时，如果stack2为空，则直接插入到stack1,stack1从栈底到栈顶的顺序为入队顺序，如果stack2不为空，则将stack2的元素倒入（栈顶—栈尾）stack1,然后再插入数据 4- 当执行队列的出队(pop)操作时，应该出的是stack1的栈底元素，故将stack1依次倒入stack2,这时stack2的栈顶就是要出队的数值，此时stack1为空，stack2从（栈顶–栈尾）为入队顺序 3. 代码12345678910111213141516171819202122232425262728public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //队列的入队 public void push(int node) &#123; //将stack2倒入stack1 while (!stack2.empty()) &#123; stack1.push(stack2.pop()); &#125; //将元素插入stack1 stack1.push(node); &#125; //队列的出队 public int pop() &#123; //将stack1倒入stack2 while (!stack1.empty()) &#123; stack2.push(stack1.pop()); &#125; //stack2的栈顶就是出队数值 return stack2.pop(); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【4】重建二叉树]]></title>
    <url>%2F2019%2F04%2F4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 2.解题思路 先序遍历为：根-&gt;左子树-&gt;右子树，中序遍历为左子树-&gt;根-&gt;右子树 先找到根结点，为先序遍历的第一个数值 根据这个数值，可以划分中序中的左子树和右子树范围 递归构建左子树和右子树 3.代码12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Arrays;//** * Definition for binary tree public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length==0 || in.length==0) return null; TreeNode node = new TreeNode(pre[0]); //根结点 for(int i=0;i&lt;pre.length;i++)&#123; //找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点 if(pre[0] == in[i])&#123; //递归构建左子树，此时前序的范围缩小为[1,i+1),中序缩小为[0,i) node.left =reConstructBinaryTree(Arrays.copyOfRange (pre,1,i+1),Arrays.copyOfRange(in,0,i)); //递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len) node.right = reConstructBinaryTree(Arrays.copyOfRange (pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length)); break; &#125; &#125; return node; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【3】从尾到头打印链表]]></title>
    <url>%2F2019%2F04%2F3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 2.解题思路 先用一个栈stack存储从头到尾的链表数值 再依次弹出，因为栈是先进后出的，故弹出的结果为从尾到头 将弹出的结果放入list返回 3.代码123456789101112131415161718192021222324252627282930public class Main_3 &#123; public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; public static class Solution &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); public static ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) &#123; list.add(stack.pop()); &#125; return list; &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-15:三数之和]]></title>
    <url>%2F2019%2F04%2Fleetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述：给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 2.解题思路 首先按升序排序；然后定义下标变量i,j,k，因为是三元组，所以要三个变量如果简单的遍历，那么跟是否有序没有关系，其时间复杂度将达到O(n^3)。仔细想想：如果当前选择了a、b、c三个数，如果其和小于目标target，那么需要将其中一个数用更大的数替换；反之亦然。但究竟替换三个数中的哪个数？无法确定就只能先固定两个变量，让其第三个变化（替换）。一种办法是：固定前两个数i,j，然后让k在一个范围中二分变化（二分查找思想） 3.代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); List&lt;Integer&gt; targets = new ArrayList&lt;&gt;(); // 用于去重 if((nums.length&gt;0 &amp;&amp; nums.length&lt;3) ||(nums.length&gt;0 &amp;&amp;nums[0]&gt;0)) return list; for(int i = 0;i&lt;=nums.length-3;i++) &#123; int target = 0 - nums[i]; if (!targets.contains(target)) &#123; //用于去重 targets.add(target); int k = i + 1; int j = nums.length - 1; while (k &lt; j) &#123; if (nums[k] + nums[j] == target) &#123; List&lt;Integer&gt; li = new ArrayList(); li.add(nums[i]); li.add(nums[k]); li.add(nums[j]); list.add(li); while (k &lt; j &amp;&amp; nums[k] == nums[k + 1]) ++k; while (k &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j; k++; j--; &#125; else if (nums[k] + nums[j] &lt; target) &#123; k++; &#125; else &#123; j--; &#125; &#125; &#125; &#125; return list; &#125;&#125; 4.我的提交记录]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【2】空格替换]]></title>
    <url>%2F2019%2F04%2F2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1. 题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 2. 解题思路 方法1：利用函数replaceAll完成 方法2： **先计算需要多少的空间 **从后向前依次插入 3.代码方法1： 12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll(" ", "%20"); &#125;&#125; 方法2： 12345678910111213141516171819202122232425262728public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int spacenum = 0;//spacenum为计算空格数 for(int i=0;i&lt;str.length();i++)&#123; if(str.charAt(i)==' ') spacenum++; &#125; //indexold为为替换前的str下标 int indexold = str.length()-1; //计算空格转换成%20之后的str长度 int newlength = str.length() + spacenum*2; //indexold为为把空格替换为%20后的str下标 int indexnew = newlength-1; //使str的长度扩大到转换成%20之后的长度,防止下标越界 str.setLength(newlength); for(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; if(str.charAt(indexold) == ' ')&#123; str.setCharAt(indexnew--, '0'); str.setCharAt(indexnew--, '2'); str.setCharAt(indexnew--, '%'); &#125;else&#123; str.setCharAt(indexnew--, str.charAt(indexold)); &#125; &#125; return str.toString(); &#125;&#125; 补充1：String和StringBuffer的转换String转换成StringBuffer 12String str = "abc";StringBuffer b=new StringBuffer(str); StringBuffer转换成String 12StringBuffer a=new StringBuffer();String b=a.toString(） 补充2：String、StringBuffer、StringBuilder 1）运行速度StringBuilder&gt;StringBuffer&gt;String 2）String是字符串常量，String对象一旦创建就不能更改。StringBuffer为 字符串变量，可更改 3） String适用于少量的字符串操作，StringBuffer适用于多线程下字符缓冲区进行大量操作的情况。 4） StringBuffer 与 StringBuilder 中的方法和功能完全是等价的， 5） 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 6） 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而StringBuffer则每次都需要判断锁，效率相对更低。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【1】二维数组的查找]]></title>
    <url>%2F2019%2F04%2F1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[1.题目描述： 在一个二维数组中（每个一维数组的长度相同），如数组 1 2 3 4 5 6 7 8 9 每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 2.解题思路 选择右上角的数字作为开始点 如果array[row][col]&gt;target,则向左查找，col–； 如果array[row][col]&lt;target,则向下查找，row++； 3.代码123456789101112131415161718public class Solution &#123; public boolean Find(int target, int [][] array) &#123; boolean res = false; int row = 0; int col = array[0].length-1; while(row&lt;=array.length-1&amp;&amp;col&gt;=0)&#123; if(array[row][col]&gt;target)&#123; col--; &#125;else if(array[row][col]&lt;target)&#123; row++; &#125;else&#123; res = true; break; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
</search>
