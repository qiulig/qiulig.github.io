<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表反转</title>
      <link href="/2019/06/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/06/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>以链表 1-&gt;2-&gt;3-&gt;4  为例子：</p><ul><li>程序到达Node newHead = reverse(head.next);时进入递归</li><li>我们假设此时递归到了3结点，此时head=3结点，temp=3结点.next(实际上是4结点)<a id="more"></a></li><li>执行Node newHead = reverse(head.next);传入的head.next是4结点，返回的newHead是4结点。</li><li>接下来就是弹栈过程了<ul><li>程序继续执行 temp.next = head就相当于4-&gt;3</li><li>head.next = null 即把 3结点指向4结点的指针断掉。</li><li>返回新链表的头结点newHead</li></ul></li></ul><blockquote><p>注意：当retuen后，系统会恢复2结点压栈时的现场，此时的head=2结点；temp=2结点.next(3结点)，再进行上述的操作。最后完成整个链表的翻转。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode temp = head.next;</span><br><span class="line">    ListNode newHead = reverse(head.next);</span><br><span class="line">    temp.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h3><p>依旧是1-&gt;2-&gt;3-&gt;4</p><ul><li>准备两个空结点 pre用来保存先前结点、next用来做临时变量</li><li>在头结点node遍历的时候此时为1结点<ul><li>next = 1结点.next(2结点)</li><li>1结点.next=pre(null)</li><li>pre = 1结点</li><li>node = 2结点</li></ul></li><li>进行下一次循环node=2结点<ul><li>next = 2结点.next(3结点)</li><li>2结点.next=pre(1结点)=&gt;即完成2-&gt;1</li><li>pre = 2结点</li><li>node = 3结点</li></ul></li><li>进行循环…</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   ListNode next;</span><br><span class="line">   ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">       ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">       ListNode cur = node;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode next = cur.next;  <span class="comment">//将下一个节点记录</span></span><br><span class="line">           cur.next = pre;  <span class="comment">//当前节点指向上一个节点</span></span><br><span class="line">           pre = cur;   <span class="comment">//记录当前节点</span></span><br><span class="line">           cur = next; <span class="comment">//将下一个节点变成当前节点</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【203】移除链表元素</title>
      <link href="/2019/06/leetcode-203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2019/06/leetcode-203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>删除链表中等于给定值 <strong><em>val</em></strong> 的所有节点。<a id="more"></a></p><p><strong>示例:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, <strong><em>val</em></strong> = 6<br><strong>输出:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：</p><pre><code>如果当前链表值head.val不等于val,则新建一个节点放到ans后面如果相等，则跳到链表下一个。</code></pre><p>方法2：</p><pre><code>遇到相等则跳指针 要考虑好头节点跟val相等的情况。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：新建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">          ListNode ans = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">          ListNode res = ans;</span><br><span class="line">          <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(head.val==val)&#123;</span><br><span class="line">                  head = head.next;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  ans.next =<span class="keyword">new</span> ListNode(head.val) ;</span><br><span class="line">                  ans = ans.next;</span><br><span class="line">                  head = head.next;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>方法2：跳指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//如果头节点与val相同</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.val == val)</span><br><span class="line">            head = head.next;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【120】三角形最小路径和</title>
      <link href="/2019/06/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2019/06/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><a id="more"></a><p>例如，给定三角形：</p><p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划：</p><p> 每一层的值加上上一层的值中最小值，最后取最后一层的最小值就好了</p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;     [<span class="number">2</span>]                             [<span class="number">2</span>]</span><br><span class="line">&gt;    [<span class="number">3</span>,<span class="number">4</span>]         变成               [<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&gt;   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>]                        [<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>]</span><br><span class="line">&gt;  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]                      [<span class="number">15</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">16</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> len = triangle.get(triangle.size()-<span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="comment">//初始化第一层跟第二层</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>]+triangle.get(<span class="number">1</span>).get(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">0</span>] + triangle.get(<span class="number">1</span>).get(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//第一列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;= i ;j++)&#123;</span><br><span class="line">                <span class="comment">//最后一个数的dp,因为上一层比下一层少一个，所以只能最后一个数只能加上上一层的最后一个dp</span></span><br><span class="line">                <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j) + dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = triangle.get(i).get(j)+ Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三角形最后一层中的最小值就是最小路径</span></span><br><span class="line">        <span class="keyword">int</span> res = dp[len-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[len-<span class="number">1</span>][i] &lt; res)&#123;</span><br><span class="line">                res = dp[len-<span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/120.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【95】不同的二叉搜索树2</title>
      <link href="/2019/06/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/"/>
      <url>/2019/06/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出:<br>[<br>  [1,null,3,2],<br>  [3,2,null,1],<br>  [3,1,null,null,2],<br>  [2,1,3],<br>  [1,null,2,null,3]<br>]<br>解释:<br>以上的输出对应以下 5 种不同结构的二叉搜索树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>        <span class="number">3</span>      <span class="number">3</span>      <span class="number">2</span>        <span class="number">1</span></span><br><span class="line">&gt;  \      /      /      / \        \</span><br><span class="line">&gt;  <span class="number">3</span>     <span class="number">2</span>      <span class="number">1</span>      <span class="number">1</span>   <span class="number">3</span>        <span class="number">2</span></span><br><span class="line">&gt;  /    /        \                   \</span><br><span class="line">&gt;  <span class="number">2</span>   <span class="number">1</span>          <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1)当n = 1时，此时只有一个以1为根节点的二叉搜索树</p><p>(2) 当n &gt; 1时，当以 i 为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，依次递归遍历，分别放到left和right列表中，然后再先序遍历放入res结果中。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//n = 1 的情况，只有一个，就是根节点为1的二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                TreeNode node = <span class="keyword">new</span> TreeNode(start);</span><br><span class="line">                list.add(node);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以 i 为根节点，左子树为start~(i-1),右子树为(i+1)~n</span></span><br><span class="line">            List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                List&lt;TreeNode&gt; left = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                List&lt;TreeNode&gt; right = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (i != start) &#123;</span><br><span class="line">                    <span class="comment">//说明有左子树</span></span><br><span class="line">                    left = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != end) &#123;</span><br><span class="line">                    <span class="comment">//说明有右子树</span></span><br><span class="line">                    right = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//先序遍历存入res里面</span></span><br><span class="line">                <span class="keyword">if</span> (!left.isEmpty() &amp;&amp; !right.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode l : left) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (TreeNode r : right) &#123;</span><br><span class="line">                            TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                            root.left = l;</span><br><span class="line">                            root.right = r;</span><br><span class="line">                            res.add(root);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!left.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode l : left) &#123;</span><br><span class="line">                        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        root.left = l;</span><br><span class="line">                        res.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!right.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode r : right) &#123;</span><br><span class="line">                        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                        root.right = r;</span><br><span class="line">                        res.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees=generate(start,i-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归遍历右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees=generate(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//先序遍历存入以i为根节点的二叉搜索树</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left:leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right:rightTrees)&#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left=left;</span><br><span class="line">                    root.right=right;</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/95.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【96】不同二叉搜索树</title>
      <link href="/2019/06/leetcode-96-%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2019/06/leetcode-96-%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><a id="more"></a><p>示例:</p><p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span>      <span class="number">3</span>     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">&gt;  \     /    /     / \     \</span><br><span class="line">&gt;  <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>     <span class="number">1</span>   <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">&gt;  /   /      \               \</span><br><span class="line">&gt;  <span class="number">2</span>  <span class="number">1</span>        <span class="number">2</span>               <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划：</p><p>(1)初始化</p><pre><code>n  = 1时，只含有1，1作为根节点，此时二叉搜索数个数为1；</code></pre><p>(2) 算法</p><pre><code>    （1）假设n个节点存在二叉排序树的个数是dp[i]，令f[i]为以i为根的二叉搜索树的个数，则                dp[n] = f[1] + f[2] + f[3] + f[4] + ... + f[n]     （2）当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则                f [i]  = dp[i-1] * dp[n-i]综合两个公式可以得到卡特兰数公式</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  dp[n] = dp[<span class="number">0</span>] * dp[n-<span class="number">1</span>] + dp[<span class="number">1</span>] * dp[n-<span class="number">2</span>]+...+dp[n-<span class="number">1</span>] * dp[<span class="number">0</span>]</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * C(<span class="number">2</span>n,n)</span><br><span class="line">&gt;        = dp[n-<span class="number">1</span>] * (<span class="number">4</span>*n-<span class="number">2</span>)/(n-<span class="number">1</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n个节点存在二叉树的个数</span></span><br><span class="line">        <span class="keyword">long</span> []dp = <span class="keyword">new</span> <span class="keyword">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//以i为根节点的二叉树个数</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]*(<span class="number">4</span>*i-<span class="number">2</span>)/(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/96.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【70】爬楼梯</title>
      <link href="/2019/06/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2019/06/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><a id="more"></a><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li><p>2 阶</p><p>示例 2：</p></li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><p>初始化：</p><pre><code>可知dp[0]  = 0;dp[1] = 1;dp[2] = 2;即跳0级有一种方法，一级有1种方法，2级有2种方法</code></pre><p>算法核心：</p><pre><code>dp[i] = dp[i-1] +dp[i-2] ,即爬i阶台阶的方法等于爬i-2阶台阶的方法加上爬i-1阶台阶的方法</code></pre><p>方法2：</p><pre><code>剑指offer第8题</code></pre><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n ;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;=n ;i++)&#123;</span><br><span class="line">            res = one + two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/70.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【64】最小路径和</title>
      <link href="/2019/06/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2019/06/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><a id="more"></a><p>示例:</p><p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果数组只有一个数，则路径最小即为该值，dp[0][0] = 0;</p><p> (1)动态规划初始化</p><pre><code>1)只有一行，则路径总和最小为 dp[0][i] = dp[0][i-1] + grid[0][i];2)只有一列，则路径总和最小为 dp[i][0] = dp[i-1][0] + grid[i][0];</code></pre><p>(2) 动态规划核心算法</p><p>  每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：</p><pre><code>dp[i][j] = grid[i][j] + min( dp[i-1][j] , dp[i][j-1]);</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划核心</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                dp[i][j] = grid[i][j]+(dp[i-<span class="number">1</span>][j]&lt;dp[i][j-<span class="number">1</span>]?dp[i-<span class="number">1</span>][j]:dp[i][j-<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/64.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【63】不同路径2</title>
      <link href="/2019/06/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/"/>
      <url>/2019/06/leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><a id="more"></a><p>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>如果第一个格点 obstacleGrid[0][0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。</p><p>如果 obstacleGrid[0][0] 是 0，我们初始化这个值为 1 然后继续算法。<br>(1)动态规划初始化</p><pre><code>1)obstacleGrid[0][0] == 0,表示没障碍，路径只有一条；dp[0][0] = 1;2)遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[0][j] = dp[0][j-1]。             3)遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，  设值为 0 ；否则设这个值是前一个节点的值dp[i][0] = obstacleGrid[i-1][0]。</code></pre><p>(2) 动态规划核心算法</p><pre><code>从 obstacleGrid[1][1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 dp[i][j] = dp[i-1][j] + dp[i][j-1]。如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> col = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;col;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span> ? <span class="number">0</span> : dp[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>? <span class="number">0</span>:dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                    dp[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/63.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【62】不同的路径</title>
      <link href="/2019/06/leetcode-62-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/06/leetcode-62-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>动态规划</p><p>（1）初始化</p><pre><code>1) 从[0,0]走到[0,0]的路径，即没走，设dp[0][0] = 0;2) 如果m*n的n为1，即机器人在m*1走，只能有一条路径，即arr[i][0] = 1;3) 如果m*n的m为1，即机器人在1*n走，只能有一条路径，即arr[0][1] = 1;</code></pre><p>(2) 动态规划核心算法</p><pre><code>机器人每次只能向下或者向右移动一步。即机器人arr[i][j]的路径由arr[i-1][j]和arr[i][j-1]决定，即arr[i][j] = arr[i-1][j]+arr[i][j-1];</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j]+arr[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/62.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【53】最大子序和</title>
      <link href="/2019/06/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
      <url>/2019/06/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：动态规划</p><blockquote><ol><li>定义一个函数f(n)，以第n个数为结束点的子数列的最大和，存在一个递推关系f(n) = max(f(n-1) + A[n], A[n]);</li><li>将这些最大和保存下来后，取最大的那个就是，最大子数组和。因为最大连续子数组 等价于 最大的以n个数为结束点的子数列</li></ol></blockquote><p>方法2：</p><blockquote><p>用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。</p><pre><code>(1)当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令    cur = 0.表示从下一个数开始累加。(2)当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最    大值即可。</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        ans[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = ans[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//依次求出以第n个数为结束点的子序列最大和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            ans[i] = Math.max(ans[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="comment">//求出最大和</span></span><br><span class="line">            res = Math.max(res,ans[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>||nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            cur = cur + nums[i];</span><br><span class="line">            ans = Math.max(cur,ans);</span><br><span class="line">            cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交结果"><a href="#4-提交结果" class="headerlink" title="4.提交结果"></a>4.提交结果</h3><p><img src="https://github.com/qiulig/IMG/raw/master/53_1.jpg" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/53_2.jpg" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【264】丑数2</title>
      <link href="/2019/06/leetcode-264-%E4%B8%91%E6%95%B02/"/>
      <url>/2019/06/leetcode-264-%E4%B8%91%E6%95%B02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>编写一个程序，找出第  <code>n</code>  个丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code>  的<strong>正整数</strong>。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> n = 10<br><strong>输出:</strong> 12</p><a id="more"></a><p><strong>解释:</strong> <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> 是前 10 个丑数。</p><p><strong>说明:</strong></p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>剑指offer-【33】</p><p>丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an</p><p>所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2<em>a1, 2</em>a2, 2*a3 …..</p><p>包含3的有序丑数序列:3<em>a1, 3</em>a2, 3<em>a3 ….. 包含5的有序丑数序列:5</em>a1, 5<em>a2, 5</em>a3 …..</p><p>以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr[i] =Math.min(Math.min(arr[t2]*<span class="number">2</span>,arr[t3]*<span class="number">3</span>),arr[t5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr[t2]*<span class="number">2</span> == arr[i])&#123;</span><br><span class="line">                t2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[t3]*<span class="number">3</span> == arr[i])&#123;</span><br><span class="line">                t3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[t5]*<span class="number">5</span> == arr[i])&#123;</span><br><span class="line">                t5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/264.png" alt="丑数2"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【263】丑数</title>
      <link href="/2019/06/leetcode-263-%E4%B8%91%E6%95%B0/"/>
      <url>/2019/06/leetcode-263-%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 6<br><strong>输出:</strong> true<br><strong>解释:</strong> 6 = 2 × 3</p><a id="more"></a><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 8<br><strong>输出:</strong> true<br><strong>解释:</strong> 8 = 2 × 2 × 2</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 14<br><strong>输出:</strong> false<br><strong>解释:</strong> <code>14</code> 不是丑数，因为它包含了另外一个质因数 <code>7</code>。</p><p><strong>说明：</strong></p><ol><li><code>1</code> 是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</li></ol></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>丑数只能被2，3，5整除，所以丑数为2*i+3*j+5*k = num[i,j,k为任意整数]</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">3</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>) &#123;</span><br><span class="line">             num/=<span class="number">5</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> num==<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/263.png" alt="丑数"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【23】合并K个排序链表</title>
      <link href="/2019/06/leetcode-23%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/06/leetcode-23%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><p><strong>输入:</strong><br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br><strong>输出:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：</p><pre><code>(1)利用priorityQueue的性质，每放一个数字进去就给你从小到大排好序了(2)队列的性质是先进先出，故依次poll出来就是从小到大的顺序，将该数值放到listNode里面即可。</code></pre><p>方法2：</p><pre><code>借用合并两个链表的代码，依次将list[]分成两部分，在分别合并，执行用时为6ms</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode ans = res;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//将所有节点的值放到一个queue里面从小到大排好序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; lists.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(lists[i]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(lists[i].val);</span><br><span class="line">                lists[i] = lists[i].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次建立链表</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            res.next = <span class="keyword">new</span> ListNode(queue.poll());</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将一半的链表放到l1里面</span></span><br><span class="line">        <span class="keyword">int</span> mid = lists.length/<span class="number">2</span>;</span><br><span class="line">        ListNode[] l1 = <span class="keyword">new</span> ListNode[mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++)&#123;</span><br><span class="line">            l1[i] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将一半的链表放到l2里面</span></span><br><span class="line">        ListNode[] l2 = <span class="keyword">new</span> ListNode[lists.length-mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid,j=<span class="number">0</span>; i &lt; lists.length; i++,j++)&#123;</span><br><span class="line">            l2[j] = lists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归实现多个链表的排序</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(mergeKLists(l1),mergeKLists(l2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方式实现两个链表排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            head.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            head.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/23.jpg" alt="合并K个排序的链表"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 困难 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【21】合并两个有序链表</title>
      <link href="/2019/06/leetcode-21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/06/leetcode-21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例：</strong></p><p><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1) 判断是否有空链表，如果有则直接返回另一个不为空有序链表</p><p>(2) 依次判断是否有对应链表大小，小的加入res链表，并移动</p><p>注：该题与剑指offer-[16]题一致，还可以用递归。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span> &amp;&amp;l2!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span> &amp;&amp; l1!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            ListNode ans = res;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//哪个小添加哪个</span></span><br><span class="line">                <span class="keyword">if</span>(l1.val&gt;l2.val)&#123;</span><br><span class="line">                    res.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将剩下的没便利完的加入</span></span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                res = res.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/21.png" alt="合并有序链表"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【19】删除链表的倒数第N个节点</title>
      <link href="/2019/06/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2019/06/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong><em>n</em> = 2</strong>.</p><p>当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p><p><strong>说明：</strong></p><p>给定的  <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>双指针</p><p>(1)第一个指针curNode先走n步</p><p>(2)然后第二个指针preNode再重头跟刚刚第一个指针curNode走,直到走到尾部【preNode走了(len-N)步,即下一个节点就是要删除的节点】</p><p>(3)此时的preNode的下一个即为倒数第N个节点，将其删除即可</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode preNode = head;</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        <span class="comment">//第一个指针先走n步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> preNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个指针同时走，走剩下的（Len-n）步，此时preNode的下一个就是要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (curNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preNode = preNode.next;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除倒数第N个节点</span></span><br><span class="line">        preNode.next = preNode.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/19.jpg" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【434】字符串中的单词数</title>
      <link href="/2019/06/leetcode-434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
      <url>/2019/06/leetcode-434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p><strong>示例:</strong></p><p><strong>输入:</strong> “Hello, my name is John”<br><strong>输出:</strong> 5</p><a id="more"></a></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>每次出现非空字符，看看上一个是不是空格，如果是，发现一个新单词</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> lastIsBlank = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                lastIsBlank = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastIsBlank) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIsBlank = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/434.png" alt="字符串中的单词数"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【13】罗马数字转整数</title>
      <link href="/2019/06/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2019/06/leetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th><strong>字符</strong></th><th><strong>数值</strong></th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。<a id="more"></a></p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “III”<br><strong>输出:</strong> 3</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “IV”<br><strong>输出:</strong> 4</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “IX”<br><strong>输出:</strong> 9</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> “LVIII”<br><strong>输出:</strong> 58<br><strong>解释:</strong> L = 50, V= 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> “MCMXCIV”<br><strong>输出:</strong> 1994<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>通常情况下，<strong>罗马数字中小的数字在大的数字的右边</strong>。这句话很关键，意思是要变成罗马数字，必须先排列大的数</p><p>（1）res初始化为字符串的最后一个字符所代表的数字</p><p>（2）从字符串数组尾部开始遍历，</p><pre><code>1)如果下一个字符所代表的数字小于当前字符所代表的数字，则res减去下一个字符所代表的数字：如IV,下一个字符I所代表数字1&lt;当前字符所代表数字5，res = res-12)如果下一个字符所代表的数字大于当前字符所代表的数字，则res加上下一个字符所代表的数字如VI,下一个字符V 所代表数字5&gt;当前字符I所代表数字1,res = res+5</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'I'</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">int</span> res = map.get(s.charAt(s.length()-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//罗马数字中大的数字在小的数字的右边，用减法</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(s.charAt(i))&gt;map.get(s.charAt(i-<span class="number">1</span>)))&#123;</span><br><span class="line">                res -=map.get(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//罗马数字中小的数字在大的数字的右边，用加法</span></span><br><span class="line">                res +=map.get(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/13.png" alt="罗马数字转整数"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【12】整数转罗马数字</title>
      <link href="/2019/06/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
      <url>/2019/06/leetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><table><thead><tr><th style="text-align:center"><strong>字符</strong></th><th style="text-align:center"><strong>数值</strong></th></tr></thead><tbody><tr><td style="text-align:center">I</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">500</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><a id="more"></a><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 3<br><strong>输出:</strong> “III”</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 4<br><strong>输出:</strong> “IV”</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 9<br><strong>输出:</strong> “IX”</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> 58<br><strong>输出:</strong> “LVIII”<br><strong>解释:</strong> L = 50, V = 5, III = 3.</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> 1994<br><strong>输出:</strong> “MCMXCIV”<br><strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>通常情况下，<strong>罗马数字中小的数字在大的数字的右边</strong>。这句话很关键，意思是要变成罗马数字，必须先排列大的数</p><p>（1）定义一个arr[],代表能用罗马数字代表的数</p><p>（2）定义一个str[],里面的字符串分别与数字arr[]里面的数字相对应，两个的联系即arr[i]  —–&gt;str[i]</p><p>（3）定义一个i,i从0开始，找到数组中第一个小于等于num的值，第一个罗马数字就是str[i],再依次循环知道num==0</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>   arr [] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>,<span class="number">100</span>,  <span class="number">90</span>, <span class="number">50</span>,  <span class="number">40</span>, <span class="number">10</span>,   <span class="number">9</span>,  <span class="number">5</span>,   <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        String str[] = &#123; <span class="string">"M"</span>,<span class="string">"CM"</span>, <span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//一般情况下罗马数字小的在大的右边</span></span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>&amp;&amp; i&lt;arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= arr[i])&#123;</span><br><span class="line">                num  = num-arr[i];</span><br><span class="line">                res.append(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/12.jpg" alt="整数转罗马数字"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="/2019/06/%E6%AD%BB%E9%94%81/"/>
      <url>/2019/06/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><pre><code>两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</code></pre><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>） <span class="string">'互斥条件'</span>： 一个资源每次只能被一个进程使用。</span><br><span class="line">（<span class="number">2</span>） <span class="string">'请求与保持条件'</span>： 一个进程因请求资源而阻塞时， 对已获得的资源保持不放。</span><br><span class="line">（<span class="number">3</span>） <span class="string">'不可剥夺条件'</span>:进程已获得的资源， 在末使用完之前， 不能强行剥夺。</span><br><span class="line">（<span class="number">4</span>） <span class="string">'环路等待条件'</span>:若干进程之间形成一种头尾相接的循环等待资源关系。</span><br><span class="line">    只要系统发生了死锁， 这些条件必然成立， 而只要上述条件之一不满足， 就不会发生死锁。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">'破坏互斥条件'</span></span><br><span class="line">     如果<span class="string">'允许系统资源都能共享使用'</span>， 则系统不会进入死锁状态。 但有些资源根本不能同时访问， 如打印机等临界资源只能互斥使用。 所以， </span><br><span class="line">    破坏互斥条件而预防死锁的方法不太可行， 而且在有的场合应该保护这种互斥性。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) <span class="string">'破坏不剥夺条件'</span></span><br><span class="line"></span><br><span class="line">    当一个已保持了某些不可剥夺资源的进程， <span class="string">'请求新的资源而得不到满足时，它必须释放已经保持的所有资源， 待以后需要时再重新申请。'</span> 这</span><br><span class="line">    意味着， 一个进程已占有的资源会被暂时释放， 或者说是被剥夺了，或从而破坏了不可剥夺条件。该策略实现起来比较复杂， 释放已获得</span><br><span class="line">    的资源可能造成前一阶段工作的失效， <span class="string">'反复地申请和释放资源会增加系统开销， 降低系统吞吐量'</span>。 这种方法常用于状态易于保存和恢复的资</span><br><span class="line">    源，如 CPU 的寄存器及内存资源， 一般不能用于打印机之类的资源。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) <span class="string">'破坏请求和保持条件'</span></span><br><span class="line"></span><br><span class="line">    釆用<span class="string">'预先静态分配方法'</span>， 即<span class="string">'进程在运行前一次申请完它所需要的全部资源'</span>， 在它的资源未满足前，不把它投入运行。 一旦投入运行后， 这</span><br><span class="line">    些资源就一直归它所有， 也不再提出其他资源请求， 这样就可以保证系统不会发生死锁。</span><br><span class="line">    这种方式实现简单， 但缺点也显而易见， 系统资源被严重浪费， 其中有些资源可能仅在运行初期或运行快结束时才使用， 甚至根本不使用。 </span><br><span class="line">    而且还会导致“饥饿” 现象， 当由于个别资源长期被其他进程占用时， 将致使等待该资源的进程迟迟不能开始运行。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) <span class="string">'破坏环路等待条件'</span></span><br><span class="line"></span><br><span class="line">    为了破坏循环等待条件， 可釆用<span class="string">'顺序资源分配法'</span>。 首先给系统中的资源编号，规定每个进程， 必须按编号递增的顺序请求资源， 同类资源</span><br><span class="line">    一次申请完。 也就是说， 只要进程提出申请分配资源 Ri， 则该进程在以后的资源申请中， 只能申请编号大于 Ri 的资源。</span><br><span class="line"></span><br><span class="line">    这种方法存在的问题是， 编号必须相对稳定， 这就<span class="string">'限制了新类型设备的增加'</span>；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的</span><br><span class="line">    顺序， 但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费； 此外， 这种按规定次序申请资源的方法， 也必</span><br><span class="line">    然会给用户的编程带来麻烦。</span><br></pre></td></tr></table></figure><h3 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h3><blockquote><p>我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。</p><p>为保证资金的安全，银行家规定：</p><pre><code>(1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客；(2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量；(3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款；(4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，</span><br><span class="line">&gt; (<span class="number">1</span>)如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。</span><br><span class="line">&gt; (<span class="number">2</span>)当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。</span><br><span class="line">&gt; (<span class="number">3</span>)若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="检测死锁-死锁定理"><a href="#检测死锁-死锁定理" class="headerlink" title="检测死锁(死锁定理)"></a>检测死锁(死锁定理)</h3><p>通常分析描述死锁，可以用资源分配图。关于资源分配图，要仅仅抓住两点：</p><ul><li>请求边</li><li>分配边</li></ul><p>关键在找：空闲资源。如果空闲资源可以满足某个进程，这个进程就可以解脱了，把它摘除资源分配图，再看剩下的资源分配图，策略相同。</p><p><strong>在资源分配图中，把分配的资源与进程连好，再看进程请求边。按照分配边分配好以后，剩余的资源就是空闲资源。此时再来分析进程Pi的请求边，如果空闲资源都能满足Pi的请求，也就意味着Pi可以从这个纠缠的图中得到解脱。删除Pi的所有相关的资源：已分配的+请求的。再递归处理剩下的资源分配图</strong>。</p><p>参看：<a href="https://blog.csdn.net/jgm20475/article/details/81297819" target="_blank" rel="noopener">https://blog.csdn.net/jgm20475/article/details/81297819</a></p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>1、资源剥夺法</p><pre><code>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</code></pre><p>2、撤销进程法</p><pre><code>强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</code></pre><p>3、进程回退法</p><pre><code>让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL-优化查询</title>
      <link href="/2019/06/SQL-%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/06/SQL-%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化查询的方法"><a href="#优化查询的方法" class="headerlink" title="优化查询的方法"></a>优化查询的方法</h1><h2 id="1-使用索引"><a href="#1-使用索引" class="headerlink" title="1.使用索引"></a>1.使用索引</h2><pre><code>尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。</code></pre><h2 id="2-优化SQL语句"><a href="#2-优化SQL语句" class="headerlink" title="2.优化SQL语句"></a>2.优化SQL语句</h2><h3 id="2-1-explain查看SQL语句执行效果"><a href="#2-1-explain查看SQL语句执行效果" class="headerlink" title="2.1 explain查看SQL语句执行效果"></a>2.1 explain查看SQL语句执行效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句，</span><br><span class="line"> 把关键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-2-任何地方都不要使用-select-from-t-，-用具体的字段列表代替“-”-，-不要返回用不到的任何字段。"><a href="#2-2-任何地方都不要使用-select-from-t-，-用具体的字段列表代替“-”-，-不要返回用不到的任何字段。" class="headerlink" title="2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*” ， 不要返回用不到的任何字段。"></a>2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*” ， 不要返回用不到的任何字段。</h3><h3 id="2-3-不在索引列做运算或者使用函数。"><a href="#2-3-不在索引列做运算或者使用函数。" class="headerlink" title="2.3 不在索引列做运算或者使用函数。"></a>2.3 不在索引列做运算或者使用函数。</h3><h3 id="2-4-查询尽可能使用-limit-减少返回的行数，-减少数据传输时间和带宽浪费。"><a href="#2-4-查询尽可能使用-limit-减少返回的行数，-减少数据传输时间和带宽浪费。" class="headerlink" title="2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。"></a>2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。</h3><h2 id="3-优化数据库对象"><a href="#3-优化数据库对象" class="headerlink" title="3.优化数据库对象"></a>3.优化数据库对象</h2><h3 id="3-1-优化表的数据类型"><a href="#3-1-优化表的数据类型" class="headerlink" title="3.1 优化表的数据类型"></a>3.1 优化表的数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="function">procedure <span class="title">analyse</span><span class="params">()</span>函数对表进行分析， 该函数可以对表中列的数据类型提出优化建议。 能小就用小。 </span></span><br><span class="line"><span class="function">表数据类型第一个原则是： 使用能正确的表示和存储数据的最短类型。 这样可以减少对磁盘空间、 内存、 cpu 缓存的使用。</span></span><br><span class="line"><span class="function">使用方法： 'select * from 表名 procedure <span class="title">analyse</span><span class="params">()</span></span>;<span class="string">'</span></span><br></pre></td></tr></table></figure><h3 id="3-2-对表进行拆分"><a href="#3-2-对表进行拆分" class="headerlink" title="3.2 对表进行拆分"></a>3.2 对表进行拆分</h3><pre><code>通过拆分表可以提高表的访问效率。  </code></pre><p><strong>1.垂直拆分</strong><br><code>把主键和一些列放在一个表中， 然后把主键和另外的列放在另一个表中。 如果一个表中某些列常用， 而另外一些不常用， 则可以采用垂直拆分。</code><br><strong>2.水平拆分</strong><br>        <code>根据一列或者多列数据的值把数据行放到二个独立的表中。</code></p><h3 id="3-3-使用中间表来提高查询速度"><a href="#3-3-使用中间表来提高查询速度" class="headerlink" title="3.3 使用中间表来提高查询速度"></a>3.3 使用中间表来提高查询速度</h3><pre><code>创建中间表， 表结构和源表结构完全相同， 转移要统计的数据到中间表， 然后在中间表上进行统计， 得出想要的结果。</code></pre><h2 id="4-硬件优化"><a href="#4-硬件优化" class="headerlink" title="4.硬件优化"></a>4.硬件优化</h2><h3 id="4-1-CPU-的优化"><a href="#4-1-CPU-的优化" class="headerlink" title="4.1 CPU 的优化"></a>4.1 CPU 的优化</h3><pre><code>选择多核和主频高的 CPU。  </code></pre><h3 id="4-2-内存的优化"><a href="#4-2-内存的优化" class="headerlink" title="4.2 内存的优化"></a>4.2 内存的优化</h3><pre><code>使用更大的内存。 将尽量多的内存分配给 MYSQL 做缓存。  </code></pre><h3 id="4-3-磁盘-I-O-的优化"><a href="#4-3-磁盘-I-O-的优化" class="headerlink" title="4.3 磁盘 I/O 的优化"></a>4.3 磁盘 I/O 的优化</h3><h4 id="4-3-1-使用磁盘阵列"><a href="#4-3-1-使用磁盘阵列" class="headerlink" title="4.3.1 使用磁盘阵列"></a>4.3.1 使用磁盘阵列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)RAID <span class="number">0</span> 没有数据冗余， 没有数据校验的磁盘陈列。 实现 RAID <span class="number">0</span>至少需要两块以上的硬盘， 它将两块以上的硬盘合并成一块， 数据连续地</span><br><span class="line">分割在每块盘上。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)RAID1 是将一个两块硬盘所构成 RAID 磁盘阵列， 其容量仅等于一块硬盘的容量， 因为另一块只是当作数据“镜像”。 </span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)RAID-<span class="number">0</span>+<span class="number">1</span> 磁盘阵列。 RAID <span class="number">0</span>+<span class="number">1</span>是 RAID <span class="number">0</span> 和 RAID <span class="number">1</span> 的组合形式。 它在提供与 RAID <span class="number">1</span> 一样的数据安全保障的同时,也提供了与 RAID <span class="number">0</span> </span><br><span class="line">近似的存储性能。</span><br></pre></td></tr></table></figure><h4 id="4-3-2-调整磁盘调度算法"><a href="#4-3-2-调整磁盘调度算法" class="headerlink" title="4.3.2 调整磁盘调度算法"></a>4.3.2 调整磁盘调度算法</h4><pre><code>选择合适的磁盘调度算法， 可以减少磁盘的寻道时间。</code></pre><h3 id="5-MYSQL自身的优化"><a href="#5-MYSQL自身的优化" class="headerlink" title="5.MYSQL自身的优化"></a>5.MYSQL自身的优化</h3><pre><code>对 MySQL 自身的优化主要是对其配置文件 my.cnf 中的各项参数进行优化调整。 如指定 MySQL 查询缓冲区的大小， 指定 MySQL 允许的最大连接进程数等。</code></pre><h2 id="6-应用优化"><a href="#6-应用优化" class="headerlink" title="6.应用优化"></a>6.应用优化</h2><h3 id="6-1-使用数据库连接池"><a href="#6-1-使用数据库连接池" class="headerlink" title="6.1 使用数据库连接池"></a>6.1 使用数据库连接池</h3><h3 id="6-2-使用查询缓存"><a href="#6-2-使用查询缓存" class="headerlink" title="6.2 使用查询缓存"></a>6.2 使用查询缓存</h3><pre><code>它的作用是存储 select 查询的文本及其相应结果。 如果随后收到一个相同的查询， 服务器会从查询缓存中直接得到查询结果。 查询缓存适用的对象是更新不频繁的表， 当表中数据更改后， 查询缓存中的相关条目就会被清空</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>(1) 选取最适合的字段</strong>：在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。还可以将字段设置为NOT NULL,在查询时就不用比较null值了</p><p><strong>(2) 使用连接（JOIN）来替代子查询</strong></p><p><strong>(3) 使用联合（UNION)来代替手动创建的临时表</strong>：它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。</p><p><strong>(4) 使用事务</strong>：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><p><strong>(5) 锁定表</strong>：事务会将数据库锁定，因此其他用户请求只能暂时等待直到事务结束，会造成响应延迟。我们可以通过锁定表的方法来获得更好的性能</p><p><strong>(6) 使用外键</strong>。锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p><p><strong>(7) 使用索引</strong>。索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p><p><strong>(8) 优化的查询语句</strong>。</p><p><strong>(9) 分库分表</strong>：可以按照业务分库，分流数据库并发压力，使数据库表更加有条理性</p><p><strong>(10) 数据库引擎</strong>：一种是innodb、一种是myisam</p><p>myisam快，是因为他的数据存储结构、索引存储结构和innodb不一样的，mysiam的索引结构是在内存中存的。 当然，myisam也有弱点，那就是他是表级锁，而innodb是行级锁，所以，mysiam适用于一次插入，多次查询的表，或者是读写分离中的读库中的表，而对于修改插入删除操作比较频繁的表，就很不合适了</p><p><strong>(11) 读写分离</strong>：数据库并发大的情况下，最好的做法就是进行横向扩展，增加机器，以提升抗并发能力，而且还兼有数据备份功能</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式—-6大原则</title>
      <link href="/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94-6%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2019/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94-6%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>六原则一法则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s( Single-Resposibility Principle ): 单一职责原则。</span><br><span class="line">o( Open-Closed principle ): 开放封闭原则。</span><br><span class="line">l( Liskov-Substituion Principle ): 里氏替换原则。</span><br><span class="line">d( Dependecy-Inversion Principle ): 依赖倒置原则。</span><br><span class="line">i( Interface-Segregation Principle ): 接口隔离原则。</span><br><span class="line"> 合成/聚合复用。</span><br><span class="line"> 迪米特法则（最少知道）&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-单一职责"><a href="#1-单一职责" class="headerlink" title="(1)单一职责"></a>(1)单一职责</h2><blockquote><p><strong><em>一个类的功能要单一， 一个类只负责一个职责。 一个类只做它该做的事情(高内聚)</em></strong>。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的的破坏</p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>如果只让一个类完成它该做的事,而不涉及与它无关的领域就是践行了高内聚的原则</code></pre><h2 id="2-开放-封闭"><a href="#2-开放-封闭" class="headerlink" title="(2)开放-封闭"></a>(2)开放-封闭</h2><p> 软件实体(类、模块、函数等) <code></code>对修改关闭。 对扩展开放`</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'有新的需求或变化时， 可以对现有代码进行扩展， 以适应新的情况。'</span></span><br><span class="line"><span class="string">'对修改封闭， 意味着类一旦设计完成， 就可以独立其工作， 而不要对类尽任何修改。'</span></span><br><span class="line"> 在开发阶段， 我们都知道， 如果对一个功能进行扩展， 如果只是一味地对方法进行修改， 可能会造成一些问题， 诸如可能会引入新的 bug，</span><br><span class="line"> 或者增加代码的复杂度， 对代码结构造成破坏、 冗余， 还需要重新进行全面的测试。 那么该怎么解决这些问题？ 很简单，这就需要系统能</span><br><span class="line"> 够支持扩展， 只有扩展性良好的系统， 才能在不进行修改已有实现代码的基础上， 引进新的功能。</span><br></pre></td></tr></table></figure><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><pre><code>可维护性，可扩展性，可复用，灵活性好</code></pre><h2 id="3-里氏替换"><a href="#3-里氏替换" class="headerlink" title="(3)里氏替换"></a>(3)里氏替换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何使用基类的地方， 都能够使用子类替换， 而且在替换子类 后， 系统能够正常工作。</span><br></pre></td></tr></table></figure><pre><code> 子类一定是增加父类的能力而不是减少父类的能力，  因为子类比父类的能力更多， 把能力多的对象当成能力少的对象来用当然没有任何问题。一个 软件实体如果使用的是一个基类， 那么当把这个基类替换成继承该基类的子类， 程序的行为不会发生任何变化。软件实体察觉不出基类对象和子类对象的区别。</code></pre><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><pre><code>1. 提高代码的重用性，子类拥有父类的方法和属性；  2. 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；  </code></pre><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><pre><code>1. 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；  2. 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成     非常糟糕的结果，要重构大量的代码。  </code></pre><h2 id="4-接口隔离"><a href="#4-接口隔离" class="headerlink" title="(4)接口隔离"></a>(4)接口隔离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'使用多个专门的接口比使用单一的总接口要好。一个类对另外一个类的依赖性应当是建立在最小的接口上的。'</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将接口粒度最小化，将功能划分到每一个不能再分的子角色， 为每一个子角色创建接口通过这样，才不会让接口的实现类实现一些不必要的功能。 </span><br><span class="line">建立单一的接口， 不要建立臃肿的庞大的接口， 也就是说接口的方法尽量少。接口要小而专， 绝不能大而全。 臃肿的接口是对接口的污染,</span><br><span class="line">既然接口表示能力,那么一个接口只应该描述一种能力， 接口也应该是高度内聚的。</span><br></pre></td></tr></table></figure><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><pre><code>实现模块间的松耦合</code></pre><h2 id="5-依赖倒置"><a href="#5-依赖倒置" class="headerlink" title="(5)依赖倒置"></a>(5)依赖倒置</h2><figure class="highlight plain"><figcaption><span>而不是依赖于具体， 也就是我们经常听到的“要面向接口编程” 。``` </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们的类要依赖于抽象， 而不是依赖于具体， 也就是我们经常听到的“要面向接口编程” 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    该原则说得具体一些就是声明方法的参数类型、 方法的返回类型、 变量的引用类型时， <span class="string">'尽可能使用抽象类型而不用具体类型，'</span> 因为抽象</span><br><span class="line">类型可以被它的任何一个子类型所替代</span><br><span class="line">（<span class="number">1</span>）高层模块不应该依赖低层模块，两个都应该依赖抽象</span><br><span class="line">（<span class="number">2</span>）抽象不应该依赖细节，细节应该依赖抽象</span><br></pre></td></tr></table></figure><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><pre><code>通过抽象（抽象类或接口） 使各个类或模块的实现彼此独立， 不相互影响， 实现模块间的松耦合。 减少类间的耦合性。</code></pre><h2 id="6-合成-聚合复用"><a href="#6-合成-聚合复用" class="headerlink" title="(6)合成/聚合复用"></a>(6)合成/聚合复用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。'</span></span><br></pre></td></tr></table></figure><p>   在面向对象设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生改变，则子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了合成/聚合复用原则，也就是在实际开发设计中，尽量使用合成/聚合，不要使用类继承.一般而言，如果一个角色得到了更多的责任，那么可以使用合成/聚合关系将新的责任委派到合适的对象。当然，这种复用也有缺点。</p><pre><code>最主要的缺点就是通过这种复用建造的系统会有较多的对象需要管理。</code></pre><h2 id="迪米特法则-最少知道法则"><a href="#迪米特法则-最少知道法则" class="headerlink" title="迪米特法则(最少知道法则)"></a>迪米特法则(最少知道法则)</h2><pre><code>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类要调用另一个类的某种方法，可以通过第三方转发这个调用</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在类的结构设计上，每个类都应当尽量降低成员的访问权限</span><br></pre></td></tr></table></figure><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><pre><code>类间解耦，降低耦合度，只有弱耦合之后，类的复用性才可以提高</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中的【IO】、【NIO】、【AIO】</title>
      <link href="/2019/06/JAVA%E4%B8%AD%E7%9A%84NIO-BIO/"/>
      <url>/2019/06/JAVA%E4%B8%AD%E7%9A%84NIO-BIO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h2><table><thead><tr><th><strong>IO</strong></th><th><strong>NIO</strong></th></tr></thead><tbody><tr><td>面向流</td><td>面向缓冲</td></tr><tr><td>阻塞IO</td><td>非阻塞IO</td></tr><tr><td>无</td><td>选择器</td></tr></tbody></table><blockquote><p><strong>1.面向流与面向缓冲</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Java IO 面向流意味着每次从流中读一个或多个字节， 直至读取所有字节，它们没有被缓存在任何地方。 此外， 它不能前后</span><br><span class="line">&gt; 移动流中的数据。</span><br><span class="line">&gt;     Java NIO 中把数据读取到一个缓冲区中， 需要时可在缓冲区中前后移动。 这就增加了处理过程中的灵活性。而且， 需确保当</span><br><span class="line">&gt; 更多的数据读入缓冲区时， 不要覆盖缓冲区里尚未处理的数据。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><a id="more"></a><p><strong>2.阻塞与非阻塞 IO</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Java IO 的各种流是阻塞的。 这意味着， 当一个线程调用 read() 或 write() 时， 该线程被阻塞， 直到有一些数据被读取,</span><br><span class="line">&gt; 或数据完全写入。 <span class="string">'该线程在此期间不能再干任何事情了'</span>。</span><br><span class="line">&gt;     Java NIO 的非阻塞模式， 使一个线程从某通道发送请求读取数据， 但是它仅能得到目前可用的数据， 如果<span class="string">'目前没有数据可用时，</span></span><br><span class="line"><span class="string">&gt; 就什么都不会获取， 而不是保持线程阻塞， 所以直至数据变的可以读取之前， 该线程可以继续做其他的事情。'</span> 非阻塞写也是如此。 一</span><br><span class="line">&gt; 个线程请求写入一些数据到某通道， 但不需要等待它完全写入， 这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用</span><br><span class="line">&gt; 于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel)。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>3.选择器（Selector）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Java NIO 的选择器允许一个单独的线程来监视多个输入通道， 你可以注册多个通道使用一个选择器， 然后使用一个单独的线程</span><br><span class="line">&gt; 来“选择”通道： 这些通道里已经有可以处理的输入， 或者选择已准备写入的通道。 为了将 Channel和Selector 配合使用,必须将</span><br><span class="line">&gt; channel 注册到 selector 上， 通过SelectableChannel.register()方法来实现。 这种选择机制，使得一个单独的线程很容易来</span><br><span class="line">&gt; 管理多个通道。 <span class="string">'只要 Channel 向 Selector 注册了某种特定的事件，Selector 就会监听这些事件是否会发生，一旦发生某个</span></span><br><span class="line"><span class="string">&gt; 便会通知对应的 Channel。 使用选择器， 借助单一线程， 就可对数量庞大的活动 I/O 通道实施监控和维护'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="IO同步阻塞"><a href="#IO同步阻塞" class="headerlink" title="IO同步阻塞"></a>IO同步阻塞</h2><h3 id="1-阻塞IO"><a href="#1-阻塞IO" class="headerlink" title="(1)阻塞IO"></a>(1)阻塞IO</h3><blockquote><p> 最传统的一种IO模型，即在<strong>读写数据过程中会发生阻塞现象</strong>。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解绑block状态。典型的阻塞IO模型的例子为：data = socket.read()；如果数据没有就绪，就会一直阻塞在read方法。</p></blockquote><h3 id="2-非阻塞IO"><a href="#2-非阻塞IO" class="headerlink" title="(2)非阻塞IO"></a>(2)非阻塞IO</h3><blockquote><p> 当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个Error时，它就知道数据还没准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次受到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就是说<strong>非阻塞IO模型不会交出CPU，而会一直占用CPU</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">&gt;   data = socket.read();</span><br><span class="line">&gt;   <span class="keyword">if</span>(data != error)&#123;</span><br><span class="line">&gt;     处理数据</span><br><span class="line">&gt;     <span class="keyword">break</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-多路复用IO-同步非阻塞NIO"><a href="#3-多路复用IO-同步非阻塞NIO" class="headerlink" title="(3)多路复用IO[同步非阻塞NIO]"></a>(3)多路复用IO[同步非阻塞NIO]</h3><blockquote><p>在多路复用IO模型中(实际上就说NIO)，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。通过一个线程就可以管理多个socket，只有在真正有socket读写事件进行时，才会使用IO资源进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。</p></blockquote><h3 id="4-信号驱动IO"><a href="#4-信号驱动IO" class="headerlink" title="(4)信号驱动IO"></a>(4)信号驱动IO</h3><blockquote><p>在信号驱动IO模型中，<strong>当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数</strong>，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p></blockquote><h3 id="5-异步IO-异步非阻塞AIO"><a href="#5-异步IO-异步非阻塞AIO" class="headerlink" title="(5)异步IO[异步非阻塞AIO]"></a>(5)异步IO[异步非阻塞AIO]</h3><p>应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。</p><p>在异步IO模型中，<strong>当用户线程发起read操作之后，立刻就可以开始去做其它的事</strong>。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求一个成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，<strong>当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了</strong>。也就是说用户线程完全不需要实际的整个IO操作是如何进行的。只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p><h2 id="NIO同步非阻塞"><a href="#NIO同步非阻塞" class="headerlink" title="NIO同步非阻塞"></a>NIO同步非阻塞</h2><p><img src="https://github.com/qiulig/IMG/raw/master/NIO.png" alt="NIO图解"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h5 id="1-缓冲区-buffer"><a href="#1-缓冲区-buffer" class="headerlink" title="1.缓冲区(buffer)"></a>1.缓冲区(buffer)</h5><pre><code>缓冲区实际上是一个容器对象， 其实就是一个数组， &apos;在 NIO 库中,所有数据都是用缓冲区处理的。&apos;在读取数据时， 它是直接读到缓冲区中的； 在写入数据时， 它也是写入到缓冲区中的； 任何时候访问 NIO 中的数据， 都是将它放到缓冲区中。 在 NIO 中， 所有的缓冲区类型都继承于抽象类 Buffer， 最常用的就是 ByteBuffer。  </code></pre><h5 id="2-通道-channel"><a href="#2-通道-channel" class="headerlink" title="2.通道(channel)"></a>2.通道(channel)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'通道是一个对象， 通过它可以读取和写入数据'</span>， 所有数据都通过 Buffer 对象来处理。 我们永远不会将字节直接写入通道中，相反是将数据写入</span><br><span class="line"></span><br><span class="line">包含一个或者多个字节的缓冲区。 同样不会直接从通道中读取字节， 而是将数据从通道读入缓冲区， 再从缓冲区获取这个字节。 而流只是在一个</span><br><span class="line"></span><br><span class="line">方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类， 比如 InputStream 只能进行读取操作， OutputStream 只能进行写操</span><br><span class="line"></span><br><span class="line">作)， 而<span class="string">'通道是双向的， 可以用于读、 写或者同时用于读写'</span>。</span><br></pre></td></tr></table></figure><h5 id="3-选择器（selector）"><a href="#3-选择器（selector）" class="headerlink" title="3.选择器（selector）"></a>3.选择器（selector）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Selector 的作用就是用来轮询每个注册的 Channel，一旦发现 Channel 有注册的事件发生， 便获取事件然后进行处理。'</span> </span><br><span class="line">用单线程处理一个 Selector， 然后通过 Selector.select()方法来获取到达事件， 在获取了到达事件之后， 就可以逐个地对这些事件进行</span><br><span class="line">响应处理。</span><br><span class="line">    <span class="string">'服务端和客户端各自维护一个管理通道的对象， 我们称之为 selector， 该对象能检测一个或多个通道（channel） 上的事件。'</span> </span><br><span class="line">我们以服务端为例， 如果服务端的 selector 上注册了读事件， 某时刻客户端给服务端送了一些数据， 阻塞 I/O这时会调用 read()方法阻</span><br><span class="line">塞地读取数据， 而 NIO 的服务端会在 selector 中添加一个读事件。 服务端的处理线程会轮询地访问 selector， 如果访问selector 时</span><br><span class="line">发现有感兴趣的事件到达， 则处理这些事件， 如果没有感兴趣的事件到达， 则处理线程会一直阻塞直到感兴趣的事件到达为止。</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式—-工厂模式</title>
      <link href="/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的<strong>实例化延迟</strong>到其子类。</p><p><strong>提供一个创建对象实例的功能，而无须关心其具体实现</strong>。被创建实例的类型可以是接口、抽象类，也可以是具体的类。工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。<a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/设计模式之工厂模式.png" alt="工厂模式结构图"></p><h3 id="1-简单工厂方法"><a href="#1-简单工厂方法" class="headerlink" title="1.简单工厂方法"></a>1.简单工厂方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISample <span class="title">creator</span><span class="params">(<span class="keyword">int</span> which)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (which==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleA();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (which==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SampleB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实例时</span></span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">1</span>);</span><br><span class="line">ISample sampleA = Factory.creator(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="2-抽象工厂"><a href="#2-抽象工厂" class="headerlink" title="2.抽象工厂"></a>2.抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample <span class="title">creator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建实现接口的实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleA</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2A</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//创建工厂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BombFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample <span class="title">creator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SampleB</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sample2 <span class="title">creator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sample2B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1、可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。</p><p>2、可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。<br>3、可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。  </p><!--more--></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上<strong>增加了系统的复杂度，同时也增加了系统具体类的依赖</strong>。</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </p><p>2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </p><p>3、设计一个连接服务器的框架，需要三个议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节。<a id="more"></a></p><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1.浅拷贝"></a>1.浅拷贝</h3><pre><code>对类实现Cloneable接口（implements Cloneable），并且重写clone对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型创建成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2.深拷贝"></a>2.深拷贝</h3><pre><code>对其中的引用类型的成员变量进行实现Cloneable接口，重写clone，就变成深拷贝了对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">     String name;</span><br><span class="line"></span><br><span class="line">     String <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1.如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程。</p><p>2.使用原型模式创建对象比直接 new 一个对象在性能上要好的多，因为 Object 类的 clone 方法是一个本地方法，它直接操作内存中的二进制流，特别  是复制大对象时，性能的差别非常明显。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p><strong>在需要重复地创建相似对象时可以考虑使用原型模式</strong>。</p><p>比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数  很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式—享元模式</title>
      <link href="/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote><p>运用<strong>共享技术</strong>有效地支持<strong>大量细粒度对象的复用</strong>。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。<a id="more"></a></p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="https://github.com/qiulig/IMG/raw/master/设计模式之享元模式.jpg" alt="享元模式结构图"></p><p>在享元模式中引入了享元工厂类FlyweightFactory，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><p>享元工厂类：FlyweightFactory</p><p>享元类：ConcreteFlyweight</p><p>享元对象：Flyweight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个HashMap用于存储享元对象，实现享元池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap flyweights = newHashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果对象存在，则直接从享元池获取</span></span><br><span class="line">        <span class="keyword">if</span>(flyweights.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>(Flyweight)flyweights.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Flyweight fw = newConcreteFlyweight();</span><br><span class="line">            flyweights.put(key,fw);</span><br><span class="line">            <span class="keyword">return</span> fw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><blockquote><p>当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。</p><p><strong>String中的享元模式</strong></p><p> Java中将String类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。</p></blockquote><blockquote><p><strong>Integer中的享元模式</strong></p><p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code>之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象</p></blockquote><blockquote><p><strong>Long中的享元模式</strong></p><p>与Integer原理类似</p></blockquote><blockquote><p><strong>Apache Commons Pool2中的享元模式（对象池）</strong></p><p>将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用，从而在一定程度上减少频繁创建对象所造成的开销。用于充当保存对象的“容器”的对象，被称为“对象池”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><pre><code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式包括（1）私有的构造方法（2）含有一个该类的静态私有对象private static（3）提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</code></pre><a id="more"></a><h3 id="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"><a href="#懒汉模式：全局的单例在第一次使用时构建（延迟初始化）" class="headerlink" title="懒汉模式：全局的单例在第一次使用时构建（延迟初始化）"></a>懒汉模式：全局的单例在第一次使用时构建（延迟初始化）</h3><p>优点：<br>    避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法。<br>缺点：<br>    懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉模式：全局的单例实例在类装载时构建"><a href="#饿汉模式：全局的单例实例在类装载时构建" class="headerlink" title="饿汉模式：全局的单例实例在类装载时构建"></a>饿汉模式：全局的单例实例在类装载时构建</h3><p>1.线程安全<br>2.在类加载的同时已经创建好一个静态对象，调用时反应速度快  </p><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><pre><code>资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式的应用"><a href="#单例模式的应用" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h3><p>数据库连接池，多线程连接池。Windows应用管理器</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例<br>2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。<br>3.提供了对唯一实例的受控访问。<br>4.由于在系统内存中只存在一个对象，因此可以<strong>节约系统资源</strong>，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。<br>5.允许可变数目的实例。<br>6.避免对共享资源的多重占用。</p></blockquote><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>单例模式可能导致内存泄漏（OOM）</p><p>1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。<br>2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。<br>3.单例类的职责过重，在一定程度上违背了“单一职责原则”。<br>4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA_集合中的快速失败与安全失败</title>
      <link href="/2019/05/JAVAVA-java%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5/"/>
      <url>/2019/05/JAVAVA-java%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="快速失败-fail—fast-机制"><a href="#快速失败-fail—fast-机制" class="headerlink" title="快速失败(fail—fast)机制"></a>快速失败(fail—fast)机制</h2><blockquote><p>java集合框架中的一种错误检测机制。多线程下用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除），则会抛出Concurrent Modification Exception。<a id="more"></a></p><p>fail-fast机制并不保证在不同步的修改下一定会抛出异常，这种机制一般仅用于检测bug。</p><p>【在循环迭代中修改会报异常，在迭代中修改不会报异常】</p><p><strong>java.util包下的集合类都是采用快速失败机制的，不能在多线程下发生并发修改（只能在迭代过程中被修改）。</strong></p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>这里异常的抛出条件是检测到 <strong>modCount!=expectedmodCount</strong>这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">6</span>)&#123;</span><br><span class="line">            list.remove(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line">----&gt;<span class="keyword">for</span>语句修改结果报错&lt;-------------------</span><br><span class="line">----&gt;Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException&lt;------------</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.next() == <span class="number">6</span>) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br><span class="line">-------&gt;结果不报错&lt;------------------</span><br></pre></td></tr></table></figure><ul><li>迭代器是作为当前集合的内部类实现的，当迭代器创建的时候保持了当前集合的引用；</li><li>集合内部维护一个int变量modCount，用来记录集合被修改的次数，比如add，remove等都会使该字段递增；</li><li>modCount这个参数记录了某个List改变大小的次数，如果modCount改变的不符合预期，那么就会抛出异常。</li><li>迭代器内部也维护着当前集合的修改次数的字段，迭代器创建时该字段初始化为集合的modCount值</li><li>当每一次迭代时，迭代器会比较迭代器维护的字段和modCount的值是否相等，如果不相等就抛ConcurrentModifiedException异常；</li><li>当然，如果用迭代器调用remove方法，那么集合和迭代器维护的修改次数都会递增，以保持两个状态的一致。</li></ul><h2 id="安全失败-fail-safe"><a href="#安全失败-fail-safe" class="headerlink" title="安全失败(fail-safe)"></a>安全失败(fail-safe)</h2><blockquote><p>在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常</p><p><strong>concurrent包下的都是安全失败的，可以在多线程下并发使用，并发修改。</strong></p></blockquote><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><blockquote><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><blockquote><p>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层</title>
      <link href="/2019/05/Hashmap%E5%BA%95%E5%B1%82/"/>
      <url>/2019/05/Hashmap%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HashMap简介</p><h4 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1.实现原理"></a>1.实现原理</h4><p><strong>底层是链表+数组，当链表长度大于8自动转化成红黑树。</strong></p><p><strong>首先有一个每个元素都是链表的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。</strong></p><a id="more"></a><p><img src="https://github.com/qiulig/IMG/raw/master/hashmap_1.jpg" alt="hashmap底层"><!--more--></p><p><img src="https://github.com/qiulig/IMG/raw/master/hashmap_2.jpg" alt="hashmap底层"></p><h4 id="2-hashMap的java构建"><a href="#2-hashMap的java构建" class="headerlink" title="2.hashMap的java构建"></a>2.hashMap的java构建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-HashMap的put实现"><a href="#3-HashMap的put实现" class="headerlink" title="3.HashMap的put实现"></a>3.HashMap的put实现</h4><blockquote><p>（1）程序先计算该key的hashCode()值</p><p>（2）对该哈希码进行再哈希，然后把哈希值和(数组长度-1)进行按位与操作，得到数组的下标</p><p>（3）该位置没有链表节点就把&lt;key,value&gt;放入该位置。有节点就对链表进行遍历，看是否有key一样的节点，有则value进行覆盖更新，没有就创建节点，把节点放链表表头（头插法）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//HashMap 允许存放null键和null值</span></span><br><span class="line">    <span class="comment">//当key为null时，调用putForNullKey,将value放置在数组第一个位置</span></span><br><span class="line">    <span class="keyword">if</span>(key==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key的keycode重新计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hascode());</span><br><span class="line">    <span class="comment">//搜索指定hash值在对应table的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash,table.length);</span><br><span class="line">    <span class="comment">//如果i索引处的entry不为null,通过循环不断遍历e元素的下一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[i];e!=<span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || ley.equals(k)))&#123;</span><br><span class="line">            V.oldValue = e.value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果i索引处的entry为null,表明此处还没有entry</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//将key、value添加到i索引处</span></span><br><span class="line">    addEntry(hash,key,value,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash,K key,V value,<span class="keyword">int</span> bucketIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取指定bucketIndex索引处的Entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  <span class="comment">//将新创建的Entry放入bucletIndex索引处，并让新的Enrty指向原来的Entry</span></span><br><span class="line">   table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt; (hash,key,value,e);</span><br><span class="line">   <span class="comment">//如果Map中的key-value对数量超过了极限</span></span><br><span class="line">   <span class="keyword">if</span>(size++&gt;=threshold)</span><br><span class="line">       <span class="comment">//把table对象的长度扩充为2倍</span></span><br><span class="line">       resize(<span class="number">2</span>*table.length); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HashMap长度扩充</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line">    Entry[] oldTable  = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span>(oldCapacity == MAXIMUM_CAPACITY)&#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>) (newCapacity*loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span></span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;src.length;j++)&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span>(e!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash,newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(e!=<span class="keyword">null</span>)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行hash计算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-HashMap的get方法"><a href="#4-HashMap的get方法" class="headerlink" title="4.HashMap的get方法"></a>4.HashMap的get方法</h4><blockquote><p>（1）通过key的两次hash的值与数组的长度-1进行按位与操作，定位到数组的某个位置</p><p>（2）对该列的链表进行遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();  </span><br><span class="line">     <span class="keyword">int</span> hash = hash(key.hasCode());</span><br><span class="line">     <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[indexFor(hash,table.length)]);e!=<span class="keyword">null</span>;e = e.next)&#123;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="keyword">if</span>(e.hash == hash &amp;&amp; (k = e.key) == key || key.equals(k))&#123;</span><br><span class="line">             <span class="keyword">return</span> e.value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-HashMap总结"><a href="#5-HashMap总结" class="headerlink" title="5.HashMap总结"></a>5.HashMap总结</h4><p>（1）hashmap可以存储null值，线性不安全</p><p>（2）hashmap扩容：当 HashMap 中的结点个数超过数组大小<em>loadFactor（加载因子） 时， 就会进行数组扩容，loadFactor 的默认值为 0.75。也就是说，默认情况下，数组大小为 16，那么当 HashMap中结点个数超过 16</em>0.75=12 的时候， 就把数组的大小扩展为 2*16=32， 即扩大一倍，然后重新计算每个元素在数组中的位置，并放进去， 而这是一个非常消耗性能的操作。</p><p>（3）多线程 put 操作后， get 操作导致死循环,导致 cpu100%的现象。 主要是多线程同时put 时， 如果同时触发了 rehash 操作，会导致扩容后的 HashMap 中的链表中出现循环节点， 进而使得后面 get 的时候，会死循环。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_内存泄漏和内存溢出</title>
      <link href="/2019/05/JVMVM-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
      <url>/2019/05/JVMVM-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h6 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h6><blockquote><p>一个不再被程序使用的对象或者变量还在内存中占有存储空间。</p><p>（1）堆中申请的空间没有被释放</p><p>（2）对象不在使用但还在内存中保留</p><a id="more"></a></blockquote><h6 id="内存泄漏的原因："><a href="#内存泄漏的原因：" class="headerlink" title="内存泄漏的原因："></a>内存泄漏的原因：</h6><blockquote><p>（1）静态集合类，如hashmap和vector，如果容器为静态，她们的生命周期与程序一致。</p><p>（2）各种连接，如数据库连接，IO连接</p><p>（3）监听器：通常一个应用中会用到多个监听器，但是在释放对象的同时往往没有相应的删除监听器</p><p>（4）变量不合理的作用域。一方面一个变量的定义作用范围大于其使用范围，很可能造成内存泄漏。另一方面如果没有及时把对象设置为null,很可能导致内存泄漏。</p><p>（5）单例模式：一直存在着一个对对象的引用，并且以一个静态变量的方式存储，因此它在JVM整个生命周期都存在。</p></blockquote><h6 id="内存泄漏解决方案："><a href="#内存泄漏解决方案：" class="headerlink" title="内存泄漏解决方案："></a>内存泄漏解决方案：</h6><blockquote><p>（1）避免在循环中创建对象</p><p>（2） 尽早释放无用的对象引用</p><p>（3）尽量少用静态变量</p><p>（4）使用字符串处理，避免使用String,应大量使用StringBuffer,因为每个String对象都得独立占用内存一块区域</p></blockquote><h2 id="内存溢出OOM"><a href="#内存溢出OOM" class="headerlink" title="内存溢出OOM"></a>内存溢出OOM</h2><h6 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h6><blockquote><p>程序运行过程中无法申请到足够的内存而导致的一种错误，除了程序计数器外，其他几个运行区都有OOM的可能。</p></blockquote><h6 id="内存溢出情况："><a href="#内存溢出情况：" class="headerlink" title="内存溢出情况："></a>内存溢出情况：</h6><blockquote><p>（1）虚拟机栈和本地方法栈溢出</p><pre><code>如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackOverflowError 异常。  如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError 异常。  </code></pre><p> （2）<strong>堆溢出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 一般的异常信息： java.lang.OutOfMemoryError:Java heap spaces</span><br><span class="line">&gt;  出现这种异常，一般手段是先通过内存映像分析工具(如 Eclipse Memory Analyzer)对 dump 出来的堆转存快照进行分析,</span><br><span class="line">&gt;  重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏还是内存溢出。</span><br><span class="line">&gt;     1.如果是内存泄漏， 可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。</span><br><span class="line">&gt;     2.如果不存在泄漏， 那就应该检查虚拟机的参数(-Xmx 与-Xms)的设置是否适当。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（3）<strong>方法区溢出</strong></p><pre><code>异常信息： java.lang.OutOfMemoryError:PermGen space。</code></pre><p>（4）<strong>运行时常量池溢出</strong></p><pre><code>异常信息： java.lang.OutOfMemoryError:PermGen space。  </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果要向运行时常量池中添加内容，最简单的做法就是使用 String.intern()这个Native 方法。</span><br><span class="line">&gt;     该方法的作用是:如果池中已经包含一个等于此 String 的字符串， 则返回代表池中这个字符串的 String 对象；</span><br><span class="line">&gt;     否则，将此 String 对象包含的字符串添加到常量池中， 并且返回此 String 对象的引用 。</span><br><span class="line">&gt; 由于常量池分配在方法区内，我们可以通过-XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小， 从而间接限制其中常量池的容量。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h6 id="内存溢出原因："><a href="#内存溢出原因：" class="headerlink" title="内存溢出原因："></a>内存溢出原因：</h6><blockquote><p>1.内存中加载的数据量过于庞大， 如一次从数据库取出过多数据；</p><p>2.集合类中有对对象的引用， 使用完后未清空， 使得 JVM 不能回收；<br>3.代码中存在死循环或循环产生过多重复的对象实体；<br>4.启动参数内存值设定的过小。</p></blockquote><h6 id="内存溢出解决方法："><a href="#内存溢出解决方法：" class="headerlink" title="内存溢出解决方法："></a>内存溢出解决方法：</h6><blockquote><p>(1) 修改 JVM 启动参数， 直接增加内存。 (-Xms， -Xmx 参数一定不要忘记加。一般要将-Xms 和-Xmx 选项设置为相同， 以避免在每次 GC 后调整堆的大小； 建  议堆的最大值设置为可用内存的最大值的 80%)。  </p><p>(2) 检查错误日志， 查看“OutOfMemory” 错误前是否有其它异常或错误。 </p><p>(3)对代码进行走查和分析， 找出可能发生内存溢出的位置</p><p>(4)  使用内存查看工具动态查看内存使用情况（Jconsole）。</p></blockquote><h2 id="减少gc次数的方法："><a href="#减少gc次数的方法：" class="headerlink" title="减少gc次数的方法："></a>减少gc次数的方法：</h2><blockquote><p><strong>（1）对象不用时最好显式置为 Null</strong></p><pre><code>一般而言,为 Null 的对象都会被作为垃圾处理,所以将不用的对象显式地设  为 Null,有利于 GC 收集器判定垃圾,从而提高了 GC 的效率。  </code></pre><p><strong>（2）尽量少用 System.gc()</strong>  </p><pre><code>此函数建议 JVM进行主 GC,虽然只是建议而非一定,但很多情况下它会触发  主 GC,从而增加主 GC 的频率,也即增加了间歇性停顿的次数。  </code></pre><p><strong>（3）尽量少用静态变量</strong>  </p><pre><code>静态变量属于全局变量,不会被 GC 回收,它们会一直占用内存。  </code></pre><p><strong>（4） 尽量使用 StringBuffer,而不用 String 来累加字符串。</strong><br>    由于 String 是固定长的字符串对象,累加 String 对象时,并非在一个 String  对象中扩增,而是重新创建新的 String 对象,如 Str5=Str1+Str2+Str3+Str4,这条  语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新  的 String 对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多  的垃圾。 避免这种情况可以改用 StringBuffer 来累加字符串,因 StringBuffer 是可变长的,它在原有基础上进行扩增,不会产生中间对象。<br><strong>（5）分散对象创建或删除的时间</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM 在面临这种情况时,只能进行主 GC,以回收内存或整合</span><br><span class="line">&gt; 内存碎片从而增加主 GC 的频率。集中删除对象,道理也是一样的。 它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大</span><br><span class="line">&gt; 增加了下一次创建新对象时强制主 GC 的机会。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（6） <strong>尽量少用 finalize 函数。 因为它会加大 GC 的工作量， 因此尽量少</strong>用finalize 方式回收资源。  </p><p><strong>（7） 如果需要使用经常用到的图片， 可以使用软引用类型， 它可以尽可能</strong></p><p><strong>（8）能用基本类型如 int,long,就不用 Integer,Long 对象</strong></p><pre><code>基本类型变量占用的内存资源比相应包装类对象占用的少得多,如果没有必要,最好使用基本变量。  </code></pre><p><strong>（9） 增大-Xmx 的值。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_深拷贝和浅拷贝</title>
      <link href="/2019/05/Java-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/05/Java-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>对基本数据类型进行了拷贝</p><p>对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。</p><h6 id="即"><a href="#即" class="headerlink" title="即"></a>即</h6><pre><code>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝</code></pre><a id="more"></a><h6 id="底层实现："><a href="#底层实现：" class="headerlink" title="底层实现："></a>底层实现：</h6><p>（1）对类实现Cloneable接口（implements Cloneable），并且重写clone</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;  String name;</span><br><span class="line">&gt;  String <span class="keyword">int</span> age;</span><br><span class="line">&gt;  Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line">&gt;  <span class="meta">@Override</span></span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;  <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;      <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>（2）用clone()方法创建新的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;     A a = <span class="keyword">new</span> A();</span><br><span class="line">&gt;     A aclone = (A)a.clone();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>对基本数据类型进行了拷贝</p><p>对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量</p><h6 id="即-1"><a href="#即-1" class="headerlink" title="即"></a>即</h6><pre><code>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容</code></pre><h6 id="底层实现：-1"><a href="#底层实现：-1" class="headerlink" title="底层实现："></a>底层实现：</h6><ol><li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li><li><p>继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，<strong>再进行一次 clone()</strong>。对A而言就是深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;     String name;</span><br><span class="line">&gt;     String <span class="keyword">int</span> age;</span><br><span class="line">&gt;     Child child; <span class="comment">//这是一个类，表A中的引用类型</span></span><br><span class="line">&gt;     <span class="meta">@Override</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;     <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">&gt;        <span class="meta">@Override</span></span><br><span class="line">&gt;         <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&gt;         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>一个对象内部只有基本数据类型，那用 clone() 方法获取到的就是这个对象的深拷贝，而如果其内部还有引用数据类型，那用 clone() 方法就是一次浅拷贝的操作。</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【42】接雨水</title>
      <link href="/2019/05/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2019/05/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/42.png" alt="图"></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>思路1：转化成每个位置留下水量的总和</p><pre><code>i位置上留下的水为[0 , (i-1)]的最大值max1,(i+1,length)位置上的max2的两者较小值-该位置的高度：min(max2-max1) - arr[i]。</code></pre><p>思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。</p><p>思路3：跟思路2一致，减掉了一个指针</p><p>思路4：左边最大值小于右边最大值，左指针右滑，左指针位置上能装的水就是左边最大值减去左指针指的值，若左指针指向的值大于左边大值，就不减，说明不能储水，更新左边最大值，当右边最大值小于左边最大值时，右指针左滑，做法跟前类似，直到左指针小于等于右指针跳出循环。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>思路1代码：转化成每个位置留下水量的总和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getWater1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; i; l++) &#123;</span><br><span class="line">                leftMax = Math.max(arr[l], leftMax);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = i + <span class="number">1</span>; r &lt; arr.length; r++) &#123;</span><br><span class="line">                rightMax = Math.max(arr[r], rightMax);</span><br><span class="line">            &#125;</span><br><span class="line">            value += Math.max(<span class="number">0</span>, Math.min(leftMax, rightMax) - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>思路2代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMaxs[<span class="number">0</span>] = arr[<span class="number">0</span>];<span class="comment">//左指针初始化为第一个数</span></span><br><span class="line">        <span class="comment">//求左边的max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            leftMaxs[i] = Math.max(leftMaxs[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] rightMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMaxs[n - <span class="number">1</span>] = arr[n + <span class="number">1</span>];<span class="comment">//右指针初始化为数组最后一个数</span></span><br><span class="line"><span class="comment">//求右边的max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightMaxs[i] = Math.max(rightMaxs[i + <span class="number">1</span>], arr[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            value += Math.max(<span class="number">0</span>, Math.min(leftMaxs[i - <span class="number">1</span>], rightMaxs[i - <span class="number">1</span>]) - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>思路3代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路3：减少一个指针</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> n = arr.length - <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span>[] rightMaxs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">     rightMaxs[n - <span class="number">1</span>] = arr[n + <span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         rightMaxs[i] = Math.max(rightMaxs[i + <span class="number">1</span>], arr[i + <span class="number">2</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">         value += Math.max(<span class="number">0</span>, Math.min(leftMax, rightMaxs[i - <span class="number">1</span>]) - arr[i]);</span><br><span class="line">         leftMax = Math.max(leftMax, arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>思路4代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap4</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rightMax = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;<span class="comment">//从第二个查看是否能蓄水</span></span><br><span class="line">        <span class="keyword">int</span> r = arr.length - <span class="number">2</span>;<span class="comment">////从倒数第二个查看是否能蓄水</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt;= rightMax) &#123;</span><br><span class="line">                value += Math.max(<span class="number">0</span>, leftMax - arr[l]);</span><br><span class="line">                leftMax = Math.max(leftMax, arr[l++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value += Math.max(<span class="number">0</span>, rightMax - arr[r]);</span><br><span class="line">                rightMax = Math.max(rightMax, arr[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p>思路1提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_11.png" alt="接雨水"></p><p>思路2提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_12.png" alt="接雨水"></p><p>思路3提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_13.png" alt="接雨水"></p><p>思路4提交记录：</p><p><img src="https://github.com/qiulig/IMG/raw/master/42_14.png" alt="接雨水"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 滑动窗口法 </tag>
            
            <tag> 困难 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【11】盛最多水的容器</title>
      <link href="/2019/05/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/05/leetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定  <em>n</em>  个非负整数  <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画  <em>n</em>  条垂直线，垂直线  <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><a id="more"></a><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://github.com/qiulig/IMG/raw/master/11.png" alt="图"></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.  解题思路"></a>2.  解题思路</h3><p>这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。</p><p>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量  res  来持续存储到目前为止所获得的最大面积。 </p><p>在每一步中，我们会找出指针所指向的两条线段形成的区域，更新  res，并将指向较短线段的指针向较长线段那端移动一步。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            res = Math.max(res,(right-left)*Math.min(height[left],height[right]));</span><br><span class="line">            <span class="comment">//舍弃高度较小的</span></span><br><span class="line">            <span class="keyword">if</span> ((height[left] &gt; height[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/11_1.png" alt="盛最多水的容器"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 滑动窗口法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【10】正则表达式匹配</title>
      <link href="/2019/05/leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/05/leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>)。实现支持  <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。<a id="more"></a></p><p>‘.’ 匹配任意单个字符。<br>‘*’ 匹配零个或多个前面的元素。</p><p>匹配应该覆盖<strong>整个</strong>字符串 (<code>s</code>) ，而不是部分字符串。</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li></ul><p><strong>示例 1:</strong></p><p><strong>输入:</strong><br>s = “aa”<br>p = “a”<br><strong>输出:</strong> false<br><strong>解释:</strong> “a” 无法匹配 “aa” 整个字符串。</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong><br>s = “aa”<br>p = “a<em>“<br><strong>输出:</strong> true<br><strong>解释:</strong> ‘</em>‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong><br>s = “ab”<br>p = “.<em>“<br><strong>输出:</strong> true<br><strong>解释:</strong> “.</em>“ 表示可匹配零个或多个(‘*’)任意字符(‘.’)。</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong><br>s = “aab”<br>p = “c<em>a</em>b”<br><strong>输出:</strong> true<br><strong>解释:</strong> ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong><br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br><strong>输出:</strong> false</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：</p><blockquote><p>跟剑指offer的52题一致</p><p>这道题的核心其实在于分析’<em>‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’</em>‘的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。</p><p><strong>情况1：Patttern第二个字符是’*’时</strong>：</p><p>1.第一个字符不匹配（’.’与任意字符视作匹配），那么’*’只能代表匹配0次</p><p>‘ba’与’a*ba’，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式</p><p>2.第一个字符匹配，那么’*’可能代表匹配0次，1次，多次，</p><p>(1)’aaa’与’a*aaa’: 匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；</p><p>(2)’aba’与’a*ba’:匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；</p><p>(3)’aaaba’与’a*ba’:匹配多次时，字符串往后移动一个字符，模式不变；</p><p><strong>情况2：Patttern第二个字符不是’*’时：</strong></p><p>(1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。</p><p>(2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。</p></blockquote><p>方法2：动态规划</p><blockquote><p>定义一个dp[][]数组，其中d[i][j]表示s[0,i]和p[0][j]是否匹配</p><p>dp初始化:dp[0][0] = true，代表str为空串，pattern为空串的情况</p><pre><code>求dp[0][j]即求str为空串，pattern是否匹配当遇到后一个为 * 时，且dp[0][i-1]为true则匹配(匹配前面字符0次)，标记dp[0][i+1] = true</code></pre><p>情况1：当前字母匹配，str和pattern都往后移动一位</p><pre><code>dp[i+1][j+1] = dp[i][j]</code></pre><p>情况2：后一个pattern是   *  ,前一个pattern跟str不匹配,str不变，pattern后移动两位</p><pre><code>dp[i+1][j+1] = dp[i+1][j-1]</code></pre><p>情况3：后一个pattern是 * ,前一个pattern跟str匹配</p><pre><code>(1)匹配0次，str不动，pattern后移2位        dp[i+1][j+1] = dp[i+1][j-1](2)匹配一次，str移动1位，pattern移动2位        dp[i+1][j+1] =dp[i][j-1](3)匹配多次，str移动1次，pattern不动        dp[i+1][j+1] = dp[i][j+1]</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str, String pattern)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> matchCore(str.toCharArray(), <span class="number">0</span>, pattern.toCharArray(), <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">       <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//pattern先到尾，匹配失败</span></span><br><span class="line">       <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;</span><br><span class="line">       <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位</span></span><br><span class="line">       <span class="comment">//   //如果当前pattern的下一个是*并且没有超出pattern的长度时</span></span><br><span class="line">       <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">           <span class="comment">// //如果当前字符str[index]和pattern[index]相等，或者当前pattern为‘.’</span></span><br><span class="line">           <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">               <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//模式后移2，视为x*匹配0个字符(当前pattern[index+1]='*'且str[index]!=pattern[index]）</span></span><br><span class="line">                       || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//视为模式匹配1个字符 (当前pattern[i+1]='*'且str[index]=pattern[index])</span></span><br><span class="line">                       || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配1个，再匹配str中的下一个（当前pattern[index]='.'）</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//当前字符str[index]和pattern[index]不相等&amp;&amp;当前pattern不为‘.’</span></span><br><span class="line">               <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">       <span class="comment">//pattern[index]='.'的情况，strindex和pattern都加1向下匹配</span></span><br><span class="line">       <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">           <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">           <span class="comment">//i= 0，j= 0表示str和pattern为空串，匹配成功标true</span></span><br><span class="line">           dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//str为空串，pattern不为空串的情况</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">               <span class="comment">//前一个为true后一个为*，*匹配0个，则标记下一个为true</span></span><br><span class="line">               <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i - <span class="number">1</span>]) &#123;</span><br><span class="line">                   dp[<span class="number">0</span>][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line">                   <span class="comment">//当前字母匹配，字符str和pattern都后移动一位</span></span><br><span class="line">                   <span class="keyword">if</span> (p.charAt(j) == <span class="string">'.'</span> || p.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                       dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//后一个字符是*</span></span><br><span class="line">                   <span class="keyword">if</span> (p.charAt(j) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                       <span class="comment">//str与pattern不匹配</span></span><br><span class="line">                       <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j - <span class="number">1</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                           <span class="comment">//str不变，pattern后移动两位</span></span><br><span class="line">                           dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">//匹配0次，str不动，pattern后移2位，匹配一次，str移动一位，pattern移动2位，匹配多次，str移动1次，pattern不动</span></span><br><span class="line">                          dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = (dp[i + <span class="number">1</span>][j-<span class="number">1</span>] || dp[i][j - <span class="number">1</span>] || dp[i][j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/10_1.jpg" alt="单纯的匹配"></p><p><img src="https://github.com/qiulig/IMG/raw/master/10_2.jpg" alt="正则表达式匹配"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 困难 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【234】回文链表</title>
      <link href="/2019/05/leetcode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/05/leetcode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请判断一个链表是否为回文链表。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 1-&gt;2<br><strong>输出:</strong> false</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> 1-&gt;2-&gt;2-&gt;1<br><strong>输出:</strong> true</p><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>方法1：将链表的数值依次入栈，然后弹栈跟listnode从头到尾比较</p><p>方法2：快慢指针弦找到中间点，再反转后面链表，再遍历比较</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            ListNode res = head;</span><br><span class="line">            <span class="comment">//链表入栈</span></span><br><span class="line">            <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出比较</span></span><br><span class="line">            <span class="keyword">while</span> (res!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.pop() == res.val)&#123;</span><br><span class="line">                    res = res.next;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode lat = head.next;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="comment">//快慢指针,pre一次一步，lat一次两步</span></span><br><span class="line">        <span class="keyword">while</span>(lat != <span class="keyword">null</span> &amp;&amp; lat.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            lat = lat.next.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转置后半链表</span></span><br><span class="line">        ListNode cur = pre.next;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode q = cur.next;</span><br><span class="line">            cur.next = p;</span><br><span class="line">            p = cur;</span><br><span class="line">            cur = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历比较</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val != head.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/234-1.jpg" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/234-2.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【9】回文数</title>
      <link href="/2019/05/leetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2019/05/leetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 121<br><strong>输出:</strong> true</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> -121<br><strong>输出:</strong> false<br><strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 10<br><strong>输出:</strong> false<br><strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>方法1：转换成字符串，将字符串反转进行比较是否相等</p><p>方法2：用一个stack存入数字从低位到高位的数；依次弹出（高位到低位弹出）跟每次数值取余的数进行对比</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        String res = x+<span class="string">""</span>;</span><br><span class="line">        <span class="comment">//字符串反转</span></span><br><span class="line">        String ans = <span class="keyword">new</span> StringBuilder(x+<span class="string">""</span>).reverse().toString();</span><br><span class="line">        <span class="keyword">if</span>(res.equals(ans))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 依次从右到左入栈 </span></span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            stack.push(x%<span class="number">10</span>);</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (res&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//pop弹出,从左到右的字符串，res%10是从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(stack.pop()==res%<span class="number">10</span>)&#123;</span><br><span class="line">                res = res/<span class="number">10</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/9-1.png" alt="leetcode提交结果"></p><p><img src="https://github.com/qiulig/IMG/raw/master/9-2.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【8】字符串转换成整数</title>
      <link href="/2019/05/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
      <url>/2019/05/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。<a id="more"></a></p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “42”<br><strong>输出:</strong> 42</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “   -42”<br><strong>输出:</strong> -42<br><strong>解释:</strong> 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “4193 with words”<br><strong>输出:</strong> 4193<br><strong>解释:</strong> 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p><strong>示例 4:</strong></p><p><strong>输入:</strong> “words and 987”<br><strong>输出:</strong> 0<br><strong>解释:</strong> 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。</p><p><strong>示例 5:</strong></p><p><strong>输入:</strong> “-91283472332”<br><strong>输出:</strong> -2147483648<br><strong>解释:</strong> 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>(1)  用一个标志位flag记录字符串的正负号</p><p>(2)  依次进行叠加，如果遇到溢出，返回它的最大值或者最小值</p><p>最大溢出判断：</p><pre><code>res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10</code></pre></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//去掉前后空格</span></span><br><span class="line">        String str = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>||str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断只有符号的情况</span></span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">1</span>&amp;&amp;(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>||str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//为正数，flag设为1，负数设为 -1,并截取后面的字符串进行字符串转换成整数</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>&amp;&amp; (str.charAt(<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">1</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">1</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>&amp;&amp;(str.charAt(<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">1</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">1</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((str.charAt(<span class="number">0</span>)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(<span class="number">0</span>)&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> Cal(flag,str,<span class="number">0</span>,str.length());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字符串转换成整数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> flag,String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span>&amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> pop = str.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//只需要判断上溢出情况，因为我们将符号单独拎出来了</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag==<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//上溢，输出最大值</span></span><br><span class="line">                        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//下溢出，输出最小值</span></span><br><span class="line">                        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = res*<span class="number">10</span> +pop;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="comment">//不是有效的字符[0-9]，直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/8.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【7】整数反转</title>
      <link href="/2019/05/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/05/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> 123<br><strong>输出:</strong> 321</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> -123<br><strong>输出:</strong> -321</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> 120<br><strong>输出:</strong> 21</p><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>主要是注意溢出问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; （<span class="number">1</span>）当x&gt;<span class="number">0</span>时，溢出考虑上界</span><br><span class="line">&gt;     <span class="number">1</span>)如果 result 的值大于 Integer.MAX_VALUE / <span class="number">10</span> ，那么一定会溢出</span><br><span class="line">&gt;     <span class="number">2</span>)如果 result 的值等于 Integer.MAX_VALUE / <span class="number">10</span>，那么 pop 的值如果大于 Integer.MAX_VALUE % <span class="number">10</span> 也会溢出</span><br><span class="line">&gt; (<span class="number">2</span>) 当x&lt;<span class="number">0</span> 时，溢出考虑下界</span><br><span class="line">&gt;     <span class="number">1</span>)result 的值小于 Integer.MIN_VALUE / <span class="number">10</span> ，那么一定会溢出</span><br><span class="line">&gt;     <span class="number">2</span>)result 的值等于 Integer.MIN_VALUE / <span class="number">10</span>，那么 pop 的值如果小于于 Integer.MIN_VALUE % <span class="number">10</span> 也会溢出</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x%<span class="number">10</span>;</span><br><span class="line">        x = x/<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//考虑上界溢出</span></span><br><span class="line">        <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//考虑下界溢出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; Integer.MIN_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最后一位</span></span><br><span class="line">        res = res*<span class="number">10</span> +pop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/7.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>得到的最短的回文长度</title>
      <link href="/2019/05/%E5%9B%9E%E6%96%87/"/>
      <url>/2019/05/%E5%9B%9E%E6%96%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>京京和东东是好朋友。东东很喜欢回文。回文是指从前往后读和从后往前读是一样的词语。京京准备给东东一个惊喜，先取定一个字符串s，然后在后面附上0个或者更多个字母形成回文，京京希望这个回文越短越好。请帮助京京计算他能够得到的最短的回文长度。</p><a id="more"></a><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>输入包括一个字符串s，字符串s长度length(1 ≤ length ≤ 50)。</p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>输出一个整数，表示京京能够得到的最短的回文长度。</p><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>abab</p><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><p>5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><p>转化成求字符串中的最长回文子串的大小，结果即不是回文那部分逆序即可。</p><p>从左往右，</p><p>三个概念：回文半径数组pArr[]，回文右边界pr，取得回文右边界的轴中心i</p><p>1）没在回文右边界里边，暴力</p><p>2）i’在回文范围里，回文右边界不扩</p><p>3）i’在回文范围外，回文右边界不扩</p><p>4）i’压线，回文右边界扩</p><p>直到回文右边界第一次到达最后一个字符</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//manacher预处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">char</span>[] manacherString(String str) &#123;</span><br><span class="line"><span class="keyword">char</span>[] charArr = str.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != res.length; i++) &#123;</span><br><span class="line">res[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">'#'</span> : charArr[index++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">shortestEnd</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] charArr = manacherString(str);</span><br><span class="line"><span class="keyword">int</span>[] pArr = <span class="keyword">new</span> <span class="keyword">int</span>[charArr.length];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pR = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxContainsEnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != charArr.length; i++) &#123;</span><br><span class="line">pArr[i] = pR &gt; i ? Math.min(pArr[<span class="number">2</span> * index - i], pR - i) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])</span><br><span class="line">pArr[i]++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + pArr[i] &gt; pR) &#123;</span><br><span class="line">pR = i + pArr[i];</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右边界到达最后一个字符就结束，那个中心就是包含最后一个字符的最长的回文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pR == charArr.length) &#123;</span><br><span class="line">    <span class="comment">//得到那个中心</span></span><br><span class="line"></span><br><span class="line">maxContainsEnd = pArr[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原来的长度 + 扩充的长度（字符最大的半径[str.length+1-回文最大的半径maxContainEnd]）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str.length() + str.length() - maxContainsEnd + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner sr = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sr.nextLine();</span><br><span class="line">        System.out.println(shortestEnd(s));      </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 京东笔试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> manacher算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【5】最长回文子串</title>
      <link href="/2019/05/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/05/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串  <code>s</code>，找到  <code>s</code>  中最长的回文子串。你可以假设 <code>s</code>  的最大长度为 1000。<a id="more"></a></p><p><strong>示例 1：</strong></p><p><strong>输入:</strong> “babad”<br><strong>输出:</strong> “bab”<br><strong>注意:</strong> “aba” 也是一个有效答案。</p><p><strong>示例 2：</strong></p><p><strong>输入:</strong> “cbbd”<br><strong>输出:</strong> “bb”</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><h5 id="方法1：暴力破解方法"><a href="#方法1：暴力破解方法" class="headerlink" title="方法1：暴力破解方法"></a>方法1：暴力破解方法</h5><h5 id="方法2：动态规划"><a href="#方法2：动态规划" class="headerlink" title="方法2：动态规划"></a>方法2：动态规划</h5><blockquote><p>新建一个dp[i][j]代表的意思是索引从i到j的子字符串是否是回文，假设s = cbbd,则可以dp对应坐标索引下的子字符串：</p><table><thead><tr><th></th><th>i = 0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>j = 0</td><td>c</td><td>cb</td><td>cbb</td><td>cbbd</td></tr><tr><td>1</td><td></td><td>b</td><td>bb</td><td>bbd</td></tr><tr><td>2</td><td></td><td></td><td>b</td><td>bd</td></tr><tr><td>3</td><td></td><td></td><td></td><td>d</td></tr></tbody></table><p>如果dp[i][j]所代表的字符串为回文，则将dp设为1.由上表可以总结出：</p><p>（1）当i = j 时，dp[j][i]  = 1</p><p>（2）i-j=1时,比如dp[1][2]为bb，表示两个相邻的字符，此时我们只要判断str[1]==str[2]就能得出dp[1][2]的结果</p><p>（3）i-j&gt;1时，我们来看dp[0][2]，首先还是要判断开头和结尾是否相等，也就是判断 str[0]==str[2]，假如此时str[0]=str[2]，我们还要再看剩下的子串是否回文， 我们可以直接从dp[j+1][i-1]来判断剩下的子串，把结果直接拿来用,判断是否是1（1表示回文）</p><p>即有公式</p><pre><code>dp[i][j] = (dp[i+1][j-1] &amp;&amp;s[i]=S[j]​) == true?1:0</code></pre><p>dp数组初始化如下：</p><pre><code>dp[i][i] = 1</code></pre><p>   dp[i][i+1] = ( S[i] == S[i+1] ?1:0;</p></blockquote><h5 id="方法3：中心扩展方法"><a href="#方法3：中心扩展方法" class="headerlink" title="方法3：中心扩展方法"></a>方法3：中心扩展方法</h5><blockquote><p>回文中心的两侧互为镜像。因此，回文可以从他的中心展开，并且只有2n-1个这样的中心(一个元素为中心的情况有n个，两个元素为中心的情况有n-1个)</p></blockquote><h5 id="方法4：manacher算法"><a href="#方法4：manacher算法" class="headerlink" title="方法4：manacher算法"></a>方法4：manacher算法</h5><blockquote><p>（1）预处理：回文的长度可奇可偶，故在每个字符的左右都加上一个特殊字符“#”,得到长度为奇数的字符串</p><p>（2）回文子串的半径：以中间的 ‘1’ 为中心的回文子串 “#2#2#1#2#2#” 的半径是6，而未添加#号的回文子串为 “22122”，长度是5，为半径减1。</p><p>（3）子串的起始位置：（字符串前面在加一个特殊字符”\$”,在字符末尾加另一个特殊字符”.”）中间位置减去半径再除以2。</p><p>（4）子串的终点位置：起点位置+半径-1</p><p>（5）马拉车核心</p><pre><code>p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1;</code></pre><p>其中p[i]代表以i为中心的半径，id为能延伸到最右端的位置的那个回文子串的中心点位置，mx是回文串能延伸到的最右端的位置</p><p><img src="https://github.com/qiulig/IMG/raw/master/5_manecher1.png" alt="manecher"></p><p>1)mx - i &gt; p[j]，即以j为半径的回文在以id为半径的回文内(j跟i是对称的),其中 j = 2*id - i，因为 j 到 id 之间到距离等于 id 到 i 之间到距离，为 i - id，所以 j = id - (i - id) = 2*id - i.</p><p><img src="https://github.com/qiulig/IMG/raw/master/5_manecher2.png" alt="manecher"></p><p>2)mx - i &lt; p[j],即以j为中心的回文子串不一定完全包含于以id为中心的回文子串中，基于对称性可知，图中两个绿框所包围的部分是相同的，也就是说以i为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 p[i] = mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了，这就是后面紧跟到while循环的作用。</p><p>3)对于 mx &lt;= i 的情况，无法对 P[i]做更多的假设，只能P[i] = 1，然后再去匹配了。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>思路1：暴力破解方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       String temp = <span class="string">""</span>;</span><br><span class="line">       String res  =<span class="string">""</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;s.length();j++)&#123;</span><br><span class="line">               temp = temp+s.charAt(j);</span><br><span class="line">               <span class="comment">//re用来保存子字符串反转的结果</span></span><br><span class="line"></span><br><span class="line">               String re  = <span class="keyword">new</span> StringBuffer(temp).reverse().toString();</span><br><span class="line">               <span class="comment">//子字符串跟反转的字符串相等则为回文</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(temp.equals(re))&#123;</span><br><span class="line">                   res = res.length()&gt;temp.length()?res:temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = <span class="string">""</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2：动态规划思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//创建一个行列均为字符串长度的二维数组，创建时默认初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++)&#123;</span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;<span class="comment">//如果是回文字符串</span></span><br><span class="line">              <span class="comment">//新得到的回文比之前的回文字符串要长，更新字符串长度，记录字符串</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; max)&#123;</span><br><span class="line">                        max = j - i + <span class="number">1</span>;</span><br><span class="line">                        res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3：中心扩展方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span>  String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i); <span class="comment">//奇数的回文，中心有一个字母，以该字母往外扩</span></span><br><span class="line">            <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);  <span class="comment">//偶数的回文，中心有两个字母，以这两个字母往外扩</span></span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：马拉车算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) </span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"> <span class="comment">//manacher预处理</span></span><br><span class="line">        <span class="comment">//起点加特殊字符$ </span></span><br><span class="line">        String t = <span class="string">"$#"</span>;</span><br><span class="line">        <span class="comment">//每个字符左右都加特殊字符 #</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            t += s.charAt(i);</span><br><span class="line">            t += <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点加特殊字符&amp;</span></span><br><span class="line">        t+=<span class="string">"&amp;"</span>;</span><br><span class="line"> <span class="comment">//马拉车算法实现</span></span><br><span class="line">        <span class="comment">//定义半径</span></span><br><span class="line">        <span class="keyword">int</span> []p = <span class="keyword">new</span> <span class="keyword">int</span>[t.length()];</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.length()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//mancher核心算法</span></span><br><span class="line">            p[i] = mx &gt; i ? Math.min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//半径往外扩</span></span><br><span class="line">            <span class="keyword">while</span> (t.charAt(i + p[i]) == t.charAt(i-p[i]))</span><br><span class="line">                ++p[i];</span><br><span class="line">            <span class="comment">//以i为中心的回文子串不一定完全包含于以id为中心的回文子串中</span></span><br><span class="line">            <span class="keyword">if</span> ((mx-i) &lt;  p[i]) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">                resLen = p[i];</span><br><span class="line">                resCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring((resCenter - resLen) / <span class="number">2</span>, (resCenter - resLen) / <span class="number">2</span> + resLen - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/5_2.png" alt="动态规划"></p><p><img src="https://github.com/qiulig/IMG/raw/master/5_3.png" alt="中心扩展"></p><p><img src="https://github.com/qiulig/IMG/raw/master/5_4.png" alt="马拉车算法"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
            <tag> manacher算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【4】寻找两个有序数组的中位数</title>
      <link href="/2019/05/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/05/leetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code>  和 <code>nums2</code>。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。<a id="more"></a></p><p><strong>示例 1:</strong></p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0</p><p><strong>示例 2:</strong></p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>排序输出中间值，但是复杂度不符合题意</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>方法1：复杂度不符合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将两个数组放到一个数组中并从小到大排序</span></span><br><span class="line">        <span class="keyword">int</span>[] ints = ArrayUtils.addAll(nums1, nums2);</span><br><span class="line">        Arrays.sort(ints);</span><br><span class="line">        <span class="comment">//奇数个数返回 中间索引，偶数个返回最中间的两个数的平均，注意/2可能为小数，要/2d或者/2.0强转为double类型</span></span><br><span class="line">        <span class="keyword">if</span>(ints.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (ints[(ints.length+<span class="number">1</span>)/<span class="number">2</span>]+ints[(ints.length+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>d;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> ints[(ints.length-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法2：复杂度还是不符合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1Length = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n2Length = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> totalLength = n1Length + n2Length;</span><br><span class="line">        <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArrayIndex = totalLength / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n1Index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2Index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> last1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last2 = <span class="number">0</span>;  <span class="comment">//用于记录偶数情况下的last1的前一个数</span></span><br><span class="line">        <span class="keyword">while</span> (arrayIndex &lt;= maxArrayIndex) &#123;</span><br><span class="line">            last2 = last1;</span><br><span class="line">            <span class="comment">//只剩下nums2的情况了，nums1的全部数跟nums2排序都还没到达中间</span></span><br><span class="line">            <span class="keyword">if</span> (n1Index &gt;= n1Length) &#123;</span><br><span class="line">                last1 = nums2[n2Index++];</span><br><span class="line">            <span class="comment">//只剩下nums1的情况了，nums2的全部数跟nums1排序都还没到达中间</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n2Index &gt;= n2Length) &#123;</span><br><span class="line">                last1 = nums1[n1Index++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//哪个小哪个索引坐标【n1Index或者n2Index】开始滑动</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[n1Index] &lt;= nums2[n2Index]) &#123;</span><br><span class="line">                    last1 = nums1[n1Index++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    last1 = nums2[n2Index++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//整体数组【nums1 U nums2】的索引每循环依次自增1，直到到达整体数组中间位置</span></span><br><span class="line">            arrayIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (last1 + last2) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> last1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/4.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【3】无重复字符的最长子串</title>
      <link href="/2019/05/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/05/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<a id="more"></a></p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> “abcabcbb”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;abc&quot;，所以其</code>长度为 3。</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> “bbbbb”<br><strong>输出:</strong> 1<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;b&quot;</code>，所以其长度为 1。</p><p><strong>示例 3:</strong></p><p><strong>输入:</strong> “pwwkew”<br><strong>输出:</strong> 3<br><strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;wke&quot;</code>，所以其长度为 3。<br>     请注意，你的答案必须是 <strong>子串</strong> 的长度，<code>&quot;pwke&quot;</code> 是一个<em>子序列，</em>不是子串。</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>滑动窗口思想</p><pre><code>准备一个list用于滑动窗口，</code></pre><p>（1）当list里面没有该字符时，加入该字符，list.size()就是无重复字符发长度。依次跟MaxLength比较取最大</p><p>（2）当list里面存在该值时，移除list里面该字符出现的第一个索引所在位置之前的所有字符[因为要求最长字串，即连续，所以要移除之前全部的字符]</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MaxLength = <span class="number">0</span>;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//list里面没有该字符就判断加入该字符是否就是最长的字符串</span></span><br><span class="line">            <span class="keyword">if</span>(!list.contains(s.charAt(i)))&#123;</span><br><span class="line">                list.add(s.charAt(i));</span><br><span class="line">                MaxLength = Math.max(MaxLength,list.size());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//加入重复的字符，并返回第一个与之相等的字符的索引位置</span></span><br><span class="line">                list.add(s.charAt(i));</span><br><span class="line">                <span class="keyword">int</span> index = list.indexOf(s.charAt(i)); </span><br><span class="line">                <span class="comment">// 移除该值以及该字符前面所有的字符</span></span><br><span class="line">                <span class="keyword">while</span>(index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    list.remove(index--); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/3.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【2】两数相加</title>
      <link href="/2019/05/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2019/05/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给出两个 <strong>非空</strong>  的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<a id="more"></a></p><p><strong>示例：</strong></p><p><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出：</strong>7 -&gt; 0 -&gt; 8<br><strong>原因：</strong>342 + 465 = 807</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>（1）设置一个进位位flag,flag的值为(当前两链表值相加+flag)/10,链表存储的值为(当前两链表值相加+flag)%10，依次遍历直到两个链表都到达尾部</p><p>（2）如果结束了flag不为0，则将flag的值继续添加到结果链表的尾部。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//用于指向res链表头</span></span><br><span class="line">            ListNode ress = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            ListNode res = ress;</span><br><span class="line">            <span class="comment">//用于最后的进位和各位数的进位</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l1!=<span class="keyword">null</span> ||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//还没为空时为l1.val,空的时候设为0</span></span><br><span class="line">                <span class="keyword">int</span> x = l1!=<span class="keyword">null</span> ?l1.val:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> y = l2!=<span class="keyword">null</span>?l2.val:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> value = x+y+flag;  </span><br><span class="line">                <span class="comment">//得到进位位</span></span><br><span class="line">                flag = value/<span class="number">10</span>; </span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(value%<span class="number">10</span>);</span><br><span class="line">                res = res.next;   </span><br><span class="line">                <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果到最后一个数相加还有进位位，则链表长度扩展一位</span></span><br><span class="line">            <span class="keyword">if</span>(flag&gt;<span class="number">0</span>)  </span><br><span class="line">                res.next = <span class="keyword">new</span> ListNode(flag);</span><br><span class="line">            <span class="keyword">return</span> ress.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-提交记录"><a href="#4-提交记录" class="headerlink" title="4.提交记录"></a>4.提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/2.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【15】三数之和</title>
      <link href="/2019/05/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/05/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述："><a href="#1-题目描述：" class="headerlink" title="1.题目描述："></a>1.题目描述：</h3><h5 id="给定一个包含-n-个整数的数组-nums，判断-nums-中是否存在三个元素-a，b，c-，使得-a-b-c-0-？找出所有满足条件且不重复的三元组。"><a href="#给定一个包含-n-个整数的数组-nums，判断-nums-中是否存在三个元素-a，b，c-，使得-a-b-c-0-？找出所有满足条件且不重复的三元组。" class="headerlink" title="给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。"></a>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。<a id="more"></a></h5><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><blockquote><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p></blockquote><blockquote><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><ul><li>首先按升序排序；然后定义下标变量i,j,k，因为是三元组，所以要三个变量如果简单的遍历，那么跟是否有序没有关系，其时间复杂度将达到O(n^3)。仔细想想：如果当前选择了a、b、c三个数，如果其和小于目标target，那么需要将其中一个数用更大的数替换；反之亦然。但究竟替换三个数中的哪个数？无法确定就只能先固定两个变量，让其第三个变化（替换）。一种办法是：固定前两个数i,j，然后让k在一个范围中二分变化（二分查找思想）</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;Integer&gt; targets = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 用于去重</span></span><br><span class="line">        <span class="keyword">if</span>((nums.length&gt;<span class="number">0</span> &amp;&amp; nums.length&lt;<span class="number">3</span>) ||(nums.length&gt;<span class="number">0</span> &amp;&amp;nums[<span class="number">0</span>]&gt;<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=nums.length-<span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (!targets.contains(target)) &#123; <span class="comment">//用于去重</span></span><br><span class="line">                targets.add(target);</span><br><span class="line">                <span class="keyword">int</span> k = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[k] + nums[j] == target) &#123;</span><br><span class="line">                        List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                        li.add(nums[i]);</span><br><span class="line">                        li.add(nums[k]);</span><br><span class="line">                        li.add(nums[j]);</span><br><span class="line">                        list.add(li);</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; j &amp;&amp; nums[k] == nums[k + <span class="number">1</span>])</span><br><span class="line">                            ++k;</span><br><span class="line">                        <span class="keyword">while</span> (k &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                            --j;</span><br><span class="line">                        k++;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] + nums[j] &lt; target) &#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-我的提交记录"><a href="#4-我的提交记录" class="headerlink" title="4.我的提交记录"></a>4.我的提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/15.png" alt="leetcode提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_【1】两数之和</title>
      <link href="/2019/05/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/05/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h3><blockquote><p>给定一个整数数组  <code>nums</code> 和一个目标值  <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<a id="more"></a></p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9</p><p>所以返回 [<strong>0, 1</strong>]</p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><blockquote><p>依次遍历数组里面的数值</p><p>（1）用一个hashmap存储（target-nums[i],索引位置）</p><p>（2）如果下一次出现nums[i],说明找到了。直接将她的坐标跟之前存储的坐标存到结果。</p><p>如示例：nums = [2, 7, 11, 15], target = 9</p><p>   i = 0 时， map存入（7,0）</p><p>   i= 1时，发现map.get(num[i]) = map.get(7)!=null, 存在，即找到了，直接将map.get(7) =0,i = 1,这两个值存到结果res里面返回。 </p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//用一个hashmap进行存储【key = target-nums[i],value = 索引位置】</span></span><br><span class="line">            Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">            <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">               <span class="comment">//此时只要寻找map里面是否有nums[i],即找到两数之和</span></span><br><span class="line">               <span class="comment">//map.get(nums[i])指向的是(target-nums[i])那个数的索引，i指向的是nums[i]的索引</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(nums[i])!=<span class="keyword">null</span>)&#123;       </span><br><span class="line">                    res= <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(target-nums[i],i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-我的提交记录"><a href="#4-我的提交记录" class="headerlink" title="4.我的提交记录"></a>4.我的提交记录</h3><p><img src="https://github.com/qiulig/IMG/raw/master/1.png" alt="两数之和"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile介绍</title>
      <link href="/2019/05/volatile%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/05/volatile%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="并发编程的三大概念："><a href="#并发编程的三大概念：" class="headerlink" title="并发编程的三大概念："></a>并发编程的三大概念：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (1)原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</span><br><span class="line">  (2)可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</span><br><span class="line">  (3)有序性：程序执行的顺序按照代码的先后顺序执行。</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a><a id="more"></a></h4><h4 id="volatile介绍："><a href="#volatile介绍：" class="headerlink" title="volatile介绍："></a>volatile介绍：</h4><blockquote><p>1.volatile是虚拟机提供的最轻量级的同步机制</p><pre><code>保证变量对所有线程的可见性但是不保证原子性，需要通过加锁保证原子性。特例：1)运算结果并不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值2)变量不需要与其他状态变量共同参与不变约束</code></pre><p>2.禁止指令重排</p><pre><code>指令重拍是指CPU采用了允许多条指令不按程序规定的顺序分开发送给各相应电路单元处理，也能得到正确的结果。</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
          <category> 线程 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【66】机器人的运动范围</title>
      <link href="/2019/05/66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
      <url>/2019/05/66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>本题使用的方法同样还是回溯法，另外还需要会计算给定整数上的各个位上数之和。</p><pre><code>(1)使用一个访问数组记录是否已经经过该格子。机器人从(0,0)开始移动，当它准备进入(i,j)的格子时，通过检查坐标的数位来判断机器人是否能够进入。(2)如果机器人能进入(i,j)的格子，接着在判断它是否能进入四个相邻的格子(i,j-1),(i,j+1),(i-1,j),(i+1,j)。</code></pre><p>因此，可以用回溯法来解决这一问题。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rows&lt;<span class="number">1</span>||cols&lt;<span class="number">1</span>||threshold&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">boolean</span> []visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</span><br><span class="line">        <span class="keyword">return</span> count(threshold,rows,cols,visit,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span>[] visit, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(threshold,rows,cols,visit,row,col))</span><br><span class="line">        &#123;</span><br><span class="line">            visit[row*cols+col]=<span class="keyword">true</span>;</span><br><span class="line">            res=<span class="number">1</span>+count(threshold,rows,cols,visit,row,col+<span class="number">1</span>)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row,col-<span class="number">1</span>)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row+<span class="number">1</span>,col)</span><br><span class="line">                 +count(threshold,rows,cols,visit,row-<span class="number">1</span>,col);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[] visit, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">                     &amp;&amp; visit[row * cols + col] == <span class="keyword">false</span> &amp;&amp;getNum(col) + getNum(row) &lt;= threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取位数之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【65】矩阵中的路径</title>
      <link href="/2019/05/65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/05/65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 * 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>回溯法</p><p>(1)在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。<br>　　由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。<br>　　需要判断这个矩阵中的每一个结点是否可以走一条路径，在走的过程中，设置一个和矩阵大小相同的整型数组flag表示是否已经访问，如果某个结点访问了，那么该结点的是否访问则为1。每次遍历一个结点的时候，递归的方式分别向左、向右、向上、向下。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] flag = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(helper(matrix, rows, cols, i, j, str, <span class="number">0</span>, flag))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> k, <span class="keyword">int</span>[] flag)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = i * cols + j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols </span><br><span class="line">                || matrix[index] != str[k] || flag[index] == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// /下标不符合，index对应的值不为和字符数组中的不一致，或者该index已经被访问，这些情况只要有符合的就返回false</span></span><br><span class="line">            <span class="comment">// 只有上面的所有情况都不符合，也就是值相等，且没有访问过，下标不符合</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == str.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">if</span>(helper(matrix, rows, cols, i - <span class="number">1</span>, j, str, k + <span class="number">1</span>, flag)<span class="comment">//左</span></span><br><span class="line"></span><br><span class="line">        ||helper(matrix, rows, cols, i + <span class="number">1</span>, j, str, k + <span class="number">1</span>, flag)<span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">        ||helper(matrix, rows, cols, i, j - <span class="number">1</span>, str, k + <span class="number">1</span>, flag)<span class="comment">//上</span></span><br><span class="line"></span><br><span class="line">      ||helper(matrix, rows, cols, i , j + <span class="number">1</span>, str, k + <span class="number">1</span>, flag))<span class="comment">//下  </span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[index] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【64】滑动窗口的最大值</title>
      <link href="/2019/05/64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2019/05/64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。<a id="more"></a></p><h6 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h6><p>{2,3,4,2,6,2,5,1} ，3</p><h6 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h6><p>{4,4,6,6,6,5}</p><h6 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h6><p> 存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}；</p><p> 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： </p><pre><code>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</code></pre></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>我们可以使用双向队列（Linklist），队列中只存放当前元素的下标，</p><pre><code>(1)设新来的元素为k，如果前面的元素比k小，直接把前面的删除（因为不可能成为后面窗口的最大值）(2)如果前面的元素比k大，判断是否还在窗口范围内，不在则移除</code></pre><h6 id="以数组-2-3-4-2-6-2-5-1-为例"><a href="#以数组-2-3-4-2-6-2-5-1-为例" class="headerlink" title="以数组{2,3,4,2,6,2,5,1}为例"></a>以数组{2,3,4,2,6,2,5,1}为例</h6><pre><code>数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。第五个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (num==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">if</span> (num.length&lt;size||size&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num.length; i++)&#123;</span><br><span class="line">     <span class="comment">//如果前面的数比插入的数小，直接把前面删除(因为不可能成为后面窗口的最大值)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()&amp;&amp;num[i]&gt;=num[queue.getLast()])</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        <span class="comment">//如果前面的元素比k大，判断是否还在窗口范围内，不在则移除</span></span><br><span class="line">        <span class="comment">//(i-(size-1))即滑动窗口最左侧的坐标索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()&amp;&amp;queue.getFirst()&lt;i-(size-<span class="number">1</span>))</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        <span class="comment">//加入队尾</span></span><br><span class="line"></span><br><span class="line">        queue.offerLast(i);</span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>&gt;=size)</span><br><span class="line">            arr.add(num[queue.getFirst()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【63】数据流中的中位数</title>
      <link href="/2019/05/63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/05/63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用一个list存储插入的数，然后对其进行排序</p><p>(1) size == 0 , 返回 null;</p><p>(2) size是偶数 , 返回 数值排序之后中间两个数的平均值;</p><p>(3) size是奇数，返回 list.get(size/2);</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//添加操作</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">            list.add(num);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取中位数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">if</span>(size!=<span class="number">0</span>)&#123;</span><br><span class="line">               </span><br><span class="line">                Collections.sort(list);</span><br><span class="line">                <span class="keyword">if</span>(size%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> (list.get(size/<span class="number">2</span>)+list.get(size/<span class="number">2</span>-<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> list.get(size/<span class="number">2</span>)*<span class="number">1.0</span>;                  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【62】二叉搜索树的第K个结点</title>
      <link href="/2019/05/62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>方法1：</p><blockquote><p>用PriorityQueue将所有结点放到queue中，再依次弹出里面的数据（队首数据依次弹出），弹出的第k个数据就是要求的数值，再将它构建成TreeNode即可。</p></blockquote><p>方法2：</p><blockquote><p>根据二叉搜索树的特点，左子树上的点小于该点，右子树上的点大于该点。所以按照中序遍历的方法得到的序列即是从小到大的序列。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">     <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        preOrderRec(pRoot);</span><br><span class="line">        <span class="keyword">if</span>(queue.size()&lt;k ||k &lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode( queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderRec</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(root.val);</span><br><span class="line">            preOrderRec(root.left);</span><br><span class="line">            preOrderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    TreeNode node=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>||pRoot==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        KthNode(pRoot.left,k);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(k==index)</span><br><span class="line">        &#123; node=pRoot;</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        KthNode(pRoot.right,k);</span><br><span class="line">        <span class="keyword">return</span> node;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSR303参数校验和全局异常处理</title>
      <link href="/2019/05/JSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2019/05/JSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。故引出使用JSR303来做参数校验。参数校验的实现: <a id="more"></a></p><ul><li><p>手机号和密码字段自定义注解</p></li><li><p>为了让客户端显示更加友好 </p></li><li><p>需要自定义异常拦截器</p></li></ul></blockquote><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--JSR303参数检验+全局异常处理器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2-在需要验证的类前加-Valid并在该类内需要参数检查的成员上加自定义注解"><a href="#2-在需要验证的类前加-Valid并在该类内需要参数检查的成员上加自定义注解" class="headerlink" title="2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解"></a>2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/do_login"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">doLogin</span><span class="params">(HttpServletResponse  response,                                             </span></span></span><br><span class="line"><span class="function"><span class="params">                               @Valid LoginVo loginVo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(loginVo.toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginVo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@IsMobile</span></span><br><span class="line">    <span class="keyword">private</span>  String mobile;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-IsMobile注解的编写-可参考-NotNull"><a href="#3-IsMobile注解的编写-可参考-NotNull" class="headerlink" title="3. IsMobile注解的编写[可参考@NotNull]"></a>3. IsMobile注解的编写[可参考@NotNull]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">            ElementType.METHOD,</span><br><span class="line">            ElementType.FIELD, </span><br><span class="line">            ElementType.ANNOTATION_TYPE, </span><br><span class="line">            ElementType.CONSTRUCTOR,</span><br><span class="line">            ElementType.PARAMETER, </span><br><span class="line">            ElementType.TYPE_USE</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(</span><br><span class="line">        validatedBy = &#123;IsMobileValidator.class&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IsMobile &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "电话号码格式错误"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-指定校验器的实现-IsMobileValidator-class"><a href="#4-指定校验器的实现-IsMobileValidator-class" class="headerlink" title="4.指定校验器的实现[IsMobileValidator.class]"></a>4.指定校验器的实现[IsMobileValidator.class]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsMobileValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">IsMobile</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> required = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//初始化方法拿到注解，可以定义一个字符为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IsMobile constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        constraintAnnotation.required();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//值是必须的</span></span><br><span class="line">        <span class="keyword">if</span>(required)&#123;</span><br><span class="line">            <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-自定义异常拦截器"><a href="#5-自定义异常拦截器" class="headerlink" title="5.自定义异常拦截器"></a>5.自定义异常拦截器</h4><blockquote><p>当校验不通过时，会抛出异常。这时如果没有定义全局异常处理器进行处理（对异常进行封装和返回）。则会发生400错误（即只有请求的发起，却没有收到正常的响应（response），因为还没有来得及return就抛出了异常（这种异常没有被处理））。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">exceptionHandler</span><span class="params">(HttpServletRequest request,Exception e)</span></span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> GlobalException) &#123;</span><br><span class="line">            GlobalException ex = (GlobalException) e;</span><br><span class="line">            <span class="keyword">return</span> Result.Error(ex.getCm());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> BindException)&#123;</span><br><span class="line">            BindException ex = (BindException) e;</span><br><span class="line">            List&lt;ObjectError&gt; errors = ex.getAllErrors();</span><br><span class="line">            <span class="comment">//为了方便起见，只取第一个错误</span></span><br><span class="line"></span><br><span class="line">            ObjectError error = errors.get(<span class="number">0</span>);</span><br><span class="line">            String msg = error.getDefaultMessage();</span><br><span class="line">            <span class="keyword">return</span> Result.Error(CodeMsg.BIND_ERROR.fillArgs(msg));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.Error(CodeMsg.SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用缓存key</title>
      <link href="/2019/05/%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key/"/>
      <url>/2019/05/%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="通用缓存key的作用"><a href="#通用缓存key的作用" class="headerlink" title="通用缓存key的作用"></a>通用缓存key的作用</h2><h5 id="当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id-订单Id，用户id等-此时若是id出现重复，将给系统带来错误。"><a href="#当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id-订单Id，用户id等-此时若是id出现重复，将给系统带来错误。" class="headerlink" title="当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。"></a>当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。<a id="more"></a></h5><p>方法：利用一个前缀来规定不同模块的缓存的key,这样不同模块之间就不会重复。</p><p>通用缓存key采用模板模式：接口-&gt;抽象类-&gt;实现类</p><h5 id="1-接口"><a href="#1-接口" class="headerlink" title="1. 接口"></a>1. 接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyPrefix</span> </span>&#123;</span><br><span class="line">    <span class="comment">//过期时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expireSeconds</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//前缀</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePrefix</span> <span class="keyword">implements</span> <span class="title">KeyPrefix</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expireSeconds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="comment">//无过期时间的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePrefix</span><span class="params">(String prefix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>(<span class="number">0</span>, prefix);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//含有过期时间的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePrefix</span><span class="params">( <span class="keyword">int</span> expireSeconds, String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expireSeconds = expireSeconds;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expireSeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> expireSeconds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取前缀，前缀为 className：prefix</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String className = getClass().getSimpleName();</span><br><span class="line">        <span class="keyword">return</span> className+<span class="string">":"</span> + prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-实现类"><a href="#3-实现类" class="headerlink" title="3. 实现类"></a>3. 实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaKey</span> <span class="keyword">extends</span> <span class="title">BasePrefix</span></span>&#123;</span><br><span class="line">    <span class="comment">//继承父类的无过期时间的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiaoshaKey</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置她这个类的前缀是className:go</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MiaoshaKey isGoodsOver = <span class="keyword">new</span> MiaoshaKey(<span class="string">"go"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitMQ实现消息缓冲</title>
      <link href="/2019/05/rabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2019/05/rabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>RabbitMQ主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是AMQP协议，它是一种二进制协议。默认启动端口5672`</p></blockquote><a id="more"></a><p>rabbitMQ的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，生产者producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。</p><ul><li><p><strong>Direct</strong>：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个       routing_key, 根据key全文匹配去寻找队列</p></li><li><p><strong>Topic</strong>：按规则转发消息（最灵活）<em>转发消息主要是根据通配符</em></p></li><li><p><strong>Headers</strong>：设置 header attribute 参数类型的交换机</p></li><li><p><strong>Fanout</strong>：转发消息到所有绑定队列(广播方式)</p><p><img src="https://github.com/qiulig/IMG/raw/master/rabbitMQ.png" alt="rabbitMQ原理"></p></li></ul><h3 id="下面介绍4种交换机与springboot的集成"><a href="#下面介绍4种交换机与springboot的集成" class="headerlink" title="下面介绍4种交换机与springboot的集成"></a>下面介绍4种交换机与springboot的集成</h3><p>添加依赖包amqp,统一配置application.properties</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--rabbitMQ依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">##rabbitMQ</span><br><span class="line">spring.rabbitmq.host=127.0.0.1</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br><span class="line">#消费者数量</span><br><span class="line">spring.rabbitmq.listener.simple.concurrency= 10</span><br><span class="line">spring.rabbitmq.listener.simple.max-concurrency= 10</span><br><span class="line">#消费者每次从队列获取的消息数量</span><br><span class="line">spring.rabbitmq.listener.simple.prefetch= 1</span><br><span class="line">#消费者自动启动</span><br><span class="line">spring.rabbitmq.listener.simple.auto-startup=true</span><br><span class="line">#消费失败，自动重新入队</span><br><span class="line">spring.rabbitmq.listener.simple.default-requeue-rejected= true</span><br><span class="line">#启用发送重试</span><br><span class="line">spring.rabbitmq.template.retry.enabled=true </span><br><span class="line">spring.rabbitmq.template.retry.initial-interval=1000</span><br><span class="line">spring.rabbitmq.template.retry.max-attempts=3</span><br></pre></td></tr></table></figure><h4 id="1-Direct交换机制"><a href="#1-Direct交换机制" class="headerlink" title="1. Direct交换机制"></a>1. Direct交换机制</h4><blockquote><p>一个队列会和一个交换机绑定，除此之外再绑定一个routing_key，当消息被发送的时候，需要指定一个binding_key，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个binding_key也是支持应用到多个队列中的。 这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。</p></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/direct.png" alt="direct原理"></p><h5 id="1-1-编写config"><a href="#1-1-编写config" class="headerlink" title="1.1 编写config"></a>1.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  QUEUE =<span class="string">"queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-创建消息发送者"><a href="#1-2-创建消息发送者" class="headerlink" title="1.2 创建消息发送者"></a>1.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate  amqpTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(MQreceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">        String msg = redisService.beanToString(message);</span><br><span class="line">        log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">        amqpTemplate.convertAndSend(MQconfig.Queue,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-创建消息接收者"><a href="#1-3-创建消息接收者" class="headerlink" title="1.3 创建消息接收者"></a>1.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(MQreceiver.class);</span><br><span class="line">    <span class="comment">//监听了queue的队列</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQconfig.Queue)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive message"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-编写controller测试"><a href="#1-4-编写controller测试" class="headerlink" title="1.4 编写controller测试"></a>1.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123; <span class="meta">@Autowired</span></span><br><span class="line">    MQsender sender;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/mq"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Result&lt;Boolean&gt; <span class="title">mq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sender.send(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-Fanout交换机制"><a href="#2-Fanout交换机制" class="headerlink" title="2. Fanout交换机制"></a>2. Fanout交换机制</h4><ul><li><p>扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。</p><p><img src="https://github.com/qiulig/IMG/raw/master/fanout.png" alt="Fanout原理"></p></li></ul><h5 id="2-1-编写config"><a href="#2-1-编写config" class="headerlink" title="2.1 编写config"></a>2.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  FANOUT_EXCHANGE =<span class="string">"fanoutxchage"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Binding <span class="title">fanoutBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span>       </span><br><span class="line">          BindingBuilder.bind(topticQueue2()).to(fanoutExchange());</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-创建消息发送者"><a href="#2-2-创建消息发送者" class="headerlink" title="2.2 创建消息发送者"></a>2.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> AmqpTemplate amqpTemplate;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> RedisService redisService;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFanout</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String msg = redisService.beanToString(message);</span><br><span class="line">    log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">    amqpTemplate.convertAndSend(MQconfig.FANOUT_EXCHANGE,<span class="string">""</span>,msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-创建消息接收者"><a href="#2-3-创建消息接收者" class="headerlink" title="2.3 创建消息接收者"></a>2.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">     <span class="comment">//fanout 广播模式都接受故不需要listener</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-编写controller测试"><a href="#2-4-编写controller测试" class="headerlink" title="2.4 编写controller测试"></a>2.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(<span class="string">"/mq/fanout"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Result&lt;String&gt; <span class="title">fanout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sender.sendFanout(<span class="string">"hellommxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">"hello xuanzi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-topic交换机制"><a href="#3-topic交换机制" class="headerlink" title="3. topic交换机制"></a>3. topic交换机制</h4><blockquote><p>通配符交换机，exchange会把消息发送到一个或者多个满足通配符规则的<code>routing-key</code>的queue。其中<em>表号匹配一个word，#匹配多个word和路径，路径之间通过.隔开。如满足a.</em>.c的routing-key有a.hello.c；满足#.hello的routing-key有a.b.c.helo。</p></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/topic.png" alt="topic原理"></p><h5 id="1-1-编写config-1"><a href="#1-1-编写config-1" class="headerlink" title="1.1 编写config"></a>1.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  TOPIC_QUEUE1 =<span class="string">"topic.queue1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  TOPIC_QUEUE2 =<span class="string">"topic.queue2"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  TOPIC_EXCHANGE =<span class="string">"topicExchange"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topticQueue1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE1,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueue2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE2,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPIC_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topticQueue1()).to(topicExchange()).with(<span class="string">"topic.key1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topticQueue2()).to(topicExchange()).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-创建消息发送者-1"><a href="#1-2-创建消息发送者-1" class="headerlink" title="1.2 创建消息发送者"></a>1.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTopic</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line">    String msg = redisService.beanToString(message);</span><br><span class="line">    log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">  amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE,</span><br><span class="line">                                <span class="string">"topic.key1"</span>,msg+<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE,</span><br><span class="line">                                <span class="string">"topic.key2"</span>,msg+<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-创建消息接收者-1"><a href="#1-3-创建消息接收者-1" class="headerlink" title="1.3 创建消息接收者"></a>1.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQconfig.TOPIC_QUEUE1)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveTopic1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive topic queue1 message"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = MQconfig.TOPIC_QUEUE2)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveTopic2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive topic queue2 message"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-编写controller测试-1"><a href="#1-4-编写controller测试-1" class="headerlink" title="1.4 编写controller测试"></a>1.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(<span class="string">"/mq/topic"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Result&lt;String&gt; <span class="title">topic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sender.sendTopic(<span class="string">"hellommxx"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">"hello xuanzi"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-header交换机制"><a href="#4-header交换机制" class="headerlink" title="4. header交换机制"></a>4. header交换机制</h4><blockquote><p>header exchange(头交换机)和主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据。<br>主题交换机路由键只有是字符串,而头交换机可以是整型和哈希值</p></blockquote><h5 id="1-1-编写config-2"><a href="#1-1-编写config-2" class="headerlink" title="1.1 编写config"></a>1.1 编写config</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQconfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String  HEADER_QUEUE =<span class="string">"header.queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeadersExchange <span class="title">headersExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeadersExchange(HEADERS_EXCHANGE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Queue <span class="title">headerQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Queue(HEADER_QUEUE,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Binding <span class="title">headerBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Map&lt;String,Object&gt; map =<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">       map.put(<span class="string">"header1"</span>,<span class="string">"value1"</span>);</span><br><span class="line"></span><br><span class="line">       map.put(<span class="string">"header2"</span>,<span class="string">"value2"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> </span><br><span class="line">         BindingBuilder.bind(headerQueue()).to(headersExchange())</span><br><span class="line">                                           .whereAll(map).match();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-创建消息发送者-2"><a href="#1-2-创建消息发送者-2" class="headerlink" title="1.2 创建消息发送者"></a>1.2 创建消息发送者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQsender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendheader</span><span class="params">(Object message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String msg = redisService.beanToString(message);</span><br><span class="line">    log.info(<span class="string">"send message"</span>+msg);</span><br><span class="line">    MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">    properties.setHeader(<span class="string">"header1"</span>,<span class="string">"value1"</span>);</span><br><span class="line">    properties.setHeader(<span class="string">"header2"</span>,<span class="string">"value2"</span>);</span><br><span class="line">    Message obj = <span class="keyword">new</span> Message(msg.getBytes(),properties);</span><br><span class="line">    amqpTemplate.convertAndSend(MQconfig.HEADERS_EXCHANGE,<span class="string">""</span>,obj);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-创建消息接收者-2"><a href="#1-3-创建消息接收者-2" class="headerlink" title="1.3 创建消息接收者"></a>1.3 创建消息接收者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQreceiver</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RabbitListener</span>(queues = MQconfig.HEADER_QUEUE)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveHeader</span><span class="params">(<span class="keyword">byte</span>[] message)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          log.info(<span class="string">"receive header queue message"</span>+message);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-编写controller测试-2"><a href="#1-4-编写controller测试-2" class="headerlink" title="1.4 编写controller测试"></a>1.4 编写controller测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">      <span class="meta">@RequestMapping</span>(<span class="string">"/mq/header"</span>)</span><br><span class="line">      <span class="meta">@ResponseBody</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span>  Result&lt;String&gt; <span class="title">header</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">          sender.sendheader(<span class="string">"hellommxx"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> Result.success(<span class="string">"hello xuanzi"</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存java端实现</title>
      <link href="/2019/05/Redis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/Redis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>redis是一个key-value<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">存储系统</a>。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(<a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">链表</a>)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">数据类型</a>都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。<a id="more"></a></p><h5 id="1-引入redis依赖"><a href="#1-引入redis依赖" class="headerlink" title="1. 引入redis依赖"></a>1. 引入redis依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="2-在application-properties添加redis配置文件"><a href="#2-在application-properties添加redis配置文件" class="headerlink" title="2.在application.properties添加redis配置文件"></a>2.在application.properties添加redis配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#redis</span><br><span class="line">redis.host=127.0.0.1</span><br><span class="line">redis.port=6379</span><br><span class="line">redis.timeout=3</span><br><span class="line">redis.password=2966</span><br><span class="line">redis.poolMaxTotal=10   //资源池中最大连接数</span><br><span class="line">redis.poolMaxIdle=10   //允许的最大空闲的连接数</span><br><span class="line">redis.poolMaxWait=3</span><br></pre></td></tr></table></figure><h5 id="3-定义redis的类，引入redis的配置"><a href="#3-定义redis的类，引入redis的配置" class="headerlink" title="3.定义redis的类，引入redis的配置"></a>3.定义redis的类，引入redis的配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"redis"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String host;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> timeout;<span class="comment">//秒</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> poolMaxTotal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> poolMaxIdle;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> poolMaxWait;<span class="comment">//秒</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-RedisPoolFactory类，用于返回一个redis池"><a href="#4-RedisPoolFactory类，用于返回一个redis池" class="headerlink" title="4.RedisPoolFactory类，用于返回一个redis池"></a>4.RedisPoolFactory类，用于返回一个redis池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPoolFactory</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   RedisConfig redisConfig;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisPool <span class="title">JedisPoolFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">      <span class="comment">//允许最大空闲的连接数</span></span><br><span class="line"></span><br><span class="line">      poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());</span><br><span class="line">      <span class="comment">//资源池中最大连接数</span></span><br><span class="line"></span><br><span class="line">      poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());</span><br><span class="line">      <span class="comment">//最大等待毫秒数</span></span><br><span class="line"></span><br><span class="line">      poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * <span class="number">1000</span>);</span><br><span class="line">      JedisPool jp = <span class="keyword">new</span> JedisPool(poolConfig,</span><br><span class="line">                                   redisConfig.getHost(),                                                                                                                                                                                                                                                    </span><br><span class="line">                                   redisConfig.getPort(),</span><br><span class="line"></span><br><span class="line">                                   redisConfig.getTimeout()*<span class="number">1000</span>,          </span><br><span class="line"></span><br><span class="line">                                   redisConfig.getPassword(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> jp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-编写RedisService类"><a href="#5-编写RedisService类" class="headerlink" title="5.编写RedisService类"></a>5.编写RedisService类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line">    <span class="comment">//里面编写redis操作：增删改查</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">returnToPool</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">             jedis.close();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-1-获取单个对象-get"><a href="#5-1-获取单个对象-get" class="headerlink" title="5.1 获取单个对象(get)"></a>5.1 获取单个对象(get)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的get key </span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(KeyPrefix prefix, String key,  Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">             <span class="comment">//生成真正的key,之前设置通用缓存key时的key设为className:key</span></span><br><span class="line"></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">             <span class="comment">//跟redis里面的获取一个key操作一致 </span></span><br><span class="line"></span><br><span class="line">             String  str = jedis.get(realKey);</span><br><span class="line">             <span class="comment">//将结果转换成一个java对象</span></span><br><span class="line"></span><br><span class="line">             T t =  stringToBean(str, clazz);</span><br><span class="line">             <span class="keyword">return</span> t;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="comment">//关闭池资源</span></span><br><span class="line"></span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//json转换为java对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; <span class="function">T <span class="title">stringToBean</span><span class="params">(String str, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span> || clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span>.class || clazz == Integer.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> (T)Integer.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> (T)str;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span>.class || clazz == Long.class) &#123;</span><br><span class="line">            <span class="keyword">return</span>  (T)Long.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJavaObject(JSON.parseObject(str), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-2-设置对象-set"><a href="#5-2-设置对象-set" class="headerlink" title="5.2 设置对象(set)"></a>5.2 设置对象(set)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的set key value</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">set</span><span class="params">(KeyPrefix prefix, String key,  T value)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">             <span class="comment">//对象转换为json字符串</span></span><br><span class="line"></span><br><span class="line">             String str = beanToString(value);</span><br><span class="line">             <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">             <span class="comment">//获取过期时间</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">int</span> seconds =  prefix.expireSeconds();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">//永久有效，无过期时间</span></span><br><span class="line"></span><br><span class="line">                 jedis.set(realKey, str);</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//为指定的 key 设置值及其过期时间。</span></span><br><span class="line"></span><br><span class="line">                 jedis.setex(realKey, seconds, str);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象转化为Json字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; <span class="function">String <span class="title">beanToString</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; clazz = value.getClass();</span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span>.class || clazz == Integer.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String.class) &#123;</span><br><span class="line">             <span class="keyword">return</span> (String)value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span>.class || clazz == Long.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-3-判断key是否存在-exists"><a href="#5-3-判断key是否存在-exists" class="headerlink" title="5.3 判断key是否存在(exists)"></a>5.3 判断key是否存在(exists)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想当于redis里面的 exists key</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">     Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         jedis =  jedisPool.getResource();</span><br><span class="line">        <span class="comment">//生成真正的key</span></span><br><span class="line">         String realKey  = prefix.getPrefix() + key;</span><br><span class="line">        <span class="keyword">return</span>  jedis.exists(realKey);</span><br><span class="line">     &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          returnToPool(jedis);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="5-4-增加值-incr"><a href="#5-4-增加值-incr" class="headerlink" title="5.4 增加值(incr)"></a>5.4 增加值(incr)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的incr key_name</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Long <span class="title">incr</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">return</span>  jedis.incr(realKey);</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-5-减少值-decr"><a href="#5-5-减少值-decr" class="headerlink" title="5.5 减少值(decr)"></a>5.5 减少值(decr)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的decr key_name</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Long <span class="title">decr</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">         Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">             String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">return</span>  jedis.decr(realKey);</span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">              returnToPool(jedis);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="5-6-删除-del"><a href="#5-6-删除-del" class="headerlink" title="5.6 删除(del)"></a>5.6 删除(del)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于redis里面的del key_name</span></span><br><span class="line">    <span class="comment">//已知key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">            String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">long</span> ret  = jedis.del(realKey);</span><br><span class="line">            <span class="keyword">return</span> ret &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            returnToPool(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过正则匹配删除 某key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(KeyPrefix prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; keys = scanKeys(prefix.getPrefix());</span><br><span class="line">        <span class="keyword">if</span>(keys==<span class="keyword">null</span> || keys.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.del(keys.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">scanKeys</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            String cursor = <span class="string">"0"</span>;</span><br><span class="line">            <span class="comment">//scan搜索</span></span><br><span class="line"></span><br><span class="line">            ScanParams sp = <span class="keyword">new</span> ScanParams();</span><br><span class="line">            sp.match(<span class="string">"*"</span>+key+<span class="string">"*"</span>);</span><br><span class="line">            <span class="comment">//设置scan的个数</span></span><br><span class="line"></span><br><span class="line">            sp.count(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                ScanResult&lt;String&gt; ret = jedis.scan(cursor, sp);</span><br><span class="line">                <span class="comment">//返回结果</span></span><br><span class="line"></span><br><span class="line">                List&lt;String&gt; result = ret.getResult();</span><br><span class="line">                <span class="keyword">if</span>(result!=<span class="keyword">null</span> &amp;&amp; result.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//搜索的结果存入list</span></span><br><span class="line"></span><br><span class="line">                    keys.addAll(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//再处理cursor，用于返回下次遍历的游标</span></span><br><span class="line"></span><br><span class="line">                cursor = ret.getStringCursor();</span><br><span class="line">            &#125;<span class="keyword">while</span>(!cursor.equals(<span class="string">"0"</span>));</span><br><span class="line">            <span class="keyword">return</span> keys;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="6-controller层测试"><a href="#6-controller层测试" class="headerlink" title="6.controller层测试"></a>6.controller层测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis/get"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Result&lt;User&gt; <span class="title">getRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">   User user = redisService.get(UserKey.getById,<span class="string">"key1"</span>,User.class);</span><br><span class="line">    <span class="keyword">return</span> Result.success(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis/set"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Result&lt;Boolean&gt; <span class="title">setRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setName(<span class="string">"1111"</span>);</span><br><span class="line">    redisService.set(UserKey.getById,<span class="string">""</span>+<span class="number">1</span>,user);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【61】序列化二叉树</title>
      <link href="/2019/05/61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树 <a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>二叉树的序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>先序序列化二叉树——&gt;&gt;&gt;&gt;定义一个stringbuilder保存序列过程中的结果：</p><p>(1)按照先序遍历方式遍历二叉树，若结点非空则把 “结点值,” append到builder中；</p><p>(2)若结点空则把 “#,” append到builder中；</p><p>(3)最后用builder生成字符串就是序列化结果。</p><p>二叉树的反序列化</p><pre><code>根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</code></pre><p>(1)先序序列化结果重构二叉树</p><p>(2)String[] nodes=str.split(“,”)；//由每个结点的结束符号划分序列化结果序列，得到各个结点值；</p><p>(3)然后按照先序遍历的顺序“根左右”的特性，遍历nodes数组建立二叉树：</p><p>  1)当前遍历元素非 # 则作为一个结点插入树中作为上一结点的左儿子；</p><p>  2)当前遍历元素为 # 则表示此子树已结束，遍历下一元素作为上一结点的右儿子；</p><p>即：<strong>遇数作左；遇#变向</strong></p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;    </span><br><span class="line">        TreeNode left = <span class="keyword">null</span>;    </span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;        </span><br><span class="line">            <span class="keyword">this</span>.val = val;    </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index = -<span class="number">1</span>;  </span><br><span class="line">    <span class="comment">//室友递归先序遍历对二叉树进行序列化</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;        </span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;            </span><br><span class="line">            sb.append(<span class="string">"#,"</span>);            </span><br><span class="line">            <span class="keyword">return</span> sb.toString();        </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="comment">//先序遍历根结点</span></span><br><span class="line">        sb.append(root.val + <span class="string">","</span>);</span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        sb.append(Serialize(root.left));   </span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        sb.append(Serialize(root.right));        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//特殊输入</span></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()&lt;=<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将字符串按照","拆分为数组</span></span><br><span class="line">        String[] strr = str.split(<span class="string">","</span>);        </span><br><span class="line">        <span class="keyword">int</span> len = strr.length;        </span><br><span class="line">        index++;        </span><br><span class="line">        <span class="keyword">if</span>(index &gt;= len)&#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="comment">//如果遇到的是#表示空节点，不再建立子树，这个结点null就是子树的根结点返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!strr[index].equals(<span class="string">"#"</span>))&#123;            </span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(Integer.valueOf(strr[index]));            </span><br><span class="line">            <span class="comment">//恢复左子树</span></span><br><span class="line">            node.left = Deserialize(str);            </span><br><span class="line">            <span class="comment">//恢复右子树</span></span><br><span class="line">            node.right = Deserialize(str);       </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//建立二叉树完成，返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> node;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【60】把二叉树打印成多行</title>
      <link href="/2019/05/60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/"/>
      <url>/2019/05/60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 <a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>利用层次遍历二叉树的方式，用一个队列进行辅助，每次打印前取n = queue.size()，可以保证逐行打印。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="comment">//加入根结点</span></span><br><span class="line">       queue.add(pRoot);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//每遍历一次，就新建一次tmp</span></span><br><span class="line">           ArrayList&lt;Integer&gt;  tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">int</span> count = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(queue.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//加入左结点</span></span><br><span class="line">                   queue.add(queue.peek().left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(queue.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//加入右结点</span></span><br><span class="line">                   queue.add(queue.peek().right);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//删除并返回queue中的头元素，删掉根（上一层结点元素）</span></span><br><span class="line">               tmp.add(queue.poll().val);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将一层的左右结点加入res</span></span><br><span class="line">           res.add(tmp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【59】按之字形顺序打印二叉树</title>
      <link href="/2019/05/59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用一个布尔量控制从左到右还是从右到左的顺序；如果为真则他的左右孩子按照从左到右的顺序放入list中，否则按照从右到左的顺序，当本行结束之后，再把list中的数据放入一个result中。其中用一个null值作为层次的分隔符。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">      ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.addLast(<span class="keyword">null</span>);<span class="comment">//层分隔符</span></span><br><span class="line">       queue.addLast(pRoot);</span><br><span class="line">       <span class="keyword">boolean</span> leftToRight = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">while</span> (queue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">           TreeNode node = queue.removeFirst();</span><br><span class="line">           <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;<span class="comment">//到达层分隔符</span></span><br><span class="line">               Iterator&lt;TreeNode&gt; iter = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (leftToRight) &#123;</span><br><span class="line">                      iter = queue.iterator();<span class="comment">//从前往后遍历</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">//从后往前遍历</span></span><br><span class="line"></span><br><span class="line">                       iter = queue.descendingIterator();</span><br><span class="line">                   &#125;</span><br><span class="line">               leftToRight = !leftToRight;</span><br><span class="line">               <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                       TreeNode temp = (TreeNode) iter.next();</span><br><span class="line">                       list.add(temp.val);</span><br><span class="line">                   &#125;</span><br><span class="line">               result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">               list.clear();</span><br><span class="line">               queue.addLast(<span class="keyword">null</span>);<span class="comment">//添加层分隔符</span></span><br><span class="line">               <span class="keyword">continue</span>;<span class="comment">//一定要continue</span></span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.addLast(node.left);</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.addLast(node.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【58】对称的二叉树</title>
      <link href="/2019/05/58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p> 【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。</p><p>【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。</p><p>【分析3】根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到</p><pre><code>① 如果Root和Root&apos;均为空，则返回true；② 如果Root为空或者Root&apos;为空，则返回false；③ 如果Root对应的值与Root&apos;对应的值不相等，则返回false。</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span> || pRoot.left==<span class="keyword">null</span>&amp;&amp;pRoot.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Symmetrical(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">Symmetrical</span><span class="params">(TreeNode left,TreeNode right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val==right.val)</span><br><span class="line">                    <span class="comment">//右子树的左边跟左子树的右边是否对称</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>    Symmetrical(left.left,right.right)</span><br><span class="line">                   <span class="comment">//左子树的右边跟右子树的左边是否对称</span></span><br><span class="line">                   &amp;&amp; Symmetrical(left.right,right.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【57】二叉树的下一个结点</title>
      <link href="/2019/05/57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>情况1：该节点有右子树：</p><pre><code>         6     /      \   3         10 /   \      /    \2     5    8      12</code></pre><p>中序遍历结果为：2–&gt;3–&gt;5–&gt;<strong>6–&gt;8</strong>–&gt;10–&gt;12</p><p>即它的下一个结点就是它的右子树中<strong>最左子结点</strong></p></blockquote><blockquote><p>情况2.1：该节点无右子树：(为父节点6的左子节点)</p><pre><code>        6     /     \   3        10  /        /    \2         8      12</code></pre><p>2–&gt;<strong>3–&gt;6</strong>–&gt;8–&gt;10–&gt;12</p><p>该节点是父节点的左子节点的这种情况比较简单，直接将父节点返回即可</p></blockquote><blockquote><p>情况2.2：该节点无右子树：(为父节点6的右子节点)</p><pre><code>          6       /    \     3        10  /     \     /   \2       5    8    null</code></pre><p>   2–&gt;3–&gt;6–&gt;8–&gt;<strong>10 –&gt;null</strong></p><p>如果是父节点的右子节点的话，需要不断的向上移动，直到对应的节点不是父节点的右节点（即左节点），既然他是父节点的左节点，此时将这个节点父节点返回即可，或者遍历到了根节点，返回null；</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该节点有右子树,它的下一个结点就是它的右子树中最左子结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该节点无右子树，父节点不为空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//pNode为父节点的左节点为该节点，直接返回父节点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left== pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">       <span class="comment">//为父节点的右子节点，不断的向上移动，直到对应的节点不是父节点的左子节点                  </span></span><br><span class="line">       <span class="comment">//一直回溯如果遍历到他是父节点的左节点，此时将这个节点父节点返回即可，</span></span><br><span class="line">       <span class="comment">//或者遍历到了根节点，返回null；</span></span><br><span class="line"></span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【56】删除链表中重复的结点</title>
      <link href="/2019/05/56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 <a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>方法一：重头构建该链表</p><p>(1) 新建两个list，一个用于存放只出现一次的数值，一个存放重复的数值</p><p>(2) 将只出现过一次的数重头构建成链表</p><p>方法二：递归思想</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; ss = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           ArrayList&lt;Integer&gt; ss2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">           ListNode node = res;</span><br><span class="line">           <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(!ss.contains(pHead.val) &amp;&amp; !ss2.contains(pHead.val))&#123;</span><br><span class="line"></span><br><span class="line">                   ss.add(pHead.val);</span><br><span class="line">                   pHead = pHead.next;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   ss2.add(pHead.val);</span><br><span class="line">                   ss.remove(Integer.valueOf(pHead.val));</span><br><span class="line">                   pHead = pHead.next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ss.size();i++)&#123;</span><br><span class="line">               res.next =<span class="keyword">new</span> ListNode(ss.get(i));</span><br><span class="line">               res = res.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> node.next;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有0个或1个结点，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pHead.val == pHead.next.val) &#123; <span class="comment">// 当前结点是重复结点</span></span><br><span class="line">            ListNode pNode = pHead.next;</span><br><span class="line">            <span class="keyword">while</span> (pNode != <span class="keyword">null</span> &amp;&amp; pNode.val == pHead.val) &#123;</span><br><span class="line">              <span class="comment">// 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点</span></span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从第一个与当前结点不同的结点开始递归</span></span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(pNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前结点不是重复结点</span></span><br><span class="line">            <span class="comment">// 保留当前结点，从下一个结点开始递归</span></span><br><span class="line">            pHead.next = deleteDuplication(pHead.next); </span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【55】链表中环的入口结点</title>
      <link href="/2019/05/55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>方法1：</p><pre><code>利用hashSet不存储重复值的思想</code></pre><p>方法2：</p><p>链表包含环，像数字6的图形。</p><p>(1)设置快慢指针，假设快指针在环内与慢指针相遇，设头节点到入口结点的距离为x,入口结点到相遇点为y,相遇点到入口结点距离为z,则有(x+y)*2 = (x+y+z+y),即z = x，即相遇点到入口结点的距离跟头节点到入口结点的距离相等。</p><p>(2)这时再设置fast = pHead,一个指针重头走，另一个指针重相遇节点走，当两个点相等时即为入口节点所在。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">         HashSet&lt;ListNode&gt; hs = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">         <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(!hs.add(pHead))<span class="comment">//如果包含了，那么这个就是入口结点</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">             pHead = pHead.next;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                fast=pHead;</span><br><span class="line">                <span class="keyword">while</span> (fast!=slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【54】字符流中第一个不重复的字符</title>
      <link href="/2019/05/54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2019/05/54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>桶排序思想</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源源不断的有字母放到字符串中，建立一个256个大小的int型数组来代表哈希表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String str=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;=<span class="number">256</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str+=ch;<span class="comment">//字符放入字符串</span></span><br><span class="line">            count[ch]++;<span class="comment">//根据字符，修改数组字符元素的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:str.toCharArray())&#123;<span class="comment">// //注意的是，要找第一个出现一次的字符，所以遍历字符串，不能遍历哈希数组</span></span><br><span class="line">            <span class="keyword">if</span>(count[c]==<span class="number">1</span>)&#123;<span class="comment">//如果字符串作为下表的元素值为1，说明该字符出现一次，直接返回该字符</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【53】表示数值的字符串</title>
      <link href="/2019/05/53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/05/53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>(1) 先判断每个字符是否合法</p><p>(2) 正负号的位置和e不能在结尾位置</p><p>(3) 小数点只能存在一个</p><p>(4)正负号在中间位置时，前面是e后面是数字</p><p>(5)e后面不能有小数点</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;      </span><br><span class="line">        String ss = String.valueOf(str);    </span><br><span class="line">        <span class="keyword">int</span> len = ss.length();</span><br><span class="line">        <span class="comment">//先判断每个字符是否合法  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;            </span><br><span class="line">            <span class="keyword">char</span> c = ss.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!((c&gt;=<span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c==<span class="string">'e'</span> || c==<span class="string">'E'</span></span><br><span class="line">                                  || c==<span class="string">'+'</span> || c==<span class="string">'-'</span>|| c==<span class="string">'.'</span>))          </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////正负号,E不能在末尾      </span></span><br><span class="line">        <span class="keyword">if</span>(ss.charAt(len-<span class="number">1</span>) == <span class="string">'+'</span> || ss.charAt(len-<span class="number">1</span>) == <span class="string">'-'</span> </span><br><span class="line">           || ss.charAt(len-<span class="number">1</span>) == <span class="string">'E'</span> || ss.charAt(len-<span class="number">1</span>) == <span class="string">'e'</span>)        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//判断小数点，只能有一个       </span></span><br><span class="line">        <span class="keyword">if</span>(ss.indexOf(<span class="string">"."</span>) != ss.lastIndexOf(<span class="string">"."</span>))  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;       </span><br><span class="line">         </span><br><span class="line">        <span class="comment">//正负号在中间的位置时，前面的是e，E,后面是数字      </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len-<span class="number">1</span>; i++)&#123;         </span><br><span class="line">            <span class="keyword">char</span> c = ss.charAt(i);          </span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'+'</span> || c==<span class="string">'-'</span>)&#123;             </span><br><span class="line">               <span class="keyword">if</span>(!(ss.charAt(i-<span class="number">1</span>) == <span class="string">'e'</span> || ss.charAt(i-<span class="number">1</span>) == <span class="string">'E'</span>)   </span><br><span class="line">                   ||!(ss.charAt(i+<span class="number">1</span>)&gt;=<span class="string">'0'</span> &amp;&amp; ss.charAt(i+<span class="number">1</span>)&lt;=<span class="string">'9'</span>))</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;               </span><br><span class="line">                &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////e的后面不能有数字12E+4.3        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;            </span><br><span class="line">            <span class="keyword">char</span> c = ss.charAt(i);          </span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'e'</span> || c==<span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==len-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;               </span><br><span class="line">                <span class="keyword">if</span>(ss.charAt(i+<span class="number">1</span>) == <span class="string">'+'</span> || ss.charAt(i+<span class="number">1</span>) == <span class="string">'-'</span>)&#123;</span><br><span class="line">                    <span class="comment">//从i+2开始往后没有小数点.则返回-1</span></span><br><span class="line">                    <span class="keyword">if</span>(ss.indexOf(<span class="string">"."</span>, i+<span class="number">2</span>) != -<span class="number">1</span>)&#123;                     </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;                   </span><br><span class="line">                      &#125;               </span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ss.indexOf(<span class="string">"."</span>, i+<span class="number">1</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【52】正则表达式匹配</title>
      <link href="/2019/05/52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/05/52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>这道题的核心其实在于分析’*‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’*’的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。</p><p><strong>情况1：Patttern第二个字符是’*’时</strong>：</p><p>1.第一个字符不匹配（’.’与任意字符视作匹配），那么’*’只能代表匹配0次</p><pre><code>&apos;ba&apos;与&apos;a*ba&apos;，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式</code></pre><p>2.第一个字符匹配，那么’*‘可能代表匹配0次，1次，多次，</p><pre><code>(1)&apos;aaa&apos;与&apos;a*aaa&apos;: 匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式；(2)&apos;aba&apos;与&apos;a*ba&apos;:匹配1次时，字符串往后移动一个字符，模式向后移动2个字符；(3)&apos;aaaba&apos;与&apos;a*ba&apos;:匹配多次时，字符串往后移动一个字符，模式不变；</code></pre><p><strong>情况2：Patttern第二个字符不是’*‘时：</strong></p><pre><code>(1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。(2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> strIndex = <span class="number">0</span>,patternIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功    </span></span><br><span class="line">        <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">    <span class="comment">//pattern先到尾，匹配失败    </span></span><br><span class="line">        <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;    &#125;    </span><br><span class="line">        <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位 </span></span><br><span class="line">        <span class="comment">//   //如果当前pattern的下一个是*并且没有超出pattern的长度时</span></span><br><span class="line">        <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;     </span><br><span class="line">            <span class="comment">// //如果当前字符str[index]和pattern[index]相等，或者当前pattern为‘.’</span></span><br><span class="line">            <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;            </span><br><span class="line">                <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//模式后移2，视为x*匹配0个字符(当前pattern[index+1]='*'且str[index]!=pattern[index]）                    </span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//视为模式匹配1个字符 (当前pattern[i+1]='*'且str[index]=pattern[index])                   </span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配1个，再匹配str中的下一个（当前pattern[index]='.'）        </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">//当前字符str[index]和pattern[index]不相等&amp;&amp;当前pattern不为‘.’</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);        </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false  </span></span><br><span class="line">         <span class="comment">//pattern[index]='.'的情况，strindex和pattern都加1向下匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex != str.length)) &#123;        </span><br><span class="line">            <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【51】构建乘积数组</title>
      <link href="/2019/05/51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2019/05/51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。<strong>不能使用除法</strong>。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>题目的意思就是B[i] = A[0]*A[1]….*A[n-2]*A[n-1]  / A[i],但是题目要求不能用除法</p><p>创建一个left数组和一个rigth数组，拿n = 3为例               </p></blockquote><table><thead><tr><th>res[i]</th><th>left[0]*right[0]</th><th>left[1]*right[1]</th><th>left[2]*right[2]</th><th>left[3]*right[3]</th></tr></thead><tbody><tr><td>right数组</td><td>A[2]*A[1]*A[0]*1</td><td>A[1]*A[0]*1</td><td>A[0]*1</td><td>1</td></tr><tr><td>left数组</td><td>1</td><td>1*A[0]</td><td>1*A[0]*A[1]</td><td>1*A[0]*A[1]*A[2]</td></tr></tbody></table><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> []res = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> []left = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> []right = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            left[i] = A[i-<span class="number">1</span>]*left[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right[A.length-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>]*A[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            res[i] = left[i]*right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【50】数组中重复的数字</title>
      <link href="/2019/05/50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>在一个<strong>长度为n</strong>的数组里的所有数字都在<strong>0到n-1的范围</strong>内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>长度为n,数字都在[0,n-1]范围，可以利用桶排序的思想，将numbers[i]的个数存入相应的res索引下，当第一次桶里有2个numbers[i]时，直接返回即找到第一个数组里面的重复数字。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span> [length];</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">           res[numbers[i]]++;</span><br><span class="line">            <span class="comment">//有重复的数</span></span><br><span class="line">            <span class="keyword">if</span>(res[numbers[i]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">              duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">               flag = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【49】把字符串转换成整数</title>
      <link href="/2019/05/49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
      <url>/2019/05/49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。<a id="more"></a></p><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h6><p>输入一个字符串,包括数字字母符号,可以为空</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h6><p>如果是合法的数值表达则返回该数字，否则返回0</p><p>示例1：</p><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>+2147483647<br>    1a33</p><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><p>2147483647<br>    0</p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>(1) 首先判断第一个字符是符号‘ + ‘ 或者 ’ - ‘ 还是数字</p><p>(2) 首字母为 ’ + ‘，则设flag 为 1，计算[1,len)的数值</p><p>(3) 首字母为 ’  -  ‘，则设flag为-1，计算[1,len)的数值</p><p>(4) 首字母为数字，则计算[0,len)的数值</p><p>计算时有个是否溢出判断。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.trim().equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) ==<span class="string">'+'</span>||str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>) &#123;</span><br><span class="line">                flag = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = cal(str,<span class="number">1</span>,str.length(),flag);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum = cal(str,<span class="number">0</span>,str.length(),flag);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum*flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">int</span> <span class="title">cal</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end,<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)&gt;=<span class="string">'0'</span> &amp;&amp;str.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span> &amp;&amp; sum&gt;Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"上溢出"</span>);</span><br><span class="line">                <span class="keyword">if</span>(flag == -<span class="number">1</span> &amp;&amp; sum&lt;Integer.MIN_VALUE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"下溢出"</span>);</span><br><span class="line">                sum = sum*<span class="number">10</span>+str.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【48】不用加减乘除做加法</title>
      <link href="/2019/05/48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
      <url>/2019/05/48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>利用&amp;、|、^等运算</p><p>(1)定义一个sum和一个进位位carry，sum用来记录二进制的两位数无进位相加得到的值（num1^num2）,进位位carry用来记录需要向哪个位进位（num&amp;num2&lt;&lt;1）</p><p>(2)将得到的sum和carry重新赋值给num1和num2.循环的结束条件是进位位为0时终止。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//异或，相同为0不同为1 ,得到的结果相当于二进制的两个数无进位相加，         </span></span><br><span class="line">            <span class="comment">//相加为2的结果是0.如6和12相异或，即（0110^1100） = 1010</span></span><br><span class="line"></span><br><span class="line">            sum = num1 ^ num2;</span><br><span class="line">            <span class="comment">//num1&amp;num2得到该位数需要进位，即向前进位&lt;&lt;1</span></span><br><span class="line"></span><br><span class="line">            carry = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 = sum;  </span><br><span class="line"></span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num2!=<span class="number">0</span>);  <span class="comment">//直到无进位结束</span></span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【47】求1+2+...+n</title>
      <link href="/2019/05/47-%E6%B1%821-2-n/"/>
      <url>/2019/05/47-%E6%B1%821-2-n/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>1.需利用逻辑与的短路特性实现递归终止。 </p><p>2.当n==0时，(n&gt;0)&amp;&amp;((ans+=Sum_Solution(n-1))&gt;0)只执行前面的判断，不执行后面的递归了，使这条语句为false，并且不往上回溯，可以执行下面return的语句了。然后直接返回ans；</p><p>3.当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="keyword">boolean</span> flag = (ans &gt; <span class="number">0</span>) &amp;&amp; (ans += Sum_Solution(n - <span class="number">1</span>))&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【46】孩子们的游戏(圆圈中最后剩下的数)</title>
      <link href="/2019/05/46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/05/46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) <a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>模拟游戏过程</p><p>i一直记录的是小朋友自己最初的的位置[0,n-1]</p><p>step记录的是报数，报到m-1时array[i]这个小朋友出局，记-1，step重头计数。人数这时减1.</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span> ;  <span class="comment">//初始状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = n;  <span class="comment">//人数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count&gt;<span class="number">0</span>)&#123;  <span class="comment">//游戏开始</span></span><br><span class="line">            <span class="comment">//报数，其实报的一直都是自己的位置数，不是[0,m-1],而是[0,n-1]</span></span><br><span class="line"></span><br><span class="line">            i++; </span><br><span class="line">            <span class="comment">//假如有8人，报数范围是[0,7],轮询一圈后那么第一个人不报8而是报0 </span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=n)  </span><br><span class="line"></span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==-<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//标记为-1即出局，不遍历下边的了</span></span><br><span class="line"></span><br><span class="line">            step++;   <span class="comment">//step用来记录报数报到哪了</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(step==m-<span class="number">1</span>)&#123;  <span class="comment">//找到喊m-1的小朋友</span></span><br><span class="line"></span><br><span class="line">                array[i] = -<span class="number">1</span>; <span class="comment">//出局</span></span><br><span class="line"></span><br><span class="line">                step = -<span class="number">1</span>;     <span class="comment">//重头开始记录报数</span></span><br><span class="line"></span><br><span class="line">                count--;   <span class="comment">//人数减1</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【45】扑克牌顺子</title>
      <link href="/2019/05/45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/"/>
      <url>/2019/05/45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>组成顺子的条件是：</p><p>(1) 数组长度为5</p><p>(2)数组中数不重复</p><p>(3)最大值Max减最小值Min&lt;5,其中Max和Min不能为0,即不包括大小王的最大值最小值</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length&lt;<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> Max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> Min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> count[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">14</span>];</span><br><span class="line">        <span class="comment">//除0以外没有重复的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            count[numbers[i]]++;</span><br><span class="line">            <span class="comment">//如果是大小王的话，可以允许多个，直接continue不执行count[numbers[i]&gt;=2的判断,而且最大值最小值的判断也会跳过0</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count[numbers[i]]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(Max&lt;numbers[i]) &#123;</span><br><span class="line">                Max = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Min &gt;numbers[i])&#123;</span><br><span class="line">                Min = numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( Max - Min &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【44】翻转单词顺序列</title>
      <link href="/2019/05/44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>用str.split(“ ”) 去切分子字符串变成str[],然后再拼接。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)&#123; <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="comment">//去掉前后空格，避免输入字符串全是空格情况，保证后面的split切分正确</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(str.trim().equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        String res[] = str.split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder ss = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//第二个到最后一个数组值后面要加“ ” </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = res.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ss.append(res[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个就是数组末尾了不需要加“ ”，保持反转后的数组长度跟原来一样</span></span><br><span class="line"></span><br><span class="line">        ss.append(res[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ss.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【43】左旋转字符串</title>
      <link href="/2019/05/43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/05/43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>两个子字符串 拼接就行了。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(n&gt;str.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> str.substring(n,str.length())+str.substring(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【42】和为s的两个数字</title>
      <link href="/2019/05/42-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/42-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h6><p>对应每个测试案例，输出两个数，小的先输出。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>将数组的数值依次放入list里面，每次放入之前查询list里面是否有（sum-array[i]），如果有,再判断两数乘积是否比之前存的两数乘积小，如果判断成功，则将这两个数放到index1和index2中。最后将这两个index放到list里面返回。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ss = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> Min_ = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//index1用于存放比较小的那个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//index2用于存放比较大的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(sum-array[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Min_&gt;(sum-array[i])*array[i])&#123;</span><br><span class="line">                    Min_ = (sum-array[i])*array[i];</span><br><span class="line">                    index1 = array[i]&lt;(sum-array[i])?</span><br><span class="line">                                           array[i]:(sum-array[i]);</span><br><span class="line"></span><br><span class="line">                    index2 = sum-index1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index1!=<span class="number">0</span>||index2!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">               ss.add(index1);</span><br><span class="line">               ss.add(index2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【41】和为S的连续正数序列</title>
      <link href="/2019/05/41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>滑动窗口移动方法</p><p>(1) 求出滑动窗口的累加和，公式为等差数列求和公式</p><p>(2)如果累加和等于sum,则将该滑动窗口内的数存到一个list里面，并右移动左指针</p><p>(3)如果累加和小于sum,则右移动右指针，加数进来</p><p>(4)如果累加和大约sum，则左指针右移动，减数出去</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小</span></span><br><span class="line">        <span class="keyword">int</span> plow = <span class="number">1</span>,phigh = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(phigh &gt; plow)&#123;</span><br><span class="line">            <span class="comment">//由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2</span></span><br><span class="line">            <span class="keyword">int</span> cur = (phigh + plow) * (phigh - plow + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//相等，那么就将窗口范围的所有数添加进结果集</span></span><br><span class="line">            <span class="keyword">if</span>(cur == sum)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=plow;i&lt;=phigh;i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                plow++;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和小于sum，那么右边窗口右移一下</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; sum)&#123;</span><br><span class="line">                phigh++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和大于sum，那么左边窗口右移一下</span></span><br><span class="line">                plow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【40】数组中只出现一次的数字</title>
      <link href="/2019/05/40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>将数组依次放到list里面，如果list里面含有准备要进去的数值，则remove掉，剩下的两个数组即为该数组中只出现过一次的数字</p></blockquote><p>list.remove要用(Object object)方法而不是list.remove(int index);</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">         ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(array[i]))&#123;</span><br><span class="line">            <span class="comment">//这里remove掉的是里面的数array[i]，而不是array[i]索引对应的数</span></span><br><span class="line"></span><br><span class="line">                res.remove(Integer.valueOf(array[i]));</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = res.get(<span class="number">0</span>);</span><br><span class="line">        num2[<span class="number">0</span>] = res.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【39】平衡二叉树</title>
      <link href="/2019/05/39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>预备知识：平衡二叉树是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>思想：从根节点开始，先判断左右子树的高度差是否超过1，然后接着判断左右子树是否是平衡二叉树。这边用到了递归思想。</p><p>代码如下：</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span>) &#123; <span class="comment">//一棵空树就是平衡二叉树</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( Math.abs(getDepth(root.left)  - getDepth(root.right)) &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//满足左右子树高度差小于等于1,那就接着判断左右子树是不是二叉树</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不满足左右子树高度差小于等于1,那这棵树肯定不是平衡二叉树啦</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归求二叉树深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ( left &gt; right ? left : right ) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【38】二叉树的深度</title>
      <link href="/2019/05/38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
      <url>/2019/05/38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><a id="more"></a></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>①如果一棵树只有一个结点，它的深度为1。</p><p>②如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。</p><p>③如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//----递归求二叉树深度----</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> (left&gt;right)?(left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【37】数字在排序数组中出现的次数</title>
      <link href="/2019/05/37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2019/05/37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>统计一个数字在<strong>排序数组</strong>中出现的次数。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>排序数组嘛，找到数组里面第一个等于k的，一直res++直到数组值不等于k。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(array[i] == k)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【36】两个链表的第一个公共结点</title>
      <link href="/2019/05/36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入两个链表，找出它们的第一个公共结点。 <a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>两个链表有公共点，考虑Y型的两链表相连，先计算出两个链表的长度，然后长的链表先走差值步，之后同步走，当遇到cur1==cur2时说明两链表相遇。直接返回即可。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode cur1 = head1;</span><br><span class="line">            ListNode cur2 = head2;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//得到差值步（head1.length-head2.length）</span></span><br><span class="line">            <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相交为Y型则最后一个结点应该相同</span></span><br><span class="line">            <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">            cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">            n = Math.abs(n);<span class="comment">//差值步</span></span><br><span class="line">            <span class="comment">//走差值步</span></span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                n--;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相等时则为相交点</span></span><br><span class="line">            <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>争吵问题.md</title>
      <link href="/2019/05/%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md/"/>
      <url>/2019/05/%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h5><p>有一个队列，每个人要么朝左边（L表示）,要么朝右边(R表示)，因为每个人都讨厌其他任何人，只要两人面对面就会发生争吵。争吵结果是胜者留在队列中，败的人移除队中。如果序列中有多对争吵，可以任选一对，胜者留在队中，败者出局，求最后队列最少人数是多少。<a id="more"></a></p><p>例子：</p><p>LRRLRL</p><p>输出：2</p><p><strong>Hint</strong></p><p>一种可能的变化情况是：LRRLRL -&gt; LRLRL -&gt; LRRL -&gt; LRL -&gt; LR</p><h5 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h5><p>由题意可知，如果真的吵架就只有RL（两人面对面）情况，像LL,RR,LR就不会争吵。</p><ul><li><p>如果吵架前面是R，则吵架结果应该是L胜利.</p></li><li><p>如果吵架前面是L，则吵架结果为R胜利</p></li></ul><h5 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String arr =<span class="string">"LRRLRL"</span>;</span><br><span class="line">        String res = solut(arr);</span><br><span class="line">        System.out.println(res.length());</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String  <span class="title">solut</span><span class="params">(String arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取第一次争吵得到的结果</span></span><br><span class="line">       String str = solution(arr);</span><br><span class="line">       <span class="comment">//如果还存在第二次争吵，则继续，否则得到结果</span></span><br><span class="line">        <span class="keyword">while</span> (str.contains(<span class="string">"RL"</span>))&#123;</span><br><span class="line">            str = solution(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">solution</span><span class="params">(String arr)</span></span>&#123;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//争吵</span></span><br><span class="line">            <span class="keyword">if</span>(arr.charAt(i)==<span class="string">'R'</span>&amp;&amp;arr.charAt(i+<span class="number">1</span>)==<span class="string">'L'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">                    list.add(<span class="string">'R'</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.get(list.size()-<span class="number">1</span>)==<span class="string">'L'</span>) &#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        list.add(<span class="string">'R'</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    &#123;</span><br><span class="line">                        list.add(<span class="string">'L'</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有争吵，下一次争吵中还有该人</span></span><br><span class="line">                list.add(arr.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将list转换成String</span></span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            str = str+list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 讯飞科技笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 讯飞科技笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【34】第一个只出现一次的字符位置</title>
      <link href="/2019/05/34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE/"/>
      <url>/2019/05/34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>1.用两个list,一个list用来存放只出现一次的字符，一个用来存放出现多次的字符</p><p>2.依次遍历str里面的字符，如果list1和list2里面都没有，则说明这个字符是第一次出现，将其添加到list1，否则说明之前出现过该字符，将其移除list1并添加到list2里面</p><p>3.最后判断list里面是否有值，有则返回list里面的第一个值在str出现的第一次的位置，即为第一次出现的字符位置。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str.length() == <span class="number">0</span> || str == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//list1存放str中出现1次的字符</span></span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Character&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">        <span class="comment">//list2用来存放多次出现的字符</span></span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Character&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">           <span class="comment">//两个list里面都没有这个字符</span></span><br><span class="line">           <span class="keyword">if</span> (!list1.contains(ch) &amp;&amp; !list2.contains(ch)) &#123;</span><br><span class="line">               <span class="comment">//将字符放到list1中</span></span><br><span class="line">               list1.add(Character.valueOf(ch));</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//将list1之前加入的删掉（此时出现了相同字符，删掉相同字符）</span></span><br><span class="line">               list1.remove(Character.valueOf(ch));</span><br><span class="line">               <span class="comment">//将str中含有的相同字符存入list2</span></span><br><span class="line">               list2.add(Character.valueOf(ch));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (list1.size() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> str.indexOf(list1.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【35】数组中的逆序对</title>
      <link href="/2019/05/35.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2019/05/35.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<a id="more"></a></p><p>题目保证输入的数组中没有的相同的数字</p><p>数据范围：</p><ol><li><p>对于%50的数据,size&lt;=10^4 </p></li><li><p>对于%75的数据,size&lt;=10^5</p></li><li><p>对于%100的数据,size&lt;=2*10^5</p></li></ol><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><pre><code>数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；</code></pre><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>方法1：暴力破解:时间超时</p><p>考察每一位，判断从这一位往后有多少小于该位的，结果累加，得到最后结果。</p><p>方法2：归并算法</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1(超时)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []array=&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> num=InversePairs(array);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;array.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i]&gt;array[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = InversePairsCore(array,copy,<span class="number">0</span>,array.length-<span class="number">1</span>);<span class="comment">//数值过大求余</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">int</span> <span class="title">InversePairsCore</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] copy,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low==high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftCount=</span><br><span class="line">                   InversePairsCore(array,copy,low,mid)%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightCount = </span><br><span class="line">                InversePairsCore(array,copy,mid+<span class="number">1</span>,high)%<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=mid;</span><br><span class="line">        <span class="keyword">int</span> j=high;</span><br><span class="line">        <span class="keyword">int</span> locCopy = high;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=low&amp;&amp;j&gt;mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                count += j-mid;</span><br><span class="line">                copy[locCopy--] = array[i--];</span><br><span class="line">                <span class="keyword">if</span>(count&gt;=<span class="number">1000000007</span>)<span class="comment">//数值过大求余</span></span><br><span class="line">                &#123;</span><br><span class="line">                    count%=<span class="number">1000000007</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                copy[locCopy--] = array[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=low;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[locCopy--]=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;mid;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[locCopy--]=array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=low;s&lt;=high;s++)</span><br><span class="line">        &#123;</span><br><span class="line">            array[s] = copy[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (leftCount+rightCount+count)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【33】丑数</title>
      <link href="/2019/05/33-%E4%B8%91%E6%95%B0/"/>
      <url>/2019/05/33-%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an</p><p>所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2<em>a1, 2</em>a2, 2*a3 …..</p><p>包含3的有序丑数序列:3<em>a1, 3</em>a2, 3<em>a3 ….. 包含5的有序丑数序列:5</em>a1, 5<em>a2, 5</em>a3 …..</p><p>以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr=<span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//第一个丑数为1，放入数组的第一个元素</span></span><br><span class="line">        <span class="keyword">int</span> t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t3=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//寻找3个序列中最小的那个数</span></span><br><span class="line">          arr[i]=Math.min(arr[t2]*<span class="number">2</span>,Math.min(arr[t3]*<span class="number">3</span>,arr[t5]*<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最小的那个数的序列值加1</span></span><br><span class="line">            <span class="keyword">if</span>(arr[t2]*<span class="number">2</span>==arr[i])</span><br><span class="line">                t2++;</span><br><span class="line">            <span class="keyword">if</span>(arr[t3]*<span class="number">3</span>==arr[i])</span><br><span class="line">                t3++;</span><br><span class="line">            <span class="keyword">if</span>(arr[t5]*<span class="number">5</span>==arr[i])</span><br><span class="line">                t5++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[index-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【32】把数组排成最小的数</title>
      <link href="/2019/05/32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2019/05/32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>方法1：</p><p>(1) 求出数组里面最大的数的位数，然后其他的数位数不够的进行补位</p><p>(2) 补位原则：如数组{3,32,321},最大位数为3，所以3进行补位变成333，补的两位为str[i]数组里面的最后一个charAt[str[i].length()-1];所以32补位变成322</p><p>(3) 对数组{333，322，321}进行从小到大排序，然后根据索引把字符串拼接即可得到答案。即从小到大排序为{321，322，333}，这三个数对应原数组的{321，32，3}，最后答案即为321323.</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(numbers.length&lt;=<span class="number">0</span>||numbers == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//排序，可得到最大的数为numbers[len-1]</span></span><br><span class="line"></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="comment">//求位数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Max_ = numbers[numbers.length-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//得到最大的数的位数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Max_&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            Max_ = Max_/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数组变成字符串数组</span></span><br><span class="line"></span><br><span class="line">        String str[] = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            str[i] = <span class="string">""</span>+numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//补位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="comment">//得到补位要填充的数</span></span><br><span class="line"></span><br><span class="line">            String tmp =<span class="string">""</span> +str[i].charAt(str[i].length()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//原数组的位数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len =str[i].length(); </span><br><span class="line">            <span class="comment">//补足到相同的位数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;count-len;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                str[i] = str[i]+tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        ArrayList&lt;Integer&gt; ss= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//该数组的索引对应着numbers的索引</span></span><br><span class="line"></span><br><span class="line">        String strcopy[] = str.clone();</span><br><span class="line">        <span class="comment">//将其进行从小到大的排序</span></span><br><span class="line"></span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        <span class="comment">//得到从小到大排序后原数组所在的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;numbers.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i].equals(strcopy[j]))&#123;</span><br><span class="line">                    ss.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将索引进行拼接得到结果</span></span><br><span class="line"></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            res = res +numbers[ss.get(i)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【31】整数中1出现的次数</title>
      <link href="/2019/05/31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2019/05/31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>方法1：</p><p>将每个数变成string,然后将string里面的1替换成”“,长度的减少就是这个string里面1的个数，但是这个方法中String是不可变字符串，故占用内存过多。</p></li><li><p>方法2：</p><p>依次计算出每个数中包含1的个数</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       String s = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           s = i+<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">           count += s.length()-s.replaceAll(<span class="string">"1"</span>, <span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>方法2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">               sum+=NumberOf1(i);</span><br><span class="line">           <span class="keyword">return</span> sum;</span><br><span class="line">       &#125;    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">10</span>==<span class="number">1</span>)<span class="comment">//求余</span></span><br><span class="line">            &#123;</span><br><span class="line">               count++; </span><br><span class="line">            &#125;</span><br><span class="line">            n=n/<span class="number">10</span>;     </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【30】连续子数组的最大和</title>
      <link href="/2019/05/30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2019/05/30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？<a id="more"></a>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。</p><ul><li><p>当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令cur = 0.表示从下一个数开始累加。</p></li><li><p>当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最大值即可。</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                cur += array[i];</span><br><span class="line">                res = Math.max(res,cur);</span><br><span class="line">                cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【29】最小的K个数</title>
      <link href="/2019/05/29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/05/29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>排序问题，本次使用快排，快排思想即：</p><p>“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input.length&lt;k)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        quicksort(input, <span class="number">0</span>, input.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> position = partition(arr, low, high);</span><br><span class="line">            quicksort(arr, low, position - <span class="number">1</span>);</span><br><span class="line">            quicksort(arr, position + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//设置基准值</span></span><br><span class="line">            <span class="keyword">int</span> key = arr[low];</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                <span class="comment">//从右到左，直到找到一个小于key的值</span></span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= key) --high;</span><br><span class="line">                <span class="comment">//将该值填入前的坑</span></span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                <span class="comment">//从左到右，直到找到一个大于key的值</span></span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= key) ++low;</span><br><span class="line">                <span class="comment">//将该值填入前一个坑</span></span><br><span class="line">                arr[high] = arr[low];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将基准值填入最后一个坑</span></span><br><span class="line">            arr[low] = key;</span><br><span class="line">            <span class="comment">//最后一个坑划分了左边小于该值，右边大于该值</span></span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【28】数组中出现次数超过一半的数字</title>
      <link href="/2019/05/28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/05/28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>利用一个hashmap用来存储数组里面每个数出现的次数，然后遍历map，比较每个数的value是否超过数组的一半</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">            HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(array[i]))&#123;</span><br><span class="line">                    map.put(array[i],map.get(array[i])+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(array[i],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(entry.getValue()&gt;array.length/<span class="number">2</span>)</span><br><span class="line">                        res = entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【27】字符串的排列</title>
      <link href="/2019/05/27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2019/05/27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>算法思路：（递归实现）<br>(1)n个元素的全排列=（n-1个元素的全排列）+（另一个元素作为前缀）；<br>(2)出口：如果只有一个元素的全排列，则说明已经排完，则输出数组；</p><p>(3)不断将每个元素放作第一个元素，然后将这个元素作为前缀，并将其余元素继续全排列，等到出口，出口出去后还需要还原数组； </p><p>以字符串abc为例：</p><ul><li>a 作为开头 -&gt; 求 bc 全排列 -&gt; 得到 bc 和 cb -&gt; 与 a 合并 -&gt; 得到 abc 和 acb</li><li>b 作为开头 -&gt; 求 ac 全排列 -&gt; 得到 ac 和 ca -&gt; 与 b 合并 -&gt; 得到 bac 和 bca</li><li>c 作为开头 -&gt; 求 ab 全排列 -&gt; 得到 ab 和 ba -&gt; 与 c 合并 -&gt; 得到 cab 和 cba</li></ul></blockquote><ol><li><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//用于排序输出</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将字符串转化成字符数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="comment">//从第0个字符开始全排列      </span></span><br><span class="line"></span><br><span class="line">        res=Permu(chars,<span class="number">0</span>,res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permu</span><span class="params">(<span class="keyword">char</span>[] str,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> start, ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置递归的出口,即当需要全排列的范围只有一个元素，则全排结束</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == str.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//去除重复的字符串</span></span><br><span class="line">            <span class="keyword">if</span> (list.contains(String.valueOf(str))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(String.valueOf(str));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//for循环将start~len-1每一个数放到start位置中去，并实现全排列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//str[start]-----str[len-1]的全排列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; str.length; j++) &#123;</span><br><span class="line">                <span class="comment">//取出第j个字符作为第一个字符</span></span><br><span class="line">                swap(str,j,start);</span><br><span class="line">                <span class="comment">//求出str[start+1]----str[len-1]的全排列</span></span><br><span class="line"></span><br><span class="line">                Permu(str, start+ <span class="number">1</span>, list);</span><br><span class="line">                <span class="comment">//恢复原数组</span></span><br><span class="line"></span><br><span class="line">                swap(str,j,start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成字典序</span></span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;<span class="comment">//因为会出现原位置与原位置交换，直接空即可</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[a];</span><br><span class="line">            chars[a]=chars[b];</span><br><span class="line">            chars[b]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【26】二叉搜索树与双向链表</title>
      <link href="/2019/05/26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/05/26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个<strong>排序</strong>的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<a id="more"></a></p><p>二叉树如</p><pre><code>             10         /        \      6            14   /     \       /      \4         8    12        16</code></pre><p>转化成双向链表    4 <----> 6  <----> 8  <----> 10  <---->12 <---->14<---->16</----></----></----></----></----></----></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>(1)二叉搜索树中，每个结点都有两个分别指向其左、右子树的指针，左子树结点的值总是小于父结点的值，右子树结点的值总是大于父结点的值。</p><p>(2)双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。所以这两种数据结构的结点是一致<br>    为了减少指针的变换次数，并让操作更加简单，在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。</p><p>链表是有序的，可以借助二叉树<strong>中序遍历</strong>，因为中序遍历算法的特点就是从小到大访问结点。当遍历访问到根结点时，假设根结点的左侧已经处理好，只需将根结点与上次访问的最近结点（左子树中最大值结点）的指针连接好即可。进而更新当前链表的最后一个结点指针。同时中序遍历过程正好是转换成链表的过程，可采用递归方法处理</p><p>思想：<em>把左子树、右子树都转换成排序的双向链表之后在和根结点链接起来，整个二叉树也变成了排序的双向链表。</em></p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;<span class="comment">//假如根节点为空，返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;<span class="comment">//假如只有一个根节点，则返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1、将左子树构造成双链表，并返回该链表头结点left</span></span><br><span class="line">    TreeNode left=Convert(root.left);</span><br><span class="line">    <span class="comment">//2、定位到左子树链表的最后一个节点（左子树最右边的节点）</span></span><br><span class="line">    <span class="comment">//创建一个临时节点P,用来遍历找到左链表的最后一个节点(左子树最右边的节点)，p初始化指向做左子树的根节点，</span></span><br><span class="line">    TreeNode p=left;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//最终p为左子树最右边的节点</span></span><br><span class="line">        p=p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、如果左子树链表不为空，将当前root追加到左子树链表后 </span></span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="keyword">null</span>)&#123;<span class="comment">//左子树链表不为空</span></span><br><span class="line">       <span class="comment">//左子树链表的最后一个节点p（左子树最右边节点）的右指针指向当前root节点</span></span><br><span class="line">        p.right=root;</span><br><span class="line">       <span class="comment">//当前root节点的左指针指向左子树链表的最后一个节点p（左子树最右边节点）</span></span><br><span class="line">        root.left=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、将右子树构造成双链表，并返回该链表的头结点right</span></span><br><span class="line">    TreeNode right=Convert(root.right);</span><br><span class="line">    <span class="comment">//5、如果右子树链表不为空，将右子树链表追加到当前root后</span></span><br><span class="line">    <span class="keyword">if</span>(right!=<span class="keyword">null</span>)&#123;<span class="comment">//右子树链表不为空</span></span><br><span class="line">        right.left=root;<span class="comment">//右子树链表的头结点right的左指针指向当前root</span></span><br><span class="line">        root.right=right;<span class="comment">//当前root的右指针指向右子树链表的头结点right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left!=<span class="keyword">null</span>?left:root;<span class="comment">//根据左子树链表是否为空返回整个双向链表的头指针。    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【25】复杂链表的复制</title>
      <link href="/2019/05/25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/05/25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode head = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">        RandomListNode ans = head;</span><br><span class="line">        <span class="keyword">if</span> (pHead.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.random = <span class="keyword">new</span> RandomListNode(pHead.random.label);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pHead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">            head.next = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">            <span class="keyword">if</span> (pHead.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                head.next.random = <span class="keyword">new</span> </span><br><span class="line">                                RandomListNode(pHead.random.label);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomListNode currentNode = pHead;</span><br><span class="line">        <span class="comment">//1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123; </span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(currentNode.label);</span><br><span class="line">            RandomListNode nextNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode;</span><br><span class="line">            cloneNode.next = nextNode;</span><br><span class="line">            currentNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        <span class="comment">//2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentNode.next.random = currentNode.random==<span class="keyword">null</span>?<span class="keyword">null</span>:currentNode.random.next;</span><br><span class="line">            currentNode = currentNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode.next;</span><br><span class="line">            cloneNode.next = cloneNode.next==<span class="keyword">null</span>?<span class="keyword">null</span>:cloneNode.next.next;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【24】二叉树中和为某值的路径</title>
      <link href="/2019/05/24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/05/24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一棵二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>整个过程可以采用先序遍历方式的DFS，即根节点—–&gt;左子树—–&gt;右子树。 </p><blockquote><p>随后考虑一次遍历完成后的处理，</p><p>(1)当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点；</p><p>(2)如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。 </p><p>(3)考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 </p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个类型为ArrayList&lt;Integer&gt;的list</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathlist=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//创建一个list,用于存放遍历的值</span></span><br><span class="line">    ArrayList&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果树为空，则返回空的pathlist</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> pathlist;</span><br><span class="line">        <span class="comment">//将root值放入list</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//如果根的左子树、右子树、目标值=根值，则返回path</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>&amp;&amp;target==root.val)</span><br><span class="line">        &#123;</span><br><span class="line">            pathlist.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此时根值小于目标值并且含有左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;=target&amp;&amp;root.left!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//将遍历左子树，将根设为左子树并且此时的target=target-遍历过的root值</span></span><br><span class="line">            FindPath(root.left,target-root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此时根值小于目标值并且含有右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;=target&amp;&amp;root.right!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//将遍历右子树，将根设为右子树并且此时的target=target-遍历过的root值</span></span><br><span class="line">            FindPath(root.right,target-root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不论路径的值是否等于输入整数值，都要回退，</span></span><br><span class="line">        <span class="comment">//即使用remove函数移除路径上的最后一个节点。</span></span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pathlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【23】二叉搜索树的后序遍历序列</title>
      <link href="/2019/05/23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>二叉搜索树后序遍历为：左子树—-&gt;右子树—-&gt;根，且左子树值&lt;根值&lt;右子树值</p><blockquote><p>如二叉搜索树：</p><pre><code>           10        /       \    6              12 /    \           /   \3      7        11     20</code></pre><p>后序遍历结果为：3   7    6   11  20   12  10</p><p>对于一个数组sequence，最后一个元素是sequence[len-1] （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于sequence[len-1] ，后一段（右子树）大于sequence[len-1] ，且这两段（子树）都是合法的后序序列 </p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span>||sequence.length&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len=sequence.length;  <span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">int</span> root=sequence[len-<span class="number">1</span>];  <span class="comment">//数组的最后一个数为根</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root&lt;=sequence[i])   <span class="comment">//左子树的数值都小于根</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的j即为划分出来的左子树部分和右子树部分的分界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=len-<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">       <span class="comment">//j到len-1都都为右子树，数值都大于root,如果root大于他们，则返回false</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root&gt;sequence[j])  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断左子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> leftflag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           leftflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,<span class="number">0</span>,i));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> rightflag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;len-<span class="number">1</span>) &#123;</span><br><span class="line">            rightflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,sequence.length-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftflag &amp;&amp; rightflag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【22】从上到下打印二叉树</title>
      <link href="/2019/05/22-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/05/22-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>使用两个队列一个存放节点treelist，一个存放值intlist。</p><blockquote><p>先将根节点root加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来,并将root值存入intlist,遍历结束条件是i值到达treelist.size-1</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//创建一个列表用来存储节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; treelist=<span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; intlist=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)  <span class="comment">//没有节点</span></span><br><span class="line">            <span class="keyword">return</span> intlist;</span><br><span class="line">        <span class="comment">//1.先存入根节点</span></span><br><span class="line">        treelist.add(root);</span><br><span class="line">        <span class="comment">//2.循环遍历列表，一开始列表里存了root</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;treelist.size();i++)</span><br><span class="line">        &#123; </span><br><span class="line">            TreeNode node=treelist.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.如果左子节点不为空，则将节点加入列表</span></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">                treelist.add(node.left);</span><br><span class="line">            <span class="comment">//3、如果右子节点不为空，则将右子节点加入到列表中，这时列表的size加1</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">                treelist.add(node.right);</span><br><span class="line"></span><br><span class="line">            intlist.add(node.val);</span><br><span class="line">            <span class="comment">//4、因为执行上面操作后会增加列表的si</span></span><br><span class="line">            <span class="comment">//因此可以继续循环下一个节点，直到循环完所有节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intlist;</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【21】栈的压入、弹出</title>
      <link href="/2019/05/21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA/"/>
      <url>/2019/05/21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>依次入栈pushA数组中的数,直到pushA[i] =popA[index],此时将栈顶这个相等的值弹出。</p></li><li><p>判断栈中是否还有值，如果没有返回true,如果有并且index！=popA.length,依次弹出栈中数值，并与popA[index++]比较,两个不相等返回false,到栈为空时没执行false则返回true</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//用于pushA入栈</span></span><br><span class="line"></span><br><span class="line">           Stack&lt;Integer&gt; a = <span class="keyword">new</span> Stack();</span><br><span class="line">           <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">               a.push(pushA[i]);</span><br><span class="line">               <span class="comment">//当遇到与popA[index]相等的数时，弹出该数</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(pushA[i] == popA[index])&#123;</span><br><span class="line">                   <span class="keyword">if</span>(index++ == popA.length-<span class="number">1</span>)&#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   a.pop();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//栈中还有值，index还没到达popA尾部，依次弹出与popA比较</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (!a.isEmpty())&#123;</span><br><span class="line">               <span class="keyword">if</span>(a.pop()!=popA[index++])&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【20】包含min函数的栈</title>
      <link href="/2019/05/20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2019/05/20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>解题思路：利用辅助栈来存储现有栈的最小值。在入栈和出栈的时候将现有栈和最小值栈进行比较。<br>(1)入栈时，若新值比最小值栈的栈顶还小，则将该值同时push到最小值栈；  (2)出栈时，若现有栈的栈顶和最小值栈栈顶一致，则同时出栈，<br>(3)否则，仅仅现有栈pop；通过这一操作，最小值栈的栈顶将永远是现有栈元素中的最小值。</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于存储所有的数据，压入push,弹出pop</span></span><br><span class="line">        Stack&lt;Integer&gt; data_stack =<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于存储栈最小的值</span></span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; min_stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果最小值栈为空或者栈顶值比新入的node值大</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(min_stack.isEmpty()||min_stack.peek()&gt;=node)&#123;</span><br><span class="line">                <span class="comment">//压入node，保持栈顶为栈的最小值</span></span><br><span class="line"></span><br><span class="line">                min_stack.push(node);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则再次压入栈顶值</span></span><br><span class="line"></span><br><span class="line">                min_stack.push(min_stack.peek());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数据都压入data_stack</span></span><br><span class="line"></span><br><span class="line">            data_stack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出栈</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data_stack.empty()||min_stack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出数据</span></span><br><span class="line"></span><br><span class="line">            data_stack.pop();</span><br><span class="line">            <span class="comment">//弹出min栈顶，此时min_stack的栈顶为弹出某数剩下数的最小值</span></span><br><span class="line"></span><br><span class="line">            min_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看栈的栈顶元素</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!data_stack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> data_stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看最小的元素，即min_stack的栈顶</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!min_stack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>stack.peek:获取栈顶元素，返回栈顶元素但是不移除它</p><p>stack.add:向栈中添加元素，成功返回true</p><p>stack.push:向栈中添加元素，返回结果是当前添加的元素</p><p>stack.pop:移除并返回栈顶元素</p><p>stack.isEmpty:检查是否为空栈</p><p>stack.search(“value”):查看某元素再栈中的位置，计算从1开始</p>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【19】顺时针打印矩阵</title>
      <link href="/2019/04/19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/04/19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>打印分为四步：循环的次数即打印的圈速，即</p><p>  rows&gt;start*2&amp;&amp;column&gt;start*2</p><p>(1) 从左到右打印一行:</p><p>  开始于[start,start]，结束于[start,col-start-1]</p><p>(2) 从上到下打印一行,               </p><p>开始于[start+1,col-start-1],结束于[col-start-1,col-start-1]</p><p>(3) 从右到左打印一行</p><p> 开始于[col-start-1,col-start-2],结束于[col-start-1,start]</p><p>(4) 从下到上打印一行</p><p> 开始于[col-start-2,start],结束于[start+1,start]</p></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 矩阵行数     </span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;      </span><br><span class="line">        <span class="comment">// 矩阵列数    </span></span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;        </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();        </span><br><span class="line">      <span class="comment">// 让循环继续的条件是当前行数大于该圈循环开始的行数的两倍以及当前列数大于</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//该圈循环开始的列数的两倍（每圈循环开始的行数、列数相同）     </span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从(0,0)开始循环,圈数：start=0第一圈，start=1第二圈...以此类推    </span></span><br><span class="line">        <span class="keyword">while</span> (rows &gt; start * <span class="number">2</span> &amp;&amp; columns &gt; start * <span class="number">2</span>)&#123;         </span><br><span class="line">            <span class="comment">// 每一圈最后一行下标           </span></span><br><span class="line">            <span class="keyword">int</span> endRow = rows - <span class="number">1</span> - start;</span><br><span class="line">            <span class="comment">// 每一圈最后一列下标           </span></span><br><span class="line">            <span class="keyword">int</span> endColumn = columns - <span class="number">1</span> - start;           </span><br><span class="line">   <span class="comment">// 开始一圈圈打印，每打印一圈分为四步，从左到右、从上到下、从右到左、从下到上           </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左到右，第一步一定会走        </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endColumn; i++)            </span><br><span class="line">                list.add(matrix[start][i]);</span><br><span class="line">            <span class="comment">// 从上到下，最后一行大于开始行          </span></span><br><span class="line">            <span class="keyword">if</span> (endRow &gt; start)&#123;            </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endRow; i++)                   </span><br><span class="line">                    list.add(matrix[i][endColumn]);        </span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="comment">// 从右到左，最后一行大于开始行，最后一列大于开始列        </span></span><br><span class="line">            <span class="keyword">if</span> (endRow &gt; start &amp;&amp; endColumn &gt; start)&#123;            </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endColumn - <span class="number">1</span>; i &gt;= start; i--)                </span><br><span class="line">                    list.add(matrix[endRow][i]);           </span><br><span class="line">            &#125;          </span><br><span class="line">    <span class="comment">// 从下到上,至少是三行两列，也就是最后一行大于开始行加2，最后一列大于开始列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endRow &gt;= start + <span class="number">2</span> &amp;&amp; endColumn &gt; start)&#123;               </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endRow - <span class="number">1</span>; i &gt; start; i--)                </span><br><span class="line">                    list.add(matrix[i][start]);        </span><br><span class="line">            &#125;          </span><br><span class="line">            <span class="comment">// 继续打印下一圈         </span></span><br><span class="line">            start++;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【18】二叉树的镜像</title>
      <link href="/2019/04/18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2019/04/18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像。<a id="more"></a></p><p>二叉树的镜像定义：</p><pre><code>        8     /      \   6         10 /   \     /    \5     7    9     11   </code></pre><p>镜像二叉树</p><pre><code>           8       /       \    10             6  /    \         /    \11      9       7       5</code></pre><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>(1)镜像即左右子树交换位置，故交换左子树右子树位置</p><p>(2)交换后的左右子树的节点保持原来的顺序，故要交换左右子树自己的左右子树</p><p>(3)终止条件为root==null || root.left==null ||root.right == null</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   int val = 0;</span></span><br><span class="line"><span class="comment">   TreeNode left = null;</span></span><br><span class="line"><span class="comment">   TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">   this.val = val;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(root!=<span class="keyword">null</span>&amp;&amp;(root.left!=<span class="keyword">null</span>||root.right!=<span class="keyword">null</span>))&#123;</span><br><span class="line">              <span class="comment">//这三句是左子树跟右子树交换</span></span><br><span class="line">              TreeNode tem=root.left;  </span><br><span class="line"></span><br><span class="line">              root.left=root.right;</span><br><span class="line">              root.right=tem;</span><br><span class="line">              <span class="comment">//然后将根节点换成root.left</span></span><br><span class="line"></span><br><span class="line">              Mirror(root.left);</span><br><span class="line">              <span class="comment">//然后将根节点换成root.right</span></span><br><span class="line"></span><br><span class="line">              Mirror(root.right);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【17】树的子结构</title>
      <link href="/2019/04/17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2019/04/17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>大体思路是首先判断B的根节点和A的根节点是否相同（这里的相同是指节点的值相同并且左右子节点相同），如果相同比较他们的左右子节点，这一步骤是相同的，可以用递归完成，直到B遍历到每个尾节点，如果这一过程比较的所有节点是相同的，则证明B是A的子结构。如果B的根节点和A的根节点不同，则A向他的左右子节点滑动，然后继续跟B的子节点比较，步骤同上。 </p><pre><code>(1) 如果root1.val==root2.val,那个就以这个为起点判断是否A包含B (2) 如果没找到，就以root1.left作为起点继续判断A是否包含B(3) 如果没找到，再以root1.right作为起点判断A是否包含B</code></pre></blockquote><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">          <span class="keyword">if</span> (root2 != <span class="keyword">null</span> &amp;&amp; root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//如果找到了对应Tree2的根节点的点</span></span><br><span class="line">              <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                  <span class="comment">//以这个根节点为为起点判断是否包含Tree2</span></span><br><span class="line">                  result = doesTree1HaveTree(root1,root2);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">          <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                  result = HasSubtree(root1.left,root2);</span><br><span class="line">              &#125;</span><br><span class="line">        <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                  result = HasSubtree(root1.right,root2);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//返回结果</span></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doesTree1HaveTree</span><span class="params">(TreeNode node1, TreeNode node2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;        <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">          <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">          <span class="keyword">if</span> (node1.val != node2.val) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">          <span class="keyword">return</span> doesTree1HaveTree(node1.left,node2.left) &amp;&amp;  </span><br><span class="line">                 doesTree1HaveTree(node1.right,node2.right);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【16】合并两个排序的链表</title>
      <link href="/2019/04/16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<a id="more"></a></p><p>例：</p><pre><code>链表1：  1  ----&gt;  3  ----&gt;  5  ----&gt; 8链表2：  2  ----&gt;  4 ----&gt;   6 ----&gt;  7</code></pre><p>合并结果：</p><pre><code>1 ----&gt; 2 ----&gt; 3 ----&gt; 4 ----&gt; 5 ----&gt; 6 ----&gt; 7  ----&gt; 8</code></pre></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>判断有没有ListNode是空的，如果有则返回另一个</p></li><li><p>递归实现，如果List1.val&lt;list2.val,pMergeHead = list1,否则pMergeHead = list2，递归直到两个ListNode都为空</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pMergeHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">            pMergeHead = list1;</span><br><span class="line">            pMergeHead.next = Merge(list1.next,list2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pMergeHead = list2;</span><br><span class="line">            pMergeHead.next = Merge(list1,list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pMergeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【15】反转链表</title>
      <link href="/2019/04/15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>用一个栈stack依次存储ListNode里面的值，因为stack的特点是先进后出，故依次弹出即为反转链表</p></li><li><p>用一个链表temp依次存储弹出的值，依次next存入下一个链表值，链表res指向这个temp的头节点</p></li><li><p>反转链表的结果为res.next,因为我们之前设temp的头节点为-1（自己设的）。</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* public static class ListNode &#123;</span></span><br><span class="line"><span class="comment">        int val;</span></span><br><span class="line"><span class="comment">        ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">            this.val = val;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.val);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode temp = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            ListNode res = temp;</span><br><span class="line">            <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp.next  = <span class="keyword">new</span> ListNode(stack.pop());</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【14】链表中倒数第K个结点</title>
      <link href="/2019/04/14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2019/04/14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>先用一个count计算出链表的长度，如果count&lt;k，返回null</p></li><li><p>链表的倒数第K个即为链表的正数（count-k+1）个,一个for循环，将指针轮询到那个点，然后再将起后面截断（head.next = null）即可。</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            ListNode root = head;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">                root = root.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//倒数第K个即正数第（count-k+1）个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;(count-k+<span class="number">1</span>);i++)&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【13】调整数值顺序使奇数位于偶数前面</title>
      <link href="/2019/04/13-%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
      <url>/2019/04/13-%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>依次遍历array数组，遇到奇数存到原来的array数组前面，遇到偶数放到res数组，然后将两个数组拼接即可。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> []res = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count2  = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">                <span class="comment">//如果是奇数，则放在数组前面</span></span><br><span class="line">                <span class="keyword">if</span>(array[i]%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                    array[count++] = array[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//偶数放在另一个数组里</span></span><br><span class="line">                    res[count2++] = array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = count;i&lt;array.length;i++)&#123;</span><br><span class="line">                array[i] = res[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【12】数值的整数次方</title>
      <link href="/2019/04/12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
      <url>/2019/04/12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>（1）exponent &gt; 0,如2^3,则可以直接运算得出结果</p></li><li><p>（2）exponent &lt; 0,如2^-3,则结果为（1/2）^3</p></li><li><p>（3）exponent = 0,如2^0,则结果为1</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> powCal(<span class="number">1.0</span>/base,-<span class="number">1</span>*exponent);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> powCal(base,exponent);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//计算base的exponent次方</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">powCal</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;exponent;i++)&#123;</span><br><span class="line">               res  = res*base;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【11】二进制中1的个数</title>
      <link href="/2019/04/11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/04/11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<a id="more"></a></p><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>方法1：直接将其转成二进制数组</p></li><li><p>方法2：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> []a=Integer.toBinaryString(n).toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                 count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【10】矩形覆盖</title>
      <link href="/2019/04/10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
      <url>/2019/04/10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><a id="more"></a></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><p>类似于青蛙跳台阶</p><ul><li><p>当 n = 1时，只有一种横向排列的方式</p></li><li><p>当 n = 2时，有两种选择，横向或者竖向</p></li><li><p>当 n = 3时，如果选择竖向，则还剩下2*2的排列，如果选择横向，只有一种选择方案(剩下的一个横向一个竖向)</p></li><li><p>递推可得F(2 * n) = F(2 * (n-1))+F(2 * (n-2) ) , n&gt;=3</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(inttarget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            return0;</span><br><span class="line">        &#125;</span><br><span class="line">         elseif(target ==<span class="number">1</span>|| target == <span class="number">2</span>)&#123;</span><br><span class="line">             returntarget;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span>(RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【9】变态跳台阶</title>
      <link href="/2019/04/9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/04/9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f(0) = 0</span></span><br><span class="line"><span class="comment">//f(1) = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。</span></span><br><span class="line"><span class="comment">//f(3) = f(3-1) + f(3-2) + f(3-3) ...</span></span><br><span class="line"><span class="comment">//f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)</span></span><br><span class="line"><span class="comment">/*说明：</span></span><br><span class="line"><span class="comment">1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。</span></span><br><span class="line"><span class="comment">2）n = 1时，只有1种跳法，f(1) = 1</span></span><br><span class="line"><span class="comment">3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)</span></span><br><span class="line"><span class="comment">4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)</span></span><br><span class="line"><span class="comment">5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1)</span></span><br><span class="line"><span class="comment">6) 由以上已经是一种结论，但是为了简单，我们可以继续简化：</span></span><br><span class="line"><span class="comment">    f(n-1) =f(0)+f(1)+f(2)+f(3)+...+f((n-1)-1)        </span></span><br><span class="line"><span class="comment">           =f(0)+f(1)+f(2)+f(3)+...+f(n-2) </span></span><br><span class="line"><span class="comment">      f(n) =f(0)+f(1)+f(2)+f(3)+...+f(n-2)+f(n-1)=f(n-1)+f(n-1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以得出：f(n) = 2*f(n-1)*/</span></span><br></pre></td></tr></table></figure><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【8】跳台阶</title>
      <link href="/2019/04/8-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/04/8-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>把n级台阶的跳的次数看成是n的函数,即为f(n),当n&gt;2时,第一次跳有两种跳法,</p><p>第一次跳1级,则该次跳法数目为后面剩下的n-1级台阶的跳法数目f(n-1)。</p><p>第一次跳2级,则该次跳法数目为后面剩下的n-2级台阶的跳法数目f(n-2)。</p><p>所以f(n)=f(n-1)+f(n-2),即相当于斐波那契数列。`</p></li></ol><p>即该题跟斐波那契数列是相似的，青蛙跳台阶的公式为</p><pre><code>F(n) = F(n-1)+F(n-2),n&gt;=3</code></pre><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> one_=<span class="number">1</span>; <span class="comment">//第一次跳台阶的方法数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> two_=<span class="number">2</span>; <span class="comment">//第二次跳台阶的方法数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> finN=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=target;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            finN=one_+two_;</span><br><span class="line">            one_=two_;</span><br><span class="line">            two_=finN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【7】斐波那契数组</title>
      <link href="/2019/04/7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E7%BB%84/"/>
      <url>/2019/04/7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p><ul><li><p>斐波那契数列：1     1     2     3     5     8     13     21     34  ….</p><a id="more"></a></li></ul><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ul><li><p>斐波那契数列：从第三项开始，每一项都等于前两项之和。通项公式为</p><pre><code>F(n) = F(n-1)+F(n-2),n&gt;=3</code></pre></li></ul><p>方法1：通过递归实现，但是时间复杂度和空间复杂度都会很大</p><p>方法2：依次F(n-1)和F(n-2)值，求F(n)就很简单啦</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> (Fibonacci(n-<span class="number">1</span>)+Fibonacci(n-<span class="number">2</span>));   </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> one_ = <span class="number">1</span>;  <span class="comment">//用于存储f(n-2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> two_ =<span class="number">1</span>;   <span class="comment">//用于存储f(n-1)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">             fin = one_+two_;</span><br><span class="line">             <span class="comment">//向前递推</span></span><br><span class="line"></span><br><span class="line">             one_ = two_;   <span class="comment">//下一次的f(n-2)为 上一次结果的f(n-1)</span></span><br><span class="line"></span><br><span class="line">             two_ = fin;    <span class="comment">//下一次的f(n-1)为 上一次结果的fin </span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【6】旋转数组的最小数字</title>
      <link href="/2019/04/6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2019/04/6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><blockquote><p>方法1：重头到尾遍历，找到数组的最小值，时间复杂度为O(N)</p></blockquote><blockquote><p>方法2：二分遍历查找</p></blockquote><ul><li><p>mid = low +(high-low)/2;</p></li><li><p>需要考虑三种情况：</p><ul><li><p>arr[mid] &gt; arr[high],如[3,4,5,1,2]说明最小数字在mid的右边，缩小范围，low = mid+1;</p></li><li><p>arr[mid]&lt;arr[high],如[1,2,3,4,5]说明最小数字在mid的左边，high = mid-1;</p></li><li><p>arr[mid] = arr[high],如[0,1,1,1,1]或者[1,1,1,0,1],一步步缩小范围，high = high-1;</p></li></ul></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; arr[high])&#123;</span><br><span class="line"></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] == arr[high])&#123;</span><br><span class="line"></span><br><span class="line">                high = high - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[low];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【5】两个栈实现队列</title>
      <link href="/2019/04/5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2019/04/5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h4><ul><li style="list-style: none"><input type="checkbox"> 栈的规则是先进后出，队列的规则是先进先出</li></ul><ol><li><p>stack1一直维持着栈底–栈顶是队列的入队顺序</p></li><li><p>stack2一直维持着栈顶–栈尾为队列的入队顺序</p></li><li><p>当执行队列的入队（push）时，如果stack2为空，则直接插入到stack1,stack1从栈底到栈顶的顺序为入队顺序，如果stack2不为空，则将stack2的元素倒入（栈顶—栈尾）stack1,然后再插入数据</p></li></ol><p>4- 当执行队列的出队(pop)操作时，应该出的是stack1的栈底元素，故将stack1依次倒入stack2,这时stack2的栈顶就是要出队的数值，此时stack1为空，stack2从（栈顶–栈尾）为入队顺序</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//队列的入队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将stack2倒入stack1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack2.empty()) &#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将元素插入stack1</span></span><br><span class="line"></span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列的出队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将stack1倒入stack2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stack2的栈顶就是出队数值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【4】重建二叉树</title>
      <link href="/2019/04/4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/04/4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>先序遍历为：根-&gt;左子树-&gt;右子树，中序遍历为左子树-&gt;根-&gt;右子树</p></li><li><p>先找到根结点，为先序遍历的第一个数值</p></li><li><p>根据这个数值，可以划分中序中的左子树和右子树范围</p></li><li><p>递归构建左子树和右子树</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//** * Definition for binary tree </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> val; </span><br><span class="line"></span><br><span class="line">     TreeNode left; </span><br><span class="line"></span><br><span class="line">     TreeNode right; </span><br><span class="line"></span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span> || in.length==<span class="number">0</span>)               </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;           </span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);    <span class="comment">//根结点       </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre.length;i++)&#123;      </span><br><span class="line">        <span class="comment">//找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点         </span></span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == in[i])&#123;    </span><br><span class="line">        <span class="comment">//递归构建左子树，此时前序的范围缩小为[1,i+1),中序缩小为[0,i)              </span></span><br><span class="line"></span><br><span class="line">             node.left =reConstructBinaryTree(Arrays.copyOfRange</span><br><span class="line">                         (pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">        <span class="comment">//递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len)                   </span></span><br><span class="line"></span><br><span class="line">             node.right = reConstructBinaryTree(Arrays.copyOfRange</span><br><span class="line">        (pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));                   </span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;               </span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;           </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【3】从尾到头打印链表</title>
      <link href="/2019/04/3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><blockquote><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<a id="more"></a></p></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h4><ol><li><p>先用一个栈stack存储从头到尾的链表数值</p></li><li><p>再依次弹出，因为栈是先进后出的，故弹出的结果为从尾到头</p></li><li><p>将弹出的结果放入list返回</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main_3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(listNode.val);</span><br><span class="line">                listNode = listNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                list.add(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【2】空格替换</title>
      <link href="/2019/04/2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2/"/>
      <url>/2019/04/2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><a id="more"></a></blockquote><h4 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h4><ul><li><p>方法1：利用函数replaceAll完成</p></li><li><p>方法2：</p><pre><code>**先计算需要多少的空间**从后向前依次插入</code></pre></li></ul><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> str.toString().replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> spacenum = <span class="number">0</span>;<span class="comment">//spacenum为计算空格数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</span><br><span class="line">                spacenum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//indexold为为替换前的str下标</span></span><br><span class="line">        <span class="keyword">int</span> indexold = str.length()-<span class="number">1</span>; </span><br><span class="line">        <span class="comment">//计算空格转换成%20之后的str长度</span></span><br><span class="line">        <span class="keyword">int</span> newlength = str.length() + spacenum*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//indexold为为把空格替换为%20后的str下标</span></span><br><span class="line">        <span class="keyword">int</span> indexnew = newlength-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//使str的长度扩大到转换成%20之后的长度,防止下标越界</span></span><br><span class="line">        str.setLength(newlength);</span><br><span class="line">        <span class="keyword">for</span>(;indexold&gt;=<span class="number">0</span> &amp;&amp; indexold&lt;newlength;--indexold)&#123; </span><br><span class="line">                <span class="keyword">if</span>(str.charAt(indexold) == <span class="string">' '</span>)&#123;  </span><br><span class="line"></span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(indexnew--, <span class="string">'%'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    str.setCharAt(indexnew--, str.charAt(indexold));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充1：String和StringBuffer的转换"><a href="#补充1：String和StringBuffer的转换" class="headerlink" title="补充1：String和StringBuffer的转换"></a>补充1：String和StringBuffer的转换</h4><p>String转换成StringBuffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">StringBuffer b=<span class="keyword">new</span> StringBuffer(str);</span><br></pre></td></tr></table></figure><p>StringBuffer转换成String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer a=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">String b=a.toString(）</span><br></pre></td></tr></table></figure><h4 id="补充2：String、StringBuffer、StringBuilder"><a href="#补充2：String、StringBuffer、StringBuilder" class="headerlink" title="补充2：String、StringBuffer、StringBuilder"></a>补充2：String、StringBuffer、StringBuilder</h4><blockquote><p>1）运行速度StringBuilder&gt;StringBuffer&gt;String</p></blockquote><blockquote><p>2）String是字符串常量，String对象一旦创建就不能更改。StringBuffer为 字符串变量，可更改</p></blockquote><blockquote><p>3） String适用于少量的字符串操作，StringBuffer适用于多线程下字符缓冲区进行大量操作的情况。 </p><p>4） StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，</p></blockquote><blockquote><p>5） 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。</p><p>6） 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而StringBuffer则每次都需要判断锁，效率相对更低。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_【1】二维数组的查找</title>
      <link href="/2019/04/1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/04/1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-题目描述："><a href="#1-题目描述：" class="headerlink" title="1.题目描述："></a>1.题目描述：</h3><blockquote><p> 在一个二维数组中（每个一维数组的长度相同），如数组</p><p>1       2       3</p><p>4       5       6 </p><p>7       8       9</p><p>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<a id="more"></a></p></blockquote><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h3><ol><li><p>选择右上角的数字作为开始点</p></li><li><p>如果array[row][col]&gt;target,则向左查找，col–；</p></li><li><p>如果array[row][col]&lt;target,则向下查找，row++；</p></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;=array.length-<span class="number">1</span>&amp;&amp;col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[row][col]&gt;target)&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[row][col]&lt;target)&#123;</span><br><span class="line">                  row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组类型题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_线程TLAB局部缓存区域</title>
      <link href="/2019/04/jvm-%E7%BA%BF%E7%A8%8BTLAB%E5%B1%80%E9%83%A8%E7%BC%93%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/04/jvm-%E7%BA%BF%E7%A8%8BTLAB%E5%B1%80%E9%83%A8%E7%BC%93%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-对象内存分配的两种方法"><a href="#1-对象内存分配的两种方法" class="headerlink" title="1.对象内存分配的两种方法"></a>1.对象内存分配的两种方法</h2><p>Ø 指针碰撞</p><blockquote><p>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”<a id="more"></a></p></blockquote><p>Ø 空闲列表</p><blockquote><p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”</p></blockquote><p>问题：</p><pre><code>多线程执行时，一个线程正在给A对象分配内存，指针还没有来的及修改，其它为B对象分配内存的线程，而且还是引用这之前的指针指向。就出现问题了</code></pre><h3 id="2-TLAB线程本地分配缓存区"><a href="#2-TLAB线程本地分配缓存区" class="headerlink" title="2.TLAB线程本地分配缓存区"></a>2.TLAB线程本地分配缓存区</h3><p>概念：线程本地分配缓存区,这是一个线程专用的内存分配区域。 由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步（虚拟机采用CAS配上失败重试的方式保证更新操作的原子性），而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。</p><h6 id="划重点："><a href="#划重点：" class="headerlink" title="划重点："></a>划重点：</h6><p>1.堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的</p><p>2.Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），<br>   其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配</p><p>3.JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB。默认设定为占用Eden Space的1%。TLAB上的分配由于是线程私有所以没有锁开销。</p><p>4.TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。</p><p>5.所有新创建的Object 都将会存储在新生代Yong Generation中。<br>   如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_内存分配和回收策略</title>
      <link href="/2019/04/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
      <url>/2019/04/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1.内存分配"></a>1.内存分配</h2><p>1.对象优先在eden分配</p><pre><code>对象先在新生代Eden区分配，当Eden区没有足够空间进行分配，虚拟机将发起  Minor GC</code></pre><a id="more"></a><p>2.大对象直接进入老年代</p><pre><code>大对象指的是需要大量的连续内存空间的java对象。如很长的字符串或者数组 -XX:PretenureSizeThreshold:大于该值直接在老年代分配</code></pre><p>3.长期存活的对象直接进入老年代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置对象年龄计数器，GC一遍没死年龄加1,默认老年阈值为15</span><br><span class="line">-XX:MaxTenuringThreshold:老年代年龄设置</span><br></pre></td></tr></table></figure><h6 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h6><pre><code>survivor空间中相同年龄的对象大小总和&gt;survivor的一半，该年龄进入老年代，无需等到MaxTenuringThreshold设定的年龄。</code></pre><h2 id="2-回收策略"><a href="#2-回收策略" class="headerlink" title="2.回收策略"></a>2.回收策略</h2><h6 id="空间分配担保："><a href="#空间分配担保：" class="headerlink" title="空间分配担保："></a>空间分配担保：</h6><pre><code>老年代最大可用空间&gt;新生代所有对象总空间，Minor GC 确保安全。如果允许，继续比较 老年代最大可用空间&gt;晋升到老年代对象的平均大小，如果大于进行Minor GC,否则进行Full GC.</code></pre><h4 id="Full-GC-和Minor-GC"><a href="#Full-GC-和Minor-GC" class="headerlink" title="Full GC 和Minor GC"></a>Full GC 和Minor GC</h4><blockquote><p>对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，与Minor GC对应的是Major GC、Full GC。</p></blockquote><pre><code>(1)Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。(2)Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。(3)Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。</code></pre><h5 id="Minor-GC-触发条件"><a href="#Minor-GC-触发条件" class="headerlink" title="Minor GC 触发条件"></a>Minor GC 触发条件</h5><pre><code>当Eden区满时，触发Minor GC。</code></pre><h5 id="Full-GC-触发条件"><a href="#Full-GC-触发条件" class="headerlink" title="Full GC 触发条件"></a>Full GC 触发条件</h5><pre><code>(1) 调用System.gc(2) 老年代空间不足    新生代对象转入及创建为大对象、大数组时出现不足的现象(3) 永久代空间不足   永久代中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。(4) gc担保失败 老年代最大可用空间&lt;新生代所有对象总空间,继续比较老年代最大可用空间&lt;晋升到老年代对象的平均大小(5) CMS清理阶段，发现有新的垃圾，而老年代没有足够空间</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_对象已死</title>
      <link href="/2019/04/JVM-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB/"/>
      <url>/2019/04/JVM-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>垃圾收集器再对堆进行回收前，第一个要做的事就是确定对象是否还存活，判断方法有2种</p><p>1)引用计数法</p><p>2)可达性分析</p><a id="more"></a><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h4><blockquote><p>给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。</p><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>很难解决对象之间的相互循环引用问题，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器收集它们。</p></blockquote><h4 id="2-可达性分析"><a href="#2-可达性分析" class="headerlink" title="2.可达性分析"></a>2.可达性分析</h4><blockquote><p>通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。</p><h6 id="GC-Roots对象"><a href="#GC-Roots对象" class="headerlink" title="GC Roots对象:"></a>GC Roots对象:</h6><p>(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</p><p>(2). 方法区中的<strong>类静态属性引用的对象</strong>。static对象</p><p>(3). 方法区中<strong>常量</strong>引用的对象。final对象</p><p>(4). <strong>本地方法</strong>栈中JNI(Native方法)引用的对象。</p></blockquote><h5 id="扩展：引用"><a href="#扩展：引用" class="headerlink" title="扩展：引用"></a>扩展：引用</h5><blockquote><p>(1) <strong>强引用</strong> ：只要强引用还存在，【垃圾收集器就永远不会回收该对象】</p><pre><code>Object obj = new Object();</code></pre><p>(2) <strong>软引用</strong> :软引用关联的对象，在系统发生内存溢出异常前，会将这些对象进行第二次回收。如果第二次回收还没有足够内存才抛出内存溢出异常。【内存空间足够，回收器就不会回收它，内存不足就会回收】</p><p>(3) <strong>弱引用</strong>：描述非必需对象。关联的对象只能生存到下一次垃圾回收前，当垃圾收集器工作时，【无论当前内存是否足够，都会回收掉它们】。</p><p>(4) <strong>虚引用</strong> ：无法通过虚引用来取得一个对象实例。唯一目的是能在这个对象被收集器回收时收到一个系统通知。【任何时候都可能被回收】</p></blockquote><h5 id="死亡过程"><a href="#死亡过程" class="headerlink" title="死亡过程"></a>死亡过程</h5><blockquote><p>可达性分析没有发现与GCRoots的引用链 </p><p>1.如果不可达，则标记筛选（条件是对象是否有必要执行finalize）<br>   1)没必要，对象没有覆盖finalize方法或者finalize已经被虚拟机调用<br>   2)有必要。放置在F-Queue队列中。这时候二次标记。如果重新与对象建立连接则不会被回收。</p></blockquote><h5 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h5><blockquote><p>永久代的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类</strong></p><p>1.废弃常量<br>         没有在其他地方引用则回收<br>2.无用的类<br>         (1) 类的实例已被回收<br>         (2) 加载该类的classloader已被回收<br>         (3) 该类对应的class没有被引用，也无反射访问。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_垃圾收集器</title>
      <link href="/2019/04/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2019/04/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>垃圾收集器一共有7种，如果说收集算法是内存回收的方法，那个垃圾收集器就是垃圾回收的具体实现。<a id="more"></a></p><p><img src="https://github.com/qiulig/IMG/raw/master/垃圾收集器.png" alt="垃圾收集器"></p><p><code>以中间绿线为界，上边三个用于年轻代，下边三个用在年老代，而G1则老少通吃，**黑线**线表示两个回收器可搭配使用，**红线**则表示两者可以在同一区域交替使用。由于G1在JDK1.7才达到商用级别，而且目前线上环境也很少使用。</code></p><table><thead><tr><th>名称</th><th></th><th>区域</th><th>算法</th><th>适用情况</th></tr></thead><tbody><tr><td>Serial</td><td>串行</td><td>年轻代</td><td>复制</td><td>单CPU（或CPU较少）、小型客户端应用</td></tr><tr><td>Parallel Scavenge</td><td>并行</td><td>年轻代</td><td>复制</td><td>多CPU、吞吐量优先（后台处理、科学计算）</td></tr><tr><td>ParNew</td><td>并行</td><td>年轻代</td><td>复制</td><td>多CPU、响应优先（web服务器等）</td></tr><tr><td>CMS</td><td>并发</td><td>年老代</td><td>标记-清除</td><td>响应优先（web服务器等）</td></tr><tr><td>Serial Old</td><td>串行</td><td>年老代</td><td>标记-整理</td><td>单CPU、小型客户端应用</td></tr><tr><td>Parallel Old</td><td>并行</td><td>年老代</td><td>标记-整理</td><td>多CPU、吞吐量优先（后台处理、科学计算）</td></tr></tbody></table><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h3><blockquote><p>从名字就能看出是串行的意思，该回收器是最早实现的，<strong>基于单线程</strong>，</p><p>优点：</p><pre><code>实现简单且效率高，</code></pre><p>缺点：</p><pre><code>进行垃圾回收是会造成“Stop-the-World”(STW)，当回收内存区域较大时，就会造成程序响应时间变长。  </code></pre><p>STW：在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。</p></blockquote><h3 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h3><blockquote><p>全名Parallel New Generation，也就是<strong>并行新生代垃圾收集</strong>器，该回收器实现与Serial基本上一样，只是采用多线程执行回收。是运行在<strong>服务端模式</strong>下首选的新生代收集器。</p></blockquote><h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h3><blockquote><p>Parallel Scavenge则<strong>侧重于吞吐量的控制</strong>，又名”吞吐量优先”回收器</p><p>(吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）；</p><p><strong>停顿时间</strong>：适合需要与用户交互的程序，良好的响应速度能提升用户体验</p><p><strong>高吞吐量</strong>：高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多的交互任务。</p><p>自适应调节策略：虚拟机会根据当前系统的运行监控信息，动态调整参数以提供最合适的停顿时间或者最大吞吐量。</p><p>该回收器与ParNew的最大区别在于ParNew通常与CMS搭配。</p></blockquote><h3 id="4-CMS收集器"><a href="#4-CMS收集器" class="headerlink" title="4.CMS收集器"></a>4.CMS收集器</h3><blockquote><p>Concurrent Mark Sweep，是一个并发回收器，旨在减少<strong>垃圾回收的停顿时间</strong>。集中应用于<strong>B/S系统的服务端</strong>，尤其注重服务的响应速度</p></blockquote><h6 id="CMS运作操作流程"><a href="#CMS运作操作流程" class="headerlink" title="CMS运作操作流程"></a>CMS运作操作流程</h6><blockquote><p>(1)初始标记：标记GCRoots能直接关联到的对象</p><p>(2)并发标记：GCRoot开始对堆中对象进行可达性分析</p><p>(3)重新标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录</p><p>(4)并发清除：回收标记的垃圾</p></blockquote><h6 id="CMS缺点："><a href="#CMS缺点：" class="headerlink" title="CMS缺点："></a>CMS缺点：</h6><blockquote><p>（1）对CPU资源非常敏感</p><p>（2）无法处理浮动垃圾：CMS在并发清除阶段用户线程还在运行，会产生新的垃圾。这部分垃圾出现在标记之后，要等待下次GC才能清理掉</p><p>（3）基于标记-清除算法，会产生大量的内存碎片。</p></blockquote><h3 id="5-Serial-Old收集器"><a href="#5-Serial-Old收集器" class="headerlink" title="5.Serial Old收集器"></a>5.Serial Old收集器</h3><blockquote><p>   标记-整理算法实现的，相当于Serial的年老代版。</p><p>（1）可以与Parallel Scavenge收集器搭配使用</p><p>（2）作为CMS收集器的后备预案</p></blockquote><h3 id="6-Paraller-Old收集器"><a href="#6-Paraller-Old收集器" class="headerlink" title="6.Paraller Old收集器"></a>6.Paraller Old收集器</h3><blockquote><p>标记-整理算法实现，相当于Parallel Scavenge的年老代版。</p><p>在注重吞吐量以及CPU资源敏感的场合：Parallel Old + Parallel Scavengr </p></blockquote><h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7.G1收集器"></a>7.G1收集器</h3><blockquote><p>G1是一款面向服务端应用的垃圾收集器。具备以下特点：</p><p>(1)并行与并发</p><pre><code>并行即使用多个CPU来缩端STW停顿的时间，还可以通过并发方式让java程序继续执行。</code></pre><p> (2)分代收集</p><pre><code>可以不需要其他收集器配合就能独立管理整个GC堆</code></pre><p> (3)空间整合</p><pre><code>标记整理算法实现，在运行期间不会产生内存空间碎片，收集后可以提供规整的可用内存。</code></pre><p> (4)可预测停顿</p><pre><code>除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上时间不超过N秒。</code></pre></blockquote><h6 id="G1收集器运作流程："><a href="#G1收集器运作流程：" class="headerlink" title="G1收集器运作流程："></a>G1收集器运作流程：</h6><blockquote><p>(1)初始标记：标记GCRoots能直接关联到的对象</p><p>(2)并发标记：GCRoot开始对堆中对象进行可达性分析</p><p>(3)最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录</p><p>(4)筛选回收：回收标记的垃圾</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_垃圾回收算法</title>
      <link href="/2019/04/JVM-%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/JVM-%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>垃圾回收算法有4种</p><ol><li><p>标记-清除算法</p></li><li><p>复制算法</p></li><li><p>标记-整理算法</p></li><li><p>分代收集算法</p><a id="more"></a></li></ol><h2 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1.复制算法"></a>1.复制算法</h2><p><code>可用的内存空间分为大小相等的两块，每次只是用其中的一块，当这一块被用完的时候，就将还存活的对象复制到另一块中，然后把原已使用过的那一块内存空间一次回收掉。这个算法常用于新生代的垃圾回收。</code></p><p><img src="https://github.com/qiulig/IMG/raw/master/复制算法.jpg" alt="复制算法"></p><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ol><li>复制算法解决了标记-清除算法的效率问题，以空间换时间。</li></ol><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ol><li>但是当存活对象非常多的时候，复制操作效率将会变低，而且每次只能使用一半的内存空间，利用率不高。</li></ol><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ol><li><p>应用于新生代</p></li><li><p>Serial、ParNew、Parallel Scavenge 垃圾收集器应用的算法</p></li></ol><h2 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记-清除算法"></a>2. 标记-清除算法</h2><p><code>先标记出所有需要被回收的对象，然后在标记完成后统一回收掉所有被标记的对象。</code></p><p><img src="https://github.com/qiulig/IMG/raw/master/标记清除算法.png" alt="标记清除算法"></p><h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><pre><code>效率问题：标记与清除两个过程的效率都不高空间问题：产生大量不连续的内存碎片，碎片太多会导致再程序运行过程中需要分配较大对象时，找不到足够的连续内存尔不得不提前触发垃圾回收动作。</code></pre><h6 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h6><pre><code>应用于老年代的垃圾回收CMS垃圾收集器应用的算法</code></pre><h2 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h2><p>这个算法分为三部分：</p><blockquote><p>标记出所有需要被回收的对象；</p><p>把所有存活的对象都向一端移动；</p><p>把所有存活对象边界以外的内存空间都回收掉。</p></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/标记整理算法.png" alt="标记整理算法"></p><h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><blockquote><p>标记-整理算法解决了复制算法多复制效率低、空间利用率低的问题，</p><p>解决了内存碎片的问题。</p></blockquote><h6 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h6><blockquote><p>Serial Old、Parallel Old 垃圾收集器应用的算法</p><p>主要应用于老年代</p></blockquote><h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><blockquote><p>根据对象生存周期的不同将内存空间划分为不同的块，然后对不同的块使用不同的回收算法。一般把Java堆分为新生代和老年代，新生代中对象的存活周期短，只有少量存活的对象，所以可以使用复制算法，而老年代中对象存活时间长，而且对象比较多，所以可以采用标记-清除和标记-整理算法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_锁问题</title>
      <link href="/2019/03/SQL-%E9%94%81%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/SQL-%E9%94%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><blockquote><p>（1）<strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。  [MYISAM、Memory、Innodb]</p><pre><code>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用</code></pre><p>（2）<strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发 度也最高。[Innodb]  </p><pre><code>行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用</code></pre><p>（3）<strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁  之间，并发度一般。[BDB]</p></blockquote><a id="more"></a><h3 id="MYISAM表级锁"><a href="#MYISAM表级锁" class="headerlink" title="MYISAM表级锁"></a>MYISAM表级锁</h3><h5 id="锁争用"><a href="#锁争用" class="headerlink" title="锁争用"></a>锁争用</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'table%'</span>;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Table_locks_immediate | <span class="number">2979</span> |</span><br><span class="line">| Table_locks_waited | <span class="number">0</span> |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">####Table_locks_waits值高则代表严重的表级锁争用</span><br></pre></td></tr></table></figure><h5 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h5><pre><code>（1）表共享读锁：可以多个用户共同读（2）表独占写锁：写操作独占一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止</code></pre><h5 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h5><pre><code>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁</code></pre><h5 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h5><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。  </p><pre><code> 当concurrent_insert设置为0时，不允许并发插入。   当concurrent_insert设置为1时，如果MyISAM表中没有空洞(即表的中间没有被删除的行),MyISAM允许在一个进程读表的同时, 另一个进程从表尾插入记录。这也是MySQL 的默认设置。   当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</code></pre><h5 id="锁调度"><a href="#锁调度" class="headerlink" title="锁调度"></a>锁调度</h5><pre><code>一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，写进程先获得锁。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一些设置来调节 MyISAM 的调度行为。 </span><br><span class="line">     通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</span><br><span class="line">     通过执行命令SET LOW_PRIORITY_UPDATES=<span class="number">1</span>，使该连接发出的更新请求优先级降低。</span><br><span class="line">     通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</span><br></pre></td></tr></table></figure><h3 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h3><h5 id="锁争用-1"><a href="#锁争用-1" class="headerlink" title="锁争用"></a>锁争用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">'innodb_row_lock%'</span>;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| InnoDB_row_lock_current_waits | <span class="number">0</span> |</span><br><span class="line">| InnoDB_row_lock_time | <span class="number">0</span> |</span><br><span class="line">| InnoDB_row_lock_time_avg | <span class="number">0</span> |</span><br><span class="line">| InnoDB_row_lock_time_max | <span class="number">0</span> |</span><br><span class="line">| InnoDB_row_lock_waits | <span class="number">0</span> |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">###InnoDB_row_lock_waits 和 InnoDB_row_lock_time_avg 的值</span><br><span class="line">比较高，代表严重的锁争用</span><br></pre></td></tr></table></figure><h5 id="锁模式-1"><a href="#锁模式-1" class="headerlink" title="锁模式"></a>锁模式</h5><p><strong>共享锁：</strong>允许一个事务去读一行，阻止其他事务获得该行的排他锁<br>         select …  lock in share mode;</p><p><strong>排他锁</strong>：允许获得排他锁的事务更新数据，阻止其他事务获得该行的共享读锁和排他写锁<br>         select … for update;</p><table><thead><tr><th></th><th>X(排他锁)</th><th>IX(意向排他锁)</th><th>S(共享锁)</th><th>IS(意向共享锁)</th></tr></thead><tbody><tr><td>X(排他锁)</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX(意向排他锁)</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S(共享锁)</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS(意向共享锁)</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</span><br><span class="line"> 排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁.另外，为了允许行锁和表锁共存，</span><br><span class="line">   实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</span><br><span class="line"> 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</span><br><span class="line"> 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁</span><br></pre></td></tr></table></figure><h5 id="锁实现方式"><a href="#锁实现方式" class="headerlink" title="锁实现方式"></a>锁实现方式</h5><pre><code>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）在不通过索引条件查询的时候，InnoDB 确实使用的是表锁，而不是行锁。</span><br><span class="line">（<span class="number">2</span>）由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的</span><br><span class="line">（<span class="number">3</span>）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行.另外，不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁</span><br><span class="line">（<span class="number">4</span>）如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。</span><br></pre></td></tr></table></figure><h5 id="表锁使用场景"><a href="#表锁使用场景" class="headerlink" title="表锁使用场景"></a>表锁使用场景</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)事务需要更新大部分或全部数据 </span><br><span class="line">(<span class="number">2</span>)事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的 开销</span><br></pre></td></tr></table></figure><h5 id="避免死锁方法"><a href="#避免死锁方法" class="headerlink" title="避免死锁方法"></a>避免死锁方法</h5><blockquote><p>（1）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表</p><p>（2）在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。</p><p>（3）隔离级别</p><pre><code>在 REPEATABLE-READ 隔离级别下，如果两个线程同时对相同条件记录用 SELECT...FOR UPDATE 加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁.这种情况下，将隔离级别改成 READ COMMITTED，就可避免问题，</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYDQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_触发器</title>
      <link href="/2019/03/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2019/03/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>触发器（trigger）是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。</p><a id="more"></a><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><br><strong>CREATE TRIGGER</strong> trigger_name trigger_time[BEFORE&#124;AFTER]<br> trigger_event[INSERT&#124;UPDATE&#124;DELETE]<br><strong>ON</strong> tbl_name<br> <strong>FOR EACH ROW</strong> trigger_stmt<br><br></td><td>创建触发器</td></tr><tr><td><strong>DROP TRIGGER</strong> [schema_name.]trigger_name</td><td>删除触发器</td></tr><tr><td><strong>show triggers \G</strong></td><td>查看触发器</td></tr><tr><td><strong>desc triggers</strong></td><td>查看触发器</td></tr></tbody></table><h3 id="触发器的使用"><a href="#触发器的使用" class="headerlink" title="触发器的使用"></a>触发器的使用</h3><p>触发器执行的语句有以下两个限制。</p><blockquote><pre><code>（1）触发程序不能调用将数据返回客户端的存储程序，也不能使用采用 CALL 语句的动态 SQL  语句     但是允许存储程序通过参数将数据返回触发程序。也就是存储过程或者函数通过 OUT  或者 INOUT 类型的参数将数据返回触发器     是可以的，但是不能调用直接返回数据的过程。  （2）不能在触发器中使用以显式或隐式方式开始或结束事务的语句，如 STARTTRANSACTION、  COMMIT 或 ROLLBACK</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_存储过程和函数</title>
      <link href="/2019/03/SQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2019/03/SQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><pre><code>存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合。</code></pre><a id="more"></a><p>与函数的区别</p><blockquote><p>（1）函数必须有返回值，而存储过程没有</p><p>（2）存储过程的参数可以使用 IN、OUT、INOUT 类型，而函数的参数只能是 IN 类型的。</p></blockquote><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><table><thead><tr><th>语句</th><th>定义</th></tr></thead><tbody><tr><td><br><strong>CREATE PROCEDURE</strong> sp_name<br> ([proc_parameter[,…]])<br> [characteristic …] routine_body<br><br></td><td>创建存储过程</td></tr><tr><td><br><strong>CREATE FUNCTION</strong> sp_name<br> ([func_parameter[,…]]<br> <strong>RETURNS</strong> type  [characteristic …]<br> routine_body<br><br></td><td>创建函数</td></tr><tr><td><br><strong>ALTER {PROCEDURE &#124; FUNCTION}</strong> sp_name<br> [characteristic …]<br><br></td><td>修改 存储过程/函数</td></tr><tr><td><br><strong>CALL</strong> sp_name([parameter[,…]])<br><br></td><td>调用过程</td></tr><tr><td><br><strong>DROP PROCEDURE</strong> name<br><br></td><td>删除存储过程</td></tr><tr><td><br><strong>SHOW {PROCEDURE&#124;FUNCTION} STATUS</strong> [LIKE ‘pattern’]<br><br></td><td>查看存储过程或者函数的状态</td></tr><tr><td><br><strong>SHOW CREATE {PROCEDURE &#124;FUNCTION}</strong> sp_name<br><br></td><td>查看存储过程或者函数的定义</td></tr><tr><td><br><strong>select * from routines</strong> where ROUTINE_NAME = ‘film_in_stock’ \G<br><br></td><td>获取存储过程和函数的包括名称、类型、语法、创建人 等信息。</td></tr><tr><td><br><strong>DECLARE</strong> var_name[,…] type [DEFAULT value]<br><br></td><td>变量的定义{用于begin…end块中}</td></tr><tr><td><br><strong>SET</strong> var_name = expr [, var_name = expr]<br><br></td><td>变量的赋值</td></tr><tr><td><br><strong>DECLARE</strong> condition_name <strong>CONDITION FOR</strong> condition_value<br><br></td><td>条件的定义</td></tr><tr><td><br><strong>DECLARE</strong> handler_type<br> <strong>HANDLER FOR</strong> condition_value[,…] sp_statement<br><br></td><td>条件的处理</td></tr><tr><td><br><strong>DECLARE</strong> cursor_name <strong>CURSOR FOR</strong> select_statement<br><br></td><td>声明光标</td></tr><tr><td><br>OPEN cursor_name<br><br></td><td>打开光标</td></tr><tr><td><br>FETCH cursor_name INTO var_name [, var_name] …<br><br></td><td>fetch光标</td></tr><tr><td><br>CLOSE cursor_name<br><br></td><td>关闭光标</td></tr><tr><td><br><strong>IF</strong> search_condition <strong>THEN</strong> statement_list<br>[<strong>ELSEIF</strong> search_condition <strong>THEN</strong> statement_list] …<br>[<strong>ELSE</strong> statement_list]<br><strong>END IF</strong><br><br></td><td>IF语句</td></tr><tr><td><br><strong>CASE</strong> case_value<br><strong>WHEN</strong> when_value <strong>THEN</strong> statement_list<br>[<strong>WHEN</strong> when_value <strong>THEN</strong> statement_list] …<br>[<strong>ELSE</strong> statement_list]<br><strong>END CASE</strong><br><br></td><td>CASE语句</td></tr><tr><td><br>[begin_label:] <strong>LOOP</strong><br>statement_list<br><strong>END LOOP</strong> [end_label]<br><br></td><td>LOOP语句</td></tr><tr><td><br>[begin_label:] <strong>REPEAT</strong><br>statement_list<br><strong>UNTIL</strong> search_condition<br><strong>END REPEAT</strong> [end_label]<br><br></td><td>REPEAT语句</td></tr><tr><td><br>[begin_label:] <strong>WHILE</strong> search_condition <strong>DO</strong><br>statement_list<br><strong>END WHILE</strong> [end_label]<br><br></td><td>WHILE语句</td></tr></tbody></table><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><blockquote><p>创建存储过程的proc_parameter: </p><pre><code>[ IN | OUT | INOUT ]   param_name type </code></pre></blockquote><blockquote><p>创建函数的func_parameter: </p><pre><code>param_name type  </code></pre></blockquote><blockquote><p>创建函数的type:</p><pre><code>Any valid MySQL data type  </code></pre></blockquote><blockquote><p>创建存储过程/函数的characteristic:<br>            LANGUAGE SQL   //说明下面过程的BODY是使用SQL语言<br>            | [NOT] DETERMINISTIC  //DEDETERMINISTIC 确定的，即每次输入一样输出也一样的程序，NOT DETERMINISTIC 非确定的，默认是非确定的。<br>            | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }   //CONTAINS SQL 表示子程序不包含读或写数据的语句。NO SQL 表示子程序不包含 SQL 语句。READS SQL DATA 表示子程序包含读数据的语句，但不包含写数据的语句。MODIFIES SQL DATA 表示子程序包含写数据的语句。<br>            | SQL SECURITY { DEFINER | INVOKER }   //可以用来指定子程序该用创建子程序者的许可来执行，还是使用调用者的许可来执行。默认值是 DEFINER<br>            | COMMENT ‘string’  //存储过程或者函数的注释信息。</p></blockquote><blockquote><p> 创建存储过程/函数的 routine_body:<br>            Valid SQL procedure statement or statements  </p></blockquote><blockquote><p>修改存储过程/函数中的characteristic:<br>    { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }<br>    | SQL SECURITY { DEFINER | INVOKER }<br>    | COMMENT ‘string</p></blockquote><blockquote><p> 条件的定义condition_value:  </p><pre><code>    SQLSTATE [VALUE] sqlstate_value &lt;|mysql_error_code</code></pre></blockquote><blockquote><p> 条件的处理参数handler_type:</p><pre><code>    CONTINUE  | EXIT  | UNDO  </code></pre><p>condition_value:  </p><pre><code>SQLSTATE [VALUE] sqlstate_value  | condition_name  | SQLWARNING  //对所有以 01 开头的 SQLSTATE 代码的速记| NOT FOUND  //对所有以 02 开头的 SQLSTATE 代码的速记| SQLEXCEPTION  //对所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的速记。| mysql_error_code</code></pre></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELIMITER $$   //delimiter将sql的结束标志设为$$</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; CREATE PROCEDURE film_in_stock(IN p_film_id INT, IN p_store_id INT, OUT p_film_count</span><br><span class="line"></span><br><span class="line">INT)</span><br><span class="line">    -&gt; READS SQL DATA</span><br><span class="line"></span><br><span class="line">    -&gt; BEGIN</span><br><span class="line"></span><br><span class="line">    -&gt; SELECT inventory_id</span><br><span class="line"></span><br><span class="line">    -&gt; FROM inventory</span><br><span class="line"></span><br><span class="line">    -&gt; WHERE film_id = p_film_id</span><br><span class="line"></span><br><span class="line">    -&gt; AND store_id = p_store_id</span><br><span class="line"></span><br><span class="line">    -&gt; AND inventory_in_stock(inventory_id);  ////调用了函数inventory_in_stock()</span><br><span class="line"></span><br><span class="line">    -&gt;</span><br><span class="line"></span><br><span class="line">    -&gt; SELECT FOUND_ROWS() INTO p_film_count;</span><br><span class="line"></span><br><span class="line">    -&gt; END $$</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; DELIMITER ;  //delimiter将sql的结束标志设为;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_视图</title>
      <link href="/2019/03/SQL-%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/03/SQL-%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="视图概念"><a href="#视图概念" class="headerlink" title="视图概念"></a>视图概念</h3><pre><code>视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。</code></pre><a id="more"></a><ul><li>视图中的数据并不属于视图本身，而是属于基本的表，对视图可以像表一样进行insert,update,delete操作。</li><li>视图不能被修改，表修改或者删除后应该删除视图再重建。</li><li>视图的数量没有限制，但是命名不能和视图以及表重复，具有唯一性。</li><li>视图可以被嵌套，一个视图中可以嵌套另一个视图。</li><li>视图不能索引，不能有相关联的触发器和默认值，sql server不能在视图后使用order by排序。</li></ul><h3 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a>视图的操作</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><strong>CREATE</strong> [OR REPLACE] [ALGORITHM = {UNDEFINED &#124; MERGE&#124;TEMPTABLE}]<br><strong>VIEW</strong> view_name [(column_list)]<br><strong>AS</strong> select_statement<br>[WITH [CASCADED &#124; LOCAL] CHECK OPTION]<br><br></td><td>创建视图<br>&gt; LOCAL 是只要满足本视图的条件就可以更新<br>&gt; CASCADED 则是必须满足所有针对该视图的所有视图的条件才可以更新<br></td></tr><tr><td><strong>ALTER</strong> [ALGORITHM = {UNDEFINED &#124;MERGE &#124;TEMPTABLE}]<br><strong>VIEW</strong> view_name [(column_list)]<br><strong>AS</strong> select_statement<br>[WITH [CASCADED &#124; LOCAL] CHECK OPTION]<br><br></td><td>修改视图</td></tr><tr><td><strong>DROP VIEW</strong> [IF EXISTS] view_name [, view_name] …[RESTRICT &#124; CASCADE]</td><td>删除视图</td></tr><tr><td>SHOW TABLES</td><td>查看视图</td></tr><tr><td>SHOW TABLE STATUS [FROM db_name] [LIKE ‘pattern’]</td><td>查看视图的信息</td></tr><tr><td><strong>show create view</strong> view_name  \G</td><td>查看视图定义</td></tr></tbody></table><h5 id="视图不可更新情况："><a href="#视图不可更新情况：" class="headerlink" title="视图不可更新情况："></a>视图不可更新情况：</h5><pre><code>（1）包含以下关键字的 SQL 语句：聚合函数（SUM、MIN、MAX、COUNT 等）、DISTINCT、GROUP BY、HAVING、UNION 或者 UNION ALL。      &gt; create or replace view payment_sum as   select staff_id,sum(amount) from payment **group by** staff_id;（2） 常量视图。     &gt; create or replace view pi as select 3.1415926 as pi;（3）SELECT 中包含子查询。      &gt;create view city_view as             select (select city from city where city_id = 1) ;（4） JION。  （5） FROM 一个不能更新的视图。  （6）WHERE 字句的子查询引用了 FROM 字句中的表</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_索引</title>
      <link href="/2019/03/SQL-%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/03/SQL-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1.索引概述"></a>1.索引概述</h3><pre><code>使用索引是提高 SELECT 操作性能的最佳途径。 MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引MySQL 目前还不支持函数索引，但是支持前缀索引。MySQL 中还支持全文本（FULLTEXT）索引，用于全文搜索，默认情况下，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。</code></pre><a id="more"></a><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><strong>CREATE</strong>[UNIQUE&#124;FULLTEXT&#124;SPATIAL] <strong>INDEX</strong> index_name<br>[USING index_type]<br><strong>ON</strong> tbl_name (index_col_name,…)<br><br></td><td>创建索引<br>index_col_name:<br>col_name [(length)] [ASC&#124;DESC]</td></tr><tr><td><strong>DROP INDEX</strong> index_name<br> <strong>ON</strong> tbl_name</td><td>删除索引</td></tr></tbody></table><h3 id="2-设计索引原则"><a href="#2-设计索引原则" class="headerlink" title="2.设计索引原则"></a>2.设计索引原则</h3><pre><code>  （1）搜索的索引列，不一定是所要选择的列。换句话说，最适合索引的列是出现在 WHERE子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。  （2） 使用唯一索引。考虑某列中值的分布。索引的列的基数越大，索引的效果越好。（3） 使用短索引。如果对字符串列进行索引，应该指定一个前缀长度。（4）利用最左前缀（5）不要过度索引</code></pre><h3 id="3-索引失效"><a href="#3-索引失效" class="headerlink" title="3.索引失效"></a>3.索引失效</h3><blockquote><p>（1）如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引.</p><p>（2）如果使用 MEMORY/HEAP 表并且 where 条件中不使用“=”进行索引列，那么不会用到索引。heap 表只有在“=”的条件下才会使用索引。</p><p>（3）用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到</p><p>（4）不符合最左前缀:有复合索引，但是搜索的那个列不是索引第一列</p><p>（5）like以%开始</p><p>（6）如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的</p></blockquote><h3 id="4-查看索引使用情况"><a href="#4-查看索引使用情况" class="headerlink" title="4.查看索引使用情况"></a>4.查看索引使用情况</h3><blockquote><p>》 show status like ‘Handler_read%’;<br>        handler_read_key:索引值被读次数 越高越好<br>        handler_read_rnd_next:查询效率，该值越低越好</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_存储引擎</title>
      <link href="/2019/03/SQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/03/SQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="四种存储引擎"><a href="#四种存储引擎" class="headerlink" title="四种存储引擎"></a>四种存储引擎</h2><a id="more"></a><blockquote><p>(1) MYISAM</p><pre><code>MyISAM 是 MySQL 的默认存储引擎。MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表.(不支持外键)</code></pre><p>(2) Innodb</p><pre><code>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。（支持外键）</code></pre><p>(3) Memory</p><pre><code>MEMORY 存储引擎使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文件，格式是.frm。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的,并且默认使用 HASH 索引，但是一旦服务关闭，表中的数据就会丢失掉。MEMORY 类型的存储引擎主要用在那些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果。</code></pre><p>(4) Merge</p><pre><code>MERGE 存储引擎是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，MERGE表本身并没有数据.对 MERGE 类型的表可以进行查询、更新、删除的操作，这些操作实际  上是对内部的实际的 MyISAM 表进行的。使用MERGE 表来透明地对多个表进行查询和更新操作，而对这种按照时间记录的操作日志表则可以透明地进行插入操作。</code></pre></blockquote><h3 id="1-MYISAM"><a href="#1-MYISAM" class="headerlink" title="1.MYISAM"></a>1.MYISAM</h3><p> 每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，但扩展名分别是：</p><pre><code> .frm（存储表定义）；   .MYD（MYData，存储数据）；   .MYI （MYIndex，存储索引）。  数据文件和索引文件可以放置在不同的目录，平均分布 IO，获得更快的速度。</code></pre><p> MyISAM 的表又支持 3 种不同的存储格式，分别是：</p><pre><code> 静态（固定长度）表：存储迅速，容易缓存，出现故障容易恢复，但占用空间多。 动态表：占用空间少， 但频繁更新删除记录会产生碎片，故障恢复较难 压缩表： 记录被单独压缩，访问开支小。</code></pre><h3 id="2-InnoDB"><a href="#2-InnoDB" class="headerlink" title="2.InnoDB"></a>2.InnoDB</h3><p>(1)自动增长列</p><pre><code>（1）ALTER TABLE *** AUTO_INCREMENT = n: 语句强制设置自动增长列的初识值（2）LAST_INSERT_ID()：查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是第一条记录使用的自动增长值。对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于 MyISAM 表，自动增长列可以是组合索引的其他列.</code></pre><p>(2)外键约束</p><blockquote><blockquote><blockquote><p><strong>CONSTRAINT</strong> <code>fk_city_country</code> <br><strong>FOREIGN KEY</strong> (子表的外键名称)<br><strong>REFERENCES</strong> 父表(父表的名称)<br><strong>ON</strong> DELETE RESTRICT<br> <strong>ON</strong> UPDATE CASCADE<br><br></p></blockquote></blockquote></blockquote><pre><code>RESTRICT/NO ACTION： 限制在子表有关联记录的情况下父表不能更新CASCADE： 表示父表在更新或者删除时，更新或者删除子表对应记录SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL</code></pre><p>(3) 存储方式</p><pre><code>@ 使用共享表空间存储@ 使用多表空间存储</code></pre><h3 id="存储引擎的选用"><a href="#存储引擎的选用" class="headerlink" title="存储引擎的选用"></a>存储引擎的选用</h3><p> <strong>MyISAM</strong>：默认的 MySQL 插件式存储引擎。如果应用是<strong>以读操作和插入操作为主，  只有很少的更新和删除操作</strong>，并且对<strong>事务的完整性、并发性要求不是很高</strong>MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。<br>  <br></p><p> <strong>InnoDB</strong>：用于<strong>事务处理应用程序</strong>，支持外键。如果应用对事务的完整性有比较高的  要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、  删除操作，那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低  由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback）,对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。  <br><br></p><p> <strong>MEMORY</strong>：将所有数据保存在 RAM 中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY 的缺陷是对表的大小有限制，太大的表无法 CACHE 在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。<strong>MEMORY 表通常用于更新不太频繁的小表，用以快速得到访问结果</strong>。 <br><br><br> <strong>MERGE</strong>：用于将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象  引用它们。MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制，并且通过将不同  的表分布在多个磁盘上，可以有效地改善 MERGE 表的访问效率。这对于诸如<strong>数据仓储</strong>等 VLDB  环境十分适合</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_常用函数</title>
      <link href="/2019/03/SQL-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2019/03/SQL-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.常用函数分为以下几种</p><blockquote><p>(1) 字符串</p><p>(2) 数值函数</p><p>(3) 日期和时间函数</p><p>(4) 流程函数</p><p>(5) 其他</p><a id="more"></a></blockquote><h3 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CANCAT(S1,S2,…Sn)</td><td>连接 S1,S2,…Sn 为一个字符串</td></tr><tr><td>INSERT(str,x,y,instr)</td><td>将字符串 str 从第 x 位置开始，y 个字符长的子串替换为字符串 instr</td></tr><tr><td>LOWER(str)</td><td>将字符串 str 中所有字符变为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串 str 中所有字符变为大写</td></tr><tr><td>LEFT(str ,x)</td><td>返回字符串 str 最左边的 x 个字符</td></tr><tr><td>RIGHT(str,x)</td><td>返回字符串 str 最右边的 x 个字符</td></tr><tr><td>LPAD(str,n ,pad)</td><td>用字符串 pad 对 str 最左边进行填充，直到长度为 n 个字符长度</td></tr><tr><td>RPAD(str,n ,pad)</td><td>用字符串 pad 对 str 最右边进行填充，直到长度为 n 个字符长度</td></tr><tr><td>LTRIM(str)</td><td>去掉字符串 str 左侧的空格</td></tr><tr><td>RTRIM(str)</td><td>去掉字符串 str 行尾的空格</td></tr><tr><td>REPEAT(str,x)</td><td>返回 str 重复 x 次的结果</td></tr><tr><td>REPLACE(str,a,b)</td><td>用字符串 b 替换字符串 str 中所有出现的字符串 a</td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串 s1 和 s2</td></tr><tr><td>TRIM(str)</td><td>去掉字符串行尾和行头的空格</td></tr><tr><td>SUBSTRING(str,x,y)</td><td>返回从字符串 str x 位置起 y 个字符长度的字串</td></tr></tbody></table><h3 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2.数值函数"></a>2.数值函数</h3><style> </style><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回 x 的绝对值</td></tr><tr><td>CEIL(x)</td><td>返回大于 x 的最大整数值</td></tr><tr><td>FLOOR(x)</td><td>返回小于 x 的最大整数值</td></tr><tr><td>MOD(x，y)</td><td>返回 x/y 的模</td></tr><tr><td>RAND()</td><td>返回 0 到 1 内的随机值</td></tr><tr><td>ROUND(x,y)</td><td>返回参数 x 的四舍五入的有 y 位小数的值</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数字 x 截断为 y 位小数的结果</td></tr></tbody></table><h3 id="3-日期和时间函数"><a href="#3-日期和时间函数" class="headerlink" title="3.日期和时间函数"></a>3.日期和时间函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前的日期和时间</td></tr><tr><td>UNIX_TIMESTAMP(date)</td><td>返回日期 date 的 UNIX 时间戳</td></tr><tr><td>FROM_UNIXTIME</td><td>返回 UNIX 时间戳的日期值</td></tr><tr><td>WEEK(date)</td><td>返回日期 date 为一年中的第几周</td></tr><tr><td>YEAR(date)</td><td>返回日期 date 的年份</td></tr><tr><td>HOUR(time)</td><td>返回 time 的小时值</td></tr><tr><td>MINUTE(time)</td><td>返回 time 的分钟值</td></tr><tr><td>MONTHNAME(date)</td><td>返回 date 的月份名</td></tr><tr><td>DATE_FORMAT(date,fmt)</td><td>返回按字符串 <strong>fmt 格式化日期</strong> date 值</td></tr><tr><td>DATE_ADD(date,<strong>INTERVAL</strong> expr type)</td><td>返回一个日期或时间值加上一个<strong>时间间隔的时间值</strong>，<br>INTERVAL 是间隔类型关键字<br>expr 是一个表达式，这个表达式对应后面的类型<br>type 是间隔类型<br></td></tr><tr><td>DATEDIFF(expr,expr2)</td><td>返回起始时间 expr 和结束时间 expr2 之间的天数</td></tr></tbody></table><p>表： MySQL 中的日期时间格式</p><table><thead><tr><th>格式符</th><th>格式说明</th></tr></thead><tbody><tr><td>%S,%s</td><td>两位数字形式的秒（00,01,…,59）</td></tr><tr><td>%i</td><td>两位数字形式的分（00,01,…,59）</td></tr><tr><td>%H</td><td>两位数字形式的小时，24 小时（00,01,…,23）</td></tr><tr><td>%h,%I</td><td>两位数字形式的小时，12 小时（01,02,…,12）</td></tr><tr><td>%k</td><td>数字形式的小时，24 小时（0,1,…,23）</td></tr><tr><td>%l</td><td>数字形式的小时，12 小时（1,2,…,12）</td></tr><tr><td>%T</td><td>24 小时的时间形式（hh:mm:ss）</td></tr><tr><td>%r</td><td>12 小时的时间形式（hh:mm:ssAM 或 hh:mm:ssPM）</td></tr><tr><td>%p</td><td>AM 或 PM</td></tr><tr><td>%W</td><td>一周中每一天的名称（Sunday,Monday,…,Saturday）</td></tr><tr><td>%a</td><td>一周中每一天名称的缩写（Sun,Mon,…,Sat）</td></tr><tr><td>%d</td><td>两位数字表示月中的天数（00,01,…,31）</td></tr><tr><td>%e</td><td>数字形式表示月中的天数（1,2，…,31）</td></tr><tr><td>%D</td><td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td></tr><tr><td>%w</td><td>以数字形式表示周中的天数（0=Sunday,1=Monday,…,6=Saturday）</td></tr><tr><td>%j</td><td>以 3 位数字表示年中的天数（001,002,…,366）</td></tr><tr><td>%U</td><td>周（0,1,52），其中 Sunday 为周中的第一天</td></tr><tr><td>%u</td><td>周（0,1,52），其中 Monday 为周中的第一天</td></tr><tr><td>%M</td><td>月名（January,February,…,December）</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表：MYSQL中的时间间隔类型</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式类型</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>HOUR</td><td>小时</td><td>hh</td></tr><tr><td>MINUTE</td><td>分</td><td>mm</td></tr><tr><td>SECOND</td><td>秒</td><td>ss</td></tr><tr><td>YEAR</td><td>年</td><td>YY</td></tr><tr><td>MONTH</td><td>月</td><td>MM</td></tr><tr><td>DAY</td><td>日</td><td>DD</td></tr><tr><td>YEAR_MONTH</td><td>年和月</td><td>YY-MM</td></tr><tr><td>DAY_HOUR</td><td>日和小时</td><td>DD hh</td></tr><tr><td>DAY_MINUTE</td><td>日和分钟</td><td>DD hh:mm</td></tr><tr><td>DAY_ SECOND</td><td>日和秒</td><td>DD hh:mm:ss</td></tr><tr><td>HOUR_MINUTE</td><td>小时和分</td><td>hh:mm</td></tr><tr><td>HOUR_SECOND</td><td>小时和秒</td><td>hh:ss</td></tr><tr><td>MINUTE_SECOND</td><td>分钟和秒</td><td>mm:ss</td></tr></tbody></table><h3 id="4-流程函数"><a href="#4-流程函数" class="headerlink" title="4.流程函数"></a>4.流程函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value,t f)</td><td>如果 value 是真，返回 t；否则返回 f</td></tr><tr><td>IFNULL(value1,value2)</td><td>如果 value1 不为空返回 value1，否则返回 value2</td></tr><tr><td>CASE WHEN [value1]  THEN[result1]…ELSE[default]END</td><td>如果 value1 是真，返回 result1，否则返回 default</td></tr><tr><td>CASE [expr] WHEN [value1]<br>THEN[result1]…ELSE[default]END</td><td>如果 expr 等于 value1，返回 result1，否则返回 default</td></tr></tbody></table><h3 id="5-其他函数"><a href="#5-其他函数" class="headerlink" title="5.其他函数"></a>5.其他函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>DATABASE()</td><td>返回当前数据库名</td></tr><tr><td>VERSION()</td><td>返回当前数据库版本</td></tr><tr><td>USER()</td><td>返回当前登录用户名</td></tr><tr><td>INET_ATON(IP)</td><td>返回 IP 地址的数字表示</td></tr><tr><td>INET_NTOA(num)</td><td>返回数字代表的 IP 地址</td></tr><tr><td>PASSWORD(str)</td><td>返回字符串 str 的加密版本</td></tr><tr><td>MD5()</td><td>返回字符串 str 的 MD5 值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL_基础</title>
      <link href="/2019/03/SQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/03/SQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><p>(1) DDL(Data Definition Languages):数据定义语言：不同的数据段、数据库、表、列、索引等数据库对象的定义（create、drop、alter）</p><p>(2)DML (Data Manipulation Language)：数据操纵语句：增删改查(inset、delete、select)</p><p>(3) DCL(Data Control Language) :数据控制语句：数据库、表、字段、用户的访问权限和安全级别。</p><a id="more"></a><h3 id="1-DDL数据定义语句"><a href="#1-DDL数据定义语句" class="headerlink" title="1.DDL数据定义语句"></a>1.DDL数据定义语句</h3><pre><code>对数据库内部的对象进行创建、删除、修改的操作语言。涉及表的定义，结构的修改。</code></pre><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><br><strong>CREATE DATABASE</strong> dbname<br><br></td><td>创建数据库</td></tr><tr><td><br><strong>SHOW databases/tables</strong><br><br></td><td>查看系统存在哪些数据库/数据表</td></tr><tr><td><br><strong>USE</strong> dbname<br><br></td><td>选择数据库</td></tr><tr><td><br><strong>DROP DATABASE</strong> dbname<br><br></td><td>删除数据库</td></tr><tr><td><br><strong>DROP TABLE</strong> tablename<br><br></td><td>删除表</td></tr><tr><td><br><strong>CREATE TABLE</strong> tablename <br> (<br> column_name_1 column_type_1 constraints，<br> column_name_2 column_type_2 constraints ， ……<br> column_name_n column_type_n<br> constraints<br> )<br><br></td><td>创建数据库</td></tr><tr><td><br><strong>DESC</strong> tablename<br><br></td><td>查看表定义</td></tr><tr><td><br><strong>SHOW CREATE TABLE</strong> tablename \G<br><br></td><td>查看更详细的表定义,\G表示使字段按照顺序竖着排列</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename<br>  <strong>MODIFY</strong> [COLUMN] column_definition<br> [FIRST &#124; AFTER col_name]<br><br></td><td>修改表类型</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename<br> <strong>ADD</strong> [COLUMN] column_definition<br> [FIRST &#124; AFTER col_name]<br><br></td><td>增加表字段</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename <br><strong>DROP</strong> [COLUMN] col_name<br><br></td><td>删除表字段</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename<br> <strong>CHANGE</strong> [COLUMN] old_col_name column_definition<br> [FIRST&#124;AFTER col_name]<br><br></td><td>字段改名</td></tr><tr><td><br><strong>ALTER TABLE</strong> tablename<br> <strong>RENAME</strong> [TO] new_tablename<br><br></td><td>表改名</td></tr></tbody></table><h3 id="2-DML数据操纵语句"><a href="#2-DML数据操纵语句" class="headerlink" title="2.DML数据操纵语句"></a>2.DML数据操纵语句</h3><pre><code>DML 操作是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select）</code></pre><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><br><strong>INSERT INTO</strong> tablename (field1,field2,……fieldn)<br> <strong>VALUES</strong>(value1,value2,……valuesn);<br><br></td><td>插入记录</td></tr><tr><td><br><strong>UPDATE</strong> tablename<br> <strong>SET</strong> field1=value1，field2.=value2，……fieldn=valuen<br> [WHERE CONDITION]<br><br></td><td>更新记录</td></tr><tr><td><br><strong>DELETE FROM</strong> tablename<br> [<strong>WHERE</strong> CONDITION]<br><br></td><td>删除记录</td></tr><tr><td><br><strong>SELECT * FROM</strong> tablename<br> [<strong>WHERE</strong> CONDITION]<br><br></td><td>查询记录</td></tr><tr><td><br><strong>SELECT DISTINCT</strong> column_name<br>  <strong>FROM</strong> tablename<br> [<strong>WHERE</strong> CONDITION]<br><br></td><td>查询不重复的记录</td></tr><tr><td><br><strong>SELECT * FROM</strong> tablename<br>   [<strong>WHERE</strong> CONDITION]<br> [<strong>ORDER BY</strong><br>        field1 [<strong>DESC &#124; ASC</strong>],<br>        field2[DESC &#124; ASC],<br>  ……fieldn [DESC&#124;ASC]<br> [<strong>LIMIT</strong> offset_start,row_count]<br><br></td><td>排序限制</td></tr><tr><td><br><strong>SELECT</strong> [field1,field2,……fieldn]  fun_name<br><strong>FROM</strong> tablename<br>[<strong>WHERE</strong> where_contition]<br>[<strong>GROUP BY</strong> field1,field2,……fieldn<br>[<strong>WITH ROLLUP</strong>]]<br>[<strong>HAVING</strong> where_contition]<br><br></td><td>聚合操作group by /having</td></tr><tr><td><br><strong>SELECT</strong> ename,deptname<br>  <strong>FROM</strong> dept<br><strong>RIGHT JOIN[LEFT JOIN]</strong> emp<br> <strong>ON</strong> dept.deptno=emp.deptno;<br><br></td><td>右连接right join 左连接left join</td></tr><tr><td><br><strong>in、not in、=、!=、exists、not exists</strong><br></td><td>子查询</td></tr><tr><td><br><strong>SELECT * FROM</strong> t1<br><strong>UNION&#124;UNION ALL</strong><br><strong>SELECT * FROM</strong> t2<br>……<br><strong>UNION&#124;UNION ALL</strong><br><strong>SELECT * FROM</strong> tn;<br><br></td><td>记录联合</td></tr></tbody></table><h3 id="3-DCL数据控制语句"><a href="#3-DCL数据控制语句" class="headerlink" title="3.DCL数据控制语句"></a>3.DCL数据控制语句</h3><pre><code>DCL 语句主要是 DBA 用来管理系统中的对象权限时所使用</code></pre><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><br><strong>grant select,insert</strong> <strong>on</strong><br> sakila.* <strong>to</strong><br> ‘z1‘@’localhost’ identified by ‘123’<br><br></td><td>创建一个数据库用户 z1，具有对 sakila 数据库中所有表的 SELECT/INSERT 权限</td></tr><tr><td><br><strong>revoke insert on</strong> sakila.* from ‘z1‘@’localhost’;<br><br></td><td>将z1 的权限变更，收回 INSERT，只能对数据进行 SELECT 操作</td></tr></tbody></table><h3 id="4-帮助的使用"><a href="#4-帮助的使用" class="headerlink" title="4.帮助的使用"></a>4.帮助的使用</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td><strong>？contents</strong></td><td>显示所有可供查询的的分类</td></tr><tr><td>？ data types</td><td>Mysql支持的数据类型</td></tr><tr><td>？ show</td><td>…</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h3 id="5-MYSQL支持的数据类型"><a href="#5-MYSQL支持的数据类型" class="headerlink" title="5.MYSQL支持的数据类型"></a>5.MYSQL支持的数据类型</h3><blockquote><p>(1)数值型</p><pre><code>整数：tinyint  smallint  mediumint  int/integer  bigint 浮点数：float  double 定点数：dec(m,d) decimal(m,d):m表示长度，d表示小数位数位：bit</code></pre><p>(2)字符串类型</p><pre><code>date  datetime  timestamp  time  year</code></pre><p>(3)日期和时间类型</p><pre><code>整数：char   varchar字节：tinyblob   blob   mediumblob   longblob  tinytext   text mediumtext   longtext   varbinary  binary</code></pre></blockquote><p><img src="https://github.com/qiulig/IMG/raw/master/sql数值型.png" alt="sql数值型类型"></p><p><img src="https://github.com/qiulig/IMG/raw/master/sql字符串类型.png" alt="sql字符串类型"></p><p><img src="https://github.com/qiulig/IMG/raw/master/sql日期和时间类型.png" alt="日期和时间类型"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sprintboot中的数据库注解</title>
      <link href="/2019/03/sprintboot%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/03/sprintboot%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@Results                 —-表字段与数据库字段映射</p><p>@Entity                    —- 生成表</p><p>@Transient              —-后台与数据库不映射</p><p>@Id                            —-主键</p><p>@Transactional        —-事务</p><a id="more"></a><p>@GeneratedValuestrategy=GenerationType.IDENTITY   —–自增值</p><p>@Table - 映射表名   —– 映射表名</p><p>@Column(name = “dict_name”,columnDefinition=”varchar(100) COMMENT ‘字典名’”)                           —– 字段名、类型、注释</p><p>@Select</p><p>@Update</p><p>@Delete</p><p>@Insert</p><p>@UpdateTimestamp  —— 更新时自动更新时间</p><p>@CreationTimestamp ——创建时自动更新时间</p><p>@Version                       —– 版本号，更新时自动加1</p><h5 id="1-Entity"><a href="#1-Entity" class="headerlink" title="1.@Entity"></a>1.@Entity</h5><p>@Entity说明这个class是实体类，并且使用默认的orm规则，即class名即数据库表中表名，class字段名即表中的字段名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDetail</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String detailId;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal productPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer productQuantity;</span><br><span class="line">    <span class="keyword">private</span> String productIcon;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span>  Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行将对应生成数据库表名为OrderDetail的表，里面字段对应上面的字段。</p><h5 id="2-DynamicUpdate"><a href="#2-DynamicUpdate" class="headerlink" title="2.@DynamicUpdate"></a>2.@DynamicUpdate</h5><p>动态更新表。</p><p>如果我们在更新表时,只想更新某个字段,就不要加 @DynamicUpdate,通常为了更新表时的效率,都是不加的.反之,如果我们更新某个字段时,更新所有的字段,就可以加上 @DynamicUpdate.</p><p>@DynamicUpdate属性:设置为true,设置为true,表示update对象的时候,生成动态的update语句,如果这个字段的值是null就不会被加入到update语句中,默认false。<br>比如只想更新某个属性，但是却把整个对象的属性都更新了，这并不是我们希望的结果，我们希望的结果是：我更改了哪些字段，只要更新我修改的字段就够了。</p><h5 id="3-Table"><a href="#3-Table" class="headerlink" title="3.@Table"></a>3.@Table</h5><p>@Table注解用来标识实体类与数据表的对应关系，默认和类名一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"c_user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Id</span></span><br><span class="line">        <span class="meta">@GeneratedValue</span></span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Column</span>(length = <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Column</span>(length = <span class="number">20</span> , unique = <span class="keyword">true</span>, nullable = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">private</span> Long mobile;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Column</span>(length = <span class="number">20</span> , unique = <span class="keyword">true</span>)</span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="meta">@Column</span>(columnDefinition=<span class="string">"tinyint"</span>)</span><br><span class="line">        <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickname;</span><br><span class="line">        <span class="keyword">private</span> Integer companyId;</span><br><span class="line">        <span class="keyword">private</span> Integer departmentId;</span><br><span class="line">        <span class="keyword">private</span> Date regTime;</span><br><span class="line">        <span class="keyword">private</span> String regIp;</span><br><span class="line">        <span class="keyword">private</span> Integer loginNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-Column"><a href="#4-Column" class="headerlink" title="4. @Column"></a>4. @Column</h5><p>@Column注解来标识实体类中属性与数据表中字段的对应关系。共有10个属性，这10个属性均为可选属性：</p><ul><li>name属性定义了被标注字段在数据库表中所对应字段的名称；</li><li>unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。</li><li>nullable属性表示该字段是否可以为null值，默认为true。如果属性里使用了验证类里的@NotNull注释，这个属性可以不写。</li><li>insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。</li><li>updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。</li><li>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。若不指定该属性，通常使用默认的类型建表，若此时需要自定义建表的类型时，可在该属性中设置。（也就是说，如果DB中表已经建好，该属性没有必要使用。）</li><li>table属性定义了包含当前字段的表名。</li><li>length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。</li><li>precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。</li></ul><h5 id="5-Transactional-事务"><a href="#5-Transactional-事务" class="headerlink" title="5.@Transactional 事务"></a>5.@Transactional 事务</h5><h5 id="Transactional-注解的属性信息"><a href="#Transactional-注解的属性信息" class="headerlink" title="@Transactional 注解的属性信息"></a>@Transactional 注解的属性信息</h5><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td></tr><tr><td>propagation</td><td>事务的传播行为，默认值为 REQUIRED。</td></tr><tr><td>isolation</td><td>事务的隔离度，默认值采用 DEFAULT。</td></tr><tr><td>timeout</td><td>事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td>read-only</td><td>指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td></tr><tr><td>rollback-for</td><td>用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td></tr><tr><td>no-rollback- for</td><td>抛出 no-rollback-for 指定的异常类型，不回滚事务。</td></tr></tbody></table><h5 id="6-Transient"><a href="#6-Transient" class="headerlink" title="6.@Transient"></a>6.@Transient</h5><p>@Transient是希望该属性不会在数据表中产生字段，但又可以在程序中使用它。</p><h5 id="7-Results"><a href="#7-Results" class="headerlink" title="7.@Results"></a>7.@Results</h5><p>(1)当数据库字段名与实体类对应的属性名不一致时，可以使用@Results映射来将其对应起来。column为数据库字段名，porperty为实体类属性名，jdbcType为数据库字段数据类型，id为是否为主键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>(2)@ResultMap的用法。当这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student where id = #&#123;id&#125;"</span>&#125;)</span><br><span class="line"><span class="meta">@ResultMap</span>(value=<span class="string">"studentMap"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">selectById</span><span class="params">(integer id)</span></span>;</span><br></pre></td></tr></table></figure><p>(3)@One的用法。当我们需要通过查询到的一个字段值作为参数，去执行另外一个方法来查询关联的内容，而且两者是一对一关系时，可以使用@One注解来便捷的实现。比如当我们需要查询学生信息以及其所属班级信息时，需要以查询到的class_id为参数，来执行ClassesMapper中的selectById方法，从而获得学生所属的班级信息。可以使用如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Select(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"myClass"</span>, javaType=MyClass.class,</span><br><span class="line"> one=<span class="meta">@One</span>(select=<span class="string">"com.mapper.MyClassMapper.selectById"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAllAndClassMsg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>（4）@Many的用法。与@One类似，只不过如果使用@One查询到的结果是多行，会抛出TooManyResultException异常，这种时候应该使用的是@Many注解，实现一对多的查询。比如在需要查询学生信息和每次考试的成绩信息时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"gradeList"</span>, javaType=List.class,</span><br><span class="line"> many=<span class="meta">@Many</span>(select=<span class="string">"com.example.demo.mapper.GradeMapper.selectByStudentId"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAllAndGrade</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>（5）传递多个参数。首先我们给这张表增加age（年龄）和gender（性别）两个参数。当我们需要根据age和gender查询学生的午餐，这时需要改写column属性的格式。等号左侧的age和gender对应java接口的参数，右侧的对应数据库字段名。即将查到的my_student表中age和gender字段的值，分别赋给getLunchByAgeAndGender方法中的age和gender参数，去查询对应的name（午餐名）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select id, name, age, gender from my_student"</span>)</span><br><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER),</span><br><span class="line"> <span class="meta">@Result</span>(column=<span class="string">"&#123;age=age,gender=gender&#125;"</span>, property=<span class="string">"lunch"</span>,</span><br><span class="line"> one=<span class="meta">@One</span>(select=<span class="string">"com.example.demo.mapper.StudentMapper.getLunchByAgeAndGender"</span>)),</span><br><span class="line"> &#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAllAndLunch</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select name from lunch where student_age = #&#123;age&#125; and student_gender = #&#123;gender&#125;"</span>)</span><br><span class="line"><span class="function">String <span class="title">getLunchByAgeAndGender</span><span class="params">(@Param(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age, @<span class="title">Param</span><span class="params">(<span class="string">"gender"</span>)</span> <span class="keyword">int</span> gender)</span>;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis_数据的持久化</title>
      <link href="/2019/03/redis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2019/03/redis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><a id="more"></a><h5 id="1-RDB-持久化"><a href="#1-RDB-持久化" class="headerlink" title="1.RDB 持久化"></a>1.RDB 持久化</h5><p>RDB是redis默认的持久化机制。RDB相当于快照，保存的是一种状态。默认文件名是dump.rdb。</p><blockquote><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p></blockquote><h5 id="2-AOF-持久化"><a href="#2-AOF-持久化" class="headerlink" title="2.AOF 持久化"></a>2.AOF 持久化</h5><p>由于快照方式是在一定时间间隔内做一次，所以如果redis意外down掉，就会丢失最后一次快照所有的修改，如果应用要求不能丢失任何修改的话，可以采用AOF。</p><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table><thead><tr><th>选项</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个写命令都同步</td></tr><tr><td>everysec</td><td>每秒同步一次</td></tr><tr><td>no</td><td>让操作系统来决定何时同步</td></tr></tbody></table><p>always 选项会严重减低服务器的性能；</p><p>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</p><p>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</p><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis.数据的淘汰机制</title>
      <link href="/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis 具体有 6 种淘汰策略：<a id="more"></a></p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td>allkeys-lru</td><td>从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据集中任意选择数据进行淘汰</td></tr><tr><td>noeviction</td><td>禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis与memcached</title>
      <link href="/2019/03/redis%E4%B8%8Ememcached/"/>
      <url>/2019/03/redis%E4%B8%8Ememcached/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Memcached介绍"><a href="#Memcached介绍" class="headerlink" title="Memcached介绍"></a>Memcached介绍</h3><p>Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。<a id="more"></a></p><p>memcached作为高速运行的分布式缓存服务器，具有以下的特点。</p><ul><li>协议简单</li><li>基于libevent的事件处理</li><li>内置内存存储方式</li><li>memcached不互相通信的分布式</li></ul><p>与数据库协同合作的过程：</p><blockquote><p>   1.检查用户请求的数据是缓存中是否有存在，如果有存在的话，只需要直接把请求的数据返回，无需查询数据库. </p><p>2.如果请求的数据在缓存中找不到，这时候再去查询数据库。返回请求数据的同时，把数据存储到缓存中一份。<br>   3.保持缓存的“新鲜性”，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据.</p></blockquote><h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。</p><p>区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。</p><p>Redis作为一个高性能的key-value数据库具有以下特征：  </p><ul><li>多样的数据模型</li><li>持久化</li><li>基于内存存储方式</li><li>主从同步</li></ul><p><strong>综合结论</strong></p><p>应该说Memcached和Redis都能很好的满足解决我们的问题，它们性能都很高，总的来说，可以把Redis理解为是对Memcached的拓展，是更加重量级的实现，提供了更多更强大的功能。</p><p>两者都是非关系型内存键值数据库，主要有以下不同：</p><h3 id="Memcached与redis区别"><a href="#Memcached与redis区别" class="headerlink" title="Memcached与redis区别"></a>Memcached与redis区别</h3><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h4><blockquote><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p></blockquote><h5 id="2-数据持久化"><a href="#2-数据持久化" class="headerlink" title="2.数据持久化"></a>2.数据持久化</h5><blockquote><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p></blockquote><h5 id="3-分布式"><a href="#3-分布式" class="headerlink" title="3.分布式"></a>3.分布式</h5><blockquote><p>Memcached 不支持分布式，只能通过在<strong>客户端</strong>使用<strong>一致性哈希</strong>来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis则在<strong>服务器端</strong>构建分布式存储。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，各个节点地位一致，具有线性可伸缩的功能。其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个 key的数值域分成16384个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是16384。</p></blockquote><h5 id="4-内存管理机制"><a href="#4-内存管理机制" class="headerlink" title="4.内存管理机制"></a>4.内存管理机制</h5><blockquote><p>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p><p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，这样能保证数据的持久性。而 Memcached 的数据则会一直在内存中(断电会挂掉，数据不能超过内存)。</p></blockquote><h5 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5.应用场景"></a>5.应用场景</h5><blockquote><p>Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息)</p><p>Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据类型</title>
      <link href="/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/03/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型<a id="more"></a></h3><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作</td></tr><tr><td>对整数和浮点数执行自增或者自减操作</td><td></td><td></td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素</td></tr><tr><td>对单个或者多个元素</td><td></td><td></td></tr><tr><td>进行修剪，只保留一个范围内的元素</td><td></td><td></td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素</td></tr><tr><td>检查一个元素是否存在于集合中</td><td></td><td></td></tr><tr><td>计算交集、并集、差集</td><td></td><td></td></tr><tr><td>从集合里面随机获取元素</td><td></td><td></td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对</td></tr><tr><td>获取所有键值对</td><td></td><td></td></tr><tr><td>检查某个键是否存在</td><td></td><td></td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素</td></tr><tr><td>根据分值范围或者成员来获取元素</td><td></td><td></td></tr><tr><td>计算一个键的排名</td><td></td><td>What Redis data structures look like</td></tr></tbody></table><h3 id="1-1Redis的键Key"><a href="#1-1Redis的键Key" class="headerlink" title="1.1Redis的键Key"></a>1.1Redis的键Key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; DEL key            删除键</span><br><span class="line">&gt; EXISTS key         判断key是否存在</span><br><span class="line">&gt; DUMP key           序列化key</span><br><span class="line">&gt; EXPIRE key seconds 给key设置过期时间</span><br><span class="line">&gt; TTL key            key的生存剩余时间（秒为单位）</span><br><span class="line">&gt; PTTL key           key的生存剩余时间(毫秒单位)</span><br><span class="line">&gt; PERSIST key        移除key的过期时间，将持久保留</span><br><span class="line">&gt; KEYS pattern       查找所有符合给定模式的key(* 所有 ？一个字符)</span><br><span class="line">&gt; RANDOM key         从当前数据库随机返回一个key</span><br><span class="line">&gt; RENAME key newkey  修改key名称</span><br><span class="line">&gt; MOVE key db        当前数据库移动到给定数据库中</span><br></pre></td></tr></table></figure><h5 id="key的应用场景"><a href="#key的应用场景" class="headerlink" title="key的应用场景"></a>key的应用场景</h5><blockquote><p>(1)限时的活动信息</p><p>(2)网站的数据缓存(对于一些要定时更新的数据如积分排行榜)</p><p>(3)手机验证码</p><p>(4)限制网站的访问频率</p></blockquote><h3 id="1-2-Redis的值value"><a href="#1-2-Redis的值value" class="headerlink" title="1.2 Redis的值value"></a>1.2 Redis的值value</h3><h3 id="1-2-1-String类型"><a href="#1-2-1-String类型" class="headerlink" title="1.2.1 String类型"></a>1.2.1 String类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET key_name value       设置给定key的值(key存在则覆盖，不存在则新建)</span><br><span class="line">&gt; SETNX key_name value     设置给定key的值(key不存在时)</span><br><span class="line">&gt; GET key_name             取值</span><br><span class="line">&gt; GETRANGE key start end   字符串截取</span><br><span class="line">&gt; GETBIT key offset        对key所存储的字符串值，获取指定偏移量上的位</span><br><span class="line">&gt; MGET key1 [key2..]       获取一个或多个key的值</span><br><span class="line">&gt; GETSET key_name value    设置key值，并返回key的旧值</span><br><span class="line">&gt; STRLEN key               获取长度</span><br><span class="line">&gt; DEL key_name             删除</span><br><span class="line">&gt; INCR key_name            自增</span><br><span class="line">&gt; DECR key_name            自减 </span><br><span class="line">&gt; APPEND key_name value    字符串拼接</span><br></pre></td></tr></table></figure><h5 id="string应用场景"><a href="#string应用场景" class="headerlink" title="string应用场景"></a>string应用场景</h5><blockquote><p>1.String通常用于<strong>保存单个字符串或JSON字符串数据</strong></p><p>2.因string是二进制安全的，所以你完全可以把一个<strong>图片文件</strong>的内容作为字符串来<strong>存储</strong></p><p>3.<strong>计数器</strong>(常规key-value缓存应用。(常规计数:微博数,粉丝数)</p><p>INCR等指令本身就具有<strong>原子操作</strong>的特性,所以我们完全可以利用redis的INCR.INCRBY.DECR，DECRBY等指令来实现原子计数的效果。不少网站都利用redis的这个特性来<strong>实现业务上的统计计数需求</strong>。</p></blockquote><h3 id="1-2-2-List类型"><a href="#1-2-2-List类型" class="headerlink" title="1.2.2 List类型"></a>1.2.2 List类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; LPUSH key value1[value2]  将一个或多个值插入列表头部</span><br><span class="line">&gt; RPUSH key value1[value2]  将一个或多个值插入列表尾部</span><br><span class="line">&gt; LPUSHX key value          将一个或多个值插入列表头部，列表不存在则操作无效             </span><br><span class="line">&gt; RPUSHX key value          将一个或多个值插入列表尾部，列表不存在则操作无效</span><br><span class="line">&gt; LLEN key                  获取列表长度</span><br><span class="line">&gt; LINDEX key index          通过索引获取列表元素</span><br><span class="line">&gt; LRANGE key start stop     获取列表指定范围内的元素</span><br><span class="line">&gt; LPOP key                  左移除</span><br><span class="line">&gt; RPOP key                  右移除</span><br><span class="line">&gt; BLPOP key1[key2] timeout  移除并获取列表的第一个元素，没有元素就会阻塞队列    </span><br><span class="line">                            直到等待超时或发现可弹出元素</span><br></pre></td></tr></table></figure><h5 id="list应用场景"><a href="#list应用场景" class="headerlink" title="list应用场景"></a>list应用场景</h5><blockquote><p>1、<strong>对数据量大的集合数据删减 </strong></p><p>列表数据显示<strong>关注列表、粉丝列表、留言评价等. .分页、热点新闻(Top5)等</strong> 利用LRANGE还可以很方便的实现分页的功能,在博客系统中，每片博文的评论也可以用到。</p><p>2、<strong>任务队列 </strong></p><p>(list通常用来实现一个消息队列,而且可以确保先后顺序,不必像MySQL那样还需要通过ORDERBY来进行排序)</p><p>任务队列介绍(生产者和消费者模式):</p><p>在处理Web客户端发送的命令请求时,某些操作的执行时间可能会比我们预期的更长一些，通过将待执行任务的相关信息放入队列里面，并在之后对队列进行处理,用户可以推迟执行那些需要一段时间才能能完成的操作,这种将工作交给任务处理器来执行的做法被称为任务队列(task queue)。</p><p><strong>RPOPLPUSH source destination </strong></p><p>移除列表的最后一个元素，并将该元素添加到另一个列表并返回示例描述:</p><p>常用案例:订单系统的下单流程、用户系统登录注册短信等</p></blockquote><h3 id="1-2-3-Hash类型"><a href="#1-2-3-Hash类型" class="headerlink" title="1.2.3 Hash类型"></a>1.2.3 Hash类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; HSET key field value                 为指定的key,设定field/value</span><br><span class="line">&gt; HMSET key field value[field1,value]  同时将多个field-value 设到key中</span><br><span class="line">&gt; HGET key field                       根据field等待value </span><br><span class="line">&gt; HMGET key field[field1]              获取key所有给定字段的值</span><br><span class="line">&gt; HGETALL key                          返回hash表所有字段和值</span><br><span class="line">&gt; HKEYS key                            获取哈希表中的字段</span><br><span class="line">&gt; HLEN key                             获取哈希表中字段的数量</span><br><span class="line">&gt; HDEL key field[field2]               删除一个或多个hash表字段</span><br><span class="line">&gt; HSETNX key field value               只有在字段不存在时，设置字段值</span><br><span class="line">&gt; HINCRBY key field increment          key中指定字段的整数值加增量</span><br><span class="line">&gt; HINCRBYFLOAT key field increment     指定字段的浮点数加增量</span><br><span class="line">&gt; HEXISTS key field                    指定字段是否存在</span><br></pre></td></tr></table></figure><h5 id="hash应用场景"><a href="#hash应用场景" class="headerlink" title="hash应用场景"></a>hash应用场景</h5><blockquote><p>Hash的应用场景:(存储个用户信息对象数据)</p><p>1、 <strong>常用于存储一个对象 </strong></p><p>2、 <strong>为什么不用string存储一个对象? </strong></p><p>hash是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。</p><p>用户ID为查找的key,存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式:</p><p><code>(1)用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时, 需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</code></p><p><code>(2)这个用户信息对象有多少成员就存成多少个key-value对,用用户ID+对应属性的名称作为唯一标识来取得对应属性的值,虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是不可观的。</code></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><p>Redis提供的Hash很好的解决了这个问题，Redis 的Hash实际是内部存储的Value为一个Hashmap,并提供了直接存取这个Map成员的接口</p></blockquote><h3 id="1-2-4-Set类型"><a href="#1-2-4-Set类型" class="headerlink" title="1.2.4 Set类型"></a>1.2.4 Set类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">赋值语句</span><br><span class="line">&gt; SADD key member1[member2]        添加一个或多个成员</span><br><span class="line">取值语句</span><br><span class="line">&gt; SCARD key                           获取成员数</span><br><span class="line">&gt; SMEMBERS key                        返回集合中的所有成员</span><br><span class="line">&gt; SISMEMBER key member                判断是否存在</span><br><span class="line">&gt; SRANDMEMBER key [count]             返回集合中一个或多个随机数</span><br><span class="line">删除语句</span><br><span class="line">&gt; SREM key member                     移除一个或多个</span><br><span class="line">&gt; SPOP key[count]                     移除并返回集合中的一个随机元素</span><br><span class="line">&gt; SMOVE source destination member     将member从source移到destination</span><br><span class="line">差集语句</span><br><span class="line">&gt; SDIFF key1[key2]                    返回给定集合的差集(左侧)</span><br><span class="line">&gt; SDIFFSTORE destination key1[key2]   返回差集并存到destina.</span><br><span class="line">交集语句</span><br><span class="line">&gt; SINTER key1 [key2]                  返回给定集合的交集</span><br><span class="line">&gt; SINTERSTORE destination key1[key2]  返回交集并存到destination</span><br><span class="line">并集</span><br><span class="line">&gt; SUNION key1[key2]                    返回并集</span><br><span class="line">&gt; SUNIONSTORE destination key1[key2]  返回并集并存储在destination</span><br></pre></td></tr></table></figure><h5 id="set应用场景"><a href="#set应用场景" class="headerlink" title="set应用场景"></a>set应用场景</h5><blockquote><p>常应用于:对两个集合间的数据[计算]进行交集、并集、差集运算</p><p><code>1、以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作,你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。</code></p><p><code>2、利用唯一性，可以统计访问网站的所有独立IP</code></p></blockquote><h3 id="1-2-5-Zset类型"><a href="#1-2-5-Zset类型" class="headerlink" title="1.2.5 Zset类型"></a>1.2.5 Zset类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">赋值语句</span><br><span class="line">&gt; ZADD key score1 member1[score member2]  添加一个或多个成员</span><br><span class="line">取值语句</span><br><span class="line">&gt; ZCARD key                               获取成员数</span><br><span class="line">&gt; ZCOUNT key min max                      计算集合中指定区间分数的成员数</span><br><span class="line">&gt; ZRANK key member                        返回有序集合中指定成员索引</span><br><span class="line">&gt; ZRANGE key start stop[WITHSCORES]       返回指定区间内成员[低到高]</span><br><span class="line">&gt; ZREVRANGE key start stop[WITHSCORES]    返回指定区间内成员[高到低]</span><br><span class="line">删除语句</span><br><span class="line">&gt; ZREM key member[member...]              移除有序集合中的一个或多个成员</span><br></pre></td></tr></table></figure><h5 id="Zset应用场景"><a href="#Zset应用场景" class="headerlink" title="Zset应用场景"></a>Zset应用场景</h5><blockquote><p>常应用于:<code>排行榜</code></p><p>1)比如twitter的public timeline可以以发表时间作为score来存储,这样获取时就是自动按时间排好序的。</p><p>2)比如一个存储全班同学成绩的Sorted Set, 其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。</p><p>3还可以用Sorted Set来做带权重的队列，比如普通消息的score为1,重要消息的score为2,然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis应用场景</title>
      <link href="/2019/03/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/03/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.概述</p><blockquote><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。<a id="more"></a></p></blockquote><blockquote><p><strong>键(key)</strong>的类型只能为<strong>字符串(String)</strong>，<strong>值(value)</strong>支持五种数据类型：<strong>字符串(String)、列表(list)、集合(set)、有序集合(zset)、哈希(hash)。</strong></p></blockquote><blockquote><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p></blockquote><h5 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h5><blockquote><p>（1）<strong>缓存</strong>：Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；</p><p>（2）<strong>排行榜</strong>：利用Redis的SortSet数据结构能够非常方便搞定；</p><p>（3）<strong>计算器/限速器</strong>：利用Redis中<strong>原子性的自增操作</strong>，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有<strong>抢购</strong>时，防止用户疯狂点击带来不必要的压力；</p><p>注：限速器也是对请求限流的一种实现方式。</p><p>（4）<strong>好友关系</strong>：利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；</p><p>（5）<strong>简单消息队列</strong>：除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；不过最好用kafka、RabbitMQ等消息中间件。</p><p>（6）<strong>Session共享</strong>：默认Session是保存在服务器的文件中，即当前服务器，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。</p></blockquote><h5 id="Redis优点："><a href="#Redis优点：" class="headerlink" title="Redis优点："></a>Redis优点：</h5><blockquote><ul><li>速度快，完全基于内存；</li><li>使用C语言实现，网络层使用epoll解决高并发问题；</li><li>单线程模型避免了不必要的上下文切换及竞争条件；</li></ul></blockquote><h5 id="Redis的缺点："><a href="#Redis的缺点：" class="headerlink" title="Redis的缺点："></a>Redis的缺点：</h5><blockquote><p>滥用可能导致系统的不稳定、成本增高等问题。</p><p>比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。</p><p>简单总结就是<strong>数据量太大、数据访问频率非常低的业务都不适合使用Redis</strong>。数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。如果不担心浪费资源，那请忽略。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
