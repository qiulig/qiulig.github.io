<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[rabbitMQ实现消息缓冲]]></title>
    <url>%2F2019%2F05%2F15%2FrabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[RabbitMQ主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是AMQP协议，它是一种二进制协议。默认启动端口5672 rabbitMQ的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，生产者producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。 Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key, 根据key全文匹配去寻找队列 Topic：按规则转发消息（最灵活）转发消息主要是根据通配符 Headers：设置 header attribute 参数类型的交换机 Fanout：转发消息到所有绑定队列(广播方式) 下面介绍4种交换机与springboot的集成添加依赖包amqp,统一配置application.properties 123456&lt;!--rabbitMQ依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 12345678910111213141516171819##rabbitMQspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/#消费者数量spring.rabbitmq.listener.simple.concurrency= 10spring.rabbitmq.listener.simple.max-concurrency= 10#消费者每次从队列获取的消息数量spring.rabbitmq.listener.simple.prefetch= 1#消费者自动启动spring.rabbitmq.listener.simple.auto-startup=true#消费失败，自动重新入队spring.rabbitmq.listener.simple.default-requeue-rejected= true#启用发送重试spring.rabbitmq.template.retry.enabled=true spring.rabbitmq.template.retry.initial-interval=1000spring.rabbitmq.template.retry.max-attempts=3 1. Direct交换机制 一个队列会和一个交换机绑定，除此之外再绑定一个routing_key，当消息被发送的时候，需要指定一个binding_key，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个binding_key也是支持应用到多个队列中的。 这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。 1.1 编写config12345678910@Configurationpublic class MQconfig &#123; public static final String QUEUE ="queue"; @Bean public Queue queue()&#123; return new Queue(QUEUE,true); &#125; &#125; 1.2 创建消息发送者1234567891011121314@Servicepublic class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); public void send(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.Queue,message); &#125;&#125; 1.3 创建消息接收者12345678910@Servicepublic class MQreceiver &#123; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); //监听了queue的队列 @RabbitListener(queues = MQconfig.Queue) public void receive(String message)&#123; log.info("receive message"+message); &#125;&#125; 1.4 编写controller测试123456789101112@Controllerpublic class HelloController &#123; @Autowired MQsender sender; @RequestMapping("/mq") @ResponseBody public Result&lt;Boolean&gt; mq()&#123; sender.send("hello"); return Result.success(true); &#125; &#125; 2. Fanout交换机制 扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。 2.1 编写config1234567891011121314151617181920@Configuration public class MQconfig &#123; public static final String FANOUT_EXCHANGE ="fanoutxchage"; @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE); &#125; @Bean public Binding fanoutBinding()&#123; return BindingBuilder.bind(topticQueue2()).to(fanoutExchange()); &#125; 2.2 创建消息发送者12345678910111213@Service public class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; public void sendFanout(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.FANOUT_EXCHANGE,"",msg); &#125;&#125; 2.3 创建消息接收者1234@Service public class MQreceiver &#123; //fanout 广播模式都接受故不需要listener &#125; 2.4 编写controller测试123456789@Controller public class HelloController &#123; @RequestMapping("/mq/fanout") @ResponseBody public Result&lt;String&gt; fanout()&#123; sender.sendFanout("hellommxx"); return Result.success("hello xuanzi");&#125; &#125; 3. topic交换机制 通配符交换机，exchange会把消息发送到一个或者多个满足通配符规则的routing-key的queue。其中表号匹配一个word，#匹配多个word和路径，路径之间通过.隔开。如满足a..c的routing-key有a.hello.c；满足#.hello的routing-key有a.b.c.helo。 1.1 编写config1234567891011121314151617181920212223242526272829@Configuration public class MQconfig &#123; public static final String TOPIC_QUEUE1 ="topic.queue1"; public static final String TOPIC_QUEUE2 ="topic.queue2"; public static final String TOPIC_EXCHANGE ="topicExchange" @Bean public Queue topticQueue1()&#123; return new Queue(TOPIC_QUEUE1,true); &#125; @Bean public Queue topicQueue2()&#123; return new Queue(TOPIC_QUEUE2,true); &#125; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; @Bean public Binding topicBinding1()&#123; return BindingBuilder.bind(topticQueue1()).to(topicExchange()).with("topic.key1"); &#125; @Bean public Binding topicBinding2()&#123; return BindingBuilder.bind(topticQueue2()).to(topicExchange()).with("topic.#"); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendTopic(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key1",msg+"1"); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key2",msg+"2");&#125;&#125; 1.3 创建消息接收者12345678910111213@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.TOPIC_QUEUE1) public void receiveTopic1(String message)&#123; log.info("receive topic queue1 message"+message); &#125; @RabbitListener(queues = MQconfig.TOPIC_QUEUE2) public void receiveTopic2(String message)&#123; log.info("receive topic queue2 message"+message); &#125; &#125; 1.4 编写controller测试12345678@Controller public class HelloController &#123; @RequestMapping("/mq/topic") @ResponseBody public Result&lt;String&gt; topic()&#123; sender.sendTopic("hellommxx"); return Result.success("hello xuanzi"); &#125; 4. header交换机制 header exchange(头交换机)和主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据。主题交换机路由键只有是字符串,而头交换机可以是整型和哈希值 1.1 编写config123456789101112131415161718192021222324252627282930313233343536@Configuration public class MQconfig &#123; public static final String HEADER_QUEUE ="header.queue"; @Bean public HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE); &#125; @Bean public Queue headerQueue()&#123; return new Queue(HEADER_QUEUE,true); &#125; @Bean public Binding headerBinding()&#123; Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); map.put("header1","value1"); map.put("header2","value2"); return BindingBuilder.bind(headerQueue()).to(headersExchange()) .whereAll(map).match(); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendheader(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); MessageProperties properties = new MessageProperties(); properties.setHeader("header1","value1"); properties.setHeader("header2","value2"); Message obj = new Message(msg.getBytes(),properties); amqpTemplate.convertAndSend(MQconfig.HEADERS_EXCHANGE,"",obj); &#125;&#125; 1.3 创建消息接收者123456789@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.HEADER_QUEUE) public void receiveHeader(byte[] message)&#123; log.info("receive header queue message"+message); &#125; &#125; 1.4 编写controller测试12345678910111213@Controller public class HelloController &#123; @RequestMapping("/mq/header") @ResponseBody public Result&lt;String&gt; header()&#123; sender.sendheader("hellommxx"); return Result.success("hello xuanzi"); &#125; &#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F15%2F%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key%2F</url>
    <content type="text"><![CDATA[123title: 通用缓存keytags: 秒杀category: 秒杀 通用缓存key的作用当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。方法：利用一个前缀来规定不同模块的缓存的key,这样不同模块之间就不会重复。 通用缓存key采用模板模式：接口-&gt;抽象类-&gt;实现类 1. 接口12345678public interface KeyPrefix &#123; //过期时间 public int expireSeconds(); //前缀 public String getPrefix();&#125; 2. 抽象类1234567891011121314151617181920212223242526272829public abstract class BasePrefix implements KeyPrefix&#123; private int expireSeconds; private String prefix; //无过期时间的构造函数 public BasePrefix(String prefix) &#123; this(0, prefix); &#125; //含有过期时间的构造函数 public BasePrefix( int expireSeconds, String prefix) &#123; this.expireSeconds = expireSeconds; this.prefix = prefix; &#125; public int expireSeconds() &#123; return expireSeconds; &#125; //获取前缀，前缀为 className：prefix public String getPrefix() &#123; String className = getClass().getSimpleName(); return className+":" + prefix; &#125;&#125; 3. 实现类12345678910public class MiaoshaKey extends BasePrefix&#123; //继承父类的无过期时间的构造函数 public MiaoshaKey(String prefix) &#123; super(prefix); &#125; //设置她这个类的前缀是className:go public static MiaoshaKey isGoodsOver = new MiaoshaKey("go");&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis缓存java端实现]]></title>
    <url>%2F2019%2F05%2F15%2FRedis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1. 引入redis依赖1234&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; 2.在application.properties添加redis配置文件12345678#redisredis.host=127.0.0.1redis.port=6379redis.timeout=3redis.password=2966redis.poolMaxTotal=10 //资源池中最大连接数redis.poolMaxIdle=10 //允许的最大空闲的连接数redis.poolMaxWait=3 3.定义redis的类，引入redis的配置12345678910111213@Component@ConfigurationProperties(prefix="redis")@Datapublic class RedisConfig &#123; private String host; private int port; private int timeout;//秒 private String password; private int poolMaxTotal; private int poolMaxIdle; private int poolMaxWait;//秒&#125; 4.RedisPoolFactory类，用于返回一个redis池12345678910111213141516171819202122232425262728@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisPoolFactory() &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); //允许最大空闲的连接数 poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); //资源池中最大连接数 poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); //最大等待毫秒数 poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(), redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125;&#125; 5.编写RedisService类12345678910111213141516@Servicepublic class RedisService &#123; @Autowired JedisPool jedisPool; //里面编写redis操作：增删改查 private void returnToPool(Jedis jedis) &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125;&#125; 5.1 获取单个对象(get)1234567891011121314151617181920212223242526272829303132333435363738//相当于redis里面的get key public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key,之前设置通用缓存key时的key设为className:key String realKey = prefix.getPrefix() + key; //跟redis里面的获取一个key操作一致 String str = jedis.get(realKey); //将结果转换成一个java对象 T t = stringToBean(str, clazz); return t; &#125;finally &#123; //关闭池资源 returnToPool(jedis); &#125; &#125;//json转换为java对象public static &lt;T&gt; T stringToBean(String str, Class&lt;T&gt; clazz) &#123; if(str == null || str.length() &lt;= 0 || clazz == null) &#123; return null; &#125; //判断类型 if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(str); &#125;else if(clazz == String.class) &#123; return (T)str; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(str); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(str), clazz); &#125; &#125; 5.2 设置对象(set)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//相当于redis里面的set key valuepublic &lt;T&gt; boolean set(KeyPrefix prefix, String key, T value) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //对象转换为json字符串 String str = beanToString(value); if(str == null || str.length() &lt;= 0) &#123; return false; &#125; //生成真正的key String realKey = prefix.getPrefix() + key; //获取过期时间 int seconds = prefix.expireSeconds(); if(seconds &lt;= 0) &#123; //永久有效，无过期时间 jedis.set(realKey, str); &#125;else &#123; //为指定的 key 设置值及其过期时间。 jedis.setex(realKey, seconds, str); &#125; return true; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //将对象转化为Json字符串 public static &lt;T&gt; String beanToString(T value) &#123; if(value == null) &#123; return null; &#125; Class&lt;?&gt; clazz = value.getClass(); if(clazz == int.class || clazz == Integer.class) &#123; return ""+value; &#125;else if(clazz == String.class) &#123; return (String)value; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; 5.3 判断key是否存在(exists)123456789101112//想当于redis里面的 exists keypublic &lt;T&gt; boolean exists(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.exists(realKey); &#125;finally &#123; returnToPool(jedis); &#125;&#125; 5.4 增加值(incr)123456789101112//相当于redis里面的incr key_namepublic &lt;T&gt; Long incr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.5 减少值(decr)123456789101112//相当于redis里面的decr key_namepublic &lt;T&gt; Long decr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.6 删除(del)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//相当于redis里面的del key_name //已知key public boolean delete(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; long ret = jedis.del(realKey); return ret &gt; 0; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //通过正则匹配删除 某key public boolean delete(KeyPrefix prefix) &#123; if(prefix == null) &#123; return false; &#125; List&lt;String&gt; keys = scanKeys(prefix.getPrefix()); if(keys==null || keys.size() &lt;= 0) &#123; return true; &#125; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.del(keys.toArray(new String[0])); return true; &#125; catch (final Exception e) &#123; e.printStackTrace(); return false; &#125; finally &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125; &#125; public List&lt;String&gt; scanKeys(String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); List&lt;String&gt; keys = new ArrayList&lt;String&gt;(); String cursor = "0"; //scan搜索 ScanParams sp = new ScanParams(); sp.match("*"+key+"*"); //设置scan的个数 sp.count(100); do&#123; ScanResult&lt;String&gt; ret = jedis.scan(cursor, sp); //返回结果 List&lt;String&gt; result = ret.getResult(); if(result!=null &amp;&amp; result.size() &gt; 0)&#123; //搜索的结果存入list keys.addAll(result); &#125; //再处理cursor，用于返回下次遍历的游标 cursor = ret.getStringCursor(); &#125;while(!cursor.equals("0")); return keys; &#125; finally &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125; &#125; 6.controller层测试123456789101112131415161718@AutowiredRedisService redisService;@RequestMapping("/redis/get")@ResponseBodypublic Result&lt;User&gt; getRedis()&#123; User user = redisService.get(UserKey.getById,"key1",User.class); return Result.success(user);&#125;@RequestMapping("/redis/set")@ResponseBodypublic Result&lt;Boolean&gt; setRedis()&#123; User user = new User(); user.setId(1); user.setName("1111"); redisService.set(UserKey.getById,""+1,user); return Result.success(true);&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[争吵问题.md]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md%2F</url>
    <content type="text"><![CDATA[1. 题目描述有一个队列，每个人要么朝左边（L表示）,要么朝右边(R表示)，因为每个人都讨厌其他任何人，只要两人面对面就会发生争吵。争吵结果是胜者留在队列中，败的人移除队中。 如果序列中有多对争吵，可以任选一对，胜者留在队中，败者出局，求最后队列最少人数是多少。 例子： LRRLRL 输出：2 Hint 一种可能的变化情况是：LRRLRL -&gt; LRLRL -&gt; LRRL -&gt; LRL -&gt; LR 2.解题思路由题意可知，如果真的吵架就只有RL（两人面对面）情况，像LL,RR,LR就不会争吵。 如果吵架前面是R，则吵架结果应该是L胜利. 如果吵架前面是L，则吵架结果为R胜利 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.List;public class test &#123; public static void main(String[] args) &#123; String arr ="LRRLRL"; String res = solut(arr); System.out.println(res.length()); System.out.println(res); &#125; public static String solut(String arr) &#123; //获取第一次争吵得到的结果 String str = solution(arr); //如果还存在第二次争吵，则继续，否则得到结果 while (str.contains("RL"))&#123; str = solution(str); &#125; return str; &#125; public static String solution(String arr)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;arr.length()-1;i++)&#123; //争吵 if(arr.charAt(i)=='R'&amp;&amp;arr.charAt(i+1)=='L')&#123; if(i==0) &#123; list.add('R'); i++; &#125; else&#123; if(list.get(list.size()-1)=='L') &#123; &#123; list.add('R'); i++; &#125; &#125;else&#123; &#123; list.add('L'); i++; &#125; &#125; &#125; &#125;else &#123; //没有争吵，下一次争吵中还有该人 list.add(arr.charAt(i)); &#125; &#125; //将list转换成String String str = ""; for(int i = 0;i&lt;list.size();i++)&#123; str = str+list.get(i); &#125; return str; &#125;&#125;]]></content>
      <categories>
        <category>讯飞科技笔试</category>
      </categories>
      <tags>
        <tag>讯飞科技笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-15:三数之和]]></title>
    <url>%2F2019%2F04%2F27%2Fleetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述：给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 2.解题思路 首先按升序排序；然后定义下标变量i,j,k，因为是三元组，所以要三个变量如果简单的遍历，那么跟是否有序没有关系，其时间复杂度将达到O(n^3)。仔细想想：如果当前选择了a、b、c三个数，如果其和小于目标target，那么需要将其中一个数用更大的数替换；反之亦然。但究竟替换三个数中的哪个数？无法确定就只能先固定两个变量，让其第三个变化（替换）。一种办法是：固定前两个数i,j，然后让k在一个范围中二分变化（二分查找思想） 3.代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); List&lt;Integer&gt; targets = new ArrayList&lt;&gt;(); // 用于去重 if((nums.length&gt;0 &amp;&amp; nums.length&lt;3) ||(nums.length&gt;0 &amp;&amp;nums[0]&gt;0)) return list; for(int i = 0;i&lt;=nums.length-3;i++) &#123; int target = 0 - nums[i]; if (!targets.contains(target)) &#123; //用于去重 targets.add(target); int k = i + 1; int j = nums.length - 1; while (k &lt; j) &#123; if (nums[k] + nums[j] == target) &#123; List&lt;Integer&gt; li = new ArrayList(); li.add(nums[i]); li.add(nums[k]); li.add(nums[j]); list.add(li); while (k &lt; j &amp;&amp; nums[k] == nums[k + 1]) ++k; while (k &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j; k++; j--; &#125; else if (nums[k] + nums[j] &lt; target) &#123; k++; &#125; else &#123; j--; &#125; &#125; &#125; &#125; return list; &#125;&#125; 4.我的提交记录]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用github和hexo搭建个人网站]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%94%A8github%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[1.基础知识 拥有github账号 安装node.js、npm,并了解相关基础知识 安装git客户端 本次搭建所使用的环境如下： C:\User\qiuli&gt;node -v v10.15.3 C:\User\qiuli&gt;git --version git version 2.21.0.windows.1 2.搭建github博客 2.1 创建仓库 新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了。 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 2.2 绑定域名]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Qiulig]]></title>
    <url>%2F2019%2F04%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
