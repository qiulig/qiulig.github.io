<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer_【6】旋转数组的最小数字]]></title>
    <url>%2F2019%2F05%2F15%2F6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1. 题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 2.解题思路3.代码]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_[5]两个栈实现队列]]></title>
    <url>%2F2019%2F05%2F15%2F5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1. 题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 2. 解题思路 栈的规则是先进后出，队列的规则是先进先出 stack1一直维持着栈底–栈顶是队列的入队顺序 stack2一直维持着栈顶–栈尾为队列的入队顺序 当执行队列的入队（push）时，如果stack2为空，则直接插入到stack1,stack1从栈底到栈顶的顺序为入队顺序，如果stack2不为空，则将stack2的元素倒入（栈顶—栈尾）stack1,然后再插入数据 4- 当执行队列的出队(pop)操作时，应该出的是stack1的栈底元素，故将stack1依次倒入stack2,这时stack2的栈顶就是要出队的数值，此时stack1为空，stack2从（栈顶–栈尾）为入队顺序 3. 代码12345678910111213141516171819202122232425262728public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //队列的入队 public void push(int node) &#123; //将stack2倒入stack1 while (!stack2.empty()) &#123; stack1.push(stack2.pop()); &#125; //将元素插入stack1 stack1.push(node); &#125; //队列的出队 public int pop() &#123; //将stack1倒入stack2 while (!stack1.empty()) &#123; stack2.push(stack1.pop()); &#125; //stack2的栈顶就是出队数值 return stack2.pop(); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_[4]重建二叉树]]></title>
    <url>%2F2019%2F05%2F15%2F4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 2.解题思路 先序遍历为：根-&gt;左子树-&gt;右子树，中序遍历为左子树-&gt;根-&gt;右子树 先找到根结点，为先序遍历的第一个数值 根据这个数值，可以划分中序中的左子树和右子树范围 递归构建左子树和右子树 3.代码12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Arrays;//** * Definition for binary tree public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length==0 || in.length==0) return null; TreeNode node = new TreeNode(pre[0]); //根结点 for(int i=0;i&lt;pre.length;i++)&#123; //找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点 if(pre[0] == in[i])&#123; //递归构建左子树，此时前序的范围缩小为[1,i+1),中序缩小为[0,i) node.left =reConstructBinaryTree(Arrays.copyOfRange (pre,1,i+1),Arrays.copyOfRange(in,0,i)); //递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len) node.right = reConstructBinaryTree(Arrays.copyOfRange (pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length)); break; &#125; &#125; return node; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_[3]从尾到头打印链表]]></title>
    <url>%2F2019%2F05%2F15%2F3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 2.解题思路 先用一个栈stack存储从头到尾的链表数值 再依次弹出，因为栈是先进后出的，故弹出的结果为从尾到头 将弹出的结果放入list返回 3.代码123456789101112131415161718192021222324252627282930public class Main_3 &#123; public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; public static class Solution &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); public static ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) &#123; list.add(stack.pop()); &#125; return list; &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSR303参数校验和全局异常处理]]></title>
    <url>%2F2019%2F05%2F15%2FJSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。故引出使用JSR303来做参数校验。参数校验的实现: 手机号和密码字段自定义注解 为了让客户端显示更加友好 需要自定义异常拦截器 1. 添加依赖123456&lt;!--JSR303参数检验+全局异常处理器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解1234567891011@Controller@RequestMapping("/login")public class LoginController &#123; @RequestMapping("/do_login") @ResponseBody public Result&lt;String&gt; doLogin(HttpServletResponse response, @Valid LoginVo loginVo)&#123; logger.info(loginVo.toString()); &#125;&#125; 12345678910@Datapublic class LoginVo &#123; @NotNull @IsMobile private String mobile; @NotNull @Length(min = 32) private String password;&#125; 3. IsMobile注解的编写[可参考@NotNull]12345678910111213141516171819202122@Target(&#123; ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint( validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile &#123; boolean required() default true; String message() default "电话号码格式错误"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; 4.指定校验器的实现[IsMobileValidator.class]1234567891011121314151617181920212223public class IsMobileValidator implements ConstraintValidator&lt;IsMobile,String&gt; &#123; private boolean required = false; @Override //初始化方法拿到注解，可以定义一个字符为空 public void initialize(IsMobile constraintAnnotation) &#123; constraintAnnotation.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //值是必须的 if(required)&#123; return ValidatorUtil.isMobile(value); &#125;else&#123; if(StringUtils.isEmpty(value))&#123; return true; &#125;else&#123; return ValidatorUtil.isMobile(value); &#125; &#125; &#125;&#125; 5.自定义异常拦截器 当校验不通过时，会抛出异常。这时如果没有定义全局异常处理器进行处理（对异常进行封装和返回）。则会发生400错误（即只有请求的发起，却没有收到正常的响应（response），因为还没有来得及return就抛出了异常（这种异常没有被处理））。 1234567891011121314151617181920212223@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public Result&lt;String&gt; exceptionHandler(HttpServletRequest request,Exception e)&#123; e.printStackTrace(); if(e instanceof GlobalException) &#123; GlobalException ex = (GlobalException) e; return Result.Error(ex.getCm()); &#125;else if(e instanceof BindException)&#123; BindException ex = (BindException) e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); //为了方便起见，只取第一个错误 ObjectError error = errors.get(0); String msg = error.getDefaultMessage(); return Result.Error(CodeMsg.BIND_ERROR.fillArgs(msg)); &#125;else&#123; return Result.Error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用缓存key]]></title>
    <url>%2F2019%2F05%2F15%2F%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key%2F</url>
    <content type="text"><![CDATA[通用缓存key的作用当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。方法：利用一个前缀来规定不同模块的缓存的key,这样不同模块之间就不会重复。 通用缓存key采用模板模式：接口-&gt;抽象类-&gt;实现类 1. 接口12345678public interface KeyPrefix &#123; //过期时间 public int expireSeconds(); //前缀 public String getPrefix();&#125; 2. 抽象类1234567891011121314151617181920212223242526272829public abstract class BasePrefix implements KeyPrefix&#123; private int expireSeconds; private String prefix; //无过期时间的构造函数 public BasePrefix(String prefix) &#123; this(0, prefix); &#125; //含有过期时间的构造函数 public BasePrefix( int expireSeconds, String prefix) &#123; this.expireSeconds = expireSeconds; this.prefix = prefix; &#125; public int expireSeconds() &#123; return expireSeconds; &#125; //获取前缀，前缀为 className：prefix public String getPrefix() &#123; String className = getClass().getSimpleName(); return className+":" + prefix; &#125;&#125; 3. 实现类12345678910public class MiaoshaKey extends BasePrefix&#123; //继承父类的无过期时间的构造函数 public MiaoshaKey(String prefix) &#123; super(prefix); &#125; //设置她这个类的前缀是className:go public static MiaoshaKey isGoodsOver = new MiaoshaKey("go");&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitMQ实现消息缓冲]]></title>
    <url>%2F2019%2F05%2F15%2FrabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[RabbitMQ主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是AMQP协议，它是一种二进制协议。默认启动端口5672 rabbitMQ的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，生产者producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。 Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key, 根据key全文匹配去寻找队列 Topic：按规则转发消息（最灵活）转发消息主要是根据通配符 Headers：设置 header attribute 参数类型的交换机 Fanout：转发消息到所有绑定队列(广播方式) 下面介绍4种交换机与springboot的集成添加依赖包amqp,统一配置application.properties 123456&lt;!--rabbitMQ依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 12345678910111213141516171819##rabbitMQspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/#消费者数量spring.rabbitmq.listener.simple.concurrency= 10spring.rabbitmq.listener.simple.max-concurrency= 10#消费者每次从队列获取的消息数量spring.rabbitmq.listener.simple.prefetch= 1#消费者自动启动spring.rabbitmq.listener.simple.auto-startup=true#消费失败，自动重新入队spring.rabbitmq.listener.simple.default-requeue-rejected= true#启用发送重试spring.rabbitmq.template.retry.enabled=true spring.rabbitmq.template.retry.initial-interval=1000spring.rabbitmq.template.retry.max-attempts=3 1. Direct交换机制 一个队列会和一个交换机绑定，除此之外再绑定一个routing_key，当消息被发送的时候，需要指定一个binding_key，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个binding_key也是支持应用到多个队列中的。 这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。 1.1 编写config12345678910@Configurationpublic class MQconfig &#123; public static final String QUEUE ="queue"; @Bean public Queue queue()&#123; return new Queue(QUEUE,true); &#125; &#125; 1.2 创建消息发送者1234567891011121314@Servicepublic class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); public void send(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.Queue,message); &#125;&#125; 1.3 创建消息接收者12345678910@Servicepublic class MQreceiver &#123; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); //监听了queue的队列 @RabbitListener(queues = MQconfig.Queue) public void receive(String message)&#123; log.info("receive message"+message); &#125;&#125; 1.4 编写controller测试123456789101112@Controllerpublic class HelloController &#123; @Autowired MQsender sender; @RequestMapping("/mq") @ResponseBody public Result&lt;Boolean&gt; mq()&#123; sender.send("hello"); return Result.success(true); &#125; &#125; 2. Fanout交换机制 扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。 2.1 编写config1234567891011121314151617181920@Configuration public class MQconfig &#123; public static final String FANOUT_EXCHANGE ="fanoutxchage"; @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE); &#125; @Bean public Binding fanoutBinding()&#123; return BindingBuilder.bind(topticQueue2()).to(fanoutExchange()); &#125; 2.2 创建消息发送者12345678910111213@Service public class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; public void sendFanout(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.FANOUT_EXCHANGE,"",msg); &#125;&#125; 2.3 创建消息接收者1234@Service public class MQreceiver &#123; //fanout 广播模式都接受故不需要listener &#125; 2.4 编写controller测试123456789@Controller public class HelloController &#123; @RequestMapping("/mq/fanout") @ResponseBody public Result&lt;String&gt; fanout()&#123; sender.sendFanout("hellommxx"); return Result.success("hello xuanzi");&#125; &#125; 3. topic交换机制 通配符交换机，exchange会把消息发送到一个或者多个满足通配符规则的routing-key的queue。其中表号匹配一个word，#匹配多个word和路径，路径之间通过.隔开。如满足a..c的routing-key有a.hello.c；满足#.hello的routing-key有a.b.c.helo。 1.1 编写config1234567891011121314151617181920212223242526272829@Configuration public class MQconfig &#123; public static final String TOPIC_QUEUE1 ="topic.queue1"; public static final String TOPIC_QUEUE2 ="topic.queue2"; public static final String TOPIC_EXCHANGE ="topicExchange" @Bean public Queue topticQueue1()&#123; return new Queue(TOPIC_QUEUE1,true); &#125; @Bean public Queue topicQueue2()&#123; return new Queue(TOPIC_QUEUE2,true); &#125; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; @Bean public Binding topicBinding1()&#123; return BindingBuilder.bind(topticQueue1()).to(topicExchange()).with("topic.key1"); &#125; @Bean public Binding topicBinding2()&#123; return BindingBuilder.bind(topticQueue2()).to(topicExchange()).with("topic.#"); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendTopic(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key1",msg+"1"); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key2",msg+"2");&#125;&#125; 1.3 创建消息接收者12345678910111213@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.TOPIC_QUEUE1) public void receiveTopic1(String message)&#123; log.info("receive topic queue1 message"+message); &#125; @RabbitListener(queues = MQconfig.TOPIC_QUEUE2) public void receiveTopic2(String message)&#123; log.info("receive topic queue2 message"+message); &#125; &#125; 1.4 编写controller测试12345678@Controller public class HelloController &#123; @RequestMapping("/mq/topic") @ResponseBody public Result&lt;String&gt; topic()&#123; sender.sendTopic("hellommxx"); return Result.success("hello xuanzi"); &#125; 4. header交换机制 header exchange(头交换机)和主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据。主题交换机路由键只有是字符串,而头交换机可以是整型和哈希值 1.1 编写config123456789101112131415161718192021222324252627282930313233343536@Configuration public class MQconfig &#123; public static final String HEADER_QUEUE ="header.queue"; @Bean public HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE); &#125; @Bean public Queue headerQueue()&#123; return new Queue(HEADER_QUEUE,true); &#125; @Bean public Binding headerBinding()&#123; Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); map.put("header1","value1"); map.put("header2","value2"); return BindingBuilder.bind(headerQueue()).to(headersExchange()) .whereAll(map).match(); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendheader(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); MessageProperties properties = new MessageProperties(); properties.setHeader("header1","value1"); properties.setHeader("header2","value2"); Message obj = new Message(msg.getBytes(),properties); amqpTemplate.convertAndSend(MQconfig.HEADERS_EXCHANGE,"",obj); &#125;&#125; 1.3 创建消息接收者123456789@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.HEADER_QUEUE) public void receiveHeader(byte[] message)&#123; log.info("receive header queue message"+message); &#125; &#125; 1.4 编写controller测试12345678910111213@Controller public class HelloController &#123; @RequestMapping("/mq/header") @ResponseBody public Result&lt;String&gt; header()&#123; sender.sendheader("hellommxx"); return Result.success("hello xuanzi"); &#125; &#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis缓存java端实现]]></title>
    <url>%2F2019%2F05%2F15%2FRedis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1. 引入redis依赖1234&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; 2.在application.properties添加redis配置文件12345678#redisredis.host=127.0.0.1redis.port=6379redis.timeout=3redis.password=2966redis.poolMaxTotal=10 //资源池中最大连接数redis.poolMaxIdle=10 //允许的最大空闲的连接数redis.poolMaxWait=3 3.定义redis的类，引入redis的配置12345678910111213@Component@ConfigurationProperties(prefix="redis")@Datapublic class RedisConfig &#123; private String host; private int port; private int timeout;//秒 private String password; private int poolMaxTotal; private int poolMaxIdle; private int poolMaxWait;//秒&#125; 4.RedisPoolFactory类，用于返回一个redis池12345678910111213141516171819202122232425262728@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisPoolFactory() &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); //允许最大空闲的连接数 poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); //资源池中最大连接数 poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); //最大等待毫秒数 poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(), redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125;&#125; 5.编写RedisService类12345678910111213141516@Servicepublic class RedisService &#123; @Autowired JedisPool jedisPool; //里面编写redis操作：增删改查 private void returnToPool(Jedis jedis) &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125;&#125; 5.1 获取单个对象(get)1234567891011121314151617181920212223242526272829303132333435363738//相当于redis里面的get key public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key,之前设置通用缓存key时的key设为className:key String realKey = prefix.getPrefix() + key; //跟redis里面的获取一个key操作一致 String str = jedis.get(realKey); //将结果转换成一个java对象 T t = stringToBean(str, clazz); return t; &#125;finally &#123; //关闭池资源 returnToPool(jedis); &#125; &#125;//json转换为java对象public static &lt;T&gt; T stringToBean(String str, Class&lt;T&gt; clazz) &#123; if(str == null || str.length() &lt;= 0 || clazz == null) &#123; return null; &#125; //判断类型 if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(str); &#125;else if(clazz == String.class) &#123; return (T)str; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(str); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(str), clazz); &#125; &#125; 5.2 设置对象(set)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//相当于redis里面的set key valuepublic &lt;T&gt; boolean set(KeyPrefix prefix, String key, T value) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //对象转换为json字符串 String str = beanToString(value); if(str == null || str.length() &lt;= 0) &#123; return false; &#125; //生成真正的key String realKey = prefix.getPrefix() + key; //获取过期时间 int seconds = prefix.expireSeconds(); if(seconds &lt;= 0) &#123; //永久有效，无过期时间 jedis.set(realKey, str); &#125;else &#123; //为指定的 key 设置值及其过期时间。 jedis.setex(realKey, seconds, str); &#125; return true; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //将对象转化为Json字符串 public static &lt;T&gt; String beanToString(T value) &#123; if(value == null) &#123; return null; &#125; Class&lt;?&gt; clazz = value.getClass(); if(clazz == int.class || clazz == Integer.class) &#123; return ""+value; &#125;else if(clazz == String.class) &#123; return (String)value; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; 5.3 判断key是否存在(exists)123456789101112//想当于redis里面的 exists keypublic &lt;T&gt; boolean exists(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.exists(realKey); &#125;finally &#123; returnToPool(jedis); &#125;&#125; 5.4 增加值(incr)123456789101112//相当于redis里面的incr key_namepublic &lt;T&gt; Long incr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.5 减少值(decr)123456789101112//相当于redis里面的decr key_namepublic &lt;T&gt; Long decr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.6 删除(del)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//相当于redis里面的del key_name //已知key public boolean delete(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; long ret = jedis.del(realKey); return ret &gt; 0; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //通过正则匹配删除 某key public boolean delete(KeyPrefix prefix) &#123; if(prefix == null) &#123; return false; &#125; List&lt;String&gt; keys = scanKeys(prefix.getPrefix()); if(keys==null || keys.size() &lt;= 0) &#123; return true; &#125; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.del(keys.toArray(new String[0])); return true; &#125; catch (final Exception e) &#123; e.printStackTrace(); return false; &#125; finally &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125; &#125; public List&lt;String&gt; scanKeys(String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); List&lt;String&gt; keys = new ArrayList&lt;String&gt;(); String cursor = "0"; //scan搜索 ScanParams sp = new ScanParams(); sp.match("*"+key+"*"); //设置scan的个数 sp.count(100); do&#123; ScanResult&lt;String&gt; ret = jedis.scan(cursor, sp); //返回结果 List&lt;String&gt; result = ret.getResult(); if(result!=null &amp;&amp; result.size() &gt; 0)&#123; //搜索的结果存入list keys.addAll(result); &#125; //再处理cursor，用于返回下次遍历的游标 cursor = ret.getStringCursor(); &#125;while(!cursor.equals("0")); return keys; &#125; finally &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125; &#125; 6.controller层测试123456789101112131415161718@AutowiredRedisService redisService;@RequestMapping("/redis/get")@ResponseBodypublic Result&lt;User&gt; getRedis()&#123; User user = redisService.get(UserKey.getById,"key1",User.class); return Result.success(user);&#125;@RequestMapping("/redis/set")@ResponseBodypublic Result&lt;Boolean&gt; setRedis()&#123; User user = new User(); user.setId(1); user.setName("1111"); redisService.set(UserKey.getById,""+1,user); return Result.success(true);&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【2】空格替换]]></title>
    <url>%2F2019%2F05%2F15%2F2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1. 题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 2. 解题思路 方法1：利用函数replaceAll完成 方法2： **先计算需要多少的空间 **从后向前依次插入 3.代码方法1： 12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll(" ", "%20"); &#125;&#125; 方法2： 12345678910111213141516171819202122232425262728public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int spacenum = 0;//spacenum为计算空格数 for(int i=0;i&lt;str.length();i++)&#123; if(str.charAt(i)==' ') spacenum++; &#125; //indexold为为替换前的str下标 int indexold = str.length()-1; //计算空格转换成%20之后的str长度 int newlength = str.length() + spacenum*2; //indexold为为把空格替换为%20后的str下标 int indexnew = newlength-1; //使str的长度扩大到转换成%20之后的长度,防止下标越界 str.setLength(newlength); for(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; if(str.charAt(indexold) == ' ')&#123; str.setCharAt(indexnew--, '0'); str.setCharAt(indexnew--, '2'); str.setCharAt(indexnew--, '%'); &#125;else&#123; str.setCharAt(indexnew--, str.charAt(indexold)); &#125; &#125; return str.toString(); &#125;&#125; 补充1：String和StringBuffer的转换String转换成StringBuffer 12String str = "abc";StringBuffer b=new StringBuffer(str); StringBuffer转换成String 12StringBuffer a=new StringBuffer();String b=a.toString(） 补充2：String、StringBuffer、StringBuilder 1）运行速度StringBuilder&gt;StringBuffer&gt;String 2）String是字符串常量，String对象一旦创建就不能更改。StringBuffer为 字符串变量，可更改 3） String适用于少量的字符串操作，StringBuffer适用于多线程下字符缓冲区进行大量操作的情况。 4） StringBuffer 与 StringBuilder 中的方法和功能完全是等价的， 5） 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 6） 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而StringBuffer则每次都需要判断锁，效率相对更低。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[争吵问题.md]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md%2F</url>
    <content type="text"><![CDATA[1. 题目描述有一个队列，每个人要么朝左边（L表示）,要么朝右边(R表示)，因为每个人都讨厌其他任何人，只要两人面对面就会发生争吵。争吵结果是胜者留在队列中，败的人移除队中。 如果序列中有多对争吵，可以任选一对，胜者留在队中，败者出局，求最后队列最少人数是多少。 例子： LRRLRL 输出：2 Hint 一种可能的变化情况是：LRRLRL -&gt; LRLRL -&gt; LRRL -&gt; LRL -&gt; LR 2.解题思路由题意可知，如果真的吵架就只有RL（两人面对面）情况，像LL,RR,LR就不会争吵。 如果吵架前面是R，则吵架结果应该是L胜利. 如果吵架前面是L，则吵架结果为R胜利 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.List;public class test &#123; public static void main(String[] args) &#123; String arr ="LRRLRL"; String res = solut(arr); System.out.println(res.length()); System.out.println(res); &#125; public static String solut(String arr) &#123; //获取第一次争吵得到的结果 String str = solution(arr); //如果还存在第二次争吵，则继续，否则得到结果 while (str.contains("RL"))&#123; str = solution(str); &#125; return str; &#125; public static String solution(String arr)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;arr.length()-1;i++)&#123; //争吵 if(arr.charAt(i)=='R'&amp;&amp;arr.charAt(i+1)=='L')&#123; if(i==0) &#123; list.add('R'); i++; &#125; else&#123; if(list.get(list.size()-1)=='L') &#123; &#123; list.add('R'); i++; &#125; &#125;else&#123; &#123; list.add('L'); i++; &#125; &#125; &#125; &#125;else &#123; //没有争吵，下一次争吵中还有该人 list.add(arr.charAt(i)); &#125; &#125; //将list转换成String String str = ""; for(int i = 0;i&lt;list.size();i++)&#123; str = str+list.get(i); &#125; return str; &#125;&#125;]]></content>
      <categories>
        <category>讯飞科技笔试</category>
      </categories>
      <tags>
        <tag>讯飞科技笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-15:三数之和]]></title>
    <url>%2F2019%2F04%2F27%2Fleetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述：给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 2.解题思路 首先按升序排序；然后定义下标变量i,j,k，因为是三元组，所以要三个变量如果简单的遍历，那么跟是否有序没有关系，其时间复杂度将达到O(n^3)。仔细想想：如果当前选择了a、b、c三个数，如果其和小于目标target，那么需要将其中一个数用更大的数替换；反之亦然。但究竟替换三个数中的哪个数？无法确定就只能先固定两个变量，让其第三个变化（替换）。一种办法是：固定前两个数i,j，然后让k在一个范围中二分变化（二分查找思想） 3.代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); List&lt;Integer&gt; targets = new ArrayList&lt;&gt;(); // 用于去重 if((nums.length&gt;0 &amp;&amp; nums.length&lt;3) ||(nums.length&gt;0 &amp;&amp;nums[0]&gt;0)) return list; for(int i = 0;i&lt;=nums.length-3;i++) &#123; int target = 0 - nums[i]; if (!targets.contains(target)) &#123; //用于去重 targets.add(target); int k = i + 1; int j = nums.length - 1; while (k &lt; j) &#123; if (nums[k] + nums[j] == target) &#123; List&lt;Integer&gt; li = new ArrayList(); li.add(nums[i]); li.add(nums[k]); li.add(nums[j]); list.add(li); while (k &lt; j &amp;&amp; nums[k] == nums[k + 1]) ++k; while (k &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j; k++; j--; &#125; else if (nums[k] + nums[j] &lt; target) &#123; k++; &#125; else &#123; j--; &#125; &#125; &#125; &#125; return list; &#125;&#125; 4.我的提交记录]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_[1]二维数组的查找]]></title>
    <url>%2F2019%2F04%2F27%2F1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[1.题目描述： 在一个二维数组中（每个一维数组的长度相同），如数组 1 2 3 4 5 6 7 8 9 每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 2.解题思路 选择右上角的数字作为开始点 如果array[row][col]&gt;target,则向左查找，col–； 如果array[row][col]&lt;target,则向下查找，row++； 3.代码123456789101112131415161718public class Solution &#123; public boolean Find(int target, int [][] array) &#123; boolean res = false; int row = 0; int col = array[0].length-1; while(row&lt;=array.length-1&amp;&amp;col&gt;=0)&#123; if(array[row][col]&gt;target)&#123; col--; &#125;else if(array[row][col]&lt;target)&#123; row++; &#125;else&#123; res = true; break; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
</search>
