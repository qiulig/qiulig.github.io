<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树的涉及的题]]></title>
    <url>%2F2019%2F07%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B6%89%E5%8F%8A%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[二叉树的定义12345678public static class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; 1.二叉树的最大深度https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 123456789 public int maxDepth(TreeNode root) &#123; if(root!=null)&#123; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left,right)+1; &#125;else&#123; return 0; &#125;&#125; 2.二叉树的最小深度https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/ 12345678910111213141516171819public static int minDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; if ((root.left == null) &amp;&amp; (root.right == null)) &#123; return 1; &#125; int minDepth = Integer.MAX_VALUE; if(root.left != null) &#123; minDepth = Math.min(minDepth, minDepth(root.left)); &#125; if(root.right != null) &#123; minDepth = Math.min(minDepth, minDepth(root.right)); &#125; return minDepth + 1; &#125; &#125; 3..求完全二叉树中节点的个数https://leetcode-cn.com/problems/count-complete-tree-nodes/ 123456789public int countNodes(TreeNode root) &#123; if(root==null)&#123; return 0; &#125; int left = countNodes(root.left); int right = countNodes(root.right); return left+right +1; &#125; 4. 平衡二叉树https://leetcode-cn.com/problems/balanced-binary-tree/ 12345678910111213141516171819class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; if(Math.abs(getDepth(root.left)-getDepth(root.right))&lt;=1)&#123; return isBalanced(root.left) &amp;&amp;isBalanced(root.right); &#125;else&#123; return false; &#125; &#125; //树的深度 public int getDepth(TreeNode root)&#123; if(root == null) return 0; int left = getDepth(root.left); int right = getDepth(root.right); return Math.max(left,right)+1; &#125;&#125; 5.二叉树的完全性检验https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/ 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean isCompleteTree(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); //加入根节点 queue.add(root); boolean hasNoChild = false; while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); if (hasNoChild) &#123; //上一层中左子树不为空，右子树为空，如果遍历到左子树，这时候左子树有孩子，则代表上一层不完全填满 if(node.left!=null || node.right!=null)&#123; return false; &#125; &#125; else &#123; if (node.left != null &amp;&amp; node.right != null) &#123; //左右子树不为空 queue.add(node.left); queue.add(node.right); &#125; else if (node.left != null &amp;&amp; node.right == null) &#123; //左子树不为空,右子树为空 queue.add(node.left); hasNoChild = true; &#125; else if (node.left == null &amp;&amp; node.right != null) &#123;//左子树为空，右子树不为空 return false; &#125; else &#123; //左右子树都为空 hasNoChild = true; &#125; &#125; &#125; return true; &#125;&#125; 6.相同的树https://leetcode-cn.com/problems/same-tree/ 1234567891011class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q==null) return true; if(p==null ||q == null) return false; if(p.val !=q.val) return false; return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); &#125;&#125; 7.对称二叉树https://leetcode-cn.com/problems/symmetric-tree/ 12345678910111213141516class Solution &#123; public static boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; return Symmetric(root.left,root.right); &#125; public static boolean Symmetric(TreeNode leftroot,TreeNode rightroot) &#123; if(leftroot==null &amp;&amp; rightroot==null) return true; if(leftroot==null || rightroot == null) return false; if(leftroot.val != rightroot.val) return false; return Symmetric(leftroot.left,rightroot.right) &amp;&amp; Symmetric(leftroot.right,rightroot.left); &#125;&#125; 1234567891011121314151617181920212223class Solution &#123; public static boolean isSymmetric(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); queue.add(root); while(!queue.isEmpty())&#123; TreeNode node1 = queue.poll(); TreeNode node2 = queue.poll(); if(node1==null &amp;&amp; node2==null) continue; if(node1==null || node2==null) return false; if(node1.val!=node2.val) return false; queue.add(node1.left); queue.add(node2.right); queue.add(node1.right); queue.add(node2.left); &#125; return true; &#125;&#125; 8.翻转二叉树https://leetcode-cn.com/problems/invert-binary-tree/ 123456789101112class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root == null) return null; TreeNode right = invertTree(root.right); TreeNode left = invertTree(root.left); root.left = right; root.right = left; return root; &#125;&#125; 9.二叉搜索树的最近公共祖先https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ 123456789101112class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; //都在右子树 if(p.val &gt;root.val &amp;&amp; q.val &gt;root.val)&#123; return lowestCommonAncestor(root.right,p,q); &#125;else if(p.val&lt;root.val &amp;&amp; q.val &lt;root.val)&#123; //都在左子树 return lowestCommonAncestor(root.left,p,q); &#125;else&#123; //一个在左子树，一个在右子树 return root; &#125; &#125;&#125; 10.二叉树的最近公共祖先https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/ 123456789class Solution &#123; TreeNode lowestCommonAncestor(TreeNode root,TreeNode p,TreeNode q)&#123; if(root==null || root==p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); return left==null ? right : right == null?left:root; &#125;&#125; 11.最深叶节点的最近公共祖先https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/ 1234567891011121314151617181920212223242526272829class Solution &#123; public TreeNode lcaDeepestLeaves(TreeNode root) &#123; if (root == null)&#123; return null; &#125; //左子树的深度 int left = depth(root.left); int right = depth(root.right); //如果左右子树深度相同，表示获取到了最深叶子节点的最近公共祖先 if (left == right)&#123; return root; //如果左右子树不等高，高度小的那个子树节点的叶子节点的深度肯定不是最深的（因为比高度大的子树深度小）。 //所以，最深叶子节点肯定在深度较大的子树当中，采用深度优先搜索，每次只要继续往深度更大的子树进行递归即可。 &#125;else if(left &gt; right)&#123; return lcaDeepestLeaves(root.left); &#125;else &#123; return lcaDeepestLeaves(root.right); &#125; &#125; //求二叉树的深度 private int depth(TreeNode root)&#123; if (root == null)&#123; return 0; &#125; int left = depth(root.left); int right = depth(root.right); return 1 + Math.max(left,right); &#125;&#125; 12.节点与其祖先中间的最大差值https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/ 1234567891011121314151617181920class Solution &#123; public static int maxAncestorDiff(TreeNode root) &#123; if(root == null) return 0; return AncestorDiff(root,root.val,root.val); &#125; // 每条从根节点到叶子节点的路径中的最大值和最小值，并求出差值更新全局变量 //一口气遍历到叶子节点，遍历的时候动态保存当前路径的最大节点值和最小节点值 //每当遍历一次叶子节点，将保存好的最大值与最小值之间的差与全局变量 maxvalue 比较，并且取较大值 private static int AncestorDiff(TreeNode root, int max_value, int min_value) &#123; if(root == null) return max_value-min_value; max_value = root.val &gt; max_value ? root.val : max_value; min_value = root.val &lt; min_value ? root.val : min_value; return Math.max(AncestorDiff(root.left,max_value,min_value),AncestorDiff(root.right,max_value,min_value)); &#125;&#125; 13.从前序与中序遍历序列构造二叉树https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ 12345678910111213141516171819class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder.length == 0 || inorder.length == 0) return null; //前序的第一个数即为树的根结点 TreeNode root = new TreeNode(preorder[0]); for(int i = 0;i&lt;inorder.length;i++)&#123; //找到中序中的根节点 if(preorder[0] == inorder[i])&#123; //pre[1,i+1] 和in[0,i]构成左子树的遍历 root.left = buildTree(Arrays.copyOfRange(preorder,1,i+1),Arrays.copyOfRange(inorder,0,i)); //pre[i+1,len-1]和in[i+1,len-1]构成右子树的遍历 root.right = buildTree(Arrays.copyOfRange(preorder,i+1,preorder.length),Arrays.copyOfRange(inorder,i+1,inorder.length)); break; &#125; &#125; return root; &#125;&#125; 14.从中序与后序遍历序列构造二叉树https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ 12345678910111213141516171819class Solution &#123; public static TreeNode buildTree(int[] inorder, int[] postorder) &#123; if(inorder.length == 0||postorder.length == 0) return null; //后序的最后一个为根结点 TreeNode root = new TreeNode(postorder[postorder.length-1]); for(int i = 0;i&lt;inorder.length;i++)&#123; //找到中序中的根节点位置 if(inorder[i] == postorder[postorder.length-1])&#123; //in[0,i]和pos[0,i-1]构成左子树的遍历 root.left = buildTree(Arrays.copyOfRange(inorder,0,i),Arrays.copyOfRange(postorder,0,i)); //in[i+1,len-1]和pos[i,len-2]构成左子树的遍历 root.right = buildTree(Arrays.copyOfRange(inorder,i+1,inorder.length),Arrays.copyOfRange(postorder,i,postorder.length-1)); break; &#125; &#125; return root; &#125;&#125; 15.把二叉树转换成累加树https://leetcode-cn.com/problems/convert-bst-to-greater-tree/ 1234567891011121314151617//中序遍历结果为从小到大，要变成累加树，则中序遍历反过来相加变成节点值即可。class Solution &#123; int num = 0; public TreeNode convertBST(TreeNode root) &#123; if(root!=null)&#123; //遍历右子树 convertBST(root.right); //改变值，依次累加即可 root.val = root.val+num; //存储上一层的值 num = root.val; //遍历左子树 convertBST(root.left); &#125; return root; &#125;&#125; 16.不同的二叉搜索树https://leetcode-cn.com/problems/unique-binary-search-trees/ 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？动态规划 初始化 假设n个节点存在二叉搜索树的个数是dp（n）,令f(i) 为以i为根的二叉搜索树的个数，则有 &emsp;&emsp; &emsp; &emsp; &emsp; &emsp; dp(n) = f(1) + f(2) + f(3) +... + f(n) 当i为根节点时，其左子树的个数为(i - 1),右子树的个数为（n-i）,则 &emsp;&emsp; &emsp; &emsp; &emsp; &emsp; f(i) = dp(i-1) *dp(n-i) 结合两个式子可以得到卡特兰数： &emsp;&emsp; &emsp; &emsp; &emsp; &emsp; dp(n) = dp(0) *dp(n-1) +dp(1) *dp(n-2) +... +dp(n-1)*dp(0) &emsp;&emsp; &emsp; &emsp; &emsp; &emsp;&emsp; &emsp; &ensp; = dp(n-1) * C(2n,n) &emsp;&emsp; &emsp; &emsp; &emsp; &emsp;&emsp; &emsp; &ensp; = dp(n-1) * (4*n-2)/(n-1) 12345678910111213class Solution &#123; public static int numTrees(int n) &#123; //n个节点存在二叉树的个数 long []dp = new long[n+1]; //以i为根节点的二叉树个数 dp[0] = 1; //以0为根节点的 dp[1] = 1; for(int i = 1;i&lt;=n;i++)&#123; dp[i] = dp[i-1]*(4*i-2)/(i+1); &#125; return (int) dp[n]; &#125;&#125; 17.不同的二叉搜索树 IIhttps://leetcode-cn.com/problems/unique-binary-search-trees-ii/ 123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if(n&lt;=0) return new ArrayList&lt;TreeNode&gt;(); return generate(1,n); &#125; public List&lt;TreeNode&gt; generate(int start,int end)&#123; List&lt;TreeNode&gt; res=new ArrayList&lt;&gt;(); if(start&gt;end)&#123; res.add(null); return res; &#125; for(int i=start;i&lt;=end;i++)&#123; // 递归遍历左子树 List&lt;TreeNode&gt; leftTrees=generate(start,i-1); // 递归遍历右子树 List&lt;TreeNode&gt; rightTrees=generate(i+1,end); //先序遍历存入以i为根节点的二叉搜索树 for(TreeNode left:leftTrees)&#123; for(TreeNode right:rightTrees)&#123; TreeNode root=new TreeNode(i); root.left=left; root.right=right; res.add(root); &#125; &#125; &#125; return res; &#125;&#125; 18.在二叉树中增加一行https://leetcode-cn.com/problems/add-one-row-to-tree/ 12345678910111213141516171819class Solution &#123; public static TreeNode addOneRow(TreeNode root, int v, int d) &#123; TreeNode node = new TreeNode(v); //如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。 if(d == 1)&#123; node.left = root; return node; &#125; if(d == 0)&#123; node.right = root; return node; &#125; if(root != null &amp;&amp; d&gt;1)&#123; root.left = addOneRow(root.left ,v, d &gt; 2 ? d - 1 : 1); root.right = addOneRow(root.right,v, d &gt; 2 ? d - 1 : 0); &#125; return root; &#125;&#125; 19.验证一棵树是不是二叉搜索树https://leetcode-cn.com/problems/validate-binary-search-tree/ 123456789101112131415161718192021//根据二叉搜索树的中序遍历为从小到大的思路写的//修改一下二叉搜索树的非递归写法class Solution &#123; public boolean isValidBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); double inorder = - Double.MAX_VALUE; while(!stack.isEmpty() || root != null)&#123; while (root!=null)&#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if(root.val &lt;= inorder)&#123; return false; &#125; inorder = root.val; root = root.right; &#125; return true; &#125;&#125; 12345678910111213141516class Solution &#123; TreeNode pre = null; public boolean isValidBST(TreeNode root) &#123; if (root == null) &#123; return true; &#125; if (!isValidBST(root.left)) &#123; return false; &#125; if (pre != null &amp;&amp; pre.val &gt;= root.val) &#123; return false; &#125; pre = root; return isValidBST(root.right); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的【前序遍历】【中序遍历】【后序遍历】【层遍历】【BFS】【DFS】]]></title>
    <url>%2F2019%2F07%2F%E6%A0%91%E7%9A%84%E3%80%90%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90%E5%B1%82%E9%81%8D%E5%8E%86%E3%80%91%E3%80%90BFS%E3%80%91%E3%80%90DFS%E3%80%91%2F</url>
    <content type="text"><![CDATA[二叉树的数据结构12345678public static class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; 1.二叉树的前序遍历https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ 12345678910111213//执行用时 :1 ms, 在所有 Java 提交中击败了99.62%的用户//内存消耗 :35.1 MB, 在所有 Java 提交中击败了40.72%的用户class Solution &#123; List&lt;Integer&gt; res = new ArrayList(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; if(root!=null)&#123; res.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); &#125; return res; &#125;&#125; 非递归 12345678910111213141516171819202122232425/**依次将每层的结点入栈，入栈顺序是右--左，方便弹出时出栈为左---右**/ //执行用时 :3 ms, 在所有 Java 提交中击败了6.05%的用户 //内存消耗 :35 MB, 在所有 Java 提交中击败了40.72%的用户 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)&#123; return res; &#125; stack.push(root); while (!stack.isEmpty())&#123; TreeNode node = stack.pop(); //入栈下一层的右节点 if(node.right!=null)&#123; stack.push(node.right); &#125; //入栈下一层的左节点 if(node.left!=null)&#123; stack.push(node.left); &#125; //加入根节点 res.add(node.val); &#125; return res; &#125; 2.二叉树的中序遍历https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ 123456789101112131415//执行用时 :1 ms, 在所有 Java 提交中击败了99.55%的用户//内存消耗 :34.7 MB, 在所有 Java 提交中击败39.5的用户class Solution &#123; List&lt;Integer&gt; res = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root==null) return res; if(root.left!=null) inorderTraversal(root.left); res.add(root.val); if(root.right!=null) inorderTraversal(root.right); return res; &#125;&#125; 非递归 123456789101112131415161718//执行用时 :2 ms, 在所有 Java 提交中击败了55.11%的用户//内存消耗 :35.1 MB, 在所有 Java 提交中击败了39.36%的用户public static List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur!=null ||!stack.isEmpty())&#123; //循环直到找到最左子树 while (cur!=null)&#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); ans.add(cur.val); cur = cur.right; &#125; return ans; &#125; 3. 二叉树的后序遍历https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 12345678910111213141516//执行用时 :1 ms, 在所有 Java 提交中击败了99.71%的用户//内存消耗 :35.6 MB, 在所有 Java 提交中击败了36.80%的用户class Solution &#123; List&lt;Integer&gt; res = new ArrayList(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; if (root == null) return res; if(root.left !=null) postorderTraversal(root.left); if(root.right !=null) postorderTraversal(root.right); if(root!=null) res.add(root.val); return res; &#125;&#125; 非递归 123456789101112131415161718192021222324//执行用时 :2 ms, 在所有 Java 提交中击败了61.53%的用户//内存消耗 :35.8 MB, 在所有 Java 提交中击败了35.50%的用户public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if (root == null) &#123; return res; &#125; //这里先加入根结点 stack.addLast(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pollLast(); //在res的头部添加，依次添加的为 根，然后再添加为 右--根，再添加为左--右--根 res.addFirst(node.val); //在stack中依次加入左--右，方便下次先弹出右子树，再弹出左子树 if (node.left != null) &#123; stack.addLast(node.left); &#125; if (node.right != null) &#123; stack.addLast(node.right); &#125; &#125; return res; &#125; 4.二叉树的层序遍历https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 12345678910111213141516171819202122//执行用时 :2 ms, 在所有 Java 提交中击败了90.77%的用户//内存消耗 :37 MB, 在所有 Java 提交中击败了43.02%的用户class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if(root == null) return ans; helper(root,0); return ans; &#125; private void helper(TreeNode root, int level) &#123; if(ans.size() == level) ans.add(new ArrayList&lt;&gt;()); ans.get(level).add(root.val); if(root.left != null) helper(root.left,level+1); if(root.right != null) helper(root.right,level+1); &#125;&#125; 非递归 12345678910111213141516171819202122232425262728//执行用时 :3 ms, 在所有 Java 提交中击败了58.74%的用户//内存消耗 :36.7 MB, 在所有 Java 提交中击败了43.83%的用户public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; //用于存一层的结果 ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); //这一层的结点个数 int count = queue.size(); for(int i = 0; i&lt;count;i++)&#123; TreeNode node = queue.poll(); //存入下一层的左右子树 if(node.left!=null) queue.add(node.left); if(node.right!=null) queue.add(node.right); //添加当前层的值到tmp tmp.add(node.val); &#125; //将一层的结果存到结果集中 res.add(tmp); &#125; return res; &#125; 5.二叉树的深度优先遍历123456789101112//递归实现class solution&#123; ArrayList&lt;Integer&gt; ans = new ArrayList(); public static ArrayList&lt;Integer&gt; DFS(TreeNode root) &#123; if (root != null) &#123; ans.add(root.val); DFS(root.left); DFS(root.right); &#125; return ans; &#125;&#125; 非递归实现 1234567891011121314151617public static ArrayList&lt;Integer&gt; DFS(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; stack.push(root); while (!stack.isEmpty())&#123; TreeNode node = stack.pop(); //先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。 if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); res.add(node.val); &#125; return res; &#125; 6.二叉树的广度优先遍历123456789101112131415161718public static ArrayList&lt;Integer&gt; BFS(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty())&#123; TreeNode node = queue.poll(); ////先往queue中压入左节点，再压右节点。 if(node.left!=null) queue.add(node.left); if(node.right!=null) queue.add(node.right); res.add(node.val); &#125; return res; &#125; &#125; N叉树的数据结构123456789class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125; 1. N叉树的前序遍历https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/ 1234567891011121314151617//执行用时 :3 ms, 在所有 Java 提交中击败了88.62%的用户//内存消耗 :52.2 MB, 在所有 Java 提交中击败了78.78%的用户class Solution &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorder(Node root) &#123; if(root == null)&#123; return res; &#125; //添加根 res.add(root.val); //递归孩子结点 for(Node node:root.children)&#123; preorder(node); &#125; return res; &#125;&#125; 非递归 1234567891011121314151617181920//执行用时 :8 ms, 在所有 Java 提交中击败了28.21%的用户//内存消耗 :54.5 MB, 在所有 Java 提交中击败了64.22%的用户 public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;Node&gt; stack= new Stack&lt;&gt;(); if(root == null) return res; stack.push(root); while (!stack.isEmpty())&#123; Node node = stack.pop(); res.add(node.val); if(node.children.size() &gt; 0)&#123; //stack从右到左入栈，以达到弹出先弹左子树再弹右子树 for(int i = node.children.size()-1;i&gt;=0;i--)&#123; stack.add(node.children.get(i)); &#125; &#125; &#125; return res; &#125; 2. N叉树的中序遍历 &emsp;&emsp;&emsp;&emsp;没找到相关题，略过~~~ 3. N叉树的后序遍历https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/ 1234567891011121314//执行用时 :3 ms, 在所有 Java 提交中击败了90.67%的用户//内存消耗 :58.9 MB, 在所有 Java 提交中击败了25.73%的用户class Solution &#123; List&lt;Integer&gt; res = new ArrayList(); public List&lt;Integer&gt; postorder(Node root) &#123; if(root == null) return res; for(Node node : root.children)&#123; postorder(node); &#125; res.add(root.val); return res; &#125;&#125; 非递归 123456789101112131415161718192021public List&lt;Integer&gt; postorder(Node root) &#123; LinkedList&lt;Node&gt; stack = new LinkedList(); LinkedList&lt;Integer&gt; res = new LinkedList(); if(root == null) return res; stack.addLast(root); while (!stack.isEmpty())&#123; Node node = stack.pollLast(); //在res的头部添加，依次添加的为 根，然后再添加为 右--根，再添加为左--右--根 res.addFirst(node.val); //判断是否有孩子结点 if(node.children.size()&gt;0)&#123; //从左到右依次入栈，方便后面先取出右子树 for(int i = 0;i&lt;node.children.size();i++)&#123; stack.addLast(node.children.get(i)); &#125; &#125; &#125; return res; &#125; 4. N叉树的层序遍历https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/ 123456789101112131415161718192021//执行用时 :3 ms, 在所有 Java 提交中击败了98.57%的用户//内存消耗 :58.8 MB, 在所有 Java 提交中击败了40.01%的用户class Solution&#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; if(root == null) return res; helper(root,0); return res; &#125; private void helper(Node root, int level) &#123; if(res.size() == level) res.add(new ArrayList&lt;&gt;()); res.get(level).add(root.val); if(root.children.size()&gt;0)&#123; for(Node node : root.children) helper(node,level+1); &#125; &#125;&#125; 非递归 1234567891011121314151617181920212223242526272829//执行用时 :7 ms, 在所有 Java 提交中击败了64.89的用户 //内存消耗 :52.6 MB, 在所有 Java 提交中击败了79.34%的用户 public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty())&#123; //用于存上一层的结果 ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); //这一层的结点个数 int count = queue.size(); for(int i = 0;i&lt;count;i++)&#123; Node node = queue.poll(); //添加当前层的值到tmp tmp.add(node.val); //存入下一层的孩子 if(node.children.size()&gt;0)&#123; for(int j = 0;j&lt;node.children.size();j++)&#123; queue.add(node.children.get(j)); &#125; &#125; &#125; //将一层的结果存到结果集中 res.add(tmp); &#125; return res; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯算法-【全排列】【组合总和】【n皇后】【子集】]]></title>
    <url>%2F2019%2F07%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E3%80%90%E5%85%A8%E6%8E%92%E5%88%97%E3%80%91%E3%80%90%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E3%80%91%E3%80%90n%E7%9A%87%E5%90%8E%E3%80%91%E3%80%90%E5%AD%90%E9%9B%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[回溯算法&emsp;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。即从一条路往前走，能进则进，不能进则退回来，换一条路再试。 如何使用回溯算法&emsp;回溯我认为也就是一种递归，有以下四个参数，当然不一定是我所举例的类型，要看题目而定&emsp;&emsp;(1)一个全局变量集合保存所有满足条件的答案，举例：List&lt;List&gt; res&emsp;&emsp;(2)一个集合保存一个满足条件的答案，举例：List tmpList核心：根据各个题情况变换12345678for (int i = start; i &lt;= n; i++) &#123; //add进去的值根据题意变换 tmplist.add(i); //递归,这里根据题意变换回溯，这仅仅是个例子 backtrack( k - 1, n, i+1,tmplist, result); //将这个集合清空，方便下一个满足条件的答案 tmplist.remove(tmplist.size()-1); &#125; leetcode_【46】全排列 Ihttps://leetcode-cn.com/problems/permutations/ 题目描述： &emsp;给定一个没有重复数字的序列，返回其所有可能的全排列。输入：&emsp;&emsp;[1,2,3]输出：&emsp;&emsp;[ &emsp;&emsp; [1,2,3], &emsp;&emsp; [1,3,2], &emsp;&emsp; [2,1,3], &emsp;&emsp; [2,3,1],&emsp;&emsp; [3,1,2], &emsp;&emsp; [3,2,1]&emsp;&emsp; ] 解题思路：&emsp; 回溯算法： 将第j个数字与第 j , j +1 , j + 2 ,…, len(nums) - 1个数字分别交换，得到 len(nums) - j 种情况； 在每种情况下递归，将第j+1处数字与第j+1,j+2,…,len(nums) - 1处数字分别交换； 每个递归跳出后，要将交换过的元素还原，这样才能实现第一条所说的内容。 直到j == len(nums) - 1，代表此种交换组合下已经交换完毕，记录答案。 代码 第一版： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.List;//执行用时 :41 ms, 在所有 Java 提交中击败了5.01%的用户//内存消耗 :44.4 MB, 在所有 Java 提交中击败了5.03%的用户public class Solution &#123; public static void main(String[] args) &#123; int [] arr = &#123;1,2,1&#125;; permute(arr); &#125; public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backTrace(nums,0,new ArrayList&lt;&gt;(),res); return res; &#125; private static void backTrace(int[] nums, int start,ArrayList&lt;Integer&gt; tempList, List&lt;List&lt;Integer&gt;&gt; res) &#123; //start为左边界值，要跟右边界的数进行交换 if(start == nums.length)&#123; if(!res.contains(tempList))&#123; res.add(new ArrayList&lt;&gt;(tempList)); &#125; &#125; for(int i = start;i&lt;nums.length;i++)&#123; //将第j个数字与第 j , j +1 , j + 2 ,..., len(nums) - 1个数字分别交换 swap(nums,start,i); tempList.add(nums[start]); backTrace(nums,start+1,tempList,res); tempList.remove(tempList.size()-1); // 每个递归跳出后，要将交换过的元素还原 swap(nums,start,i); &#125; &#125; //交换 private static void swap(int[] nums, int start, int i) &#123; int temp = nums[start]; nums[start] = nums[i]; nums[i] = temp; &#125;&#125; 第二版：leetcode官网解答 这里有一个回溯函数，使用第一个整数的索引作为参数 backtrack(first)。 如果第一个整数有索引 n，意味着当前排列已完成。 遍历索引 first 到索引 n - 1 的所有整数。 在排列中放置第 i 个整数， 即 swap(nums[first], nums[i]). 继续生成从第 i 个整数开始的所有排列: backtrack(first + 1). 现在回溯，即通过 swap(nums[first], nums[i]) 还原. 12345678910111213141516171819202122232425262728293031 //执行用时 :3 ms, 在所有 Java 提交中击败了87.64%的用户 //内存消耗 :38.5 MB, 在所有 Java 提交中击败了67.89%的用户 class Solution &#123; public void backtrack(int n,ArrayList&lt;Integer&gt; nums, List&lt;List&lt;Integer&gt;&gt; output, int first) &#123; //如果第一个整数有索引 n，意味着当前排列已完成。 if (first == n) output.add(new ArrayList&lt;Integer&gt;(nums)); // 遍历索引 first 到索引 n - 1 的所有整数。 for (int i = first; i &lt; n; i++) &#123; //在排列中放置第 i 个整数 Collections.swap(nums, first, i); // 继续生成从第 i 个整数开始的所有排列 backtrack(n, nums, output, first + 1); //回溯 Collections.swap(nums, first, i); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; output = new LinkedList(); // convert nums into list since the output is a list of lists ArrayList&lt;Integer&gt; nums_lst = new ArrayList&lt;Integer&gt;(); for (int num : nums) nums_lst.add(num); int n = nums.length; backtrack(n, nums_lst, output, 0); return output; &#125;&#125; leetcode_【47】全排列 II https://leetcode-cn.com/problems/permutations-ii/ 题目描述：&emsp;给定一个可能包含重复数字的序列，返回其所有可能的不重复全排列。输入：&emsp;&emsp;[1,1,2]输出：&emsp;&emsp;[ &emsp;&emsp; [1,1,2], &emsp;&emsp; [1,2,1], &emsp;&emsp; [2,1,1], &emsp;&emsp; ] 代码第一版： 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.List;//执行用时 :742 ms, 在所有 Java 提交中击败了8.80%的用户//内存消耗 :45.7 MB, 在所有 Java 提交中击败了44.99%的用户public class Solution&#123; public static List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backTrace(nums,0,new ArrayList&lt;&gt;(),res); return res; &#125; private static void backTrace(int[] nums, int start,ArrayList&lt;Integer&gt; tempList, List&lt;List&lt;Integer&gt;&gt; res) &#123; //start为边界值 if(start == nums.length)&#123; //加了这一句 if(!res.contains(tempList))&#123; res.add(new ArrayList&lt;&gt;(tempList)); &#125; &#125; for(int i = start;i&lt;nums.length;i++)&#123; swap(nums,start,i); tempList.add(nums[start]); backTrace(nums,start+1,tempList,res); tempList.remove(tempList.size()-1); swap(nums,start,i); &#125; &#125; private static void swap(int[] nums, int start, int i) &#123; int temp = nums[start]; nums[start] = nums[i]; nums[i] = temp; &#125; &#125; 优化的第二版:leetcode官网解答 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//执行用时 :6 ms, 在所有 Java 提交中击败了63.63%的用户//内存消耗 :42.8 MB, 在所有 Java 提交中击败了76.28%的用户public class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); private boolean[] used; private void findPermuteUnique(int[] nums, int depth, Stack&lt;Integer&gt; stack) &#123; if (depth == nums.length) &#123; res.add(new ArrayList&lt;&gt;(stack)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (!used[i]) &#123; // 修改 2：因为排序以后重复的数一定不会出现在开始，故 i &gt; 0 // 和之前的数相等，并且之前的数还未使用过，只有出现这种情况，才会出现相同分支 // 这种情况跳过即可 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123; continue; &#125; used[i] = true; stack.add(nums[i]); findPermuteUnique(nums, depth + 1, stack); stack.pop(); used[i] = false; &#125; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; int len = nums.length; if (len == 0) &#123; return res; &#125; // 修改 1：首先排序，之后才有可能发现重复分支 Arrays.sort(nums); used = new boolean[len]; findPermuteUnique(nums, 0, new Stack&lt;&gt;()); return res; &#125; public static void main(String[] args) &#123; int[] nums = &#123;1, 1, 2&#125;; Solution solution = new Solution(); List&lt;List&lt;Integer&gt;&gt; permuteUnique = solution.permuteUnique(nums); System.out.println(permuteUnique); &#125;&#125; leetcode_【77】组合https://leetcode-cn.com/problems/combinations/ &emsp;给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 输入: &emsp;&emsp;n = 4, k = 2 输出: &emsp;&ensp; [ &emsp;&emsp; [2,4], &emsp;&emsp; [3,4], &emsp;&emsp; [2,3], &emsp;&emsp; [1,2], &emsp;&emsp; [1,3], &emsp;&emsp; [1,4], &emsp;&ensp; ] 12345678910111213141516171819202122&gt; //执行用时 :40 ms, 在所有 Java 提交中击败了52.77%的用户&gt; //内存消耗 :52.5 MB, 在所有 Java 提交中击败了26.41%的用户&gt; public class Solution &#123;&gt; public static List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;&gt; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();&gt; backtrack(k,n,1,new ArrayList(),res);&gt; return res;&gt; &#125;&gt; public static void backtrack(int k,int n,int start,List&lt;Integer&gt; tmplist,List&lt;List&lt;Integer&gt;&gt; result)&#123;&gt; if(k == 0)&#123;&gt; result.add(new ArrayList&lt;&gt;(tmplist));&gt; &#125;else &#123;&gt; for (int i = start; i &lt;= n; i++) &#123;&gt; tmplist.add(i);&gt; //递归，这里回溯 从 i+1 ~ n 中 k-1 个数的组合，直到k == 0就可将这次结果存到res里面&gt; backtrack( k - 1, n, i+1,tmplist, result);&gt; tmplist.remove(tmplist.size()-1);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; leetcode_【39】组合总和 I&emsp;&emsp;&emsp;https://leetcode-cn.com/problems/combination-sum/ &emsp;给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以&gt;使数字和为 target 的组合。&emsp;candidates 中的数字可以无限制重复被选取。说明：&emsp; (1)所有数字（包括 target）都是正整数。&emsp;(2)解集不能包含重复的组合。 示例 1: 输入: &emsp;&emsp; candidates = [2,3,6,7], target = 7, 所求解集为: &emsp;&emsp; [ &emsp;&emsp; [7], &emsp;&emsp; [2,2,3] &emsp;&emsp; ] 示例 2: 输入: &emsp;&emsp;candidates = [2,3,5], target = 8, 所求解集为: &emsp;&emsp;[ &emsp;&emsp;[2,2,2,2], &emsp;&emsp; [2,3,3], &emsp;&emsp; [3,5] &emsp;&emsp;] 代码123456789101112131415161718192021222324252627282930313233//执行用时 :7 ms, 在所有 Java 提交中击败了81.11%的用户//内存消耗 :39.1 MB, 在所有 Java 提交中击败了87.66%的用户class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; //存放结果 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //排序 Arrays.sort(candidates); //从第一个数开始递归 calculate(candidates,target,0,new ArrayList&lt;&gt;(),res); return res; &#125; public static void calculate(int[] candidates,int target,int start,ArrayList&lt;Integer&gt; tmpList,List&lt;List&lt;Integer&gt;&gt; result) &#123; //回溯 if (target &lt; 0) &#123; return; &#125; //存入结果集 else if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(tmpList)); return; &#125; else &#123; for (int i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123; //加入 tmpList.add(candidates[i]); //递归,candidates 中的数字可以使用无数次，故start还是从 i 开始 calculate( candidates, target - candidates[i], i, tmpList,result); //清空所得到的一次结果的list tmpList.remove(tmpList.size() - 1); &#125; &#125; &#125; leetcode_【40】组合总和 II&emsp;&emsp;&emsp;https://leetcode-cn.com/problems/combination-sum-ii/ &emsp;&emsp;给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。&emsp;candidates 中的数字可以只能使用一次。说明：&emsp; (1)所有数字（包括 target）都是正整数。&emsp;(2)解集不能包含重复的组合。输入:&emsp;&emsp;candidates = [10,1,2,7,6,1,5], target = 8，所求解集为: &emsp;&ensp; [ &emsp;&emsp; [1, 7], &emsp;&emsp; [1, 2, 5], &emsp;&emsp; [2, 6], &emsp;&emsp; [1, 1, 6] &emsp;&ensp; ] 示例 2: 输入: &emsp;&emsp; candidates = [2,5,2,1,2], target = 5, 所求解集为: &emsp;&ensp; [ &emsp;&emsp;[1,2,2], &emsp;&emsp; [5] &emsp;&ensp; ] 代码12345678910111213141516171819202122232425262728293031 //执行用时 :30 ms, 在所有 Java 提交中击败了22.59%的用户//内存消耗 :45 MB, 在所有 Java 提交中击败了27.34%的用户public class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //排序 Arrays.sort(candidates); //从下标为0，目标为target的开始回溯 backTrace(candidates,target,0,new ArrayList&lt;&gt;(),res); return res; &#125; private static void backTrace(int[] candidates, int target,int start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res) &#123; if(target&lt;0) return; // else if(target == 0)&#123; //解集不能包含重复的组合。 Collections.sort(tmpList); if(!res.contains(tmpList))&#123; res.add(new ArrayList&lt;&gt;(tmpList)); &#125; &#125;else &#123; for (int i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++) &#123; tmpList.add(candidates[i]); //回溯,因为candidates 中的数字可以只能使用一次，所以这里start变成了i+1 backTrace(candidates, target - candidates[i], i + 1, tmpList, res); tmpList.remove(tmpList.size() - 1); &#125; &#125; &#125; leetcode_【216】组合总和III https://leetcode-cn.com/problems/combination-sum-iii/submissions/ &emsp;&emsp;找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： &emsp;所有数字都是正整数。 &emsp; 解集不能包含重复的组合。 示例 1: 输入: &emsp;&emsp; k = 3, n = 7 输出: &emsp;&emsp; [[1,2,4]] 示例 2: 输入: &emsp;&emsp;k = 3, n = 9 输出: &emsp;&emsp; [[1,2,6], [1,3,5], [2,3,4]] 代码123456789101112131415161718192021222324 //执行用时 :5 ms, 在所有 Java 提交中击败了8.96%的用户//内存消耗 :34.1 MB, 在所有 Java 提交中击败了28.88%的用户class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backTrace(k,n,1,new ArrayList&lt;&gt;(),res); return res; &#125; private static void backTrace(int k, int target,int start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res) &#123; if(0 == k &amp;&amp; target == 0)&#123; Collections.sort(tmpList); if(!res.contains(tmpList)) res.add(new ArrayList&lt;&gt;(tmpList)); &#125;else&#123; // 组合数中只包含1-9的数，故i&lt;=9 for(int i = start;i &lt;= 9 ;i++)&#123; tmpList.add(i); backTrace(k-1,target - i,i+1,tmpList,res); tmpList.remove(tmpList.size()-1); &#125; &#125; &#125;&#125; leetcode_【377】组合总和 IV &emsp;给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: &emsp;&emsp; nums = [1, 2, 3] &emsp;&emsp;target = 4 所有可能的组合为： &emsp;&emsp; (1, 1, 1, 1) &emsp;&emsp; (1, 1, 2) &emsp;&emsp; (1, 2, 1) &emsp;&emsp; (1, 3) &emsp;&emsp; (2, 1, 1) &emsp;&emsp; (2, 2) &emsp;&emsp; (3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。 代码 回溯超出内存限制 1234567891011121314151617181920 public static int combinationSum4(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); backTrace(nums,target,0,new ArrayList&lt;&gt;(),res); return res.size(); &#125;private static void backTrace(int[] nums, int target, int start, ArrayList&lt;Integer&gt; tmpList, List&lt;List&lt;Integer&gt;&gt; res) &#123; if(target &lt; 0)&#123; return; &#125;else if(target == 0)&#123; res.add(new ArrayList&lt;&gt;(tmpList)); &#125;else&#123; for(int i = 0;i&lt;nums.length &amp;&amp; target &gt;= nums[i];i++)&#123; tmpList.add(nums[i]); backTrace(nums,target - nums[i],i,tmpList,res); tmpList.remove(tmpList.size()-1); &#125; &#125;&#125; 动态规划：dp[i] 代表组成i 能有多少种组合数，即dp[1] = 2代表 和为1的组合个数为2 初始化 dp[0] = 1;即组成和为0的组合数为1，即都nums里面的数都不取 状态转移方程： dp[i]=dp[ i - nums[0] ]+dp[ i - nums[1] ]+dp[ i - nums[2] ] + ... 举个例子 : 比如nums=[1,3,4],target=7;dp[7]=dp[6]+dp[4]+dp[3] 123456789101112131415//执行用时 :5 ms, 在所有 Java 提交中击败了68.54%的用户//内存消耗 :34.3 MB, 在所有 Java 提交中击败了39.00%的用户public static int combinationSum6(int[] nums, int target) &#123; int dp[] = new int[target + 1]; //初始化 dp[0] = 1; for(int i = 1;i&lt;=target;i++)&#123; for(int j = 0;j&lt;nums.length;j++)&#123; if(i - nums[j] &gt;= 0 )&#123; dp[i] += dp[i-nums[j]]; &#125; &#125; &#125; return dp[target];&#125; leetcode_【51】N皇后 Ihttps://leetcode-cn.com/problems/n-queens/ &emsp; n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp; 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 &emsp; 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例: 输入: &emsp; 4 输出: &emsp; &ensp; [ &emsp; &emsp; [“.Q..”, // 解法 1 &emsp; &emsp; “…Q”, &emsp; &emsp; “Q…”, &emsp; &emsp; “..Q.” ], &emsp; &ensp; [ “..Q.”, // 解法 2 &emsp; &emsp; “Q…”, &emsp; &emsp; “…Q”, &emsp; &emsp; “.Q..”] &emsp; &ensp; ] 解释: 4 皇后问题存在两个不同的解法。 代码 回溯函数 backtrack(row = 0). 从第一个 row = 0 开始. 循环列并且试图在每个 column 中放置皇后. 如果方格 (row, column) 不在攻击范围内 在 (row, column) 方格上放置皇后 排除对应行，列和两个对角线的位置。 If 所有的行被考虑过，row == NunOfQueen 意味着我们找到了一个解 else 继续考虑接下来的皇后放置 backtrack(row + 1). 回溯：将在 (row, column) 方格的皇后移除. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package leetcode.Arrays.回溯;import java.lang.reflect.Array;import java.util.*;//执行用时 :9 ms, 在所有 Java 提交中击败了53.89%的用户//内存消耗 :39.3 MB, 在所有 Java 提交中击败了84.75%的用户public class Main_51 &#123; public static List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //用于存储行 List&lt;Integer&gt; col = new ArrayList&lt;&gt;(); //用于存储正对角线 List&lt;Integer&gt; z_diagonal = new ArrayList&lt;&gt;(); //用于存储负对角线 List&lt;Integer&gt; f_diagonal = new ArrayList&lt;&gt;(); //存储结果 List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //从第一个row = 0开始 backtrack(0, n, res, new ArrayList&lt;String&gt;(), col, z_diagonal, f_diagonal); return res; &#125; public static void backtrack(int row, int NumOfQueen, List&lt;List&lt;String&gt;&gt; res, ArrayList&lt;String&gt; tmplist, List&lt;Integer&gt; col, List&lt;Integer&gt; z_diagonal, List&lt;Integer&gt; f_diagonal) &#123; //到达了最后一行 if (row == NumOfQueen) &#123; res.add(new ArrayList&lt;&gt;(tmplist)); return; &#125; //从第0列开始遍历 for (int column = 0; column &lt; NumOfQueen; column++) &#123; //如果不在攻击范围内（不在同一行或者同一列 &amp;&amp; 负对角线和相等 &amp;&amp; 正对角线差相等） if (!col.contains(column) &amp;&amp; !f_diagonal.contains(row + column) &amp;&amp; !z_diagonal.contains(row - column)) &#123; col.add(column); f_diagonal.add(row + column); z_diagonal.add(row - column); char[] s = new char[NumOfQueen]; Arrays.fill(s, '.'); //这一行的j位置放皇后 s[column] = 'Q'; tmplist.add(new String(s)); //回溯算法 backtrack(row+1,NumOfQueen,res,tmplist,col,z_diagonal,f_diagonal); tmplist.remove(tmplist.size() - 1); col.remove(Integer.valueOf(column)); f_diagonal.remove(Integer.valueOf(row + column)); z_diagonal.remove(Integer.valueOf(row - column)); &#125; &#125; &#125;&#125; leetcode_【52】N皇后 IIhttps://leetcode-cn.com/problems/n-queens-ii/ &emsp; n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp; 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 &emsp; 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例: 输入: &emsp; 4 输出: &emsp; 2 解释：4皇后存在两种不同的解法 &emsp; &ensp; [ &emsp; &emsp; [“.Q..”, // 解法 1 &emsp; &emsp; “…Q”, &emsp; &emsp; “Q…”, &emsp; &emsp; “..Q.” ], &emsp; &ensp; [ “..Q.”, // 解法 2 &emsp; &emsp; “Q…”, &emsp; &emsp; “…Q”, &emsp; &emsp; “.Q..”] &emsp; &ensp; ] 如leetcode_【51】代码返回res.size(); 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445//执行用时 :29 ms, 在所有 Java 提交中击败了5.45%的用户//内存消耗 :34.8 MB, 在所有 Java 提交中击败了41.25%的用户public class Solution &#123; public static int totalNQueens(int n) &#123; //用于存储行 List&lt;Integer&gt; col = new ArrayList&lt;&gt;(); //用于存储正对角线 List&lt;Integer&gt; z_diagonal = new ArrayList&lt;&gt;(); //用于存储负对角线 List&lt;Integer&gt; f_diagonal = new ArrayList&lt;&gt;(); //存储结果 List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //从第一个row = 0开始 backtrack(0, n, res, new ArrayList&lt;String&gt;(), col, z_diagonal, f_diagonal); return res.size(); &#125; public static void backtrack(int row, int NumOfQueen, List&lt;List&lt;String&gt;&gt; res, ArrayList&lt;String&gt; tmplist, List&lt;Integer&gt; col, List&lt;Integer&gt; z_diagonal, List&lt;Integer&gt; f_diagonal) &#123; //到达了最后一行 if (row == NumOfQueen) &#123; res.add(new ArrayList&lt;&gt;(tmplist)); return; &#125; //从第0列开始遍历 for (int column = 0; column &lt; NumOfQueen; column++) &#123; //如果不在攻击范围内（不在同一行或者同一列 &amp;&amp; 负对角线和相等 &amp;&amp; 正对角线差相等） if (!col.contains(column) &amp;&amp; !f_diagonal.contains(row + column) &amp;&amp; !z_diagonal.contains(row - column)) &#123; col.add(column); f_diagonal.add(row + column); z_diagonal.add(row - column); char[] s = new char[NumOfQueen]; Arrays.fill(s, '.'); //这一行的j位置放皇后 s[column] = 'Q'; tmplist.add(new String(s)); //回溯算法 backtrack(row+1,NumOfQueen,res,tmplist,col,z_diagonal,f_diagonal); tmplist.remove(tmplist.size() - 1); col.remove(Integer.valueOf(column)); f_diagonal.remove(Integer.valueOf(row + column)); z_diagonal.remove(Integer.valueOf(row - column)); &#125; &#125; &#125;&#125; leetcode_【78】子集I https://leetcode-cn.com/problems/subsets/ &emsp;给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 &emsp;说明：解集不能包含重复的子集。 &emsp;示例: 输入: &emsp;&emsp;nums = [1,2,3] 输出: &emsp;&ensp; [ &emsp;&emsp; [3], &emsp;&emsp; [1], &emsp;&emsp; [2], &emsp;&emsp; [1,2,3], &emsp;&emsp; [1,3], &emsp;&emsp; [2,3], &emsp;&emsp; [1,2], &emsp;&emsp; [] &emsp;&ensp; ] 代码123456789101112131415161718//执行用时 :2 ms, 在所有 Java 提交中击败了87.86%的用户//内存消耗 :37 MB, 在所有 Java 提交中击败了44.12%的用户class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); backTrace(nums,0,new ArrayList&lt;&gt;(),res); return res; &#125; private static void backTrace(int[] nums, int start, ArrayList&lt;Integer&gt; tmplist, List&lt;List&lt;Integer&gt;&gt; res) &#123; res.add(new ArrayList&lt;&gt;(tmplist)); for(int i = start;i&lt;nums.length;i++)&#123; tmplist.add(nums[i]); backTrace(nums,i+1,tmplist,res); tmplist.remove(tmplist.size()-1); &#125; &#125;&#125; leetcode_【90】子集 IIhttps://leetcode-cn.com/problems/subsets-ii/ 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: &emsp; [1,2,2] 输出: &emsp; &ensp; [ &emsp; &emsp; [2], &emsp; &emsp; [1], &emsp; &emsp; [1,2,2], &emsp; &emsp; [2,2], &emsp; &emsp; [1,2], &emsp; &emsp; [] &emsp; &ensp; ] 代码123456789101112131415161718192021222324//执行用时 :3 ms, 在所有 Java 提交中击败了87.52%的用户//内存消耗 :38.5 MB, 在所有 Java 提交中击败了47.42%的用户class Solution &#123; public static List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); backTrace(nums,0,new ArrayList&lt;&gt;(),res); return res; &#125; private static void backTrace(int[] nums, int start, ArrayList&lt;Integer&gt; tmplist, List&lt;List&lt;Integer&gt;&gt; res) &#123; res.add(new ArrayList&lt;&gt;(tmplist)); for(int i = start;i&lt;nums.length;i++)&#123; //和上一个数字相等则跳过 if(i &gt; start &amp;&amp; nums[i] == nums[i-1] )&#123; continue; &#125;else&#123; tmplist.add(nums[i]); backTrace(nums,i+1,tmplist,res); tmplist.remove(tmplist.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【102】二叉树的层次遍历]]></title>
    <url>%2F2019%2F06%2Fleetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; 返回其层次遍历结果： [ [3], [9,20], [15,7]] 2.解题思路 同【剑指offer - 60】 BFS广度优先搜索的扩展题 迭代思想： 我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。 第 0 层只包含根节点 root ，算法实现如下： (1)初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。 (2)当队列非空的时候： 1) 在输出结果 levels 中插入一个空列表，开始当前层的算法。 2)计算当前层有多少个元素：等于队列的长度。 3)将这些元素从队列中弹出，并加入 levels 当前层的空列表中。 4)将他们的孩子节点作为下一层压入队列中。 5)进入下一层 level++。 递归思想： 最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下： (1)输出列表称为 ans，当前最高层数就是列表的长度 len(ans)。比较访问节点所在的层次 level 和当前最高层次 len(ans) 的大小，如果前者更大就向 ans 添加一个空列表。 (2)将当前节点插入到对应层的列表 ans[level] 中。 (3)递归非空的孩子节点：helper(node.left , level + 1)。helper(node.right, level + 1)。 3.代码方法1：迭代 12345678910111213141516171819202122232425262728293031323334执行用时 : 3 ms, 在所有 Java 提交中击败了55.91%的用户内存消耗 : 36.5 MB, 在所有 Java 提交中击败了44.59%的用户 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; //用于记录所有结果 List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); if(root == null) return lists; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; //用于保存当前层的节点数 ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); //当前层包含的节点个数 int count = queue.size(); for(int i = 0; i&lt;count;i++)&#123; //删除并返回queue中的头元素，删掉根（上一层结点元素） TreeNode node = queue.poll(); //加入左子树 if(node.left!=null) queue.add(node.left); //加入右子树 if(node.right!=null) queue.add(node.right); //加入当前层的节点 tmp.add(node.val); &#125; lists.add(tmp); &#125; return lists; &#125; 方法2：递归 12345678910111213141516171819202122232425执行用时 : 2 ms, 在所有 Java 提交中击败了92.32%的用户内存消耗 : 37.1 MB, 在所有 Java 提交中击败了42.97%的用户class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if(root == null) return ans; helper(root,0); return ans; &#125; private void helper(TreeNode root, int level) &#123; if(ans.size() == level) ans.add(new ArrayList&lt;&gt;()); ans.get(level).add(root.val); if(root.left != null) helper(root.left,level+1); if(root.right != null) helper(root.right,level+1); &#125;&#125; 4.提交结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>中等</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【108】将有序数组转换成二叉搜索树]]></title>
    <url>%2F2019%2F06%2Fleetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 123456&gt; 0&gt; / \&gt; -3 9&gt; / /&gt; -10 5&gt; 2.解题思路 将一个排序array转化为平衡二叉搜索树：平衡二叉树：对于每个根节点，左右子树高度差 &lt;= 1；二叉搜索树：对于每个节点，其左子树值&lt;此节点值，右子树&gt;此节点值。要满足以上两个特点，我们自然想到以array中点值作为根节点值，并递归重建，这样就可以同时保证以上两个条件。 3.代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 执行用时 : 3 ms, 在所有 Java 提交中击败了8.50%的用户 内存消耗 : 40.2 MB, 在所有 Java 提交中击败了29.40%的用户class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(nums.length == 0) return null; //将最中间的数作为根节点 TreeNode root =new TreeNode( nums[nums.length/2]); //以中间的树为分界，左边归属于左子树，右边归属于右子树 root.left = sortedArrayToBST(Arrays.copyOfRange(nums,0,nums.length/2)); root.right = sortedArrayToBST(Arrays.copyOfRange(nums,nums.length/2+1,nums.length)); return root; &#125;&#125; 执行用时为2ms的范例： 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; // 左右等分建立左右子树，中间节点作为子树根节点，递归该过程 return nums == null ? null : buildTree(nums, 0, nums.length - 1); &#125; private TreeNode buildTree(int[] nums, int left, int right) &#123; if (left &gt; right) &#123; return null; &#125; int mid = left + (right - left) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = buildTree(nums, left, mid - 1); root.right = buildTree(nums, mid + 1, right); return root; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>简单</tag>
        <tag>深度优先遍历</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【106】从中序与后序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F06%2Fleetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]返回如下的二叉树： 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; 2.解题思路 中序9,3,15,20,7,后序 9,15,7,20,3 有如下特征： 后序中最后一位1肯定是根结点，我们可以据此找到中序中根结点的位置root； 中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，我们就可以得出左子树结点个数为int left = rootin - leftin;； 后序中结点分布应该是：[左子树结点，右子树结点，根结点]； 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围； 如果我们要后序遍历生成二叉树的话，下一层递归应该是： 左子树：root.left = buildTree(中序左子树范围，后序左子树范围);； 右子树：root.right = buildTree(中序右子树范围，后序左子树范围，);。 每一层递归都要返回当前根结点root； 3.代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 执行用时 : 42 ms, 在所有 Java 提交中击败了15.47%的用户 内存消耗 : 78.1 MB, 在所有 Java 提交中击败了5.17%的用户class Solution &#123; public static TreeNode buildTree(int[] inorder, int[] postorder) &#123; if(inorder.length == 0||postorder.length == 0) return null; //根节点为后序遍历的最后一个节点 TreeNode root = new TreeNode(postorder[postorder.length-1]); for(int i = 0;i&lt;inorder.length;i++)&#123; //找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点 if(inorder[i] == postorder[postorder.length-1])&#123; //递归构建左子树，此时,中序缩小为[0,i),后序的范围缩小为[0,i] root.left = buildTree(Arrays.copyOfRange(inorder,0,i),Arrays.copyOfRange(postorder,0,i)); //递归构建右子树,中序缩小为[i+1,len),后序的范围缩小为[i,len-1), root.right = buildTree(Arrays.copyOfRange(inorder,i+1,inorder.length),Arrays.copyOfRange(postorder,i,postorder.length-1)); break; &#125; &#125; return root; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>深度优先遍历</tag>
        <tag>中等</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【105】从前序与中序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F06%2Fleetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 123456&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; 2.解题思路 同【剑指offer_4】 前序3,9,20,15,7 ，中序9,3,15,20,7； 有如下特征： 前序中左起第一位3肯定是根结点，我们可以据此找到中序中根结点的位置root； 中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，我们就可以得出左子树结点个数为int left = rootin - leftin;； 前序中结点分布应该是：[根结点，左子树结点，右子树结点]； 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围； 如果我们要前序遍历生成二叉树的话，下一层递归应该是： 左子树：root.left = buildTree(前序左子树范围，中序左子树范围);； 右子树：root.right = buildTree(前序右子树范围，中序右子树范围);。 每一层递归都要返回当前根结点root； 3.代码123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 执行用时 : 43 ms, 在所有 Java 提交中击败了15.42%的用户 内存消耗 : 76.5 MB, 在所有 Java 提交中击败了6.76%的用户class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder.length == 0 || inorder.length == 0) return null; //根节点 TreeNode root = new TreeNode(preorder[0]); for(int i = 0;i&lt;inorder.length;i++)&#123; //找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点 if(preorder[0] == inorder[i])&#123; //递归构建左子树，此时前序的范围缩小为[1,i],中序缩小为[0,i) root.left = buildTree(Arrays.copyOfRange(preorder,1,i+1),Arrays.copyOfRange(inorder,0,i)); //递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len) root.right = buildTree(Arrays.copyOfRange(preorder,i+1,preorder.length),Arrays.copyOfRange(inorder,i+1,inorder.length)); break; &#125; &#125; return root; &#125;&#125; 执行用时32ms的范例： 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if (preorder.length != inorder.length) &#123; return null; &#125; return buildHelper(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1); &#125; private TreeNode buildHelper(int[] preorder, int[] inorder, int preL, int preR, int inL, int inR) &#123; if (preL &gt; preR) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preL]); int rootIdx = -1; for (int i = inL; i &lt;= inR; i ++) &#123; if (inorder[i] == preorder[preL]) &#123; rootIdx = i; break; &#125; &#125; if (rootIdx == -1) &#123; return null; &#125; root.left = buildHelper(preorder, inorder, preL + 1, rootIdx - inL + preL, inL, rootIdx - 1); root.right = buildHelper(preorder, inorder, rootIdx - inL + preL + 1, preR, rootIdx + 1, inR); return root; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>中等</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【101】对称二叉树]]></title>
    <url>%2F2019%2F06%2Fleetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 123456&gt; 1&gt; / \&gt; 2 2&gt; / \ / \&gt; 3 4 4 3&gt; 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 123456&gt; 1&gt; / \&gt; 2 2&gt; \ \&gt; 3 3&gt; 2.解题思路方法1：递归 如果一个树的左子树与右子树镜像对称，那么这个树是对称的。 因此，该问题可以转化为：两个树在什么情况下互为镜像？ 如果同时满足下面的条件，两个树互为镜像： (1)它们的两个根结点具有相同的值。(2)每个树的右子树都与另一个树的左子树镜像对称。 递归过程： 判断两个指针当前节点值是否相等 判断 A 的右子树与 B 的左子树是否对称 判断 A 的左子树与 B 的右子树是否对称 方法2：迭代 类似于广度优先遍历BFS，用一个队列queue存储左右节点。其中队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。 (1) 最初，队列中包含的是 root 以及 root。每次提取两个结点并比较它们的值。 (2)当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。 (3)然后，将两个结点的左右子结点按相反的顺序插入队列中。 3.代码方法1：递归 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 执行用时 : 2 ms, 在所有 Java 提交中击败了84.89%的用户 内存消耗 : 35.5 MB, 在所有 Java 提交中击败了80.63%的用户class Solution &#123; public static boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; return Symmetric(root.left,root.right); &#125; public static boolean Symmetric(TreeNode leftroot,TreeNode rightroot) &#123; if(leftroot==null &amp;&amp; rightroot==null) return true; if(leftroot==null || rightroot == null) return false; if(leftroot.val != rightroot.val) return false; return Symmetric(leftroot.left,rightroot.right) &amp;&amp; Symmetric(leftroot.right,rightroot.left); &#125;&#125; 方法2：迭代 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 执行用时 : 3 ms, 在所有 Java 提交中击败了28.02%的用户 内存消耗 : 35.7 MB, 在所有 Java 提交中击败了80.01%的用户class Solution &#123; public static boolean isSymmetric(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); queue.add(root); while(!queue.isEmpty())&#123; TreeNode node1 = queue.poll(); TreeNode node2 = queue.poll(); if(node1==null &amp;&amp; node2==null) continue; if(node1==null || node2==null) return false; if(node1.val!=node2.val) return false; queue.add(node1.left); queue.add(node2.right); queue.add(node1.right); queue.add(node2.left); &#125; return true; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>简单</tag>
        <tag>深度优先遍历</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【100】相同的树]]></title>
    <url>%2F2019%2F06%2Fleetcode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 12345678910111213141516171819202122232425&gt; 示例 1:&gt; 输入: 1 1&gt; / \ / \&gt; 2 3 2 3&gt; &gt; [1,2,3], [1,2,3]&gt; 输出: true&gt; &gt; 示例 2:&gt; &gt; 输入: 1 1&gt; / \&gt; 2 2&gt; &gt; [1,2], [1,null,2]&gt; 输出: false&gt; &gt; 示例 3:&gt; 输入: 1 1&gt; / \ / \&gt; 2 1 1 2&gt; &gt; [1,2,1], [1,1,2]&gt; 输出：false&gt; 2.解题思路 最简单的策略是使用递归。检查p和q节点是否不是空，它们的值是否相等。如果所有检查都正常，则递归地为子节点执行相同操作。 3.代码123456789101112131415161718192021222324执行用时 : 1 ms, 在所有 Java 提交中击败了86.63%的用户内存消耗 : 34.2 MB, 在所有 Java 提交中击败了85.19%的用户/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q==null) return true; if(p==null ||q == null) return false; if(p.val !=q.val) return false; return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); &#125;&#125; 4. 提交结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>简单</tag>
        <tag>深度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【104】二叉树的最大深度]]></title>
    <url>%2F2019%2F06%2Fleetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[1. 题目描述 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 1234567&gt; 3&gt; / \&gt; 9 20&gt; / \&gt; 15 7&gt; 返回它的最大深度 3 。&gt; 2.解题思路同 【剑指offer38题】 递归实现 3.代码1234567891011121314151617181920212223242526执行用时 : 1 ms, 在所有 Java 提交中击败了98.19%的用户内存消耗 : 37.5 MB, 在所有 Java 提交中击败了45.48%的用户/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root!=null)&#123; int left_height = maxDepth(root.left); int right_height = maxDepth(root.right); return Math.max(left_height,right_height)+1; &#125;else&#123; return 0; &#125; &#125;&#125; 4.提交结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>简单</tag>
        <tag>深度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度优先遍历和广度优先遍历]]></title>
    <url>%2F2019%2F06%2F%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[深度优先遍历(DFS) 假设给定图G的初态是所有顶点均未曾访问过。在G中任选一顶点v为初始出发点(源点)，则深度优先遍历可定义如下： (1)首先访问出发点v，并将其标记为已访问过； (2)然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和源点v有路径相通的顶点(亦称为从源点可达的顶点)均已被访问为止。 (3)若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点作为新的源点重复上述过程，直至图中所有顶点均已被访问为止。 123456789&gt; A&gt; / \&gt; B C&gt; / \ / &gt; E F G&gt; /&gt; I&gt; 深度遍历结果为： A--B--E--F--I--C--G(假设先走子节点的的左侧)&gt; 遍历过程如下： 先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。 (1)首先将A节点压入栈中，stack（A）; (2)将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)； (3)将B节点弹出，同时将B的子节点F，E压入栈中，此时E在栈的顶部，stack（E,F,C）； (4)将E节点弹出，没有子节点压入,此时E在栈的顶部，stack（F，C）； (5)将F节点弹出，同时将F的子节点I压入，stack（I,C）； (6)将I节点弹出，没有子节点压入,此时C在栈的顶部，stack（C）； (7)将C节点弹出，同时将C的子节点G压入栈中，stack(G)； (8)将C节点弹出，没有子节点压入，stack为空； 最终遍历完成。 123456789101112131415161718192021222324252627// class TreeNode &#123;// int val;// TreeNode left;// TreeNode right;//// public TreeNode(int val) &#123;// this.val = val;// &#125;// &#125;public static ArrayList&lt;Integer&gt; DFS(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; stack.push(root); while (!stack.isEmpty())&#123; TreeNode node = stack.pop(); //先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。 if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); res.add(node.val); &#125; return res; &#125; 递归实现： 1234567891011121314class solution&#123; ArrayList&lt;Integer&gt; ans = new ArrayList(); public static ArrayList&lt;Integer&gt; DFS(TreeNode root) &#123; if (root != null) &#123; ans.add(root.val); DFS(root.left); DFS(root.right); &#125; return ans; &#125;&#125; 广度优先遍历(BFS) 广度优先遍历从某个顶点出发，首先访问这个顶点，然后找出这个结点的所有未被访问的邻接点，访问完后再访问这些结点中第一个邻接点的所有结点，重复此方法，直到所有结点都被访问完为止。 1、从图中某个顶点V0出发，并访问此顶点； 2、从V0出发，访问V0的各个未曾访问的邻接点W1，W2，…,Wk;然后,依次从W1,W2,…,Wk出发访问各自未被访问的邻接点； 3、重复步骤2，直到全部顶点都被访问为止。 123456789&gt; A&gt; / \&gt; B C&gt; / \ /&gt; E F G&gt; /&gt; I&gt; 深度遍历结果为： A--B--C--E--F--G--I(假设先走子节点的的左侧)&gt; 遍历过程如下： 先往队列中插入左节点，再插右节点，这样出队就是先左节点后右节点了。 (1)首先将A节点插入队列中，队列queue（A）; (2)将A节点弹出，同时将A节点的左、右节点B、C依次插入队列，queue（B，C）； (3)将B节点弹出，同时将B节点的左、右节点E、F依次插入队列，queue（C, E, F）； (4将C节点弹出，同时将C节点的左节点G依次插入队列，queue（E , F , G）； (5)将E节点弹出，同时将E节点的左节点I依次插入队列，queue（F , G , I）； (6)将F节点弹出，F没有子节点插入，queue（G,I）； (7)将G节点弹出，G没有子节点插入，queue（I）； (8)将I节点弹出，I没有子节点插入，queue为空； 最终遍历完成。 实现： 123456789101112131415161718192021222324252627// class TreeNode &#123;// int val;// TreeNode left;// TreeNode right;//// public TreeNode(int val) &#123;// this.val = val;// &#125;// &#125; public static ArrayList&lt;Integer&gt; BFS(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty())&#123; TreeNode node = queue.poll(); ////先往queue中压入左节点，再压右节点。 if(node.left!=null) queue.add(node.left); if(node.right!=null) queue.add(node.right); res.add(node.val); &#125; return res; &#125; &#125;]]></content>
      <tags>
        <tag>深度优先遍历</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【623】在二叉树中增加一行]]></title>
    <url>%2F2019%2F06%2Fleetcode-623-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。 添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。 将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。 如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。 123456789101112131415161718192021222324252627282930313233343536373839&gt; 示例 1:&gt; &gt; 输入:&gt; 二叉树如下所示:&gt; 4&gt; / \&gt; 2 6&gt; / \ /&gt; 3 1 5&gt; v = 1&gt; d = 2&gt; 输出:&gt; 4&gt; / \&gt; 1 1&gt; / \&gt; 2 6&gt; / \ /&gt; 3 1 5&gt; &gt; 示例 2:&gt; 输入:&gt; 二叉树如下所示:&gt; 4&gt; /&gt; 2&gt; / \&gt; 3 1&gt; v = 1&gt; d = 3&gt; 输出:&gt; 4&gt; /&gt; 2&gt; / \&gt; 1 1&gt; / \&gt; 3 1&gt; 2.解题思路3.代码方法1：递归 123456789101112131415161718public static TreeNode addOneRow(TreeNode root, int v, int d) &#123; TreeNode node = new TreeNode(v); //d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。 if(d == 1)&#123; node.left = root; return node; &#125; // if(d == 0)&#123; node.right = root; return node; &#125; if(root != null &amp;&amp; d&gt;1)&#123; root.left = addOneRow(root.left ,v, d &gt; 2 ? d - 1 : 1); root.right = addOneRow(root.right,v, d &gt; 2 ? d - 1 : 0); &#125; return root; &#125; 方法2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public static TreeNode addOneRow(TreeNode root, int v, int d) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); //如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。 if(d==1)&#123; TreeNode node = new TreeNode(v); node.left = root; return node; &#125; queue.add(root); int depth = 1; TreeNode temp; //计算层数，到达前一层结束 while (!queue.isEmpty())&#123; if(depth == d-1) break; int size = queue.size(); while (size--&gt;0)&#123; temp = queue.remove(); if(temp.left!=null) queue.add(temp.left); if(temp.right!=null) queue.add(temp.right); &#125; depth++; &#125; TreeNode parent; //分别插入 while (!queue.isEmpty())&#123; parent = queue.remove(); //将v插到左子树 temp = new TreeNode(v); temp.left = parent.left; parent.left = temp; //将v插到右子树 temp = new TreeNode(v); temp.right = parent.right; parent.right = temp; &#125; return root; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【94】二叉树的中序遍历]]></title>
    <url>%2F2019%2F06%2Fleetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个二叉树，返回它的中序遍历。 示例: 123456789&gt; 输入: [1,null,2,3]&gt; 1&gt; \&gt; 2&gt; /&gt; 3&gt; 输出: [1,3,2]&gt; 进阶: 递归算法很简单，你可以通过迭代算法完成吗？&gt; 2.解题思路 思路1：使用递归 中序遍历的 左子树--&gt; 跟--&gt; 右子树 思路2：迭代 用一个指针模拟访问过程，先遍历到root的最左节点， 123456789101112&gt; 1&gt; / \&gt; 2 3&gt; / \ / &gt; 4 5 6&gt; (1)第一次循环，栈stack里面放入root的左子树：分别放入1--2--4为root的树，然后ans里面存入stack.pop(),即4，cur = cur.right = null&gt; (2)stack内有2个TreeNode,进入第二次循环，ans.add(cur.val) = 2;cur = cur.right = 5;&gt; (3)stack里面还有一个以1为root的TreeNode,进入第三次循环，stack加入以5为root的TreeNode,ans加入5，cur = null,&gt; (4)stack里面还有一个以1为root的TreeNode,进入第四次循环，ans加入1，cur = cur.right = 3&gt; (5)cur!=null,进入第四次循环,stack加入3和6为root的树，ans加入6，cur = null&gt; (6) stack里面还有一个以3为root的TreeNode,进入第五次循环，ans加入3，cur = null,stack为空，结束循环&gt; 3.代码方法1：递归 12345678910111213141516171819202122/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; res = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root==null) return res; if(root.left!=null) inorderTraversal(root.left); res.add(root.val); if(root.right!=null) inorderTraversal(root.right); return res; &#125;&#125; 方法2：迭代 123456789101112131415public static List&lt;Integer&gt; inorderTraversal2(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur!=null ||!stack.isEmpty())&#123; while (cur!=null)&#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); ans.add(cur.val); cur = cur.right; &#125; return ans; &#125; 4.提交结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【717】1比特和2比特字符]]></title>
    <url>%2F2019%2F06%2Fleetcode-717-1%E6%AF%94%E7%89%B9%E5%92%8C2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1.题目描述 有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。 现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。 示例 1: 输入: bits = [1, 0, 0] 输出: True 解释: 唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。 示例 2: 输入: bits = [1, 1, 1, 0] 输出: False 解释: 唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。 2.解题思路 从倒数第二个开始计算1的个数，直到遇到0结束，如果此时得到的1的个数是奇数个，代表最后一个0是2比特中的0，如果是偶数个，代表最后一个0是1比特中的0. 如： 111110111110 ： 得到的count = 5，则最后一个0是2比特中的0,返回false 11111011110 ： 得到的count = 4，则最后一个0是1比特中的0，返回true 3.代码1234567891011class Solution &#123; public boolean isOneBitCharacter(int[] bits) &#123; int count = 0; for(int i = bits.length -2 ; i&gt;=0 ; i--)&#123; if(bits[i]==1) count++; else break; &#125; int ret = count % 2; return ret==0; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F06%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背包问题给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。 可参考https://www.cnblogs.com/-guz/p/9866118.html 1. 0-1背包问题 我们有n种物品，物品i的重量为weight[i]，价格为value[i]。我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为total。如果限定每种物品只能选择0个或1个，求背包里面能放的最大价格。 情况1：第i件不放进去，所得价值f[i-1][v],即不放第i件，转化成前i-1件物品放入容量为v的背包中的情况 情况2：第i件放进去，所得价值f[i-1][v-weight[i]] + c[i]，转化成前i-1件物品放入剩下的容量为v-w[i]的背包中的情况 由此得到状态转移方程：注：f[i][v]表示重量不超过v公斤的最大价值 f[i][v] = Math.max(f[i-1][v],f[i-1][v-w[i]]+c[i]) 时间和空间复杂度都为O(Num*total)=O(N*N),可以将其压缩成空间为O(total) = O(N) 情况1：第i件不放进去，所得价值f[v] 情况2：第i件放进去，所得价值f[v-weight[i]]+c[i] 由此得到状态转移方程： f[v] = Math.max(f[v],f[v-w[i]]+c[i])，f[v]表示重量不超过v公斤的最大价值 123456789//weight表示每件物品的重量，value代表每件物品的价值，total 表示容量，Num表示物品数量，设 f[v]表示重量不超过v公斤的最大价值public static int ZeroOnePackage(int []weight,int []value,int []f,int Num,int total)&#123; for(int i = 0;i&lt;Num;i++)&#123; for(int v = total;v&gt;=weight[i];v--)&#123; //注意是逆序 f[v] = Math.max(f[v-weight[i]]+value[i],f[v]); &#125; &#125; return f[total];&#125; 2. 完全背包问题有Num种物品和一个容量为total的背包，每种物品都有无限件可用。第i种物品的体重量是weight[i]，价值是value[i]。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。 情况1：第i件不放进去，所得价值 f[i-1][v] 情况2：第i件放进去，所得价值 f[i-1][v-weight[i]]+c[i] 由此得到状态转移方程：，f[i][v]表示前i个背包装入重量不超过v公斤的最大价值 f[i][v] = Math.max(f[i-1][v],f[i-1][v-n*w[i]]+n*c[i]){0&lt;n*value[i]&lt;total} 时间和空间复杂度都为O(Num*total)=O(N*N),可以将其压缩成空间为O(total) = O(N) 情况1：第i件不放进去，所得价值f[v] 情况2：第i件放进去，所得价值f[v-weight[i]]+c[i] 由此得到状态转移方程：f[v]表示重量不超过v公斤的最大价值 f[v] = Math.max(f[v],f[v-n*w[i]] + n*c[i]) {0&lt;n*value[i]&lt;total} 123456789//weight表示每件物品的重量，value代表每件物品的价值，total 表示容量，Num表示物品数量，设 f[v]表示重量不超过v公斤的最大价值 public static int ZeroMorePackage(int []weight,int []value,int []f,int Num,int total)&#123; for(int i = 0;i&lt;Num;i++)&#123; for(int v = weight[i];v&lt;=total;v++)&#123; //注意是++ f[v] = Math.max(f[v-weight[i]]+value[i],f[v]); &#125; &#125; return f[total]; &#125; 3.多重背包问题有Num种物品和一个容量为total的背包。第i种物品最多有eachNum[i]件可用，每件体积是weight[i]，价值是value[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量total，且价值总和最大。 情况1：第i件不放进去，所得价值f[v] 情况2：第i件放进去，所得价值f[v-weight[i]] + c[i] 由此得到状态转移方程：f[v]表示装入重量不超过v公斤的最大价值 f[v] = Math.max(f[v] , f[v-n*w[i]] + n*c[i]) {0 &lt; k &lt; eachNum[i]，0&lt;k*value[i]&lt;total}， 123456789101112131415//多重背包问题 public static int MorePackage(int []weight,int []value,int []f,int Num,int total,int eachNum[])&#123; for(int i = 0;i&lt;Num;i++) &#123; for (int v = total; v &gt;= 0; v--) &#123; //注意是逆序 for (int k = 0; k &lt;= eachNum[i]; k++) &#123; if (v - k * weight[i] &lt; 0) &#123; break; &#125;else&#123; f[v] = Math.max(f[v - k * weight[i]] + k * value[i], f[v]); &#125; &#125; &#125; &#125; return f[total]; &#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【55】跳跃游戏]]></title>
    <url>%2F2019%2F06%2Fleetcode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 2.解题思路方法1：动态规划 从左到右依次判断索引坐标i是否能跳到，当遍历到数组末尾时，当dp[nums.length-1]==true时说明能跳到这个位置。即可以跳到最后一个位置。 方法2: 贪心算法 从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。 如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意 味着可以从第一个位置跳到最后的位置。 3.代码方法1：动态规划 1234567891011121314151617public static boolean canJump(int[] nums) &#123; if(nums==null) return false; boolean []dp = new boolean[nums.length]; dp[0] = true; for(int i = 1;i&lt;nums.length;i++)&#123; for(int j = 0;j&lt;i;j++)&#123; //如果之前j节点可达，并且从此节点可以跳到i if(dp[j] &amp;&amp; nums[j]+j&gt;=i)&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[nums.length-1]; &#125; 方法2：贪心算法 123456789public static boolean canJump2(int[] nums) &#123; int lastPos = nums.length - 1; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (i + nums[i] &gt;= lastPos) &#123; lastPos = i; &#125; &#125; return lastPos == 0; &#125; 4.提交记录方法1：动态规划 ![leetcode提交结果] (https://github.com/qiulig/IMG/raw/master/55-1.jpg) 方法2：贪心算法 ![leetcode提交结果] (https://github.com/qiulig/IMG/raw/master/55-2.jpg)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>中等</tag>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-82.删除排序链表中的重复元素2]]></title>
    <url>%2F2019%2F06%2Fleetcode-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5示例 2: 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 2.解题思路 剑指offer-56题 3.代码12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public static ListNode deleteDuplicates(ListNode head) &#123; if(head==null || head.next==null) return head; if(head.val==head.next.val)&#123; ListNode node = head.next; while( node != null &amp;&amp; head.val == node.val )&#123; node = node.next; &#125; return deleteDuplicates(node); &#125;else&#123; head.next = deleteDuplicates(head.next); return head; &#125; &#125;&#125; 4.提交结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-83.删除排序链表中的重复元素]]></title>
    <url>%2F2019%2F06%2Fleetcode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2输出: 1-&gt;2示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 2.解题思路 这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。 3.代码1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode res = head; if(head==null || head.next == null) return head; while(head!=null &amp;&amp; head.next!=null)&#123; if(head.val == head.next.val)&#123; head.next = head.next.next; &#125;else&#123; head = head.next; &#125; &#125; return res; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-各种模式应用场景]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[创建型模式将对象的创建与使用分离。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。 1234567891011- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式， 1.单例（Singleton）模式 某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 1231.某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。2.当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。3.当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。 2.原型（Prototype）模式 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 121.如果一个系统想要独立于它想要使用的对象时,可以使用原型模式,让系统只面向接口编程,在系统需要新的对象的时候,可以通过克隆原型来得到. 2.如果需要实例化的类是在运行时刻动态指定时,可以使用原型模式,通过克隆原型来得到需要的实例. 3.工厂方法（FactoryMethod）模式 定义一个用于创建产品的接口，由子类决定生产什么产品。 123451.客户类不关心使用哪个具体类,只关心该接口所提供的功能. 2.创建过程比较复杂,例如需要初始化其他关联的资源类,读取配置文件等. 3.接口有很多具体实现或者抽象类有很多具体子类时, 4.不希望给客户程序暴露过多的此类的内部结构,隐藏这些细节可以降低耦合度. 5.优化性能,比如缓存大对象或者初始化比较耗时的对象. 4.抽象工厂（AbstractFactory）模式 提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 1231.如果希望一个系统独立于它的产品的创建,组合和表示的时候,换句话说,希望一个系统只是知道产品的接口,而不关心实现的时候. 2.如果一个系统要由多个产品系列中的一个来配置的时候.换句话说,就是可以,就是可以动态地切换产品族的时候. 3.如果强调一系列相关产品的接口,以便联合使用他们的时候 5.建造者（Builder）模式 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 121.如果创建对象的算法,应该独立于该对象的组成部分以及它们的装配方式时 2.如果同一个构建过程有着不同的表示时 结构型模式结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合 或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 12345678- 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。- 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。- 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。- 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。- 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。- 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。- 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 以上 7 种结构型模式，除了 适配器模式 分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式 1.适配器模式(Adapter) 将一个类的接口转换成客户希望的另外一个接口.适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作. 1231.如果先要使用一个已经存在的类,但是它的接口不符合你的需求,这种情况可以使用适配器模式,来把已有的实现转换成你需要的接口.2.如果你想创建一个可以复用的类,这个类可能和一些不兼容的类一起工作,这中情况可以使用适配器模式,到时候需要什么就适配什么. 3.如果你想使用一些已经窜在的子类,但不对每一个子类都进行适配,这中情况可以使用适配器模式,直接适配这些子类的父类就可以了. 2.桥接模式(Bridge) 将抽象部分与它的实现部分分离,使他们可以独立变化. 12341.如果你不希望在抽象部分和实现部分采用固定的绑定关系,可以采用桥接模式. 2.如果出现抽象部分和实现部分都能够扩展的情况,可以采用桥接模式,让抽象部分和实现部分独立地变化. 3.如果希望实现部分的修改不会对客户产生影响,可以采用桥接模式. 4.如果采用继承的实现方案,会导致产生很多子类,对于这种情况,可以考虑采用桥接模式. 3.组合模式(Composite) 将对象组合成属性结构以表示&quot;部分-整体&quot;的层次结构,组合模式使用的用户对单个对象和组合对象的使用具有一致性. 121.如果你想表示对象的部分-整体层次结构,可以使用..把整体和部分的操作统一起来,使得层次结构实现更简单,从外部来使用,这个层次结构也容易. 2.如果希望同意地使用组合结构中的所有对象,可以选用,这正是组合模式提供的主要功能. 4.装饰器模式(Decorator Method) 动态的给一个对象增加一些额外的职责,就增加功能来说,装饰模式生成子类更为灵活. 121.如果需要爱不影响其他对象的情况下,以动态,透明的方式给对象添加职责,可以使用装饰模式. 2.如果不适合使用子类来进行扩展的时候,可以考虑使用装饰模式. 5.外观模式(Facade) 为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层的接口,这个接口使得这一子系统更加同容易使用. 1231.如果希望为一个复杂的子系统提供一个简单接口的时候,可以考虑使用外观模式.使用外观对象来实现大部分客户需要的功能,从而简化客户的使用. 2.如果想要让客户程序和抽象类的实现部分松散耦合,可以考虑使用外观模式,使用外观对象来将这个子系统与他的客户分离开来,从而提高子系统的独立性和可移植性. 3.如果构建多层节后的系统,可以考虑使用外观模式使用外观模式对象作为每层的入口,这样可以简化层间调用,也可以松散出层次之间的依赖关系. 6.享元模式(Flyweight) 运用共享技术有效地支持大量细粒度的对象. 12341.如果一个应用程序使用了大量的细粒度对象,可以使用享元模式来减少对象的数量. 2.如果犹豫使用大量的对象,造成很大的存储开销,可以使用享元模式来减少对象数量,并节约内存. 3.如果对象的大多数状态都可以转变成外部状态,比如通过计算得到,或者从外部传入等,可以使用享元模式来实现内部状态和外部状态的分离.4.如果不考虑对象的外部状态,可以用相对较少的共享对象取代很多组合对象,可以使用享元模式来共享对象.然后组合对象来使用这些共享对象. 7.代理模式(Proxy) 为其他对象提供一种代理以控制对这个对象的访问. 12341.需要为一个对象在不同的地址空间提供局部代表的时候,可以使用远程代理. 2.需要按照需要创建开销很大的对象的时候,可以使用虚代理. 3.需要控制对原始对象的访问的时候,可以使用保护代理. 4.需要在访问你对象执行一些附加操作的时候,可以使用智能指引代理. 行为型模式行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。 行为型模式是 设计模式中最为庞大的一类，它包含以下 11 种模式。 1234567891011- 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。- 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。- 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。- 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。- 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。- 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。- 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。- 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。- 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。- 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。- 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 1.策略模式(Strategy) 定义一系列的算法,把它们一个个封装起来,并且使他们可以相互替换.本模式使得算法可独立于使用它的客户而变化. 12341.出现有许多相关的类,仅仅是行为有差别的情况下,可以使用策略模式来使用多个行为中的一个来配置一个类的方法,实现算法动态切换 2.出现同一算法,有很多不同实现的情况下,可以使用策略模式来把这些"不同的实现"实现成为一个算法的类层次. 3.需要封装算法中,有与算法相关数据的情况下,可以使用策略模式来避免暴露这些跟算法相关的数据结构. 4.出现抽象一个定义了很多行为的类,并且是通过多个if-else语句来选择这些行为的情况下,可以使用策略模式来替换这些条件语句. 2.模版方法模式(TemplateMethod) 定义在一个操作中的算法框架,把一些步骤推迟到子类去实现.模版方法模式让子类不需要改变算法的结构而重新定义特定的算法步骤 123451.算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。2.当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。3.当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。 3.职责链模式(Chain Of Responsibility) 使多个对象都有机会处理请求,,从而避免请求的发送者和接收者之间耦合关系.将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止. 1231.如果有多个对象可以处理同一个请求,但是具体由哪个对象来处理该请求,是运行时刻动态确定的. 2.如果你想在不明确指定接收者的情况下,向多个对象中的其中一个提交请求的话,可以使用职责链模式. 3.如果想要动态指定处理一个请求的对象结合,可以使用职责链模式. 4.命令模式(Command) 将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化,对请求排队或者记录请求日志,以及支持可撤销的操作. 5.解释器模式(Interpreter) 给定一个语言,定义它的文法的一种表示,并定义一个解释器,这个解释器使用该表示来解释语言中的句子. 使用场合: 6.迭代器模式(Iterator) 提供一种方法顺序访问一个聚合对象中的各个元素,而又不需要暴露该对象的内部表示. 1231.如果你希望提供访问一个聚合对象的内容,但是又不想暴露他的内部表示的时候,可以使用迭代器模式来提供迭代器接口,从而让客户端只是通过迭代器的接口来访问聚合对象,而无须关心聚合对象的内部实现. 2.如果你希望有多种遍历方式可以访问聚合对象,可以使用3.如果你希望为遍历不同的聚合对象提供一个统一的接口,可以使用.... 7.中介模式(Mediator) 用一个中介对象类封装一系列对象的交互.中介者使得各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立地改变他们之间的交互. 121.如果一组对象之间的通信方式比较复杂,导致相互依赖,结构混乱,可以采用中介模式,把这些对象相互的交互管理起来,各个对象都只需要和中介者交互,从而是的各个对象松散耦合,结构也更清晰易懂. 2.如果一个对象引用很多的对象,并直接跟这些对象交互,导致难以复用该对象,可以采用中介者模式,把这个对象跟其他对象的交互封装到中介者对象里面,这个对象只需要和中介者对象交互就可了. 8.备忘录模式(Memento) 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态.这样以后就可将该对象恢复到原先保存的状态. 121.如果必须要保存一个对象在某一个时刻的全部或者部分状态,方便以后需要的时候,可以把该对象恢复到先前的状态,可以使用备忘录模式. 2.如果需要保存一个对象的内部状态,但是如果用接口来让其他对象直接得到这些需要保存的状态,将会暴露对象的实现希捷并破坏对象的封装性,这是可以使用备忘录. 9.观察者模式(Observer) 定义对象间的一种一对多的依赖关系.当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新. 1231.当一个抽象模型有两个方面,其中一个方面的操作依赖于另一个方面的状态变化,那么就可以选用观察者模式,将这两者封装成观察者和目标对象,当目标对象变化的时候,依赖于它的观察者对象也会发生相应的变化.这样就把抽象模型的这两个方面分离了使得,它们可以独立地改变和复用. 2.如果在更改一个对象的时候,需要同时连带改变其他对象,而且不知道究竟应该有多少对象需要被连带改变,这种情况可以选用观察者模式,被改的那一个对象很明显就相当于是目标对象,而需要连带修改的对歌其他对象,就作为多个观察着对象了. 3.当一个对象必须通知其他的对象,但是你又希望这个对象和其他被它通知的对象是松散耦合的,也就是说这个对象其实不详知道具体被通知的对象.这种情况可以选用观察者模式,这个对象就相当于是目标对象,而被它通知的对象就是观察者对象了. 10.状态模式(State) 允许一个对象在其内部状态改变是改变它的行为.对象看起来似乎修改了他的类. 1231.如果一个对象的行为取决于它的状态,而且它必须在运行时刻根据状态来改变它的行为,可以使用.来包状态和行为分离开.虽然分离了,但是状态和行为是有对应关系的,可以在运行期间,通过改变状态,就能够调用到该状态对应的状态处理对象上去从而改变对象的行为. 2.如果一个操作中含有庞大的多分枝语句,而且这些分支依赖于该对象的状态,可以使用3.把各个分支的处理分散包装到单独的对象处理类中,这样,这些分支对应的对象就可以不依赖于其他对象而独立变化了.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-观察者模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式。 优点1. 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 2. 目标与观察者之间建立了一套触发机 缺点1. 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 2. 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 组成1234567- '抽象主题'（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。- '具体主题'（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。- '抽象观察者'（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。- '具体观察者'（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。 应用场景1. 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。 2. 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 123456789在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。1. Observable类 1) Observable 类是抽象目标类，它有一个 Vector 向量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。 2)void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。 3)void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update。方法，通知它们数据发生改变。通常越晚加入向量的观察者越先得到通知。 4)void setChange() 方法：用来设置一个 boolean 类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers() 才会通知观察者。2. Observer 接口 Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ObserverPattern&#123; public static void main(String[] args) &#123; Subject subject=new ConcreteSubject(); Observer obs1=new ConcreteObserver1(); Observer obs2=new ConcreteObserver2(); subject.add(obs1); subject.add(obs2); subject.notifyObserver(); &#125;&#125;//抽象目标abstract class Subject&#123; protected List&lt;Observer&gt; observers=new ArrayList&lt;Observer&gt;(); //增加观察者方法 public void add(Observer observer) &#123; observers.add(observer); &#125; //删除观察者方法 public void remove(Observer observer) &#123; observers.remove(observer); &#125; public abstract void notifyObserver(); //通知观察者方法&#125;//具体目标class ConcreteSubject extends Subject&#123; public void notifyObserver() &#123; System.out.println("具体目标发生改变..."); System.out.println("--------------"); for(Object obs:observers) &#123; ((Observer)obs).response(); &#125; &#125; &#125;//抽象观察者interface Observer&#123; void response(); //反应&#125;//具体观察者1class ConcreteObserver1 implements Observer&#123; public void response() &#123; System.out.println("具体观察者1作出反应！"); &#125;&#125;//具体观察者1class ConcreteObserver2 implements Observer&#123; public void response() &#123; System.out.println("具体观察者2作出反应！"); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-策略模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 优点1. 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。 2. 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。 3. 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。 4. 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。 5. 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。 缺点1. 客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。 2. 策略模式造成很多的策略类。 组成12345- '抽象策略'（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。- '具体策略'（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。- '策略上下文'（Context）类：持有一个策略类的引用，最终给客户端调用。 应用场景12345678910111.一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。2.一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。3.系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。4.系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。5.多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。具体使用：Java SE 的容器布局管理，每个容器都存在多种布局供用户选择 线程池的拒绝策略RejectedExecutionHandler：AbortPolicy/DiscardPolicy/DiscardOldestPolicy/CallerRunsPolicy 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class StrategyPattern&#123; public static void main(String[] args) &#123; Context c=new Context(); Strategy s=new ConcreteStrategyA(); c.setStrategy(s); c.strategyMethod(); System.out.println("-----------------"); s=new ConcreteStrategyB(); c.setStrategy(s); c.strategyMethod(); &#125;&#125;//抽象策略类interface Strategy&#123; public void strategyMethod(); //策略方法&#125;//具体策略类Aclass ConcreteStrategyA implements Strategy&#123; public void strategyMethod() &#123; System.out.println("具体策略A的策略方法被访问！"); &#125;&#125;//具体策略类Bclass ConcreteStrategyB implements Strategy&#123; public void strategyMethod() &#123; System.out.println("具体策略B的策略方法被访问！"); &#125;&#125;//环境类class Context&#123; private Strategy strategy; public Strategy getStrategy() &#123; return strategy; &#125; public void setStrategy(Strategy strategy) &#123; this.strategy=strategy; &#125; public void strategyMethod() &#123; strategy.strategyMethod(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-模板方法模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 优点123451. 它'封装了不变部分，扩展可变部分'。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。2. 它在父类中提取了公共的部分代码，'便于代码复用'。3. '部分方法是由子类实现'的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 缺点1231.对每个不同的实现都需要定义一个子类，这会导致类的个数增加，'系统更加庞大'，设计也更加抽象。2.父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 组成12345678910111213(1) '抽象类'（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。 ① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 ② 基本方法：是整个算法中的一个步骤，包含以下几种类型。 抽象方法：在抽象类中申明，由具体子类实现。 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。(2) '具体子类'（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。 应用场景1. 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。 2. 当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处 分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 3. 当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。 实现12345678910111213141516171819202122232425262728293031323334353637public class TemplateMethodPattern&#123; public static void main(String[] args) &#123; AbstractClass tm=new ConcreteClass(); tm.TemplateMethod(); &#125;&#125;//抽象类abstract class AbstractClass&#123; public void TemplateMethod() //模板方法 &#123; SpecificMethod(); abstractMethod1(); abstractMethod2(); &#125; public void SpecificMethod() //具体方法 &#123; System.out.println("抽象类中的具体方法被调用..."); &#125; public abstract void abstractMethod1(); //抽象方法1 public abstract void abstractMethod2(); //抽象方法2&#125;//具体子类class ConcreteClass extends AbstractClass&#123; public void abstractMethod1() &#123; System.out.println("抽象方法1的实现被调用..."); &#125; public void abstractMethod2() &#123; System.out.println("抽象方法2的实现被调用..."); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-组合模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合模式有时又叫作部分-整体模式，将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。 优点1. 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码； 2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； 缺点1.设计较复杂，客户端需要花更多时间理清类之间的层次关系； 2.不容易限制容器中的构件； 3.不容易用继承的方法来增加构件的新功能； 组成1234567- '抽象构件'（Component）角色：它的主要作用是为树叶构件和树枝构件'声明公共接口，并实现它们的默认行为'。在透明式的组合模式中抽象 构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。- '树叶构件'（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于'实现抽象构件角色中声明的公共接口'。- '树枝构件'（Composite）角色：是组合中的分支节点对象，它有子节点。它'实现了抽象构件角色中声明的接口'，它的主要作用是存储和管理 子部件，通常包含 Add()、Remove()、GetChild() 等方法。 分类(1) 透明式抽象构件声明了所有子类中的全部方法，包括add,remove等，使树叶和树枝具备完全一致的行为接口。所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。 缺点：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。 (2) 安全式抽象构件不去声明add、remove方法，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题。 缺点：由于不够透明，树叶和树枝不具备相同的接口，客户端的调用需要做相应的判断带来不便。 应用场景1.在需要表示一个对象整体与部分的层次结构的场合。 2.要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。 Java AWT/Swing中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class CompositePattern&#123; public static void main(String[] args) &#123; Component c0=new Composite(); Component c1=new Composite(); Component leaf1=new Leaf("1"); Component leaf2=new Leaf("2"); Component leaf3=new Leaf("3"); c0.add(leaf1); c0.add(c1); c1.add(leaf2); c1.add(leaf3); c0.operation(); &#125;&#125;//抽象构件interface Component&#123; public void add(Component c); public void remove(Component c); public Component getChild(int i); public void operation();&#125;//树叶构件class Leaf implements Component&#123; private String name; public Leaf(String name) &#123; this.name=name; &#125; public void add(Component c)&#123; &#125; public void remove(Component c)&#123; &#125; public Component getChild(int i) &#123; return null; &#125; public void operation() &#123; System.out.println("树叶"+name+"：被访问！"); &#125;&#125;//树枝构件class Composite implements Component&#123; private ArrayList&lt;Component&gt; children=new ArrayList&lt;Component&gt;(); public void add(Component c) &#123; children.add(c); &#125; public void remove(Component c) &#123; children.remove(c); &#125; public Component getChild(int i) &#123; return children.get(i); &#125; public void operation() &#123; for(Object obj:children) &#123; ((Component)obj).operation(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-外观模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[外观模式为多个子系统提供一个统一的接口，而使这些子系统更加容易被访问的模式。降低系统的耦合度。 迪米特法则的典型应用，但是增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 组成12345- '外观'（Facade）角色：为多个子系统对外提供一个共同的接口。- '子系统'（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。- '客户'（Client）角色：通过一个外观角色访问各个子系统的功能。 应用场景(1) 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 (2) 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 (3) 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546//客户角色public class FacadePattern&#123; public static void main(String[] args) &#123; Facade f=new Facade(); f.method(); &#125;&#125;//外观角色class Facade&#123; private SubSystem01 obj1=new SubSystem01(); private SubSystem02 obj2=new SubSystem02(); private SubSystem03 obj3=new SubSystem03(); public void method() &#123; obj1.method1(); obj2.method2(); obj3.method3(); &#125;&#125;//子系统角色class SubSystem01&#123; public void method1() &#123; System.out.println("子系统01的method1()被调用！"); &#125; &#125;//子系统角色class SubSystem02&#123; public void method2() &#123; System.out.println("子系统02的method2()被调用！"); &#125; &#125;//子系统角色class SubSystem03&#123; public void method3() &#123; System.out.println("子系统03的method3()被调用！"); &#125; &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-装饰模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。 就增加功能来说，装饰模式比生成子类更为灵活。 结构与实现通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关 系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。 组成1234- '抽象构件'（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。- '具体构件'（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。- '抽象装饰'（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。- '具体装饰'（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 应用场景123- 当需要给一个'现有类添加附加职责'，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。- 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用'继承关系很难实现'，而采用装饰模式却很好实现。- 当对象的'功能要求可以动态地添加，也可以再动态地撤销时'。 实际中的应用 Java I/O 标准库的设计。例如， (1) InputStream 的子类 FilterInputStream， (2) OutputStream 的子类 FilterOutputStream， (3) Reader 的子类BufferedReader 以及 FilterReader， (4) Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等， 它们都是抽象装饰类。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class DecoratorPattern&#123; public static void main(String[] args) &#123; Component p=new ConcreteComponent(); p.operation(); System.out.println("---------------------------------"); Component d=new ConcreteDecorator(p); d.operation(); &#125;&#125;//抽象构件角色interface Component&#123; public void operation();&#125;//具体构件角色class ConcreteComponent implements Component&#123; public ConcreteComponent() &#123; System.out.println("创建具体构件角色"); &#125; public void operation() &#123; System.out.println("调用具体构件角色的方法operation()"); &#125;&#125;//抽象装饰角色class Decorator implements Component&#123; private Component component; public Decorator(Component component) &#123; this.component=component; &#125; public void operation() &#123; component.operation(); &#125;&#125;//具体装饰角色class ConcreteDecorator extends Decorator&#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; public void operation() &#123; super.operation(); addedFunction(); &#125; public void addedFunction() &#123; System.out.println("为具体构件角色增加额外的功能addedFunction()"); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-桥接模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[桥接模式将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 组成1234- '实现化'（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。- '具体实现化'（Concrete Implementor）角色：给出实现化角色接口的具体实现。- '抽象化'（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。- '扩展抽象化'（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 优点(1) 由于抽象与实现分离，所以扩展能力强； (2) 可动态的切换实现 由于桥接模式实现了抽象和实现的分离，所以在实现桥接模式时，就可以实现动态的选择和使用具体的实现。 (3) 实现细节对客户端透明，可以对用户隐藏实现细节。 缺点(1) 由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 (2) 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。 应用场景(1)当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 (2)当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 (3)当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class BridgeTest&#123; public static void main(String[] args) &#123; Implementor imple=new ConcreteImplementorA(); Abstraction abs=new RefinedAbstraction(imple); abs.Operation(); &#125;&#125;//实现化角色interface Implementor&#123; public void OperationImpl();&#125;//具体实现化角色class ConcreteImplementorA implements Implementor&#123; public void OperationImpl() &#123; System.out.println("具体实现化(Concrete Implementor)角色被访问" ); &#125;&#125;//抽象化角色abstract class Abstraction&#123; protected Implementor imple; protected Abstraction(Implementor imple) &#123; this.imple=imple; &#125; public abstract void Operation(); &#125;//扩展抽象化角色class RefinedAbstraction extends Abstraction&#123; protected RefinedAbstraction(Implementor imple) &#123; super(imple); &#125; public void Operation() &#123; System.out.println("扩展抽象化(Refined Abstraction)角色被访问" ); imple.OperationImpl(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-适配器模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 优点 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 缺点对类适配器来说，更换适配器的实现过程比较复杂。 组成 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 模式的应用场景适配器模式（Adapter）通常适用于以下场景。 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 实际应用https://blog.csdn.net/wwwdc1012/article/details/82780560 (1)spring AOP中的适配器模式123456在Spring的Aop中，使用的 Advice（通知） 来增强被代理类的功能。Advice的类型有：MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice在每个类型 Advice 都有对应的拦截器，MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptorSpring需要将每个 Advice 都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对 Advice 进行转换 (2)spring JPA中的适配器模式1234567在Spring的ORM包中，对于JPA的支持也是采用了适配器模式，首先定义了一个接口的 JpaVendorAdapter，然后不同的持久层框架都实现此接口。jpaVendorAdapter：用于设置实现厂商JPA实现的特定属性，如设置Hibernate的是否自动生成DDL的属性generateDdl；这些属性是厂商特定的，因此最好在这里设置；目前Spring提供 HibernateJpaVendorAdapter、OpenJpaVendorAdapter、EclipseLinkJpaVendorAdapter、TopLinkJpaVendorAdapter 四个实现。其中最重要的属性是 database，用来指定使用的数据库类型，从而能根据数据库类型来决定比如如何将数据库特定异常转换为Spring的一致性异常，目前支持如下数据库（DB2、DERBY、H2、HSQL、INFORMIX、MYSQL、ORACLE、POSTGRESQL、SQL_SERVER、SYBASE） (3)spring MVC中的适配器模式12Spring MVC中的适配器模式主要用于执行目标 Controller 中的请求处理方法。在Spring MVC中，DispatcherServlet 作为用户，HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-代理模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式为其他对象提供一种代理以控制对这个对象的访问。 组成（1）抽象角色(Subject)：通过接口或抽象类声明真实角色实现的业务方法。 （2）代理角色（Proxy）：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 （3）真实角色(RealSubject)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 代理模式的应用（1）远程代理。为一个位于不同的地址空间的对象提供一个本地的代理对象。这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远 程代理又叫做大使(Ambassador)。这样可以隐藏一个对象存在于不同地址空间的事实，使得客户端可以访问在远程机器上的对象。 （2）虚拟代理。根据需要创建开销很大的对象。如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时 才会被真正创建。 （3）安全代理。用来控制真实对象访问时的权限。 （4）智能指引。当调用真实对象时，代理处理另外的一些事。 应用实例Spring 的AOP 优点职责清晰： 真实角色就是实现实际的业务逻辑，不用关心其他非本职的事物 高扩展性： 真实角色可以随时更换或扩展，只需要实现接口就行，而代理不需要有任何变化 缺点(1)由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 (2)实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 静态代理由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ProxyTest&#123; public static void main(String[] args) &#123; Proxy proxy=new Proxy(); proxy.Request(); &#125;&#125;//抽象主题interface Subject&#123; void Request();&#125;//真实主题class RealSubject implements Subject&#123; public void Request() &#123; System.out.println("访问真实主题方法..."); &#125;&#125;//代理class Proxy implements Subject&#123; private RealSubject realSubject; public void Request() &#123; if (realSubject==null) &#123; realSubject=new RealSubject(); &#125; preRequest(); realSubject.Request(); postRequest(); &#125; public void preRequest() &#123; System.out.println("访问真实主题之前的预处理。"); &#125; public void postRequest() &#123; System.out.println("访问真实主题之后的后续处理。"); &#125;&#125; 动态代理在实现阶段不需要关心代理谁，在运行阶段会动态生成一个代理类去代理指定的对象 默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用CGlib来生成代理 (1)jdk动态代理：接口+InvocationHandler+目标对象1234567主要用到java.lang.reflect中的两个类：'Proxy和InvocationHandler'InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类代码，动态的将横切逻辑与业务逻辑编织在一起 1.定义业务逻辑接口 2.实现业务逻辑接口创建业务实现类 3.实现（implements）InvacationHandler代理接口，创建代理类 4.创建业务类和代理类对象，通过代理类对象.bind(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。缺点：要求目标类必须实现对应方法非接口，它只能为接口创建代理 123456789101112131415161718192021222324252627282930313233//InvocationHandler + invoke()public class Proxy implements InvocationHandler &#123; // 被代理类的实例 Object obj; // 将被代理者的实例传进动态代理类的构造函数中 public Proxy(Object obj) &#123; this.obj = obj; &#125; /** * 覆盖InvocationHandler接口中的invoke()方法 * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构 * 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到 * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊 * 代码切入的扩展点了。 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /* * before ：doSomething(); */ Object result = method.invoke(this.obj, args); /* * after : doSomething(); */ return result; &#125;&#125; (2)cglib动态代理：接口或类+MethodInterceptor+目标对象12345主要用到java.lang.reflect中的两个类:'MethodInterceptor和CglibProcy' 1.定义业务类，无需实现接口（也可以实现） 2.实现MethodInterceptor方法代理接口，创建代理类 3.创建业务类和代理类对象，通过代理类对象.getInstance(业务类对象)返回一个动态代理对象，然后通过动态代理对象对方法进行调用。特点：能代理类和接口，但是不能代理final类 12345678910111213141516171819202122232425//MethodIntercepter + intercept()public class Proxy implements MethodInterceptor &#123; // 单例模式 private static Proxy instance = new CGLibProxy(); private Proxy() &#123;&#125; public static Proxy getInstance () &#123; return instance; &#125; public &lt;T&gt; T getProxy(Class&lt;T&gt; cls) &#123; return (T) Enhancer.create(cls, this); &#125; public Object intercept(Object obj, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; sayBefore(); Object result = methodProxy.invokeSuper(obj, objects); sayAfter(); return result; &#125; private void sayBefore() &#123; System.out.println("before..."); &#125; private void sayAfter() &#123; System.out.println("after..."); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-建造者模式]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造者模式将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示 模式的结构 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 指挥者（Director）：构建一个使用builder接口的对象。它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 使用场景主要用于创建一些复杂的对象，这些对象内部间的建造顺序是稳定的，但对象内部的构建通常面临着复杂的变化。 优点（1）使得建造代码与表示代码分离，由于建造者隐藏了产品如何组装，所以若需要改变一个产品内部表示，只需要在定义一个具体的建造者就可以了。 （2） 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 （3）增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则” （4）可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F06%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法一览表 1.冒泡排序[稳定] 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 12345678910111213public static int[] Bubblesort(int []arr)&#123; for(int i =0;i&lt;arr.length-1;i++)&#123;//外层控制排序的趟数 for(int j = i;j&lt;arr.length-i-1;j++)&#123;//内层循环控制每趟排序多少次 //前一个数比后一个数大，交换位置 if(arr[j]&gt;arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125; 2.选择排序[不稳定] 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 1234567891011121314public static int[] selectSort(int []arr)&#123; for(int i =0;i&lt;arr.length;i++)&#123; int minIndex =i; for(int j = i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt; arr[minIndex])&#123; minIndex = j; &#125; &#125; int temp =arr[i]; arr[i] =arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 3.插入排序[稳定] 每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 12345678910111213public static int[] insertSort(int []arr)&#123; for(int i =1;i&lt;arr.length;i++)&#123; for(int j = i;j&gt;0;j--)&#123; //后一个数小于前一个数则交换 if(arr[j]&lt;arr[j-1])&#123; int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; &#125; return arr;&#125; 4.归并排序[稳定] 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 如 设有数列{6，202，100，301，38，8，1} 初始状态：6 , 202 , 100 , 301 , 38 , 8 , 1 第一次归并后：{6,202} , {100,301}, {8,38}, {1} ，比较次数：3； 第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4； 第三次归并后：{1,6,8,38,100,202,301},比较次数：4； 总的比较次数为：3+4+4=11； 逆序数为14； 123456789101112131415161718192021222324252627282930313233343536public static void mergeSort(int arr[],int low,int high)&#123; if(low&lt;high)&#123; int mid = (low+high)/2; mergeSort(arr,low,mid); mergeSort(arr,mid+1,high); //两路归并 merge(arr,low,mid,high); &#125;&#125;private static void merge(int[] arr, int low,int mid,int high) &#123; int []tmp = new int[high-low+1];//汇总两个有序区的临时区域 int i = low;//左边序列起始索引 int j = mid+1;//右边序列起始索引 int k = 0; //临时区域的索引 //把较小的数先移到新数组中 while(i&lt;=mid &amp;&amp; j&lt;= high)&#123; if(arr[i]&lt;arr[j])&#123; tmp[k++] = arr[i++]; &#125;else&#123; tmp[k++] = arr[j++]; &#125; &#125; //若左边序列还有剩余，则将其全部拷贝进tmp[]中 while(i &lt;= mid)&#123; tmp[k++] = arr[i++]; &#125; //若右边序列还有剩余，则将其全部拷贝进tmp[]中 while(j &lt;= high)&#123; tmp[k++] = arr[j++]; &#125; // 将排序后的元素，全部都整合到数组中。 for(int t = 0;t &lt; tmp.length ;t++) arr[t+low] = tmp[t];&#125; 5.计数排序[稳定]–升级为桶排序 工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列 1234567891011121314151617181920212223242526public static void countSort(int[] arr) &#123; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++) &#123; max = Math.max(max, arr[i]); &#125; //桶数 int bucketNum = max + 1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum); for(int i = 0;i&lt;bucketNum;i++)&#123; bucketArr.add(new ArrayList&lt;Integer&gt;()); &#125; //将每个元素放入桶 for(int i = 0;i&lt;arr.length;i++)&#123; bucketArr.get(arr[i]).add(arr[i]); &#125; //对每个桶进行排序 for(int i = 0; i &lt; bucketArr.size(); i++)&#123; Collections.sort(bucketArr.get(i)); &#125; for(int i = 0;i&lt;bucketArr.size();i++)&#123; if(!bucketArr.get(i).isEmpty())&#123; for(Integer a:bucketArr.get(i)) System.out.print(a+" "); &#125; &#125;&#125; 6.基数排序[稳定] 将整数按位数切割成不同的数字，然后按每个位数分别比较。 准备10个桶，按照个位将数放入桶中，在倒出来，再按照十位数放入桶中再倒出来….. 1234567891011121314151617181920212223242526272829public static void Redixsort(int[] arr, int d)//d表示最大的数有多少位&#123; int k = 0; //保存每一位排序后的结果用于下一位的排序输入 int n = 1; //表示位数对应的数 int len = arr.length; int [][]bucket = new int[10][len];//排序桶，用于保存每次排序后的结果，这样位排序结果相同的数字放在同一个桶里 int []order = new int[len]; // 用于保存每个桶里面有多少个数字 while(n&lt; Math.pow(10,d))&#123; for(int i = 0;i&lt;arr.length;i++)&#123;//将数组array里的每个数字放在相应的桶里 int digit = (arr[i]/n)%10; //求位上的数 bucket[digit][order[digit]] = arr[i]; order[digit]++; &#125; //将前一个循环生成的桶里的数据覆盖到原数组中，用于保存这一位的排序结果 for(int i = 0;i&lt;len;i++)&#123; //桶里有数据 if(order[i]!=0)&#123; for(int j = 0;j&lt;order[i];j++)&#123; arr[k] = bucket[i][j]; k++; &#125; &#125; //桶里计数器计0，用于下一次排序 order[i] =0; &#125; n =n*10; k = 0; //将k置0，用于下一轮保存位排序结果 &#125;&#125; 7.快速排序[不稳定] 选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。 简单记忆为： “挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。 123456789101112131415161718192021222324252627public static void quicksort(int arr[], int low, int high) &#123; if(low &lt; high) &#123; int position = partition(arr, low, high); quicksort(arr, low, position - 1); quicksort(arr, position + 1, high); &#125; &#125;public static int partition(int arr[], int low, int high) &#123; //设置基准值 int key = arr[low]; while(low &lt; high)&#123; //从右到左，直到找到一个小于key的值 while(low &lt; high &amp;&amp; arr[high] &gt;= key) --high; //将该值填入前的坑 arr[low] = arr[high]; //从左到右，直到找到一个大于key的值 while(low &lt; high &amp;&amp; arr[low] &lt;= key) ++low; //将该值填入前一个坑 arr[high] = arr[low]; &#125; //将基准值填入最后一个坑 arr[low] = key; //最后一个坑划分了左边小于该值，右边大于该值 return low;&#125; 8.希尔排序[不稳定]–插入排序的优化 现在有一个array,希尔排序就是设定一个增量incrementNum (0&lt;incrementNum&lt;array.length) (1)先从array[0]开始，以incrementNum为增量的进行直接插入排序，直到数组末尾，然后从array[1]开始重复：以incrementNum为增量的进行直接插入排序; 然后从array[1]开始重复……一直到array[n]。 然后取一个小于上一步增量的新的增量（比如设置为incrementNum/2）,对前一个步骤的结果array进行遍历，直接插入排序…. 再取小于上一步增量的新的增量，重复进行：遍历，直接插入排序，直到新的增量小于1之后再退出循环 1234567891011121314151617public static void shellSort(int []arr)&#123; int incrementNums = arr.length/2; while(incrementNums&gt;=1)&#123; for(int i = 0;i&lt;arr.length;i++)&#123; //进行插入排序 for(int j =i+incrementNums;j&lt;arr.length;j+=incrementNums)&#123; if(arr[j]&lt;arr[j-incrementNums])&#123; int tmp = arr[j]; arr[j] =arr[j-incrementNums]; arr[j-incrementNums] = tmp; &#125; &#125; &#125; //设置新的增量 incrementNums =incrementNums/2; &#125;&#125; 9.堆排序[不稳定] 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 123456789101112131415161718192021222324252627282930313233343536373839public static void HeapSort(int []arr)&#123; int len = arr.length; //叶子节点为（n/2+1~n,每个叶子本身就是一个大根堆）,故需要遍历的非叶子结点数位len/2 for(int i = len/2 ; i&gt;=0;i-- )&#123; //从第一个非叶子结点从下往上，从右至左调整，构造大根堆 // i为最后一个根节点，n为数组最后一个元素的下标 HeapAdjust(arr,i,len-1); &#125; //调整堆结构+交换堆顶元素与末尾元素 for(int i = len-1;i&gt;0;i--)&#123; //最后一个元素跟第一个元素交换 int tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; HeapAdjust(arr,0,i); &#125;&#125;//大根堆的构建private static void HeapAdjust(int[] arr, int parent, int length) &#123; int largest = parent; //获得左孩子 int leftchild = 2 * parent + 1; int rightchild = 2* parent + 2; if(leftchild&lt;length &amp;&amp; arr[leftchild]&gt;arr[largest])&#123; largest= leftchild; &#125; if(rightchild&lt;length &amp;&amp; arr[rightchild]&gt;arr[largest])&#123; largest = rightchild; &#125; if(parent != largest)&#123; int temp = arr[parent]; arr[parent] = arr[largest]; arr[largest]= temp; //递归 HeapAdjust(arr,largest,length); &#125;&#125;]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【237】删除链表的节点]]></title>
    <url>%2F2019%2F06%2Fleetcode-237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.示例 2: 输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 2.解题思路 这题的输入只给出了要删除的点所在的位置node,即如果链表node为 2–&gt;3–&gt;4–&gt;1,则只删除2节点，即 将node后面的向前移动覆盖即可 3.代码1234567891011121314/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public static void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125; &#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【24】两两交换链表中的节点]]></title>
    <url>%2F2019%2F06%2Fleetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 2.解题思路 方法1：将链表中的数放到stack里面，每当stack里面有两个值，就pop弹出，将弹出的值放到新的链表后面。 方法2：递归 3.代码1234567891011121314151617181920public static ListNode swapPairs(ListNode head) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); ListNode res = new ListNode(-1); ListNode ans = res; while(head!=null)&#123; stack.push(head.val); head = head.next; if(stack.size()==2)&#123; while(!stack.isEmpty())&#123; res.next = new ListNode(stack.pop()); res = res.next; &#125; &#125; &#125; while(!stack.isEmpty())&#123; res.next = new ListNode(stack.pop()); res = res.next; &#125; return ans.next; &#125; 方法2： 123456789public static ListNode swapPairs2(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; &#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表反转]]></title>
    <url>%2F2019%2F06%2F%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[1.递归以链表 1-&gt;2-&gt;3-&gt;4 为例子： 程序到达Node newHead = reverse(head.next);时进入递归 我们假设此时递归到了3结点，此时head=3结点，temp=3结点.next(实际上是4结点) 执行Node newHead = reverse(head.next);传入的head.next是4结点，返回的newHead是4结点。 接下来就是弹栈过程了 程序继续执行 temp.next = head就相当于4-&gt;3 head.next = null 即把 3结点指向4结点的指针断掉。 返回新链表的头结点newHead 注意：当retuen后，系统会恢复2结点压栈时的现场，此时的head=2结点；temp=2结点.next(3结点)，再进行上述的操作。最后完成整个链表的翻转。 12345678910111213141516static class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;public static ListNode reverse(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode temp = head.next; ListNode newHead = reverse(head.next); temp.next = head; head.next = null; return newHead;&#125;&#125; 2.遍历依旧是1-&gt;2-&gt;3-&gt;4 准备两个空结点 pre用来保存先前结点、next用来做临时变量 在头结点node遍历的时候此时为1结点 next = 1结点.next(2结点) 1结点.next=pre(null) pre = 1结点 node = 2结点 进行下一次循环node=2结点 next = 2结点.next(3结点) 2结点.next=pre(1结点)=&gt;即完成2-&gt;1 pre = 2结点 node = 3结点 进行循环… 12345678910111213141516static class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public static ListNode reverseList(ListNode node) &#123; ListNode pre = null; ListNode cur = node; while (cur != null) &#123; ListNode next = cur.next; //将下一个节点记录 cur.next = pre; //当前节点指向上一个节点 pre = cur; //记录当前节点 cur = next; //将下一个节点变成当前节点 &#125; return pre; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【203】移除链表元素]]></title>
    <url>%2F2019%2F06%2Fleetcode-203%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[1.题目描述 删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 2.解题思路 方法1： 如果当前链表值head.val不等于val,则新建一个节点放到ans后面 如果相等，则跳到链表下一个。 方法2： 遇到相等则跳指针 要考虑好头节点跟val相等的情况。 3.代码方法1：新建 123456789101112131415public static ListNode removeElements(ListNode head, int val) &#123; ListNode ans = new ListNode(-1); ListNode res = ans; while(head!=null)&#123; if(head.val==val)&#123; head = head.next; &#125;else&#123; ans.next =new ListNode(head.val) ; ans = ans.next; head = head.next; &#125; &#125; return res.next; &#125; 方法2：跳指针 12345678910111213141516public static ListNode removeElements(ListNode head, int val) &#123; if(head == null) return head; //如果头节点与val相同 while (head != null &amp;&amp; head.val == val) head = head.next; ListNode cur = head; while(cur.next != null)&#123; if(cur.next.val == val)&#123; cur.next = cur.next.next; &#125;else&#123; cur = cur.next; &#125; &#125; return head; &#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【120】三角形最小路径和]]></title>
    <url>%2F2019%2F06%2Fleetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3]]自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 2.解题思路 动态规划： 每一层的值加上上一层的值中最小值，最后取最后一层的最小值就好了 例如 123456&gt; &gt; [2] [2]&gt; [3,4] 变成 [5,6]&gt; [6,5,7] [11,10,13]&gt; [4,1,8,3] [15,11,18,16]&gt; 3.代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public static int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle.size() == 0) return 0; if(triangle.size() == 1) return triangle.get(0).get(0); int len = triangle.get(triangle.size()-1).size(); int dp[][] = new int[len][len]; //初始化第一层跟第二层 dp[0][0] = triangle.get(0).get(0); dp[1][0] = dp[0][0]+triangle.get(1).get(0); dp[1][1] = dp[0][0] + triangle.get(1).get(1); //第一列初始化 for(int i = 2;i &lt; len;i++)&#123; dp[i][0] = dp[i-1][0] + triangle.get(i).get(0); &#125; for(int i = 2;i&lt;len;i++)&#123; for(int j = 1;j&lt;= i ;j++)&#123; //最后一个数的dp,因为上一层比下一层少一个，所以只能最后一个数只能加上上一层的最后一个dp if(j == i)&#123; dp[i][j] = triangle.get(i).get(j) + dp[i-1][j-1]; &#125;else&#123; dp[i][j] = triangle.get(i).get(j)+ Math.min(dp[i-1][j-1],dp[i-1][j]); &#125; &#125; &#125; //三角形最后一层中的最小值就是最小路径 int res = dp[len-1][0]; for(int i = 1;i&lt;len;i++)&#123; if(dp[len-1][i] &lt; res)&#123; res = dp[len-1][i]; &#125; &#125; return res; &#125;&#125; 4.提交结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【95】不同的二叉搜索树2]]></title>
    <url>%2F2019%2F06%2Fleetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例: 输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 123456&gt; 1 3 3 2 1&gt; \ / / / \ \&gt; 3 2 1 1 3 2&gt; / / \ \&gt; 2 1 2 3&gt; 2.解题思路 (1)当n = 1时，此时只有一个以1为根节点的二叉搜索树 (2) 当n &gt; 1时，当以 i 为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，依次递归遍历，分别放到left和right列表中，然后再先序遍历放入res结果中。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static class Solution &#123; public static List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt; res = new LinkedList&lt;&gt;(); if (n == 0) return res; return generateTrees(1, n); &#125; static private List&lt;TreeNode&gt; generateTrees(int start, int end) &#123; //n = 1 的情况，只有一个，就是根节点为1的二叉搜索树 if (start == end) &#123; List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); TreeNode node = new TreeNode(start); list.add(node); return list; &#125; //以 i 为根节点，左子树为start~(i-1),右子树为(i+1)~n List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); for (int i = start; i &lt;= end; i++) &#123; List&lt;TreeNode&gt; left = new ArrayList&lt;&gt;(); List&lt;TreeNode&gt; right = new ArrayList&lt;&gt;(); if (i != start) &#123; //说明有左子树 left = generateTrees(start, i - 1); &#125; if (i != end) &#123; //说明有右子树 right = generateTrees(i + 1, end); &#125; //先序遍历存入res里面 if (!left.isEmpty() &amp;&amp; !right.isEmpty()) &#123; for (TreeNode l : left) &#123; for (TreeNode r : right) &#123; TreeNode root = new TreeNode(i); root.left = l; root.right = r; res.add(root); &#125; &#125; &#125; else if (!left.isEmpty()) &#123; for (TreeNode l : left) &#123; TreeNode root = new TreeNode(i); root.left = l; res.add(root); &#125; &#125; else if (!right.isEmpty()) &#123; for (TreeNode r : right) &#123; TreeNode root = new TreeNode(i); root.right = r; res.add(root); &#125; &#125; &#125; return res; &#125; 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if(n&lt;=0) return new ArrayList&lt;TreeNode&gt;(); return generate(1,n); &#125; public List&lt;TreeNode&gt; generate(int start,int end)&#123; List&lt;TreeNode&gt; res=new ArrayList&lt;&gt;(); if(start&gt;end)&#123; res.add(null); return res; &#125; for(int i=start;i&lt;=end;i++)&#123; // 递归遍历左子树 List&lt;TreeNode&gt; leftTrees=generate(start,i-1); // 递归遍历右子树 List&lt;TreeNode&gt; rightTrees=generate(i+1,end); //先序遍历存入以i为根节点的二叉搜索树 for(TreeNode left:leftTrees)&#123; for(TreeNode right:rightTrees)&#123; TreeNode root=new TreeNode(i); root.left=left; root.right=right; res.add(root); &#125; &#125; &#125; return res; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【96】不同二叉搜索树]]></title>
    <url>%2F2019%2F06%2Fleetcode-96-%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 123456&gt; 1 3 3 2 1&gt; \ / / / \ \&gt; 3 2 1 1 3 2&gt; / / \ \&gt; 2 1 2 3&gt; 2.解题思路 动态规划： (1)初始化 n = 1时，只含有1，1作为根节点，此时二叉搜索数个数为1； (2) 算法 （1）假设n个节点存在二叉排序树的个数是dp[i]，令f[i]为以i为根的二叉搜索树的个数，则 dp[n] = f[1] + f[2] + f[3] + f[4] + ... + f[n] （2）当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则 f [i] = dp[i-1] * dp[n-i] 综合两个公式可以得到卡特兰数公式 1234&gt; dp[n] = dp[0] * dp[n-1] + dp[1] * dp[n-2]+...+dp[n-1] * dp[0]&gt; = dp[n-1] * C(2n,n)&gt; = dp[n-1] * (4*n-2)/(n-1)&gt; 3.代码123456789101112class Solution &#123; public static int numTrees(int n) &#123; //n个节点存在二叉树的个数 long []dp = new long[n+1]; //以i为根节点的二叉树个数 dp[1] = 1; for(int i = 1;i&lt;=n;i++)&#123; dp[i] = dp[i-1]*(4*i-2)/(i+1); &#125; return (int) dp[n]; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【70】爬楼梯]]></title>
    <url>%2F2019%2F06%2Fleetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[1.题目描述 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2： 输入： 3输出： 3解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 2.解题思路方法1：动态规划 初始化： 可知dp[0] = 0;dp[1] = 1;dp[2] = 2;即跳0级有一种方法，一级有1种方法，2级有2种方法 算法核心： dp[i] = dp[i-1] +dp[i-2] ,即爬i阶台阶的方法等于爬i-2阶台阶的方法加上爬i-1阶台阶的方法 方法2： 剑指offer第8题 3.代码方法1：动态规划 123456789101112131415class Solution &#123; public int climbStairs(int n) &#123; if(n&lt;3)&#123; return n; &#125; int dp[] = new int[n+1]; dp[0] = 0; dp[1] = 1; dp[2] = 2; for(int i = 3;i&lt;=n;i++)&#123; dp[i] = dp[i-1]+dp[i-2]; &#125; return dp[n]; &#125;&#125; 方法2： 123456789101112131415class Solution &#123; public int climbStairs(int n) &#123; if(n &lt;= 2) return n ; int one = 1; int two = 2; int res = 0; for(int i = 3;i &lt;=n ;i++)&#123; res = one + two; one = two; two = res; &#125; return res; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>简单</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【64】最小路径和]]></title>
    <url>%2F2019%2F06%2Fleetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 2.解题思路 如果数组只有一个数，则路径最小即为该值，dp[0][0] = 0; (1)动态规划初始化 1)只有一行，则路径总和最小为 dp[0][i] = dp[0][i-1] + grid[0][i]; 2)只有一列，则路径总和最小为 dp[i][0] = dp[i-1][0] + grid[i][0]; (2) 动态规划核心算法 每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式： dp[i][j] = grid[i][j] + min( dp[i-1][j] , dp[i][j-1]); 3.代码1234567891011121314151617181920212223class Solution &#123; public int minPathSum(int[][] grid) &#123; int row = grid.length; int col = grid[0].length; int dp[][] = new int[row][col]; dp[0][0] = grid[0][0]; //行初始化 for(int i = 1;i&lt;col;i++)&#123; dp[0][i] = dp[0][i-1] + grid[0][i]; &#125; //列初始化 for(int i = 1;i&lt;row;i++)&#123; dp[i][0] = dp[i-1][0]+grid[i][0]; &#125; //动态规划核心 for(int i = 1;i&lt;row;i++)&#123; for(int j = 1;j&lt;col;j++)&#123; dp[i][j] = grid[i][j]+(dp[i-1][j]&lt;dp[i][j-1]?dp[i-1][j]:dp[i][j-1]); &#125; &#125; return dp[row-1][col-1]; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【63】不同路径2]]></title>
    <url>%2F2019%2F06%2Fleetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842%2F</url>
    <content type="text"><![CDATA[1.题目描述 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 2.解题思路 如果第一个格点 obstacleGrid[0][0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。 如果 obstacleGrid[0][0] 是 0，我们初始化这个值为 1 然后继续算法。(1)动态规划初始化 1)obstacleGrid[0][0] == 0,表示没障碍，路径只有一条；dp[0][0] = 1; 2)遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过， 设值为 0 ；否则设这个值是前一个节点的值dp[0][j] = dp[0][j-1]。 3)遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过， 设值为 0 ；否则设这个值是前一个节点的值dp[i][0] = obstacleGrid[i-1][0]。 (2) 动态规划核心算法 从 obstacleGrid[1][1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 dp[i][j] = dp[i-1][j] + dp[i][j-1]。 如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。 3.代码1234567891011121314151617181920212223242526class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int row = obstacleGrid.length; int col = obstacleGrid[0].length; if(obstacleGrid[0][0] == 1 || obstacleGrid==null)&#123; return 0; &#125; int dp[][] = new int[row][col]; dp[0][0] = 1; //行初始化 for(int i = 1;i&lt;col;i++)&#123; dp[0][i] = obstacleGrid[0][i]==1 ? 0 : dp[0][i-1]; &#125; //列初始化 for(int i = 1;i&lt;row; i++)&#123; dp[i][0] = obstacleGrid[i][0] == 1? 0:dp[i-1][0]; &#125; //动态规划 for(int i = 1;i&lt;row;i++)&#123; for(int j = 1;j&lt;col;j++)&#123; dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[row-1][col-1]; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【62】不同的路径]]></title>
    <url>%2F2019%2F06%2Fleetcode-62-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.题目描述 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 2.解题思路 动态规划 （1）初始化 1) 从[0,0]走到[0,0]的路径，即没走，设dp[0][0] = 0; 2) 如果m*n的n为1，即机器人在m*1走，只能有一条路径，即arr[i][0] = 1; 3) 如果m*n的m为1，即机器人在1*n走，只能有一条路径，即arr[0][1] = 1; (2) 动态规划核心算法 机器人每次只能向下或者向右移动一步。即机器人arr[i][j]的路径由arr[i-1][j]和arr[i][j-1]决定，即arr[i][j] = arr[i-1][j]+arr[i][j-1]; 3.代码123456789101112131415161718192021222324class Solution &#123; public static int uniquePaths(int m, int n) &#123; if(m &lt; 0 || n &lt; 0) return 0; int arr[][] = new int[m][n]; //初始化 arr[0][0] = 0; //初始化列 for(int i = 0;i&lt;n;i++)&#123; arr[0][i] = 1; &#125; //初始化行 for(int i = 0;i&lt;m;i++)&#123; arr[i][0] = 1; &#125; //动态规划 for(int i =1;i&lt;m;i++)&#123; for(int j = 1;j&lt;n;j++)&#123; arr[i][j] = arr[i-1][j]+arr[i][j-1]; &#125; &#125; return arr[m-1][n-1]; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【53】最大子序和]]></title>
    <url>%2F2019%2F06%2Fleetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 2.解题思路方法1：动态规划 定义一个函数f(n)，以第n个数为结束点的子数列的最大和，存在一个递推关系f(n) = max(f(n-1) + A[n], A[n]); 将这些最大和保存下来后，取最大的那个就是，最大子数组和。因为最大连续子数组 等价于 最大的以n个数为结束点的子数列 方法2： 用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。 (1)当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令 cur = 0.表示从下一个数开始累加。 (2)当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最 大值即可。 3.代码方法1：动态规划 1234567891011121314151617181920class Solution &#123; public int maxSubArray(int[] nums) &#123; if(nums.length == 0||nums == null)&#123; return 0; &#125; //初始化 int[] ans = new int[nums.length]; ans[0] = nums[0]; int res = ans[0]; //依次求出以第n个数为结束点的子序列最大和 for(int i = 1;i&lt;nums.length;i++)&#123; ans[i] = Math.max(ans[i-1]+nums[i],nums[i]); //求出最大和 res = Math.max(res,ans[i]); &#125; return res; &#125;&#125; 方法2： 123456789101112131415class Solution &#123; public int maxSubArray(int[] nums) &#123; if(nums.length == 0||nums == null)&#123; return 0; &#125; int ans = Integer.MIN_VALUE; int cur = 0; for(int i = 0;i&lt;nums.length;i++)&#123; cur = cur + nums[i]; ans = Math.max(cur,ans); cur = cur &lt; 0 ? 0 : cur; &#125; return ans; &#125;&#125; 4.提交结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>简单</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【264】丑数2]]></title>
    <url>%2F2019%2F06%2Fleetcode-264-%E4%B8%91%E6%95%B02%2F</url>
    <content type="text"><![CDATA[1.题目描述 编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例: 输入: n = 10输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 2.解题思路 剑指offer-【33】 丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an 所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2a1, 2a2, 2*a3 ….. 包含3的有序丑数序列:3a1, 3a2, 3a3 ….. 包含5的有序丑数序列:5a1, 5a2, 5a3 ….. 以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可 3.代码123456789101112131415161718192021222324class Solution &#123; public int nthUglyNumber(int n) &#123; int [] arr = new int[n]; if(n==0) return 0; arr[0] = 1; int t2 = 0; int t3 = 0; int t5 = 0; for(int i = 1;i&lt;n;i++)&#123; arr[i] =Math.min(Math.min(arr[t2]*2,arr[t3]*3),arr[t5]*5); if(arr[t2]*2 == arr[i])&#123; t2++; &#125; if(arr[t3]*3 == arr[i])&#123; t3++; &#125; if(arr[t5]*5 == arr[i])&#123; t5++; &#125; &#125; return arr[n-1]; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【263】丑数]]></title>
    <url>%2F2019%2F06%2Fleetcode-263-%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 输入: 6输出: true解释: 6 = 2 × 3 示例 2: 输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3: 输入: 14输出: false解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明： 1 是丑数。 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 2.解题思路 丑数只能被2，3，5整除，所以丑数为2*i+3*j+5*k = num[i,j,k为任意整数] 3.代码1234567891011121314public static boolean isUgly(int num) &#123; if(num==0) return false; if(num==1) return true; while(num%2==0) &#123; num/=2; &#125; while(num%3==0) &#123; num/=3; &#125; while(num%5==0) &#123; num/=5; &#125; return num==1; &#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【23】合并K个排序链表]]></title>
    <url>%2F2019%2F06%2Fleetcode-23%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 2.解题思路 方法1： (1)利用priorityQueue的性质，每放一个数字进去就给你从小到大排好序了 (2)队列的性质是先进先出，故依次poll出来就是从小到大的顺序，将该数值放到listNode里面即可。 方法2： 借用合并两个链表的代码，依次将list[]分成两部分，在分别合并，执行用时为6ms 3.代码1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode res = new ListNode(-1); ListNode ans = res; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); //将所有节点的值放到一个queue里面从小到大排好序 for(int i = 0;i&lt; lists.length;i++)&#123; while(lists[i]!=null)&#123; queue.add(lists[i].val); lists[i] = lists[i].next; &#125; &#125; //依次建立链表 while(queue.size()!=0)&#123; res.next = new ListNode(queue.poll()); res = res.next; &#125; return ans.next; &#125; &#125; 方法2： 1234567891011121314151617181920212223242526272829303132333435363738public ListNode mergeKLists(ListNode[] lists)&#123; if(lists.length == 0) return null; if(lists.length == 1) return lists[0]; if(lists.length == 2)&#123; return mergeTwoLists(lists[0],lists[1]); &#125; //将一半的链表放到l1里面 int mid = lists.length/2; ListNode[] l1 = new ListNode[mid]; for(int i = 0; i &lt; mid; i++)&#123; l1[i] = lists[i]; &#125; //将一半的链表放到l2里面 ListNode[] l2 = new ListNode[lists.length-mid]; for(int i = mid,j=0; i &lt; lists.length; i++,j++)&#123; l2[j] = lists[i]; &#125; //递归实现多个链表的排序 return mergeTwoLists(mergeKLists(l1),mergeKLists(l2)); &#125; //递归方式实现两个链表排序 public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; ListNode head = null; if (l1.val &lt;= l2.val)&#123; head = l1; head.next = mergeTwoLists(l1.next, l2); &#125; else &#123; head = l2; head.next = mergeTwoLists(l1, l2.next); &#125; return head; &#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【21】合并两个有序链表]]></title>
    <url>%2F2019%2F06%2Fleetcode-21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 2.解题思路 (1) 判断是否有空链表，如果有则直接返回另一个不为空有序链表 (2) 依次判断是否有对应链表大小，小的加入res链表，并移动 注：该题与剑指offer-[16]题一致，还可以用递归。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142/** * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null &amp;&amp;l2!=null) return l2; if(l2 == null &amp;&amp; l1!=null) return l1; ListNode res = new ListNode(-1); ListNode ans = res; while(l1!=null&amp;&amp;l2!=null)&#123; //哪个小添加哪个 if(l1.val&gt;l2.val)&#123; res.next = new ListNode(l2.val); l2 = l2.next; res = res.next; &#125;else&#123; res.next = new ListNode(l1.val); l1 = l1.next; res = res.next; &#125; &#125; //将剩下的没便利完的加入 while(l1!=null)&#123; res.next = new ListNode(l1.val); l1 = l1.next; res = res.next; &#125; while(l2!=null)&#123; res.next = new ListNode(l2.val); l2 = l2.next; res = res.next; &#125; return ans.next; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【19】删除链表的倒数第N个节点]]></title>
    <url>%2F2019%2F06%2Fleetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 2.解题思路 双指针 (1)第一个指针curNode先走n步 (2)然后第二个指针preNode再重头跟刚刚第一个指针curNode走,直到走到尾部【preNode走了(len-N)步,即下一个节点就是要删除的节点】 (3)此时的preNode的下一个即为倒数第N个节点，将其删除即可 3.代码1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode preNode = head; ListNode curNode = head; //第一个指针先走n步 for (int i = 0; i &lt; n; i++) &#123; curNode = curNode.next; &#125; if (curNode == null) &#123; return preNode.next; &#125; //两个指针同时走，走剩下的（Len-n）步，此时preNode的下一个就是要删除的节点 while (curNode.next != null) &#123; preNode = preNode.next; curNode = curNode.next; &#125; //删除倒数第N个节点 preNode.next = preNode.next.next; return head; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【434】字符串中的单词数]]></title>
    <url>%2F2019%2F06%2Fleetcode-434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例: 输入: “Hello, my name is John”输出: 5 2.解题思路 每次出现非空字符，看看上一个是不是空格，如果是，发现一个新单词 3.代码1234567891011121314151617class Solution &#123; public int countSegments(String s) &#123; int count = 0; boolean lastIsBlank = true; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ' ') &#123; lastIsBlank = true; &#125; else &#123; if (lastIsBlank) &#123; count++; &#125; lastIsBlank = false; &#125; &#125; return count; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【13】罗马数字转整数]]></title>
    <url>%2F2019%2F06%2Fleetcode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: “III”输出: 3 示例 2: 输入: “IV”输出: 4 示例 3: 输入: “IX”输出: 9 示例 4: 输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3. 示例 5: 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 2.解题思路 通常情况下，罗马数字中小的数字在大的数字的右边。这句话很关键，意思是要变成罗马数字，必须先排列大的数 （1）res初始化为字符串的最后一个字符所代表的数字 （2）从字符串数组尾部开始遍历， 1)如果下一个字符所代表的数字小于当前字符所代表的数字，则res减去下一个字符所代表的数字：如IV,下一个字符I所代表数字1&lt;当前字符所代 表数字5，res = res-1 2)如果下一个字符所代表的数字大于当前字符所代表的数字，则res加上下一个字符所代表的数字如VI,下一个字符V 所代表数字5&gt;当前字符I所代 表数字1,res = res+5 3.代码1234567891011121314151617181920212223class Solution &#123; public static int romanToInt(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int res = map.get(s.charAt(s.length()-1)); for(int i = s.length()-1;i&gt;0;i--)&#123; //罗马数字中大的数字在小的数字的右边，用减法 if(map.get(s.charAt(i))&gt;map.get(s.charAt(i-1)))&#123; res -=map.get(s.charAt(i-1)); &#125;else&#123; //罗马数字中小的数字在大的数字的右边，用加法 res +=map.get(s.charAt(i-1)); &#125; &#125; return res; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【12】整数转罗马数字]]></title>
    <url>%2F2019%2F06%2Fleetcode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3输出: “III” 示例 2: 输入: 4输出: “IV” 示例 3: 输入: 9输出: “IX” 示例 4: 输入: 58输出: “LVIII”解释: L = 50, V = 5, III = 3. 示例 5: 输入: 1994输出: “MCMXCIV”解释: M = 1000, CM = 900, XC = 90, IV = 4. 2.解题思路 通常情况下，罗马数字中小的数字在大的数字的右边。这句话很关键，意思是要变成罗马数字，必须先排列大的数 （1）定义一个arr[],代表能用罗马数字代表的数 （2）定义一个str[],里面的字符串分别与数字arr[]里面的数字相对应，两个的联系即arr[i] —–&gt;str[i] （3）定义一个i,i从0开始，找到数组中第一个小于等于num的值，第一个罗马数字就是str[i],再依次循环知道num==0 3.代码123456789101112131415161718class Solution &#123; public static String intToRoman(int num) &#123; int arr [] = &#123;1000, 900, 500, 400,100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; String str[] = &#123; "M","CM", "D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; int i = 0; StringBuilder res = new StringBuilder(""); //一般情况下罗马数字小的在大的右边 while(num!=0&amp;&amp; i&lt;arr.length)&#123; if(num &gt;= arr[i])&#123; num = num-arr[i]; res.append(str[i]); &#125;else&#123; i++; &#125; &#125; return res.toString(); &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F2019%2F06%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[死锁的概念两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 产生死锁的原因12345（1） '互斥条件'： 一个资源每次只能被一个进程使用。（2） '请求与保持条件'： 一个进程因请求资源而阻塞时， 对已获得的资源保持不放。（3） '不可剥夺条件':进程已获得的资源， 在末使用完之前， 不能强行剥夺。（4） '环路等待条件':若干进程之间形成一种头尾相接的循环等待资源关系。 只要系统发生了死锁， 这些条件必然成立， 而只要上述条件之一不满足， 就不会发生死锁。 预防死锁12345678910111213141516171819202122232425261) '破坏互斥条件' 如果'允许系统资源都能共享使用'， 则系统不会进入死锁状态。 但有些资源根本不能同时访问， 如打印机等临界资源只能互斥使用。 所以， 破坏互斥条件而预防死锁的方法不太可行， 而且在有的场合应该保护这种互斥性。2) '破坏不剥夺条件' 当一个已保持了某些不可剥夺资源的进程， '请求新的资源而得不到满足时，它必须释放已经保持的所有资源， 待以后需要时再重新申请。' 这 意味着， 一个进程已占有的资源会被暂时释放， 或者说是被剥夺了，或从而破坏了不可剥夺条件。该策略实现起来比较复杂， 释放已获得 的资源可能造成前一阶段工作的失效， '反复地申请和释放资源会增加系统开销， 降低系统吞吐量'。 这种方法常用于状态易于保存和恢复的资 源，如 CPU 的寄存器及内存资源， 一般不能用于打印机之类的资源。3) '破坏请求和保持条件' 釆用'预先静态分配方法'， 即'进程在运行前一次申请完它所需要的全部资源'， 在它的资源未满足前，不把它投入运行。 一旦投入运行后， 这 些资源就一直归它所有， 也不再提出其他资源请求， 这样就可以保证系统不会发生死锁。 这种方式实现简单， 但缺点也显而易见， 系统资源被严重浪费， 其中有些资源可能仅在运行初期或运行快结束时才使用， 甚至根本不使用。 而且还会导致“饥饿” 现象， 当由于个别资源长期被其他进程占用时， 将致使等待该资源的进程迟迟不能开始运行。4) '破坏环路等待条件' 为了破坏循环等待条件， 可釆用'顺序资源分配法'。 首先给系统中的资源编号，规定每个进程， 必须按编号递增的顺序请求资源， 同类资源 一次申请完。 也就是说， 只要进程提出申请分配资源 Ri， 则该进程在以后的资源申请中， 只能申请编号大于 Ri 的资源。 这种方法存在的问题是， 编号必须相对稳定， 这就'限制了新类型设备的增加'；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的 顺序， 但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费； 此外， 这种按规定次序申请资源的方法， 也必 然会给用户的编程带来麻烦。 避免死锁（银行家算法） 我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。 为保证资金的安全，银行家规定： (1) 当一个顾客对资金的最大需求量不超过银行家现有的资金时就可接纳该顾客； (2) 顾客可以分期贷款，但贷款的总数不能超过最大需求量； (3) 当银行家现有的资金不能满足顾客尚需的贷款数额时，对顾客的贷款可推迟支付，但总能使顾客在有限的时间里得到贷款； (4) 当顾客得到所需的全部资金后，一定能在有限的时间里归还所有的资金. 12345&gt; 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，&gt; (1)如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。&gt; (2)当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。&gt; (3)若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。&gt; 检测死锁(死锁定理)通常分析描述死锁，可以用资源分配图。关于资源分配图，要仅仅抓住两点： 请求边 分配边 关键在找：空闲资源。如果空闲资源可以满足某个进程，这个进程就可以解脱了，把它摘除资源分配图，再看剩下的资源分配图，策略相同。 在资源分配图中，把分配的资源与进程连好，再看进程请求边。按照分配边分配好以后，剩余的资源就是空闲资源。此时再来分析进程Pi的请求边，如果空闲资源都能满足Pi的请求，也就意味着Pi可以从这个纠缠的图中得到解脱。删除Pi的所有相关的资源：已分配的+请求的。再递归处理剩下的资源分配图。 参看：https://blog.csdn.net/jgm20475/article/details/81297819 解除死锁1、资源剥夺法 挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。 2、撤销进程法 强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。 3、进程回退法 让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>多线程</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-优化查询]]></title>
    <url>%2F2019%2F06%2FSQL-%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[优化查询的方法1.使用索引尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。 2.优化SQL语句2.1 explain查看SQL语句执行效果12可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句， 把关键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news; 2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*” ， 不要返回用不到的任何字段。2.3 不在索引列做运算或者使用函数。2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和带宽浪费。3.优化数据库对象3.1 优化表的数据类型123使用 procedure analyse()函数对表进行分析， 该函数可以对表中列的数据类型提出优化建议。 能小就用小。 表数据类型第一个原则是： 使用能正确的表示和存储数据的最短类型。 这样可以减少对磁盘空间、 内存、 cpu 缓存的使用。使用方法： 'select * from 表名 procedure analyse();' 3.2 对表进行拆分通过拆分表可以提高表的访问效率。 1.垂直拆分把主键和一些列放在一个表中， 然后把主键和另外的列放在另一个表中。 如果一个表中某些列常用， 而另外一些不常用， 则可以采用垂直拆分。2.水平拆分 根据一列或者多列数据的值把数据行放到二个独立的表中。 3.3 使用中间表来提高查询速度创建中间表， 表结构和源表结构完全相同， 转移要统计的数据到中间表， 然后在中间表上进行统计， 得出想要的结果。 4.硬件优化4.1 CPU 的优化选择多核和主频高的 CPU。 4.2 内存的优化使用更大的内存。 将尽量多的内存分配给 MYSQL 做缓存。 4.3 磁盘 I/O 的优化4.3.1 使用磁盘阵列1234567(1)RAID 0 没有数据冗余， 没有数据校验的磁盘陈列。 实现 RAID 0至少需要两块以上的硬盘， 它将两块以上的硬盘合并成一块， 数据连续地分割在每块盘上。(2)RAID1 是将一个两块硬盘所构成 RAID 磁盘阵列， 其容量仅等于一块硬盘的容量， 因为另一块只是当作数据“镜像”。 (3)RAID-0+1 磁盘阵列。 RAID 0+1是 RAID 0 和 RAID 1 的组合形式。 它在提供与 RAID 1 一样的数据安全保障的同时,也提供了与 RAID 0 近似的存储性能。 4.3.2 调整磁盘调度算法选择合适的磁盘调度算法， 可以减少磁盘的寻道时间。 5.MYSQL自身的优化对 MySQL 自身的优化主要是对其配置文件 my.cnf 中的各项参数进行优化调整。 如指定 MySQL 查询缓冲区的大小， 指定 MySQL 允许的最大连接 进程数等。 6.应用优化6.1 使用数据库连接池6.2 使用查询缓存它的作用是存储 select 查询的文本及其相应结果。 如果随后收到一个相同的查询， 服务器会从查询缓存中直接得到查询结果。 查询缓存适用的 对象是更新不频繁的表， 当表中数据更改后， 查询缓存中的相关条目就会被清空 总结：(1) 选取最适合的字段：在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。还可以将字段设置为NOT NULL,在查询时就不用比较null值了 (2) 使用连接（JOIN）来替代子查询 (3) 使用联合（UNION)来代替手动创建的临时表：它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。 (4) 使用事务：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。 (5) 锁定表：事务会将数据库锁定，因此其他用户请求只能暂时等待直到事务结束，会造成响应延迟。我们可以通过锁定表的方法来获得更好的性能 (6) 使用外键。锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。 (7) 使用索引。索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。 (8) 优化的查询语句。 (9) 分库分表：可以按照业务分库，分流数据库并发压力，使数据库表更加有条理性 (10) 数据库引擎：一种是innodb、一种是myisam myisam快，是因为他的数据存储结构、索引存储结构和innodb不一样的，mysiam的索引结构是在内存中存的。 当然，myisam也有弱点，那就是他是表级锁，而innodb是行级锁，所以，mysiam适用于一次插入，多次查询的表，或者是读写分离中的读库中的表，而对于修改插入删除操作比较频繁的表，就很不合适了 (11) 读写分离：数据库并发大的情况下，最好的做法就是进行横向扩展，增加机器，以提升抗并发能力，而且还兼有数据备份功能]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-六大原则]]></title>
    <url>%2F2019%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[六原则一法则 1234567s( Single-Resposibility Principle ): 单一职责原则。o( Open-Closed principle ): 开放封闭原则。l( Liskov-Substituion Principle ): 里氏替换原则。d( Dependecy-Inversion Principle ): 依赖倒置原则。i( Interface-Segregation Principle ): 接口隔离原则。 合成/聚合复用。 迪米特法则（最少知道）&lt;!--more--&gt; (1)单一职责 一个类的功能要单一， 一个类只负责一个职责。 一个类只做它该做的事情(高内聚)。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的的破坏 作用如果只让一个类完成它该做的事,而不涉及与它无关的领域就是践行了高内聚的原则 (2)开放-封闭 软件实体(类、模块、函数等) 对修改关闭。 对扩展开放` 12345'有新的需求或变化时， 可以对现有代码进行扩展， 以适应新的情况。''对修改封闭， 意味着类一旦设计完成， 就可以独立其工作， 而不要对类尽任何修改。' 在开发阶段， 我们都知道， 如果对一个功能进行扩展， 如果只是一味地对方法进行修改， 可能会造成一些问题， 诸如可能会引入新的 bug， 或者增加代码的复杂度， 对代码结构造成破坏、 冗余， 还需要重新进行全面的测试。 那么该怎么解决这些问题？ 很简单，这就需要系统能 够支持扩展， 只有扩展性良好的系统， 才能在不进行修改已有实现代码的基础上， 引进新的功能。 作用可维护性，可扩展性，可复用，灵活性好 (3)里氏替换1任何使用基类的地方， 都能够使用子类替换， 而且在替换子类 后， 系统能够正常工作。 子类一定是增加父类的能力而不是减少父类的能力， 因为子类比父类的能力更多， 把能力多的对象当成能力少的对象来用当然没有任何问题。一个 软件实体如果使用的是一个基类， 那么当把这个基类替换成继承该基类的子类， 程序的行为不会发生任何变化。软件实体察觉不出基类对象和子类对 象的区别。 作用1. 提高代码的重用性，子类拥有父类的方法和属性； 2. 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性； 不足1. 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性； 2. 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成 非常糟糕的结果，要重构大量的代码。 (4)接口隔离1'使用多个专门的接口比使用单一的总接口要好。一个类对另外一个类的依赖性应当是建立在最小的接口上的。' 123将接口粒度最小化，将功能划分到每一个不能再分的子角色， 为每一个子角色创建接口通过这样，才不会让接口的实现类实现一些不必要的功能。 建立单一的接口， 不要建立臃肿的庞大的接口， 也就是说接口的方法尽量少。接口要小而专， 绝不能大而全。 臃肿的接口是对接口的污染,既然接口表示能力,那么一个接口只应该描述一种能力， 接口也应该是高度内聚的。 作用实现模块间的松耦合 (5)依赖倒置而不是依赖于具体， 也就是我们经常听到的“要面向接口编程” 。``` 1我们的类要依赖于抽象， 而不是依赖于具体， 也就是我们经常听到的“要面向接口编程” 。 1234 该原则说得具体一些就是声明方法的参数类型、 方法的返回类型、 变量的引用类型时， '尽可能使用抽象类型而不用具体类型，' 因为抽象类型可以被它的任何一个子类型所替代（1）高层模块不应该依赖低层模块，两个都应该依赖抽象（2）抽象不应该依赖细节，细节应该依赖抽象 作用通过抽象（抽象类或接口） 使各个类或模块的实现彼此独立， 不相互影响， 实现模块间的松耦合。 减少类间的耦合性。 (6)合成/聚合复用1'将已有对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能。' 在面向对象设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生改变，则子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。于是就提出了合成/聚合复用原则，也就是在实际开发设计中，尽量使用合成/聚合，不要使用类继承.一般而言，如果一个角色得到了更多的责任，那么可以使用合成/聚合关系将新的责任委派到合适的对象。当然，这种复用也有缺点。 最主要的缺点就是通过这种复用建造的系统会有较多的对象需要管理。 迪米特法则(最少知道法则)如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类要调用另一个类的某种方法，可以通过第三方转发这个调用 1在类的结构设计上，每个类都应当尽量降低成员的访问权限 作用类间解耦，降低耦合度，只有弱耦合之后，类的复用性才可以提高]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA中的【IO】、【NIO】、【AIO】]]></title>
    <url>%2F2019%2F06%2FJAVA%E4%B8%AD%E7%9A%84NIO-BIO%2F</url>
    <content type="text"><![CDATA[IO和NIO的区别 IO NIO 面向流 面向缓冲 阻塞IO 非阻塞IO 无 选择器 1.面向流与面向缓冲 12345&gt; Java IO 面向流意味着每次从流中读一个或多个字节， 直至读取所有字节，它们没有被缓存在任何地方。 此外， 它不能前后&gt; 移动流中的数据。&gt; Java NIO 中把数据读取到一个缓冲区中， 需要时可在缓冲区中前后移动。 这就增加了处理过程中的灵活性。而且， 需确保当&gt; 更多的数据读入缓冲区时， 不要覆盖缓冲区里尚未处理的数据。&gt; 2.阻塞与非阻塞 IO 1234567&gt; Java IO 的各种流是阻塞的。 这意味着， 当一个线程调用 read() 或 write() 时， 该线程被阻塞， 直到有一些数据被读取,&gt; 或数据完全写入。 '该线程在此期间不能再干任何事情了'。&gt; Java NIO 的非阻塞模式， 使一个线程从某通道发送请求读取数据， 但是它仅能得到目前可用的数据， 如果'目前没有数据可用时，&gt; 就什么都不会获取， 而不是保持线程阻塞， 所以直至数据变的可以读取之前， 该线程可以继续做其他的事情。' 非阻塞写也是如此。 一&gt; 个线程请求写入一些数据到某通道， 但不需要等待它完全写入， 这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用&gt; 于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel)。&gt; 3.选择器（Selector） 123456&gt; Java NIO 的选择器允许一个单独的线程来监视多个输入通道， 你可以注册多个通道使用一个选择器， 然后使用一个单独的线程&gt; 来“选择”通道： 这些通道里已经有可以处理的输入， 或者选择已准备写入的通道。 为了将 Channel和Selector 配合使用,必须将&gt; channel 注册到 selector 上， 通过SelectableChannel.register()方法来实现。 这种选择机制，使得一个单独的线程很容易来&gt; 管理多个通道。 '只要 Channel 向 Selector 注册了某种特定的事件，Selector 就会监听这些事件是否会发生，一旦发生某个&gt; 便会通知对应的 Channel。 使用选择器， 借助单一线程， 就可对数量庞大的活动 I/O 通道实施监控和维护'&gt; IO同步阻塞(1)阻塞IO 最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解绑block状态。典型的阻塞IO模型的例子为：data = socket.read()；如果数据没有就绪，就会一直阻塞在read方法。 (2)非阻塞IO 当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个Error时，它就知道数据还没准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次受到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就是说非阻塞IO模型不会交出CPU，而会一直占用CPU. 123456789&gt; &gt; while(true)&#123;&gt; data = socket.read();&gt; if(data != error)&#123;&gt; 处理数据&gt; break;&gt; &#125;&gt; &#125;&gt; (3)多路复用IO[同步非阻塞NIO] 在多路复用IO模型中(实际上就说NIO)，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。通过一个线程就可以管理多个socket，只有在真正有socket读写事件进行时，才会使用IO资源进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。 (4)信号驱动IO 在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。 (5)异步IO[异步非阻塞AIO]应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。 在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求一个成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就是说用户线程完全不需要实际的整个IO操作是如何进行的。只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。 NIO同步非阻塞 原理1.缓冲区(buffer)缓冲区实际上是一个容器对象， 其实就是一个数组， &apos;在 NIO 库中,所有数据都是用缓冲区处理的。&apos;在读取数据时， 它是直接读到缓冲区中的； 在写入数据时， 它也是写入到缓冲区中的； 任何时候访问 NIO 中的数据， 都是将它放到缓冲区中。 在 NIO 中， 所有的缓冲区类型都继承于 抽象类 Buffer， 最常用的就是 ByteBuffer。 2.通道(channel)1234567'通道是一个对象， 通过它可以读取和写入数据'， 所有数据都通过 Buffer 对象来处理。 我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。 同样不会直接从通道中读取字节， 而是将数据从通道读入缓冲区， 再从缓冲区获取这个字节。 而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类， 比如 InputStream 只能进行读取操作， OutputStream 只能进行写操作)， 而'通道是双向的， 可以用于读、 写或者同时用于读写'。 3.选择器（selector）1234567'Selector 的作用就是用来轮询每个注册的 Channel，一旦发现 Channel 有注册的事件发生， 便获取事件然后进行处理。' 用单线程处理一个 Selector， 然后通过 Selector.select()方法来获取到达事件， 在获取了到达事件之后， 就可以逐个地对这些事件进行响应处理。 '服务端和客户端各自维护一个管理通道的对象， 我们称之为 selector， 该对象能检测一个或多个通道（channel） 上的事件。' 我们以服务端为例， 如果服务端的 selector 上注册了读事件， 某时刻客户端给服务端送了一些数据， 阻塞 I/O这时会调用 read()方法阻塞地读取数据， 而 NIO 的服务端会在 selector 中添加一个读事件。 服务端的处理线程会轮询地访问 selector， 如果访问selector 时发现有感兴趣的事件到达， 则处理这些事件， 如果没有感兴趣的事件到达， 则处理线程会一直阻塞直到感兴趣的事件到达为止。 ##]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA基础</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式]]></title>
    <url>%2F2019%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式定义一个用于创建对象的接口，让子类决定实例化哪个类，工厂方法使一个类的实例化延迟到其子类。 提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。 1.简单工厂方法12345678910111213//创建工厂public class Factory&#123; public static ISample creator(int which)&#123; if (which==1) return new SampleA(); else if (which==2) return new SampleB(); &#125;&#125;//创建实例时ISample sampleA = Factory.creator(1);ISample sampleA = Factory.creator(2); 2.抽象工厂12345678910111213141516171819202122232425262728//创建一个工厂接口public abstract class Factory&#123; public abstract Sample creator(); public abstract Sample2 creator(String name);&#125;//创建实现接口的实体类public class SimpleFactory extends Factory&#123; public Sample creator()&#123; ......... return new SampleA &#125; public Sample2 creator(String name)&#123; ......... return new Sample2A &#125;&#125; //创建工厂public class BombFactory extends Factory&#123; public Sample creator()&#123; ...... return new SampleB &#125; public Sample2 creator(String name)&#123; ...... return new Sample2B &#125;&#125; 优点 1、可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。 2、可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。3、可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。 缺点 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。 应用场景 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-原型模式]]></title>
    <url>%2F2019%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另外一个可定制的对象，而不需要知道任何创建细节。 1.浅拷贝对类实现Cloneable接口（implements Cloneable），并且重写clone 对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象. 12345678910111213//具体原型类class Realizetype implements Cloneable&#123; Realizetype() &#123; System.out.println("具体原型创建成功！"); &#125; public Object clone() throws CloneNotSupportedException &#123; System.out.println("具体原型复制成功！"); return (Realizetype)super.clone(); &#125;&#125; 2.深拷贝对其中的引用类型的成员变量进行实现Cloneable接口，重写clone，就变成深拷贝了 对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class A implements Cloneable&#123; String name; String int age; Child child; //这是一个类，表A中的引用类型 @Override public Object clone()&#123; try&#123; return super.clone(); &#125;catch(Exception e)&#123; &#125; return null; &#125; &#125; public class child implements Cloneable&#123; @Override public Object clone()&#123; try&#123; return super.clone(); &#125;catch(Exception e)&#123; &#125; return null; &#125; &#125; 优点 1.如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程。 2.使用原型模式创建对象比直接 new 一个对象在性能上要好的多，因为 Object 类的 clone 方法是一个本地方法，它直接操作内存中的二进制流，特别 是复制大对象时，性能的差别非常明显。 使用场景 在需要重复地创建相似对象时可以考虑使用原型模式。 比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数 很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-享元模式]]></title>
    <url>%2F2019%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[享元模式 运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。 代码实现 在享元模式中引入了享元工厂类FlyweightFactory，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。 享元工厂类：FlyweightFactory 享元类：ConcreteFlyweight 享元对象：Flyweight 12345678910111213141516class FlyweightFactory &#123; //定义一个HashMap用于存储享元对象，实现享元池 private HashMap flyweights = newHashMap(); public Flyweight getFlyweight(String key)&#123; //如果对象存在，则直接从享元池获取 if(flyweights.containsKey(key))&#123; return(Flyweight)flyweights.get(key); &#125; //如果对象不存在，先创建一个新的对象添加到享元池中，然后返回 else &#123; Flyweight fw = newConcreteFlyweight(); flyweights.put(key,fw); return fw; &#125; &#125;&#125; 优点 可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享 缺点 享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。 应用 当我们项目中创建很多对象，而且这些对象存在许多相同模块，这时，我们可以将这些相同的模块提取出来采用享元模式生成单一对象，再使用这个对象与之前的诸多对象进行配合使用，这样无疑会节省很多空间。 String中的享元模式 Java中将String类定义为final（不可改变的），JVM中字符串一般保存在字符串常量池中，java会确保一个字符串在常量池中只有一个拷贝，这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。 Integer中的享元模式 可以看到 Integer 默认先创建并缓存 -128 ~ 127 之间数的 Integer 对象，当调用 valueOf 时如果参数在 -128 ~ 127之间则计算下标并从缓存中返回，否则创建一个新的 Integer 对象 Long中的享元模式 与Integer原理类似 Apache Commons Pool2中的享元模式（对象池） 将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用，从而在一定程度上减少频繁创建对象所造成的开销。用于充当保存对象的“容器”的对象，被称为“对象池”]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2F2019%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式包括 （1）私有的构造方法 （2）含有一个该类的静态私有对象private static （3）提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。 懒汉模式：全局的单例在第一次使用时构建（延迟初始化）优点： 避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法。缺点： 懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。 123456789101112131415public class Singleton &#123; private Singleton()&#123; &#125; private static volatile Singleton instance = null; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 饿汉模式：全局的单例实例在类装载时构建1.线程安全2.在类加载的同时已经创建好一个静态对象，调用时反应速度快 缺点资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化 123456789public class Singleton &#123; private Singleton()&#123; &#125; private static volatile Singleton instance = new Singleton(); public static Singleton getInstance() &#123; return instance; &#125; &#125;&#125; 单例模式的应用数据库连接池，多线程连接池。Windows应用管理器 优点 1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。3.提供了对唯一实例的受控访问。4.由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。5.允许可变数目的实例。6.避免对共享资源的多重占用。 缺点 单例模式可能导致内存泄漏（OOM） 1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。3.单例类的职责过重，在一定程度上违背了“单一职责原则”。4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA_集合中的快速失败与安全失败]]></title>
    <url>%2F2019%2F05%2FJAVAVA-java%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E4%B8%8E%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[快速失败(fail—fast)机制 java集合框架中的一种错误检测机制。多线程下用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除），则会抛出Concurrent Modification Exception。 fail-fast机制并不保证在不同步的修改下一定会抛出异常，这种机制一般仅用于检测bug。 【在循环迭代中修改会报异常，在迭代中修改不会报异常】 java.util包下的集合类都是采用快速失败机制的，不能在多线程下发生并发修改（只能在迭代过程中被修改）。 原理迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 这里异常的抛出条件是检测到 modCount!=expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。 1234567891011121314public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;10;i++) &#123; list.add(i); &#125; for(int n:list)&#123; if(n==6)&#123; list.remove(n); &#125; &#125; System.out.println(list.toString());&#125;----&gt;for语句修改结果报错&lt;-----------------------&gt;Exception in thread "main" java.util.ConcurrentModificationException&lt;------------ 1234567891011121314public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;10;i++) &#123; list.add(i); &#125; Iterator&lt;Integer&gt; it = list.iterator(); while (it.hasNext()) &#123; if (it.next() == 6) &#123; it.remove(); &#125; &#125; System.out.println(list.toString());&#125;-------&gt;结果不报错&lt;------------------ 迭代器是作为当前集合的内部类实现的，当迭代器创建的时候保持了当前集合的引用； 集合内部维护一个int变量modCount，用来记录集合被修改的次数，比如add，remove等都会使该字段递增； modCount这个参数记录了某个List改变大小的次数，如果modCount改变的不符合预期，那么就会抛出异常。 迭代器内部也维护着当前集合的修改次数的字段，迭代器创建时该字段初始化为集合的modCount值 当每一次迭代时，迭代器会比较迭代器维护的字段和modCount的值是否相等，如果不相等就抛ConcurrentModifiedException异常； 当然，如果用迭代器调用remove方法，那么集合和迭代器维护的修改次数都会递增，以保持两个状态的一致。 安全失败(fail-safe) 在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常 concurrent包下的都是安全失败的，可以在多线程下并发使用，并发修改。 原理 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 缺点 基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>集合类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap底层]]></title>
    <url>%2F2019%2F05%2FHashmap%E5%BA%95%E5%B1%82%2F</url>
    <content type="text"><![CDATA[HashMap简介 1.实现原理底层是链表+数组，当链表长度大于8自动转化成红黑树。 首先有一个每个元素都是链表的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。 2.hashMap的java构建12345678transient Entry[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;&#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; ...&#125; 3.HashMap的put实现 （1）程序先计算该key的hashCode()值 （2）对该哈希码进行再哈希，然后把哈希值和(数组长度-1)进行按位与操作，得到数组的下标 （3）该位置没有链表节点就把&lt;key,value&gt;放入该位置。有节点就对链表进行遍历，看是否有key一样的节点，有则value进行覆盖更新，没有就创建节点，把节点放链表表头（头插法）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public V put(K key,V value)&#123; //HashMap 允许存放null键和null值 //当key为null时，调用putForNullKey,将value放置在数组第一个位置 if(key==null)&#123; return putForNullKey(value); &#125; //根据key的keycode重新计算hash值 int hash = hash(key.hascode()); //搜索指定hash值在对应table的索引 int i = indexFor(hash,table.length); //如果i索引处的entry不为null,通过循环不断遍历e元素的下一个元素 for(Entry&lt;K,V&gt; e = table[i];e!=null;e = e.next)&#123; Object k; if(e.hash == hash &amp;&amp; ((k = e.key) == key || ley.equals(k)))&#123; V.oldValue = e.value; e.recordAccess(this); return oldValue; &#125; &#125; //如果i索引处的entry为null,表明此处还没有entry modCount++; //将key、value添加到i索引处 addEntry(hash,key,value,i); return null;&#125;void addEntry(int hash,K key,V value,int bucketIndex)&#123; //获取指定bucketIndex索引处的Entry Entry&lt;K,V&gt; e = table[bucketIndex]; //将新创建的Entry放入bucletIndex索引处，并让新的Enrty指向原来的Entry table[bucketIndex] = new Entry&lt;K,V&gt; (hash,key,value,e); //如果Map中的key-value对数量超过了极限 if(size++&gt;=threshold) //把table对象的长度扩充为2倍 resize(2*table.length); &#125;//HashMap长度扩充void resize(int newCapacity)&#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if(oldCapacity == MAXIMUM_CAPACITY)&#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int) (newCapacity*loadFactor);&#125;void transfer(Entry[] newTable)&#123; Entry[] src = table; int newCapacity = newTable.length; for(int j = 0;j&lt;src.length;j++)&#123; Entry&lt;K,V&gt; e = src[j]; if(e!=null)&#123; src[j] = null; &#125; do&#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash,newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125;while(e!=null) &#125;&#125;//进行hash计算static int indexFor(int hash,int length)&#123; return hash&amp; (length-1);&#125; 4.HashMap的get方法 （1）通过key的两次hash的值与数组的长度-1进行按位与操作，定位到数组的某个位置 （2）对该列的链表进行遍历 123456789101112public V get(Object key)&#123; if(key == null) return getForNullKey(); int hash = hash(key.hasCode()); for(Entry&lt;K,V&gt; e = table[indexFor(hash,table.length)]);e!=null;e = e.next)&#123; Object k; if(e.hash == hash &amp;&amp; (k = e.key) == key || key.equals(k))&#123; return e.value; &#125; &#125; return null; &#125; 5.HashMap总结（1）hashmap可以存储null值，线性不安全 （2）hashmap扩容：当 HashMap 中的结点个数超过数组大小loadFactor（加载因子） 时， 就会进行数组扩容，loadFactor 的默认值为 0.75。也就是说，默认情况下，数组大小为 16，那么当 HashMap中结点个数超过 160.75=12 的时候， 就把数组的大小扩展为 2*16=32， 即扩大一倍，然后重新计算每个元素在数组中的位置，并放进去， 而这是一个非常消耗性能的操作。 （3）多线程 put 操作后， get 操作导致死循环,导致 cpu100%的现象。 主要是多线程同时put 时， 如果同时触发了 rehash 操作，会导致扩容后的 HashMap 中的链表中出现循环节点， 进而使得后面 get 的时候，会死循环。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_内存泄漏和内存溢出]]></title>
    <url>%2F2019%2F05%2FJVMVM-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[内存泄漏概念： 一个不再被程序使用的对象或者变量还在内存中占有存储空间。 （1）堆中申请的空间没有被释放 （2）对象不在使用但还在内存中保留 内存泄漏的原因： （1）静态集合类，如hashmap和vector，如果容器为静态，她们的生命周期与程序一致。 （2）各种连接，如数据库连接，IO连接 （3）监听器：通常一个应用中会用到多个监听器，但是在释放对象的同时往往没有相应的删除监听器 （4）变量不合理的作用域。一方面一个变量的定义作用范围大于其使用范围，很可能造成内存泄漏。另一方面如果没有及时把对象设置为null,很可能导致内存泄漏。 （5）单例模式：一直存在着一个对对象的引用，并且以一个静态变量的方式存储，因此它在JVM整个生命周期都存在。 内存泄漏解决方案： （1）避免在循环中创建对象 （2） 尽早释放无用的对象引用 （3）尽量少用静态变量 （4）使用字符串处理，避免使用String,应大量使用StringBuffer,因为每个String对象都得独立占用内存一块区域 内存溢出OOM概念： 程序运行过程中无法申请到足够的内存而导致的一种错误，除了程序计数器外，其他几个运行区都有OOM的可能。 内存溢出情况： （1）虚拟机栈和本地方法栈溢出 如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackOverflowError 异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError 异常。 （2）堆溢出 123456&gt; 一般的异常信息： java.lang.OutOfMemoryError:Java heap spaces&gt; 出现这种异常，一般手段是先通过内存映像分析工具(如 Eclipse Memory Analyzer)对 dump 出来的堆转存快照进行分析,&gt; 重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏还是内存溢出。&gt; 1.如果是内存泄漏， 可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。&gt; 2.如果不存在泄漏， 那就应该检查虚拟机的参数(-Xmx 与-Xms)的设置是否适当。&gt; （3）方法区溢出 异常信息： java.lang.OutOfMemoryError:PermGen space。 （4）运行时常量池溢出 异常信息： java.lang.OutOfMemoryError:PermGen space。 12345&gt; 如果要向运行时常量池中添加内容，最简单的做法就是使用 String.intern()这个Native 方法。&gt; 该方法的作用是:如果池中已经包含一个等于此 String 的字符串， 则返回代表池中这个字符串的 String 对象；&gt; 否则，将此 String 对象包含的字符串添加到常量池中， 并且返回此 String 对象的引用 。&gt; 由于常量池分配在方法区内，我们可以通过-XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小， 从而间接限制其中常量池的容量。&gt; 内存溢出原因： 1.内存中加载的数据量过于庞大， 如一次从数据库取出过多数据； 2.集合类中有对对象的引用， 使用完后未清空， 使得 JVM 不能回收；3.代码中存在死循环或循环产生过多重复的对象实体；4.启动参数内存值设定的过小。 内存溢出解决方法： (1) 修改 JVM 启动参数， 直接增加内存。 (-Xms， -Xmx 参数一定不要忘记加。一般要将-Xms 和-Xmx 选项设置为相同， 以避免在每次 GC 后调整堆的大小； 建 议堆的最大值设置为可用内存的最大值的 80%)。 (2) 检查错误日志， 查看“OutOfMemory” 错误前是否有其它异常或错误。 (3)对代码进行走查和分析， 找出可能发生内存溢出的位置 (4) 使用内存查看工具动态查看内存使用情况（Jconsole）。 减少gc次数的方法： （1）对象不用时最好显式置为 Null 一般而言,为 Null 的对象都会被作为垃圾处理,所以将不用的对象显式地设 为 Null,有利于 GC 收集器判定垃圾,从而提高了 GC 的效率。 （2）尽量少用 System.gc() 此函数建议 JVM进行主 GC,虽然只是建议而非一定,但很多情况下它会触发 主 GC,从而增加主 GC 的频率,也即增加了间歇性停顿的次数。 （3）尽量少用静态变量 静态变量属于全局变量,不会被 GC 回收,它们会一直占用内存。 （4） 尽量使用 StringBuffer,而不用 String 来累加字符串。 由于 String 是固定长的字符串对象,累加 String 对象时,并非在一个 String 对象中扩增,而是重新创建新的 String 对象,如 Str5=Str1+Str2+Str3+Str4,这条 语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新 的 String 对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多 的垃圾。 避免这种情况可以改用 StringBuffer 来累加字符串,因 StringBuffer 是可变长的,它在原有基础上进行扩增,不会产生中间对象。（5）分散对象创建或删除的时间 1234&gt; 集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM 在面临这种情况时,只能进行主 GC,以回收内存或整合&gt; 内存碎片从而增加主 GC 的频率。集中删除对象,道理也是一样的。 它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大&gt; 增加了下一次创建新对象时强制主 GC 的机会。&gt; （6） 尽量少用 finalize 函数。 因为它会加大 GC 的工作量， 因此尽量少用finalize 方式回收资源。 （7） 如果需要使用经常用到的图片， 可以使用软引用类型， 它可以尽可能 （8）能用基本类型如 int,long,就不用 Integer,Long 对象 基本类型变量占用的内存资源比相应包装类对象占用的少得多,如果没有必要,最好使用基本变量。 （9） 增大-Xmx 的值。]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java_深拷贝和浅拷贝]]></title>
    <url>%2F2019%2F05%2FJava-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[浅拷贝 对基本数据类型进行了拷贝 对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象。 即对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝 底层实现：（1）对类实现Cloneable接口（implements Cloneable），并且重写clone 1234567891011121314&gt; public class A implements Cloneable&#123;&gt; String name;&gt; String int age;&gt; Child child; //这是一个类，表A中的引用类型&gt; @Override&gt; public Object clone()&#123;&gt; try&#123;&gt; return super.clone();&gt; &#125;catch(Exception e)&#123;&gt; &#125;&gt; return null;&gt; &#125;&gt; &#125;&gt; （2）用clone()方法创建新的对象 123&gt; A a = new A();&gt; A aclone = (A)a.clone();&gt; 深拷贝 对基本数据类型进行了拷贝 对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量 即对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容 底层实现： 序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。 继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。对A而言就是深拷贝。 123456789101112131415161718192021222324&gt; public class A implements Cloneable&#123;&gt; String name;&gt; String int age;&gt; Child child; //这是一个类，表A中的引用类型&gt; @Override&gt; public Object clone()&#123;&gt; try&#123;&gt; return super.clone();&gt; &#125;catch(Exception e)&#123;&gt; &#125;&gt; return null;&gt; &#125;&gt; &#125;&gt; public class child implements Cloneable&#123;&gt; @Override&gt; public Object clone()&#123;&gt; try&#123;&gt; return super.clone();&gt; &#125;catch(Exception e)&#123;&gt; &#125;&gt; return null;&gt; &#125;&gt; &#125;&gt; 总结一个对象内部只有基本数据类型，那用 clone() 方法获取到的就是这个对象的深拷贝，而如果其内部还有引用数据类型，那用 clone() 方法就是一次浅拷贝的操作。]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【42】接雨水]]></title>
    <url>%2F2019%2F05%2Fleetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 2.解题思路思路1：转化成每个位置留下水量的总和 i位置上留下的水为[0 , (i-1)]的最大值max1,(i+1,length)位置上的max2的两者较小值-该位置的高度：min(max2-max1) - arr[i]。 思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。 思路3：跟思路2一致，减掉了一个指针 思路4：左边最大值小于右边最大值，左指针右滑，左指针位置上能装的水就是左边最大值减去左指针指的值，若左指针指向的值大于左边大值，就不减，说明不能储水，更新左边最大值，当右边最大值小于左边最大值时，右指针左滑，做法跟前类似，直到左指针小于等于右指针跳出循环。 3.代码思路1代码：转化成每个位置留下水量的总和 123456789101112131415161718public static int getWater1(int[] arr) &#123; if (arr == null || arr.length &lt; 3) &#123; return 0; &#125; int value = 0; for (int i = 1; i &lt; arr.length - 1; i++) &#123; int leftMax = 0; int rightMax = 0; for (int l = 0; l &lt; i; l++) &#123; leftMax = Math.max(arr[l], leftMax); &#125; for (int r = i + 1; r &lt; arr.length; r++) &#123; rightMax = Math.max(arr[r], rightMax); &#125; value += Math.max(0, Math.min(leftMax, rightMax) - arr[i]); &#125; return value; &#125; 思路2代码： 123456789101112131415161718192021222324//思路2：依次结算每个位置的水量，max_left和max_right那边数值小结算哪边。并向中间滑动。 public static int trap2(int[] arr) &#123; if (arr == null || arr.length &lt; 3) &#123; return 0; &#125; int n = arr.length - 2; int[] leftMaxs = new int[n]; leftMaxs[0] = arr[0];//左指针初始化为第一个数 //求左边的max for (int i = 1; i &lt; n; i++) &#123; leftMaxs[i] = Math.max(leftMaxs[i - 1], arr[i]); &#125; int[] rightMaxs = new int[n]; rightMaxs[n - 1] = arr[n + 1];//右指针初始化为数组最后一个数//求右边的max for (int i = n - 2; i &gt;= 0; i--) &#123; rightMaxs[i] = Math.max(rightMaxs[i + 1], arr[i + 2]); &#125; int value = 0; for (int i = 1; i &lt;= n; i++) &#123; value += Math.max(0, Math.min(leftMaxs[i - 1], rightMaxs[i - 1]) - arr[i]); &#125; return value; &#125; 思路3代码： 12345678910111213141516171819//思路3：减少一个指针 public static int trap3(int[] arr) &#123; if (arr == null || arr.length &lt; 3) &#123; return 0; &#125; int n = arr.length - 2; int[] rightMaxs = new int[n]; rightMaxs[n - 1] = arr[n + 1]; for (int i = n - 2; i &gt;= 0; i--) &#123; rightMaxs[i] = Math.max(rightMaxs[i + 1], arr[i + 2]); &#125; int leftMax = arr[0]; int value = 0; for (int i = 1; i &lt;= n; i++) &#123; value += Math.max(0, Math.min(leftMax, rightMaxs[i - 1]) - arr[i]); leftMax = Math.max(leftMax, arr[i]); &#125; return value; &#125; 思路4代码： 1234567891011121314151617181920public static int trap4(int[] arr) &#123; if (arr == null || arr.length &lt; 3) &#123; return 0; &#125; int value = 0; int leftMax = arr[0]; int rightMax = arr[arr.length - 1]; int l = 1;//从第二个查看是否能蓄水 int r = arr.length - 2;////从倒数第二个查看是否能蓄水 while (l &lt;= r) &#123; if (leftMax &lt;= rightMax) &#123; value += Math.max(0, leftMax - arr[l]); leftMax = Math.max(leftMax, arr[l++]); &#125; else &#123; value += Math.max(0, rightMax - arr[r]); rightMax = Math.max(rightMax, arr[r--]); &#125; &#125; return value; &#125; 4.提交记录思路1提交记录： 思路2提交记录： 思路3提交记录： 思路4提交记录：]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>滑动窗口法</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【11】盛最多水的容器]]></title>
    <url>%2F2019%2F05%2Fleetcode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 2. 解题思路这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。 我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 res 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 res，并将指向较短线段的指针向较长线段那端移动一步。 3.代码123456789101112131415161718import java.util.*;class Solution &#123; public int maxArea(int[] height) &#123; int res = 0; int left = 0; int right = height.length-1; while(left&lt;right)&#123; res = Math.max(res,(right-left)*Math.min(height[left],height[right])); //舍弃高度较小的 if ((height[left] &gt; height[right])) &#123; right--; &#125; else &#123; left++; &#125; &#125; return res; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>中等</tag>
        <tag>滑动窗口法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【10】正则表达式匹配]]></title>
    <url>%2F2019%2F05%2Fleetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个字符串 (s) 和一个字符模式 (p)。实现支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。 ‘.’ 匹配任意单个字符。‘*’ 匹配零个或多个前面的元素。 匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1: 输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。 示例 2: 输入:s = “aa”p = “a“输出: true解释: ‘‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。 示例 3: 输入:s = “ab”p = “.“输出: true解释: “.“ 表示可匹配零个或多个(‘*’)任意字符(‘.’)。 示例 4: 输入:s = “aab”p = “cab”输出: true解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。 示例 5: 输入:s = “mississippi”p = “misisp*.”输出: false 2.解题思路方法1： 跟剑指offer的52题一致 这道题的核心其实在于分析’‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’‘的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。 情况1：Patttern第二个字符是’*’时： 1.第一个字符不匹配（’.’与任意字符视作匹配），那么’*’只能代表匹配0次 ‘ba’与’a*ba’，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式 2.第一个字符匹配，那么’*’可能代表匹配0次，1次，多次， (1)’aaa’与’a*aaa’: 匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式； (2)’aba’与’a*ba’:匹配1次时，字符串往后移动一个字符，模式向后移动2个字符； (3)’aaaba’与’a*ba’:匹配多次时，字符串往后移动一个字符，模式不变； 情况2：Patttern第二个字符不是’*’时： (1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。 (2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。 方法2：动态规划 定义一个dp[][]数组，其中d[i][j]表示s[0,i]和p[0][j]是否匹配 dp初始化:dp[0][0] = true，代表str为空串，pattern为空串的情况 求dp[0][j]即求str为空串，pattern是否匹配 当遇到后一个为 * 时，且dp[0][i-1]为true则匹配(匹配前面字符0次)，标记dp[0][i+1] = true 情况1：当前字母匹配，str和pattern都往后移动一位 dp[i+1][j+1] = dp[i][j] 情况2：后一个pattern是 * ,前一个pattern跟str不匹配,str不变，pattern后移动两位 dp[i+1][j+1] = dp[i+1][j-1] 情况3：后一个pattern是 * ,前一个pattern跟str匹配 (1)匹配0次，str不动，pattern后移2位 dp[i+1][j+1] = dp[i+1][j-1] (2)匹配一次，str移动1位，pattern移动2位 dp[i+1][j+1] =dp[i][j-1] (3)匹配多次，str移动1次，pattern不动 dp[i+1][j+1] = dp[i][j+1] 3.代码方法1： 12345678910111213141516171819202122232425262728293031323334public static boolean isMatch(String str, String pattern) &#123; if (str == null || pattern == null) return false; return matchCore(str.toCharArray(), 0, pattern.toCharArray(), 0); &#125; public static boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) &#123; //有效性检验：str到尾，pattern到尾，匹配成功 if (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123; return true; &#125; //pattern先到尾，匹配失败 if (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123; return false; &#125; //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位 // //如果当前pattern的下一个是*并且没有超出pattern的长度时 if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] == '*') &#123; // //如果当前字符str[index]和pattern[index]相等，或者当前pattern为‘.’ if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符(当前pattern[index+1]='*'且str[index]!=pattern[index]） || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符 (当前pattern[i+1]='*'且str[index]=pattern[index]) || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个（当前pattern[index]='.'） &#125; else &#123; //当前字符str[index]和pattern[index]不相等&amp;&amp;当前pattern不为‘.’ return matchCore(str, strIndex, pattern, patternIndex + 2); &#125; &#125; //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false //pattern[index]='.'的情况，strindex和pattern都加1向下匹配 if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return matchCore(str, strIndex + 1, pattern, patternIndex + 1); &#125; return false; &#125; 方法2：动态规划 1234567891011121314151617181920212223242526272829303132333435363738public static boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; //i= 0，j= 0表示str和pattern为空串，匹配成功标true dp[0][0] = true; //str为空串，pattern不为空串的情况 for (int i = 0; i &lt; p.length(); i++) &#123; //前一个为true后一个为*，*匹配0个，则标记下一个为true if (p.charAt(i) == '*' &amp;&amp; dp[0][i - 1]) &#123; dp[0][i + 1] = true; &#125; &#125; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; //当前字母匹配，字符str和pattern都后移动一位 if (p.charAt(j) == '.' || p.charAt(j) == s.charAt(i)) &#123; dp[i + 1][j + 1] = dp[i][j]; &#125; //后一个字符是* if (p.charAt(j) == '*') &#123; //str与pattern不匹配 if (p.charAt(j - 1) != s.charAt(i) &amp;&amp; p.charAt(j - 1) != '.') &#123; //str不变，pattern后移动两位 dp[i + 1][j + 1] = dp[i + 1][j - 1]; &#125; else &#123; //匹配0次，str不动，pattern后移2位，匹配一次，str移动一位，pattern移动2位，匹配多次，str移动1次，pattern不动 dp[i + 1][j + 1] = (dp[i + 1][j-1] || dp[i][j - 1] || dp[i][j + 1]); &#125; &#125; &#125; &#125; return dp[s.length()][p.length()]; &#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
        <tag>动态规划</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【234】回文链表]]></title>
    <url>%2F2019%2F05%2Fleetcode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 请判断一个链表是否为回文链表。 示例 1: 输入: 1-&gt;2输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 2.解题思路方法1：将链表的数值依次入栈，然后弹栈跟listnode从头到尾比较 方法2：快慢指针弦找到中间点，再反转后面链表，再遍历比较 3.代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); ListNode res = head; //链表入栈 while (head!=null)&#123; stack.push(head.val); head = head.next; &#125; //弹出比较 while (res!=null)&#123; if(stack.pop() == res.val)&#123; res = res.next; &#125;else &#123; return false; &#125; &#125; return true; &#125;&#125; 方法2： 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if(head == null || head.next == null) return true; ListNode lat = head.next; ListNode pre = head; //快慢指针,pre一次一步，lat一次两步 while(lat != null &amp;&amp; lat.next != null)&#123; lat = lat.next.next; pre = pre.next; &#125; //转置后半链表 ListNode cur = pre.next; pre.next = null; ListNode p = null; while (cur != null)&#123; ListNode q = cur.next; cur.next = p; p = cur; cur = q; &#125; //遍历比较 while(p != null &amp;&amp; head != null)&#123; if(p.val != head.val)&#123; return false; &#125; p = p.next; head = head.next; &#125; return true; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【9】回文数]]></title>
    <url>%2F2019%2F05%2Fleetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121输出: true 示例 2: 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 2.解题思路 方法1：转换成字符串，将字符串反转进行比较是否相等 方法2：用一个stack存入数字从低位到高位的数；依次弹出（高位到低位弹出）跟每次数值取余的数进行对比 3.代码方法1： 1234567891011class Solution &#123; public boolean isPalindrome(int x) &#123; String res = x+""; //字符串反转 String ans = new StringBuilder(x+"").reverse().toString(); if(res.equals(ans))&#123; return true; &#125; return false; &#125;&#125; 方法2： 12345678910111213141516171819202122class Solution &#123; public boolean isPalindrome(int x) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int res = x; if(x&lt;0) return false; // 依次从右到左入栈 while(x&gt;0)&#123; stack.push(x%10); x = x / 10; &#125; while (res&gt;0)&#123; //pop弹出,从左到右的字符串，res%10是从右到左 if(stack.pop()==res%10)&#123; res = res/10; &#125;else &#123; return false; &#125; &#125; return true; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【8】字符串转换成整数]]></title>
    <url>%2F2019%2F05%2Fleetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: “42”输出: 42 示例 2: 输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。 示例 4: 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 2.解题思路 (1) 用一个标志位flag记录字符串的正负号 (2) 依次进行叠加，如果遇到溢出，返回它的最大值或者最小值 最大溢出判断： res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int myAtoi(String s) &#123; //去掉前后空格 String str = s.trim(); if(str.length()==0||str == null) return 0; //判断只有符号的情况 if(str.length()==1&amp;&amp;(str.charAt(0)=='+'||str.charAt(0)=='-')) return 0; int flag = 1; //为正数，flag设为1，负数设为 -1,并截取后面的字符串进行字符串转换成整数 if(str.charAt(0)=='+'&amp;&amp; (str.charAt(1)&gt;='0'&amp;&amp;str.charAt(1)&lt;='9'))&#123; return Cal(flag,str,1,str.length()); &#125;else if(str.charAt(0)=='-'&amp;&amp;(str.charAt(1)&gt;='0'&amp;&amp;str.charAt(1)&lt;='9'))&#123; flag = -1; return Cal(flag,str,1,str.length()); &#125;else if((str.charAt(0)&gt;='0'&amp;&amp;str.charAt(0)&lt;='9'))&#123; return Cal(flag,str,0,str.length()); &#125;else&#123; return 0; &#125; &#125; //字符串转换成整数 private int Cal(int flag,String str, int start, int end) &#123; int res = 0; for(int i = start;i&lt;end;i++)&#123; if(str.charAt(i)&gt;='0'&amp;&amp;str.charAt(i)&lt;='9') &#123; int pop = str.charAt(i) - '0'; //只需要判断上溢出情况，因为我们将符号单独拎出来了 if (res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) &#123; if(flag==1) &#123; //上溢，输出最大值 return Integer.MAX_VALUE; &#125;else&#123; //下溢出，输出最小值 return Integer.MIN_VALUE; &#125; &#125; res = res*10 +pop; &#125;else&#123; //不是有效的字符[0-9]，直接退出 break; &#125; &#125; return flag*res; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【7】整数反转]]></title>
    <url>%2F2019%2F05%2Fleetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[1.题目描述 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123输出: 321 示例 2: 输入: -123输出: -321 示例 3: 输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 2.解题思路 主要是注意溢出问题 1234567&gt; （1）当x&gt;0时，溢出考虑上界&gt; 1)如果 result 的值大于 Integer.MAX_VALUE / 10 ，那么一定会溢出&gt; 2)如果 result 的值等于 Integer.MAX_VALUE / 10，那么 pop 的值如果大于 Integer.MAX_VALUE % 10 也会溢出&gt; (2) 当x&lt;0 时，溢出考虑下界&gt; 1)result 的值小于 Integer.MIN_VALUE / 10 ，那么一定会溢出&gt; 2)result 的值等于 Integer.MIN_VALUE / 10，那么 pop 的值如果小于于 Integer.MIN_VALUE % 10 也会溢出&gt; 3.代码12345678910111213141516171819202122class Solution &#123; public static int reverse(int x) &#123; int res = 0; while (x!=0)&#123; int pop = x%10; x = x/10; //考虑上界溢出 if (res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) &#123; res = 0; break; &#125; //考虑下界溢出 else if (res &lt; Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; Integer.MIN_VALUE % 10)) &#123; res = 0; break; &#125; //得到最后一位 res = res*10 +pop; &#125; return res; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[得到的最短的回文长度]]></title>
    <url>%2F2019%2F05%2F%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[1.题目描述 京京和东东是好朋友。东东很喜欢回文。回文是指从前往后读和从后往前读是一样的词语。京京准备给东东一个惊喜，先取定一个字符串s，然后在后面附上0个或者更多个字母形成回文，京京希望这个回文越短越好。请帮助京京计算他能够得到的最短的回文长度。 输入描述：输入包括一个字符串s，字符串s长度length(1 ≤ length ≤ 50)。 输出描述：输出一个整数，表示京京能够得到的最短的回文长度。 示例：输入abab 输出5 2.解题思路转化成求字符串中的最长回文子串的大小，结果即不是回文那部分逆序即可。 从左往右， 三个概念：回文半径数组pArr[]，回文右边界pr，取得回文右边界的轴中心i 1）没在回文右边界里边，暴力 2）i’在回文范围里，回文右边界不扩 3）i’在回文范围外，回文右边界不扩 4）i’压线，回文右边界扩 直到回文右边界第一次到达最后一个字符 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.*;public class Main &#123; //manacher预处理 public static char[] manacherString(String str) &#123; char[] charArr = str.toCharArray(); char[] res = new char[str.length() * 2 + 1]; int index = 0; for (int i = 0; i != res.length; i++) &#123; res[i] = (i &amp; 1) == 0 ? '#' : charArr[index++]; &#125; return res; &#125; public static int shortestEnd(String str) &#123; if (str == null || str.length() == 0) &#123; return 0; &#125; char[] charArr = manacherString(str); int[] pArr = new int[charArr.length]; int index = 0; int pR = 0; int maxContainsEnd = 0; for (int i = 0; i != charArr.length; i++) &#123; pArr[i] = pR &gt; i ? Math.min(pArr[2 * index - i], pR - i) : 1; while (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -1) &#123; if (charArr[i + pArr[i]] == charArr[i - pArr[i]]) pArr[i]++; else &#123; break; &#125; &#125; if (i + pArr[i] &gt; pR) &#123; pR = i + pArr[i]; index = i; &#125; //右边界到达最后一个字符就结束，那个中心就是包含最后一个字符的最长的回文 if (pR == charArr.length) &#123; //得到那个中心 maxContainsEnd = pArr[i]; break; &#125; &#125; //原来的长度 + 扩充的长度（字符最大的半径[str.length+1-回文最大的半径maxContainEnd]） return str.length() + str.length() - maxContainsEnd + 1; &#125; public static void main(String[] args) &#123; Scanner sr = new Scanner(System.in); String s = sr.nextLine(); System.out.println(shortestEnd(s)); &#125;&#125;]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
        <tag>manacher算法</tag>
        <tag>京东笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【5】最长回文子串]]></title>
    <url>%2F2019%2F05%2Fleetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 2.解题思路方法1：暴力破解方法方法2：动态规划 新建一个dp[i][j]代表的意思是索引从i到j的子字符串是否是回文，假设s = cbbd,则可以dp对应坐标索引下的子字符串： i = 0 1 2 3 j = 0 c cb cbb cbbd 1 b bb bbd 2 b bd 3 d 如果dp[i][j]所代表的字符串为回文，则将dp设为1.由上表可以总结出： （1）当i = j 时，dp[j][i] = 1 （2）i-j=1时,比如dp[1][2]为bb，表示两个相邻的字符，此时我们只要判断str[1]==str[2]就能得出dp[1][2]的结果 （3）i-j&gt;1时，我们来看dp[0][2]，首先还是要判断开头和结尾是否相等，也就是判断 str[0]==str[2]，假如此时str[0]=str[2]，我们还要再看剩下的子串是否回文， 我们可以直接从dp[j+1][i-1]来判断剩下的子串，把结果直接拿来用,判断是否是1（1表示回文） 即有公式 dp[i][j] = (dp[i+1][j-1] &amp;&amp;s[i]=S[j]​) == true?1:0 dp数组初始化如下： dp[i][i] = 1 dp[i][i+1] = ( S[i] == S[i+1] ?1:0; 方法3：中心扩展方法 回文中心的两侧互为镜像。因此，回文可以从他的中心展开，并且只有2n-1个这样的中心(一个元素为中心的情况有n个，两个元素为中心的情况有n-1个) 方法4：manacher算法 （1）预处理：回文的长度可奇可偶，故在每个字符的左右都加上一个特殊字符“#”,得到长度为奇数的字符串 （2）回文子串的半径：以中间的 ‘1’ 为中心的回文子串 “#2#2#1#2#2#” 的半径是6，而未添加#号的回文子串为 “22122”，长度是5，为半径减1。 （3）子串的起始位置：（字符串前面在加一个特殊字符”\$”,在字符末尾加另一个特殊字符”.”）中间位置减去半径再除以2。 （4）子串的终点位置：起点位置+半径-1 （5）马拉车核心 p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; 其中p[i]代表以i为中心的半径，id为能延伸到最右端的位置的那个回文子串的中心点位置，mx是回文串能延伸到的最右端的位置 1)mx - i &gt; p[j]，即以j为半径的回文在以id为半径的回文内(j跟i是对称的),其中 j = 2*id - i，因为 j 到 id 之间到距离等于 id 到 i 之间到距离，为 i - id，所以 j = id - (i - id) = 2*id - i. 2)mx - i &lt; p[j],即以j为中心的回文子串不一定完全包含于以id为中心的回文子串中，基于对称性可知，图中两个绿框所包围的部分是相同的，也就是说以i为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 p[i] = mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了，这就是后面紧跟到while循环的作用。 3)对于 mx &lt;= i 的情况，无法对 P[i]做更多的假设，只能P[i] = 1，然后再去匹配了。 3.代码思路1：暴力破解方法 12345678910111213141516171819public static String longestPalindrome(String s) &#123; String temp = ""; String res =""; for(int i = 0;i&lt;s.length();i++)&#123; for(int j = i;j&lt;s.length();j++)&#123; temp = temp+s.charAt(j); //re用来保存子字符串反转的结果 String re = new StringBuffer(temp).reverse().toString(); //子字符串跟反转的字符串相等则为回文 if(temp.equals(re))&#123; res = res.length()&gt;temp.length()?res:temp; &#125; &#125; temp = ""; &#125; return res; &#125; 方法2：动态规划思想 1234567891011121314151617181920212223242526class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); if(s == null || len == 0)&#123; return s; &#125; String res = ""; int max = 0; //创建一个行列均为字符串长度的二维数组，创建时默认初始化为false boolean[][] dp = new boolean[len][len]; for(int j = 0; j &lt; len; j++)&#123; for(int i = 0; i &lt;= j; i++)&#123; dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= 2 || dp[i + 1][j - 1]); if(dp[i][j])&#123;//如果是回文字符串 //新得到的回文比之前的回文字符串要长，更新字符串长度，记录字符串 if(j - i + 1 &gt; max)&#123; max = j - i + 1; res = s.substring(i, j + 1); &#125; &#125; &#125; &#125; return res; &#125;&#125; 方法3：中心扩展方法 123456789101112131415161718192021222324class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return ""; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); //奇数的回文，中心有一个字母，以该字母往外扩 int len2 = expandAroundCenter(s, i, i + 1); //偶数的回文，中心有两个字母，以这两个字母往外扩 int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1; &#125;&#125; 方法4：马拉车算法 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return ""; //manacher预处理 //起点加特殊字符$ String t = "$#"; //每个字符左右都加特殊字符 # for (int i = 0; i &lt; s.length(); ++i) &#123; t += s.charAt(i); t += "#"; &#125; //终点加特殊字符&amp; t+="&amp;"; //马拉车算法实现 //定义半径 int []p = new int[t.length()]; int mx = 0, id = 0, resLen = 0, resCenter = 0; for (int i = 1; i &lt; t.length()-1; i++) &#123; //mancher核心算法 p[i] = mx &gt; i ? Math.min(p[2 * id - i], mx - i) : 1; //半径往外扩 while (t.charAt(i + p[i]) == t.charAt(i-p[i])) ++p[i]; //以i为中心的回文子串不一定完全包含于以id为中心的回文子串中 if ((mx-i) &lt; p[i]) &#123; mx = i + p[i]; id = i; &#125; if (resLen &lt; p[i]) &#123; resLen = p[i]; resCenter = i; &#125; &#125; return s.substring((resCenter - resLen) / 2, (resCenter - resLen) / 2 + resLen - 1); &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
        <tag>中等</tag>
        <tag>动态规划</tag>
        <tag>manacher算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【4】寻找两个有序数组的中位数]]></title>
    <url>%2F2019%2F05%2Fleetcode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 2.解题思路 排序输出中间值，但是复杂度不符合题意 3.代码方法1：复杂度不符合 123456789public static double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; //将两个数组放到一个数组中并从小到大排序 int[] ints = ArrayUtils.addAll(nums1, nums2); Arrays.sort(ints); //奇数个数返回 中间索引，偶数个返回最中间的两个数的平均，注意/2可能为小数，要/2d或者/2.0强转为double类型 if(ints.length%2==0)&#123; return (ints[(ints.length+1)/2]+ints[(ints.length+1)/2-1])/2d; &#125;else return ints[(ints.length-1)/2]; &#125; 方法2：复杂度还是不符合 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int n1Length = nums1.length; int n2Length = nums2.length; int totalLength = n1Length + n2Length; int arrayIndex = 0; int maxArrayIndex = totalLength / 2; int n1Index = 0; int n2Index = 0; int last1 = 0; int last2 = 0; //用于记录偶数情况下的last1的前一个数 while (arrayIndex &lt;= maxArrayIndex) &#123; last2 = last1; //只剩下nums2的情况了，nums1的全部数跟nums2排序都还没到达中间 if (n1Index &gt;= n1Length) &#123; last1 = nums2[n2Index++]; //只剩下nums1的情况了，nums2的全部数跟nums1排序都还没到达中间 &#125; else if (n2Index &gt;= n2Length) &#123; last1 = nums1[n1Index++]; &#125; else &#123; //哪个小哪个索引坐标【n1Index或者n2Index】开始滑动 if (nums1[n1Index] &lt;= nums2[n2Index]) &#123; last1 = nums1[n1Index++]; &#125; else &#123; last1 = nums2[n2Index++]; &#125; &#125; //整体数组【nums1 U nums2】的索引每循环依次自增1，直到到达整体数组中间位置 arrayIndex++; &#125; if (totalLength % 2 == 0) &#123; return (last1 + last2) / 2.0; &#125; else &#123; return last1; &#125; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【3】无重复字符的最长子串]]></title>
    <url>%2F2019%2F05%2Fleetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 2.解题思路 滑动窗口思想 准备一个list用于滑动窗口， （1）当list里面没有该字符时，加入该字符，list.size()就是无重复字符发长度。依次跟MaxLength比较取最大 （2）当list里面存在该值时，移除list里面该字符出现的第一个索引所在位置之前的所有字符[因为要求最长字串，即连续，所以要移除之前全部的字符] 3.代码12345678910111213141516171819202122class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int MaxLength = 0; List&lt;Character&gt; list = new ArrayList(); for(int i = 0;i&lt;s.length();i++)&#123; //list里面没有该字符就判断加入该字符是否就是最长的字符串 if(!list.contains(s.charAt(i)))&#123; list.add(s.charAt(i)); MaxLength = Math.max(MaxLength,list.size()); &#125;else&#123; //加入重复的字符，并返回第一个与之相等的字符的索引位置 list.add(s.charAt(i)); int index = list.indexOf(s.charAt(i)); // 移除该值以及该字符前面所有的字符 while(index&gt;=0)&#123; list.remove(index--); &#125; &#125; &#125; return MaxLength; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【2】两数相加]]></title>
    <url>%2F2019%2F05%2Fleetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[1.题目描述 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 2.解题思路 （1）设置一个进位位flag,flag的值为(当前两链表值相加+flag)/10,链表存储的值为(当前两链表值相加+flag)%10，依次遍历直到两个链表都到达尾部 （2）如果结束了flag不为0，则将flag的值继续添加到结果链表的尾部。 3.代码12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //用于指向res链表头 ListNode ress = new ListNode(0); ListNode res = ress; //用于最后的进位和各位数的进位 int flag = 0; while(l1!=null ||l2!=null)&#123; //还没为空时为l1.val,空的时候设为0 int x = l1!=null ?l1.val:0; int y = l2!=null?l2.val:0; int value = x+y+flag; //得到进位位 flag = value/10; res.next = new ListNode(value%10); res = res.next; if(l1!=null) l1 = l1.next; if(l2!=null) l2 = l2.next; &#125; //如果到最后一个数相加还有进位位，则链表长度扩展一位 if(flag&gt;0) res.next = new ListNode(flag); return ress.next; &#125;&#125; 4.提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【15】三数之和]]></title>
    <url>%2F2019%2F05%2Fleetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述：给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 2.解题思路 首先按升序排序；然后定义下标变量i,j,k，因为是三元组，所以要三个变量如果简单的遍历，那么跟是否有序没有关系，其时间复杂度将达到O(n^3)。仔细想想：如果当前选择了a、b、c三个数，如果其和小于目标target，那么需要将其中一个数用更大的数替换；反之亦然。但究竟替换三个数中的哪个数？无法确定就只能先固定两个变量，让其第三个变化（替换）。一种办法是：固定前两个数i,j，然后让k在一个范围中二分变化（二分查找思想） 3.代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); Arrays.sort(nums); List&lt;Integer&gt; targets = new ArrayList&lt;&gt;(); // 用于去重 if((nums.length&gt;0 &amp;&amp; nums.length&lt;3) ||(nums.length&gt;0 &amp;&amp;nums[0]&gt;0)) return list; for(int i = 0;i&lt;=nums.length-3;i++) &#123; int target = 0 - nums[i]; if (!targets.contains(target)) &#123; //用于去重 targets.add(target); int k = i + 1; int j = nums.length - 1; while (k &lt; j) &#123; if (nums[k] + nums[j] == target) &#123; List&lt;Integer&gt; li = new ArrayList(); li.add(nums[i]); li.add(nums[k]); li.add(nums[j]); list.add(li); while (k &lt; j &amp;&amp; nums[k] == nums[k + 1]) ++k; while (k &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j; k++; j--; &#125; else if (nums[k] + nums[j] &lt; target) &#123; k++; &#125; else &#123; j--; &#125; &#125; &#125; &#125; return list; &#125;&#125; 4.我的提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_【1】两数之和]]></title>
    <url>%2F2019%2F05%2Fleetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 2.解题思路 依次遍历数组里面的数值 （1）用一个hashmap存储（target-nums[i],索引位置） （2）如果下一次出现nums[i],说明找到了。直接将她的坐标跟之前存储的坐标存到结果。 如示例：nums = [2, 7, 11, 15], target = 9 i = 0 时， map存入（7,0） i= 1时，发现map.get(num[i]) = map.get(7)!=null, 存在，即找到了，直接将map.get(7) =0,i = 1,这两个值存到结果res里面返回。 3.代码123456789101112131415161718class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; //用一个hashmap进行存储【key = target-nums[i],value = 索引位置】 Map&lt;Integer,Integer&gt; map = new HashMap(); int res[] = new int[2]; for(int i = 0;i&lt;nums.length;i++)&#123; //此时只要寻找map里面是否有nums[i],即找到两数之和 //map.get(nums[i])指向的是(target-nums[i])那个数的索引，i指向的是nums[i]的索引 if(map.get(nums[i])!=null)&#123; res= new int[]&#123;map.get(nums[i]), i&#125;; return res; &#125;else&#123; map.put(target-nums[i],i); &#125; &#125; return res; &#125; &#125; 4.我的提交记录]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile介绍]]></title>
    <url>%2F2019%2F05%2Fvolatile%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[并发编程的三大概念：123 (1)原子性：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 (2)可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 (3)有序性：程序执行的顺序按照代码的先后顺序执行。 volatile介绍： 1.volatile是虚拟机提供的最轻量级的同步机制 保证变量对所有线程的可见性但是不保证原子性，需要通过加锁保证原子性。 特例： 1)运算结果并不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值 2)变量不需要与其他状态变量共同参与不变约束 2.禁止指令重排 指令重拍是指CPU采用了允许多条指令不按程序规定的顺序分开发送给各相应电路单元处理，也能得到正确的结果。]]></content>
      <categories>
        <category>JAVA虚拟机</category>
        <category>线程</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>JVM</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【66】机器人的运动范围]]></title>
    <url>%2F2019%2F05%2F66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[1.题目描述 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 2.解题思路 本题使用的方法同样还是回溯法，另外还需要会计算给定整数上的各个位上数之和。 (1)使用一个访问数组记录是否已经经过该格子。机器人从(0,0)开始移动，当它准备进入(i,j)的格子时，通过检查坐标的数位来判断机器人是否能够进入。 (2)如果机器人能进入(i,j)的格子，接着在判断它是否能进入四个相邻的格子(i,j-1),(i,j+1),(i-1,j),(i+1,j)。 因此，可以用回溯法来解决这一问题。 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int movingCount(int threshold, int rows, int cols) &#123; if(rows&lt;1||cols&lt;1||threshold&lt;0) &#123; return 0; &#125; boolean []visit=new boolean[rows*cols]; return count(threshold,rows,cols,visit,0,0); &#125; private static int count(int threshold, int rows, int cols, boolean[] visit, int row, int col) &#123; int res=0; if(check(threshold,rows,cols,visit,row,col)) &#123; visit[row*cols+col]=true; res=1+count(threshold,rows,cols,visit,row,col+1) +count(threshold,rows,cols,visit,row,col-1) +count(threshold,rows,cols,visit,row+1,col) +count(threshold,rows,cols,visit,row-1,col); &#125; return res; &#125; private static boolean check(int threshold, int rows, int cols, boolean[] visit, int row, int col) &#123; if (row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; visit[row * cols + col] == false &amp;&amp;getNum(col) + getNum(row) &lt;= threshold) &#123; return true; &#125; return false; &#125; //获取位数之和 private static int getNum(int num) &#123; int sum = 0; while (num &gt; 0) &#123; sum += num % 10; num /= 10; &#125; return sum; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【65】矩阵中的路径]]></title>
    <url>%2F2019%2F05%2F65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 * 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 2.解题思路 回溯法 (1)在矩阵中任选一个格子作为路径的起点。假设矩阵中某个格子的字符为ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。 由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。 需要判断这个矩阵中的每一个结点是否可以走一条路径，在走的过程中，设置一个和矩阵大小相同的整型数组flag表示是否已经访问，如果某个结点访问了，那么该结点的是否访问则为1。每次遍历一个结点的时候，递归的方式分别向左、向右、向上、向下。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; int[] flag = new int[matrix.length]; for(int i = 0; i &lt; rows; i ++)&#123; for(int j = 0; j &lt; cols; j ++)&#123; if(helper(matrix, rows, cols, i, j, str, 0, flag))&#123; return true; &#125; &#125; &#125; return false; &#125; public boolean helper(char[] matrix, int rows, int cols, int i, int j, char[] str, int k, int[] flag)&#123; int index = i * cols + j; if(i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || matrix[index] != str[k] || flag[index] == 1)&#123; /// /下标不符合，index对应的值不为和字符数组中的不一致，或者该index已经被访问，这些情况只要有符合的就返回false // 只有上面的所有情况都不符合，也就是值相等，且没有访问过，下标不符合 return false; &#125; if(k == str.length - 1)&#123; return true; &#125; flag[index] = 1; if(helper(matrix, rows, cols, i - 1, j, str, k + 1, flag)//左 ||helper(matrix, rows, cols, i + 1, j, str, k + 1, flag)//右 ||helper(matrix, rows, cols, i, j - 1, str, k + 1, flag)//上 ||helper(matrix, rows, cols, i , j + 1, str, k + 1, flag))//下 &#123; return true; &#125; flag[index] = 0; return false; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【64】滑动窗口的最大值]]></title>
    <url>%2F2019%2F05%2F64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。 输入描述：{2,3,4,2,6,2,5,1} ，3 输出描述：{4,4,6,6,6,5} 解析： 存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 2.解题思路 我们可以使用双向队列（Linklist），队列中只存放当前元素的下标， (1)设新来的元素为k，如果前面的元素比k小，直接把前面的删除（因为不可能成为后面窗口的最大值） (2)如果前面的元素比k大，判断是否还在窗口范围内，不在则移除 以数组{2,3,4,2,6,2,5,1}为例数组的第一个数字是2，把它存入队列中。 第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。 第三个数字是4，比3大，同样的删3存4。 此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。 第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。 第五个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。 3.代码12345678910111213141516171819202122232425public static ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); if (num==null) return arr; if (num.length&lt;size||size&lt;=0) return arr; Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i&lt;num.length; i++)&#123; //如果前面的数比插入的数小，直接把前面删除(因为不可能成为后面窗口的最大值) while (!queue.isEmpty()&amp;&amp;num[i]&gt;=num[queue.getLast()]) queue.pollLast(); //如果前面的元素比k大，判断是否还在窗口范围内，不在则移除 //(i-(size-1))即滑动窗口最左侧的坐标索引 while (!queue.isEmpty()&amp;&amp;queue.getFirst()&lt;i-(size-1)) queue.pollFirst(); //加入队尾 queue.offerLast(i); if (i+1&gt;=size) arr.add(num[queue.getFirst()]); &#125; return arr;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【63】数据流中的中位数]]></title>
    <url>%2F2019%2F05%2F63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 2.解题思路 用一个list存储插入的数，然后对其进行排序 (1) size == 0 , 返回 null; (2) size是偶数 , 返回 数值排序之后中间两个数的平均值; (3) size是奇数，返回 list.get(size/2); 3.代码123456789101112131415161718192021222324import java.util.*;public class Solution &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //添加操作 public void Insert(Integer num) &#123; list.add(num); &#125; //获取中位数 public Double GetMedian() &#123; int size = list.size(); if(size!=0)&#123; Collections.sort(list); if(size%2==0)&#123; return (list.get(size/2)+list.get(size/2-1))/2.0; &#125;else &#123; return list.get(size/2)*1.0; &#125; &#125;else &#123; return null; &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【62】二叉搜索树的第K个结点]]></title>
    <url>%2F2019%2F05%2F62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 2.解题思路方法1： 用PriorityQueue将所有结点放到queue中，再依次弹出里面的数据（队首数据依次弹出），弹出的第k个数据就是要求的数值，再将它构建成TreeNode即可。 方法2： 根据二叉搜索树的特点，左子树上的点小于该点，右子树上的点大于该点。所以按照中序遍历的方法得到的序列即是从小到大的序列。 3.代码方法1： 123456789101112131415161718192021222324252627282930313233/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.*;public class Solution &#123; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); TreeNode KthNode(TreeNode pRoot, int k) &#123; preOrderRec(pRoot); if(queue.size()&lt;k ||k &lt;=0) return null; for(int i = 0;i&lt;k-1;i++)&#123; queue.poll(); &#125; return new TreeNode( queue.poll()); &#125; public void preOrderRec(TreeNode root)&#123; if(root!=null)&#123; queue.add(root.val); preOrderRec(root.left); preOrderRec(root.right); &#125; &#125;&#125; 方法2： 123456789101112131415161718192021public class Solution &#123; int index=0; TreeNode node=null; TreeNode KthNode(TreeNode pRoot, int k) &#123; if(k==0||pRoot==null) return node; KthNode(pRoot.left,k); index++; if(k==index) &#123; node=pRoot; return node; &#125; KthNode(pRoot.right,k); return node; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSR303参数校验和全局异常处理]]></title>
    <url>%2F2019%2F05%2FJSR303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[开发web项目有时候我们需要对controller层传过来的参数进行一些基本的校验，比如非空，非null，整数值的范围，字符串的个数，日期，邮箱等等。最常见的就是我们直接写代码校验，这样以后比较繁琐，而且不够灵活。故引出使用JSR303来做参数校验。参数校验的实现: 手机号和密码字段自定义注解 为了让客户端显示更加友好 需要自定义异常拦截器 1. 添加依赖123456&lt;!--JSR303参数检验+全局异常处理器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2.在需要验证的类前加@Valid并在该类内需要参数检查的成员上加自定义注解1234567891011@Controller@RequestMapping("/login")public class LoginController &#123; @RequestMapping("/do_login") @ResponseBody public Result&lt;String&gt; doLogin(HttpServletResponse response, @Valid LoginVo loginVo)&#123; logger.info(loginVo.toString()); &#125;&#125; 12345678910@Datapublic class LoginVo &#123; @NotNull @IsMobile private String mobile; @NotNull @Length(min = 32) private String password;&#125; 3. IsMobile注解的编写[可参考@NotNull]12345678910111213141516171819202122@Target(&#123; ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint( validatedBy = &#123;IsMobileValidator.class&#125;)public @interface IsMobile &#123; boolean required() default true; String message() default "电话号码格式错误"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; 4.指定校验器的实现[IsMobileValidator.class]1234567891011121314151617181920212223public class IsMobileValidator implements ConstraintValidator&lt;IsMobile,String&gt; &#123; private boolean required = false; @Override //初始化方法拿到注解，可以定义一个字符为空 public void initialize(IsMobile constraintAnnotation) &#123; constraintAnnotation.required(); &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //值是必须的 if(required)&#123; return ValidatorUtil.isMobile(value); &#125;else&#123; if(StringUtils.isEmpty(value))&#123; return true; &#125;else&#123; return ValidatorUtil.isMobile(value); &#125; &#125; &#125;&#125; 5.自定义异常拦截器 当校验不通过时，会抛出异常。这时如果没有定义全局异常处理器进行处理（对异常进行封装和返回）。则会发生400错误（即只有请求的发起，却没有收到正常的响应（response），因为还没有来得及return就抛出了异常（这种异常没有被处理））。 1234567891011121314151617181920212223@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public Result&lt;String&gt; exceptionHandler(HttpServletRequest request,Exception e)&#123; e.printStackTrace(); if(e instanceof GlobalException) &#123; GlobalException ex = (GlobalException) e; return Result.Error(ex.getCm()); &#125;else if(e instanceof BindException)&#123; BindException ex = (BindException) e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); //为了方便起见，只取第一个错误 ObjectError error = errors.get(0); String msg = error.getDefaultMessage(); return Result.Error(CodeMsg.BIND_ERROR.fillArgs(msg)); &#125;else&#123; return Result.Error(CodeMsg.SERVER_ERROR); &#125; &#125;&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用缓存key]]></title>
    <url>%2F2019%2F05%2F%E9%80%9A%E7%94%A8%E7%BC%93%E5%AD%98key%2F</url>
    <content type="text"><![CDATA[通用缓存key的作用当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。方法：利用一个前缀来规定不同模块的缓存的key,这样不同模块之间就不会重复。 通用缓存key采用模板模式：接口-&gt;抽象类-&gt;实现类 1. 接口1234567public interface KeyPrefix &#123; //过期时间 public int expireSeconds(); //前缀 public String getPrefix();&#125; 2. 抽象类1234567891011121314151617181920212223242526public abstract class BasePrefix implements KeyPrefix&#123; private int expireSeconds; private String prefix; //无过期时间的构造函数 public BasePrefix(String prefix) &#123; this(0, prefix); &#125; //含有过期时间的构造函数 public BasePrefix( int expireSeconds, String prefix) &#123; this.expireSeconds = expireSeconds; this.prefix = prefix; &#125; public int expireSeconds() &#123; return expireSeconds; &#125; //获取前缀，前缀为 className：prefix public String getPrefix() &#123; String className = getClass().getSimpleName(); return className+":" + prefix; &#125;&#125; 3. 实现类123456789public class MiaoshaKey extends BasePrefix&#123; //继承父类的无过期时间的构造函数 public MiaoshaKey(String prefix) &#123; super(prefix); &#125; //设置它这个类的前缀是className:go public static MiaoshaKey isGoodsOver = new MiaoshaKey("go");&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitMQ实现消息缓冲]]></title>
    <url>%2F2019%2F05%2FrabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[RabbitMQ主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是AMQP协议，它是一种二进制协议。默认启动端口5672` rabbitMQ的message model实际上消息不直接发送到queue中，中间有一个exchange是做消息分发，生产者producer甚至不知道消息发送到那个队列中去。因此，当exchange收到message时，必须准确知道该如何分发。 Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key, 根据key全文匹配去寻找队列 Topic：按规则转发消息（最灵活）转发消息主要是根据通配符 Headers：设置 header attribute 参数类型的交换机 Fanout：转发消息到所有绑定队列(广播方式) 下面介绍4种交换机与springboot的集成添加依赖包amqp,统一配置application.properties 123456&lt;!--rabbitMQ依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 12345678910111213141516171819##rabbitMQspring.rabbitmq.host=127.0.0.1spring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/#消费者数量spring.rabbitmq.listener.simple.concurrency= 10spring.rabbitmq.listener.simple.max-concurrency= 10#消费者每次从队列获取的消息数量spring.rabbitmq.listener.simple.prefetch= 1#消费者自动启动spring.rabbitmq.listener.simple.auto-startup=true#消费失败，自动重新入队spring.rabbitmq.listener.simple.default-requeue-rejected= true#启用发送重试spring.rabbitmq.template.retry.enabled=true spring.rabbitmq.template.retry.initial-interval=1000spring.rabbitmq.template.retry.max-attempts=3 1. Direct交换机制 一个队列会和一个交换机绑定，除此之外再绑定一个routing_key，当消息被发送的时候，需要指定一个binding_key，这个消息被送达交换机的时候，就会被这个交换机送到指定的队列里面去。同样的一个binding_key也是支持应用到多个队列中的。 这样当一个交换机绑定多个队列，就会被送到对应的队列去处理。 1.1 编写config12345678910@Configurationpublic class MQconfig &#123; public static final String QUEUE ="queue"; @Bean public Queue queue()&#123; return new Queue(QUEUE,true); &#125; &#125; 1.2 创建消息发送者1234567891011121314@Servicepublic class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); public void send(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.Queue,message); &#125;&#125; 1.3 创建消息接收者12345678910@Servicepublic class MQreceiver &#123; private static Logger log = LoggerFactory.getLogger(MQreceiver.class); //监听了queue的队列 @RabbitListener(queues = MQconfig.Queue) public void receive(String message)&#123; log.info("receive message"+message); &#125;&#125; 1.4 编写controller测试123456789101112@Controllerpublic class HelloController &#123; @Autowired MQsender sender; @RequestMapping("/mq") @ResponseBody public Result&lt;Boolean&gt; mq()&#123; sender.send("hello"); return Result.success(true); &#125; &#125; 2. Fanout交换机制 扇形交换机会把能接收到的消息全部发送给绑定在自己身上的队列。因为广播不需要“思考”，所以扇形交换机处理消息的速度也是所有的交换机类型里面最快的。 2.1 编写config1234567891011121314151617181920@Configuration public class MQconfig &#123; public static final String FANOUT_EXCHANGE ="fanoutxchage"; @Bean public FanoutExchange fanoutExchange()&#123; return new FanoutExchange(FANOUT_EXCHANGE); &#125; @Bean public Binding fanoutBinding()&#123; return BindingBuilder.bind(topticQueue2()).to(fanoutExchange()); &#125; 2.2 创建消息发送者12345678910111213@Service public class MQsender &#123; @Autowired AmqpTemplate amqpTemplate; @Autowired RedisService redisService; public void sendFanout(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.FANOUT_EXCHANGE,"",msg); &#125;&#125; 2.3 创建消息接收者1234@Service public class MQreceiver &#123; //fanout 广播模式都接受故不需要listener &#125; 2.4 编写controller测试123456789@Controller public class HelloController &#123; @RequestMapping("/mq/fanout") @ResponseBody public Result&lt;String&gt; fanout()&#123; sender.sendFanout("hellommxx"); return Result.success("hello xuanzi");&#125; &#125; 3. topic交换机制 通配符交换机，exchange会把消息发送到一个或者多个满足通配符规则的routing-key的queue。其中表号匹配一个word，#匹配多个word和路径，路径之间通过.隔开。如满足a..c的routing-key有a.hello.c；满足#.hello的routing-key有a.b.c.helo。 1.1 编写config1234567891011121314151617181920212223242526272829@Configuration public class MQconfig &#123; public static final String TOPIC_QUEUE1 ="topic.queue1"; public static final String TOPIC_QUEUE2 ="topic.queue2"; public static final String TOPIC_EXCHANGE ="topicExchange" @Bean public Queue topticQueue1()&#123; return new Queue(TOPIC_QUEUE1,true); &#125; @Bean public Queue topicQueue2()&#123; return new Queue(TOPIC_QUEUE2,true); &#125; @Bean public TopicExchange topicExchange()&#123; return new TopicExchange(TOPIC_EXCHANGE); &#125; @Bean public Binding topicBinding1()&#123; return BindingBuilder.bind(topticQueue1()).to(topicExchange()).with("topic.key1"); &#125; @Bean public Binding topicBinding2()&#123; return BindingBuilder.bind(topticQueue2()).to(topicExchange()).with("topic.#"); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendTopic(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key1",msg+"1"); amqpTemplate.convertAndSend(MQconfig.TOPIC_EXCHANGE, "topic.key2",msg+"2");&#125;&#125; 1.3 创建消息接收者12345678910111213@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.TOPIC_QUEUE1) public void receiveTopic1(String message)&#123; log.info("receive topic queue1 message"+message); &#125; @RabbitListener(queues = MQconfig.TOPIC_QUEUE2) public void receiveTopic2(String message)&#123; log.info("receive topic queue2 message"+message); &#125; &#125; 1.4 编写controller测试12345678@Controller public class HelloController &#123; @RequestMapping("/mq/topic") @ResponseBody public Result&lt;String&gt; topic()&#123; sender.sendTopic("hellommxx"); return Result.success("hello xuanzi"); &#125; 4. header交换机制 header exchange(头交换机)和主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的header数据。主题交换机路由键只有是字符串,而头交换机可以是整型和哈希值 1.1 编写config123456789101112131415161718192021222324252627282930313233343536@Configuration public class MQconfig &#123; public static final String HEADER_QUEUE ="header.queue"; @Bean public HeadersExchange headersExchange()&#123; return new HeadersExchange(HEADERS_EXCHANGE); &#125; @Bean public Queue headerQueue()&#123; return new Queue(HEADER_QUEUE,true); &#125; @Bean public Binding headerBinding()&#123; Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); map.put("header1","value1"); map.put("header2","value2"); return BindingBuilder.bind(headerQueue()).to(headersExchange()) .whereAll(map).match(); &#125; &#125; 1.2 创建消息发送者12345678910111213@Service public class MQsender &#123; public void sendheader(Object message)&#123; String msg = redisService.beanToString(message); log.info("send message"+msg); MessageProperties properties = new MessageProperties(); properties.setHeader("header1","value1"); properties.setHeader("header2","value2"); Message obj = new Message(msg.getBytes(),properties); amqpTemplate.convertAndSend(MQconfig.HEADERS_EXCHANGE,"",obj); &#125;&#125; 1.3 创建消息接收者123456789@Service public class MQreceiver &#123; @RabbitListener(queues = MQconfig.HEADER_QUEUE) public void receiveHeader(byte[] message)&#123; log.info("receive header queue message"+message); &#125; &#125; 1.4 编写controller测试12345678910111213@Controller public class HelloController &#123; @RequestMapping("/mq/header") @ResponseBody public Result&lt;String&gt; header()&#123; sender.sendheader("hellommxx"); return Result.success("hello xuanzi"); &#125; &#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis缓存java端实现]]></title>
    <url>%2F2019%2F05%2FRedis%E7%BC%93%E5%AD%98java%E7%AB%AF%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 1. 引入redis依赖1234&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; 2.在application.properties添加redis配置文件12345678#redisredis.host=127.0.0.1redis.port=6379redis.timeout=3redis.password=2966redis.poolMaxTotal=10 //资源池中最大连接数redis.poolMaxIdle=10 //允许的最大空闲的连接数redis.poolMaxWait=3 3.定义redis的类，引入redis的配置12345678910111213@Component@ConfigurationProperties(prefix="redis")@Datapublic class RedisConfig &#123; private String host; private int port; private int timeout;//秒 private String password; private int poolMaxTotal; private int poolMaxIdle; private int poolMaxWait;//秒&#125; 4.RedisPoolFactory类，用于返回一个redis池12345678910111213141516171819202122232425@Servicepublic class RedisPoolFactory &#123; @Autowired RedisConfig redisConfig; @Bean public JedisPool JedisPoolFactory() &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); //允许最大空闲的连接数 poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle()); //资源池中最大连接数 poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal()); //最大等待毫秒数 poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000); JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(), redisConfig.getTimeout()*1000, redisConfig.getPassword(), 0); return jp; &#125;&#125; 5.编写RedisService类123456789101112131415@Servicepublic class RedisService &#123; @Autowired JedisPool jedisPool; //里面编写redis操作：增删改查 private void returnToPool(Jedis jedis) &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125;&#125; 5.1 获取单个对象(get)123456789101112131415161718192021222324252627282930313233//相当于redis里面的get key public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key,之前设置通用缓存key时的key设为className:key String realKey = prefix.getPrefix() + key; //跟redis里面的获取一个key操作一致 String str = jedis.get(realKey); //将结果转换成一个java对象 T t = stringToBean(str, clazz); return t; &#125;finally &#123; //关闭池资源 returnToPool(jedis); &#125; &#125;//json转换为java对象public static &lt;T&gt; T stringToBean(String str, Class&lt;T&gt; clazz) &#123; if(str == null || str.length() &lt;= 0 || clazz == null) &#123; return null; &#125; //判断类型 if(clazz == int.class || clazz == Integer.class) &#123; return (T)Integer.valueOf(str); &#125;else if(clazz == String.class) &#123; return (T)str; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return (T)Long.valueOf(str); &#125;else &#123; return JSON.toJavaObject(JSON.parseObject(str), clazz); &#125; &#125; 5.2 设置对象(set)123456789101112131415161718192021222324252627282930313233343536373839404142//相当于redis里面的set key valuepublic &lt;T&gt; boolean set(KeyPrefix prefix, String key, T value) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //对象转换为json字符串 String str = beanToString(value); if(str == null || str.length() &lt;= 0) &#123; return false; &#125; //生成真正的key String realKey = prefix.getPrefix() + key; //获取过期时间 int seconds = prefix.expireSeconds(); if(seconds &lt;= 0) &#123; //永久有效，无过期时间 jedis.set(realKey, str); &#125;else &#123; //为指定的 key 设置值及其过期时间。 jedis.setex(realKey, seconds, str); &#125; return true; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //将对象转化为Json字符串 public static &lt;T&gt; String beanToString(T value) &#123; if(value == null) &#123; return null; &#125; Class&lt;?&gt; clazz = value.getClass(); if(clazz == int.class || clazz == Integer.class) &#123; return ""+value; &#125;else if(clazz == String.class) &#123; return (String)value; &#125;else if(clazz == long.class || clazz == Long.class) &#123; return ""+value; &#125;else &#123; return JSON.toJSONString(value); &#125; &#125; 5.3 判断key是否存在(exists)123456789101112//想当于redis里面的 exists keypublic &lt;T&gt; boolean exists(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.exists(realKey); &#125;finally &#123; returnToPool(jedis); &#125;&#125; 5.4 增加值(incr)123456789101112//相当于redis里面的incr key_namepublic &lt;T&gt; Long incr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.incr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.5 减少值(decr)123456789101112//相当于redis里面的decr key_namepublic &lt;T&gt; Long decr(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; return jedis.decr(realKey); &#125;finally &#123; returnToPool(jedis); &#125; &#125; 5.6 删除(del)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//相当于redis里面的del key_name //已知key public boolean delete(KeyPrefix prefix, String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); //生成真正的key String realKey = prefix.getPrefix() + key; long ret = jedis.del(realKey); return ret &gt; 0; &#125;finally &#123; returnToPool(jedis); &#125; &#125; //通过正则匹配删除 某key public boolean delete(KeyPrefix prefix) &#123; if(prefix == null) &#123; return false; &#125; List&lt;String&gt; keys = scanKeys(prefix.getPrefix()); if(keys==null || keys.size() &lt;= 0) &#123; return true; &#125; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.del(keys.toArray(new String[0])); return true; &#125; catch (final Exception e) &#123; e.printStackTrace(); return false; &#125; finally &#123; if(jedis != null) &#123; jedis.close(); &#125; &#125; &#125; public List&lt;String&gt; scanKeys(String key) &#123; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); List&lt;String&gt; keys = new ArrayList&lt;String&gt;(); String cursor = "0"; //scan搜索 ScanParams sp = new ScanParams(); sp.match("*"+key+"*"); //设置scan的个数 sp.count(100); do&#123; ScanResult&lt;String&gt; ret = jedis.scan(cursor, sp); //返回结果 List&lt;String&gt; result = ret.getResult(); if(result!=null &amp;&amp; result.size() &gt; 0)&#123; //搜索的结果存入list keys.addAll(result); &#125; //再处理cursor，用于返回下次遍历的游标 cursor = ret.getStringCursor(); &#125;while(!cursor.equals("0")); return keys; &#125; finally &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125; &#125; 6.controller层测试123456789101112131415161718@AutowiredRedisService redisService;@RequestMapping("/redis/get")@ResponseBodypublic Result&lt;User&gt; getRedis()&#123; User user = redisService.get(UserKey.getById,"key1",User.class); return Result.success(user);&#125;@RequestMapping("/redis/set")@ResponseBodypublic Result&lt;Boolean&gt; setRedis()&#123; User user = new User(); user.setId(1); user.setName("1111"); redisService.set(UserKey.getById,""+1,user); return Result.success(true);&#125;]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【61】序列化二叉树]]></title>
    <url>%2F2019%2F05%2F61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现两个函数，分别用来序列化和反序列化二叉树 2.解题思路 二叉树的序列化 12&gt; 把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。&gt; 序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 先序序列化二叉树——&gt;&gt;&gt;&gt;定义一个stringbuilder保存序列过程中的结果： (1)按照先序遍历方式遍历二叉树，若结点非空则把 “结点值,” append到builder中； (2)若结点空则把 “#,” append到builder中； (3)最后用builder生成字符串就是序列化结果。 二叉树的反序列化 根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 (1)先序序列化结果重构二叉树 (2)String[] nodes=str.split(“,”)；//由每个结点的结束符号划分序列化结果序列，得到各个结点值； (3)然后按照先序遍历的顺序“根左右”的特性，遍历nodes数组建立二叉树： 1)当前遍历元素非 # 则作为一个结点插入树中作为上一结点的左儿子； 2)当前遍历元素为 # 则表示此子树已结束，遍历下一元素作为上一结点的右儿子； 即：遇数作左；遇#变向 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;public class Solution &#123; //递归先序遍历对二叉树进行序列化 String Serialize(TreeNode root) &#123; StringBuffer sb = new StringBuffer(); if(root == null)&#123; sb.append("#,"); return sb.toString(); &#125; //先序遍历根结点 sb.append(root.val + ","); //左子树 sb.append(Serialize(root.left)); //右子树 sb.append(Serialize(root.right)); return sb.toString(); &#125; //反序列化 public int index = -1; TreeNode Deserialize(String str) &#123; //特殊输入 if(str==null||str.length()&lt;=0) return null; //将字符串按照","拆分为数组 String[] strr = str.split(","); int len = strr.length; index++; if(index &gt;= len)&#123; return null; &#125; TreeNode node = null; //如果遇到的是#表示空节点，不再建立子树，这个结点null就是子树的根结点返回 if(!strr[index].equals("#"))&#123; node = new TreeNode(Integer.valueOf(strr[index])); //恢复左子树 node.left = Deserialize(str); //恢复右子树 node.right = Deserialize(str); &#125; //建立二叉树完成，返回根节点 return node; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【60】把二叉树打印成多行]]></title>
    <url>%2F2019%2F05%2F60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 2.解题思路 利用层次遍历二叉树的方式，用一个队列进行辅助，每次打印前取n = queue.size()，可以保证逐行打印。 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(pRoot == null) &#123; return res; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); //加入根结点 queue.add(pRoot); while (!queue.isEmpty())&#123; //每遍历一次，就新建一次tmp ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); int count = queue.size(); for(int i = 0;i&lt;count;i++)&#123; if(queue.peek().left!=null)&#123; //加入左结点 queue.add(queue.peek().left); &#125; if(queue.peek().right!=null)&#123; //加入右结点 queue.add(queue.peek().right); &#125; //删除并返回queue中的头元素，删掉根（上一层结点元素） tmp.add(queue.poll().val); &#125; //将一层的左右结点加入res res.add(tmp); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【59】按之字形顺序打印二叉树]]></title>
    <url>%2F2019%2F05%2F59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 2.解题思路 用一个布尔量控制从左到右还是从右到左的顺序；如果为真则他的左右孩子按照从左到右的顺序放入list中，否则按照从右到左的顺序，当本行结束之后，再把list中的数据放入一个result中。其中用一个null值作为层次的分隔符。 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041public static class Solution &#123; public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (pRoot == null) &#123; return result; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.addLast(null);//层分隔符 queue.addLast(pRoot); boolean leftToRight = true; while (queue.size() != 1) &#123; TreeNode node = queue.removeFirst(); if (node == null) &#123;//到达层分隔符 Iterator&lt;TreeNode&gt; iter = null; if (leftToRight) &#123; iter = queue.iterator();//从前往后遍历 &#125; else &#123; //从后往前遍历 iter = queue.descendingIterator(); &#125; leftToRight = !leftToRight; while (iter.hasNext()) &#123; TreeNode temp = (TreeNode) iter.next(); list.add(temp.val); &#125; result.add(new ArrayList&lt;Integer&gt;(list)); list.clear(); queue.addLast(null);//添加层分隔符 continue;//一定要continue &#125; if (node.left != null) &#123; queue.addLast(node.left); &#125; if (node.right != null) &#123; queue.addLast(node.right); &#125; &#125; return result; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【58】对称的二叉树]]></title>
    <url>%2F2019%2F05%2F58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 2.解题思路 【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。 【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。 【分析3】根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到 ① 如果Root和Root&apos;均为空，则返回true； ② 如果Root为空或者Root&apos;为空，则返回false； ③ 如果Root对应的值与Root&apos;对应的值不相等，则返回false。 3.代码12345678910111213141516171819202122public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; if(pRoot==null || pRoot.left==null&amp;&amp;pRoot.right==null) return true; return Symmetrical(pRoot.left,pRoot.right); &#125; boolean Symmetrical(TreeNode left,TreeNode right) &#123; if(left==null&amp;&amp;right==null) return true; if(left==null||right==null) return false; if(left.val==right.val) //右子树的左边跟左子树的右边是否对称 return Symmetrical(left.left,right.right) //左子树的右边跟右子树的左边是否对称 &amp;&amp; Symmetrical(left.right,right.left); return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【57】二叉树的下一个结点]]></title>
    <url>%2F2019%2F05%2F57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 2.解题思路 情况1：该节点有右子树： 6 / \ 3 10 / \ / \ 2 5 8 12 中序遍历结果为：2–&gt;3–&gt;5–&gt;6–&gt;8–&gt;10–&gt;12 即它的下一个结点就是它的右子树中最左子结点 情况2.1：该节点无右子树：(为父节点6的左子节点) 6 / \ 3 10 / / \ 2 8 12 2–&gt;3–&gt;6–&gt;8–&gt;10–&gt;12 该节点是父节点的左子节点的这种情况比较简单，直接将父节点返回即可 情况2.2：该节点无右子树：(为父节点6的右子节点) 6 / \ 3 10 / \ / \ 2 5 8 null 2–&gt;3–&gt;6–&gt;8–&gt;10 –&gt;null 如果是父节点的右子节点的话，需要不断的向上移动，直到对应的节点不是父节点的右节点（即左节点），既然他是父节点的左节点，此时将这个节点父节点返回即可，或者遍历到了根节点，返回null； 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/ public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if(pNode == null)&#123; return null; &#125; //该节点有右子树,它的下一个结点就是它的右子树中最左子结点 if(pNode.right != null)&#123; pNode = pNode.right; while(pNode.left != null)&#123; pNode = pNode.left; &#125; return pNode; &#125; //该节点无右子树，父节点不为空 while(pNode.next != null)&#123; //pNode为父节点的左节点为该节点，直接返回父节点 if(pNode.next.left== pNode)&#123; return pNode.next; &#125; //为父节点的右子节点，不断的向上移动，直到对应的节点不是父节点的左子节点 //一直回溯如果遍历到他是父节点的左节点，此时将这个节点父节点返回即可， //或者遍历到了根节点，返回null； pNode = pNode.next; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【56】删除链表中重复的结点]]></title>
    <url>%2F2019%2F05%2F56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 2.解题思路 方法一：重头构建该链表 (1) 新建两个list，一个用于存放只出现一次的数值，一个存放重复的数值 (2) 将只出现过一次的数重头构建成链表 方法二：递归思想 3.代码方法1： 12345678910111213141516171819202122public static ListNode deleteDuplication(ListNode pHead) &#123; ArrayList&lt;Integer&gt; ss = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; ss2 = new ArrayList&lt;&gt;(); ListNode res = new ListNode(-1); ListNode node = res; while(pHead!=null)&#123; if(!ss.contains(pHead.val) &amp;&amp; !ss2.contains(pHead.val))&#123; ss.add(pHead.val); pHead = pHead.next; &#125;else&#123; ss2.add(pHead.val); ss.remove(Integer.valueOf(pHead.val)); pHead = pHead.next; &#125; &#125; for(int i = 0;i&lt;ss.size();i++)&#123; res.next =new ListNode(ss.get(i)); res = res.next; &#125; return node.next; &#125; 方法2： 123456789101112131415161718192021public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; // 只有0个或1个结点，则返回 if (pHead == null || pHead.next == null) &#123; return pHead; &#125; if (pHead.val == pHead.next.val) &#123; // 当前结点是重复结点 ListNode pNode = pHead.next; while (pNode != null &amp;&amp; pNode.val == pHead.val) &#123; // 跳过值与当前结点相同的全部结点,找到第一个与当前结点不同的结点 pNode = pNode.next; &#125; // 从第一个与当前结点不同的结点开始递归 return deleteDuplication(pNode); &#125; else &#123; // 当前结点不是重复结点 // 保留当前结点，从下一个结点开始递归 pHead.next = deleteDuplication(pHead.next); return pHead; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【55】链表中环的入口结点]]></title>
    <url>%2F2019%2F05%2F55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 2.解题思路 方法1： 利用hashSet不存储重复值的思想 方法2： 链表包含环，像数字6的图形。 (1)设置快慢指针，假设快指针在环内与慢指针相遇，设头节点到入口结点的距离为x,入口结点到相遇点为y,相遇点到入口结点距离为z,则有(x+y)*2 = (x+y+z+y),即z = x，即相遇点到入口结点的距离跟头节点到入口结点的距离相等。 (2)这时再设置fast = pHead,一个指针重头走，另一个指针重相遇节点走，当两个点相等时即为入口节点所在。 3.代码方法1： 1234567891011121314public ListNode EntryNodeOfLoop(ListNode pHead)&#123; HashSet&lt;ListNode&gt; hs = new HashSet&lt;ListNode&gt;(); while(pHead!=null)&#123; if(!hs.add(pHead))//如果包含了，那么这个就是入口结点 return pHead; pHead = pHead.next; &#125; return null;&#125; 方法2： 1234567891011121314151617181920212223242526272829303132/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode fast = pHead; ListNode slow = pHead; while(fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast==slow)&#123; fast=pHead; while (fast!=slow)&#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【54】字符流中第一个不重复的字符]]></title>
    <url>%2F2019%2F05%2F54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 2.解题思路桶排序思想 3.代码1234567891011121314151617181920212223//源源不断的有字母放到字符串中，建立一个256个大小的int型数组来代表哈希表public class Solution &#123; String str=""; int[] count=new int[256]; public void Insert(char ch) &#123; if(ch &gt;=256)&#123; return ; &#125;else&#123; str+=ch;//字符放入字符串 count[ch]++;//根据字符，修改数组字符元素的值 &#125; &#125; public char FirstAppearingOnce() &#123; for(char c:str.toCharArray())&#123;// //注意的是，要找第一个出现一次的字符，所以遍历字符串，不能遍历哈希数组 if(count[c]==1)&#123;//如果字符串作为下表的元素值为1，说明该字符出现一次，直接返回该字符 return c; &#125; &#125; return '#'; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【53】表示数值的字符串]]></title>
    <url>%2F2019%2F05%2F53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 2.解题思路 (1) 先判断每个字符是否合法 (2) 正负号的位置和e不能在结尾位置 (3) 小数点只能存在一个 (4)正负号在中间位置时，前面是e后面是数字 (5)e后面不能有小数点 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public boolean isNumeric(char[] str) &#123; String ss = String.valueOf(str); int len = ss.length(); //先判断每个字符是否合法 for(int i=0; i&lt;len; i++)&#123; char c = ss.charAt(i); if(!((c&gt;='0' &amp;&amp; c &lt;= '9') || c=='e' || c=='E'|| c=='+' || c=='-'|| c=='.')) return false; &#125; ////正负号,E不能在末尾 if(ss.charAt(len-1) == '+' || ss.charAt(len-1) == '-' || ss.charAt(len-1) == 'E' || ss.charAt(len-1) == 'e') return false; //判断小数点，只能有一个 if(ss.indexOf(".") != ss.lastIndexOf(".")) return false; //正负号在中间的位置时，前面的是e，E,后面是数字 for(int i=1; i&lt;len-1; i++)&#123; char c = ss.charAt(i); if(c == '+' || c=='-')&#123; if(!(ss.charAt(i-1) == 'e' || ss.charAt(i-1) == 'E') ||!(ss.charAt(i+1)&gt;='0' &amp;&amp; ss.charAt(i+1)&lt;='9')) return false; &#125; &#125; ////e的后面不能有数字12E+4.3 for(int i=1; i&lt;len; i++)&#123; char c = ss.charAt(i); if(c == 'e' || c=='E')&#123; if(i==len-1) return false; if(ss.charAt(i+1) == '+' || ss.charAt(i+1) == '-')&#123; //从i+2开始往后没有小数点.则返回-1 if(ss.indexOf(".", i+2) != -1)&#123; return false; &#125; &#125;else&#123; if(ss.indexOf(".", i+1) != -1)&#123; return false; &#125; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【52】正则表达式匹配]]></title>
    <url>%2F2019%2F05%2F52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.题目描述 请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配。 2.解题思路 这道题的核心其实在于分析’*‘,对于’.’来说，它和任意字符都匹配，可把其当做普通字符。对于’*’的分析，我们要进行分情况讨论，当所有的情况都搞清楚了以后，就可以写代码了。 情况1：Patttern第二个字符是’*’时： 1.第一个字符不匹配（’.’与任意字符视作匹配），那么’*’只能代表匹配0次 &apos;ba&apos;与&apos;a*ba&apos;，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式 2.第一个字符匹配，那么’*‘可能代表匹配0次，1次，多次， (1)&apos;aaa&apos;与&apos;a*aaa&apos;: 匹配0次时，字符串不变，模式向后移动两个字符，然后匹配剩余字符串和模式； (2)&apos;aba&apos;与&apos;a*ba&apos;:匹配1次时，字符串往后移动一个字符，模式向后移动2个字符； (3)&apos;aaaba&apos;与&apos;a*ba&apos;:匹配多次时，字符串往后移动一个字符，模式不变； 情况2：Patttern第二个字符不是’*‘时： (1)如果字符串的第一个字符和模式中的第一个字符匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余字符串和模式。 (2)如果字符串的第一个字符和模式中的第一个字符不匹配，那么直接返回false。 3.代码1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if (str == null || pattern == null) return false; int strIndex = 0,patternIndex = 0; return matchCore(str, strIndex, pattern, patternIndex); &#125; public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) &#123; //有效性检验：str到尾，pattern到尾，匹配成功 if (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123; return true; &#125; //pattern先到尾，匹配失败 if (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123; return false; &#125; //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位 // //如果当前pattern的下一个是*并且没有超出pattern的长度时 if (patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] == '*') &#123; // //如果当前字符str[index]和pattern[index]相等，或者当前pattern为‘.’ if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符(当前pattern[index+1]='*'且str[index]!=pattern[index]） || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符 (当前pattern[i+1]='*'且str[index]=pattern[index]) || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个（当前pattern[index]='.'） &#125; else &#123; //当前字符str[index]和pattern[index]不相等&amp;&amp;当前pattern不为‘.’ return matchCore(str, strIndex, pattern, patternIndex + 2); &#125; &#125; //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false //pattern[index]='.'的情况，strindex和pattern都加1向下匹配 if ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' &amp;&amp; strIndex != str.length)) &#123; return matchCore(str, strIndex + 1, pattern, patternIndex + 1); &#125; return false; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【51】构建乘积数组]]></title>
    <url>%2F2019%2F05%2F51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 2.解题思路 题目的意思就是B[i] = A[0]*A[1]….*A[n-2]*A[n-1] / A[i],但是题目要求不能用除法 创建一个left数组和一个rigth数组，拿n = 3为例 res[i] left[0]*right[0] left[1]*right[1] left[2]*right[2] left[3]*right[3] right数组 A[2]*A[1]*A[0]*1 A[1]*A[0]*1 A[0]*1 1 left数组 1 1*A[0] 1*A[0]*A[1] 1*A[0]*A[1]*A[2] 3.代码1234567891011121314151617181920212223import java.util.ArrayList;public class Solution &#123; public int[] multiply(int[] A) &#123; int []res = new int[A.length]; int []left = new int[A.length]; int []right = new int[A.length]; left[0] = 1; for(int i = 1;i&lt;A.length;i++)&#123; left[i] = A[i-1]*left[i-1]; &#125; right[A.length-1] = 1; for(int i = A.length-2;i&gt;=0;i--)&#123; right[i] = right[i+1]*A[i+1]; &#125; //计算结果 for(int i = 0;i&lt;A.length;i++)&#123; res[i] = left[i]*right[i]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【50】数组中重复的数字]]></title>
    <url>%2F2019%2F05%2F50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 2.解题思路 长度为n,数字都在[0,n-1]范围，可以利用桶排序的思想，将numbers[i]的个数存入相应的res索引下，当第一次桶里有2个numbers[i]时，直接返回即找到第一个数组里面的重复数字。 3.代码123456789101112131415161718 public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(length == 0) return false; int res[] = new int [length]; boolean flag = false; for(int i = 0;i&lt;length;i++)&#123; res[numbers[i]]++; //有重复的数 if(res[numbers[i]]&gt;1)&#123; duplication[0] = numbers[i]; flag = true; break; &#125; &#125; return flag;&#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【49】把字符串转换成整数]]></title>
    <url>%2F2019%2F05%2F49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 输入描述:输入一个字符串,包括数字字母符号,可以为空 输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1： 输入+2147483647 1a33 输出2147483647 0 2.解题思路 (1) 首先判断第一个字符是符号‘ + ‘ 或者 ’ - ‘ 还是数字 (2) 首字母为 ’ + ‘，则设flag 为 1，计算[1,len)的数值 (3) 首字母为 ’ - ‘，则设flag为-1，计算[1,len)的数值 (4) 首字母为数字，则计算[0,len)的数值 计算时有个是否溢出判断。 3.代码12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int StrToInt(String str) &#123; if(str.trim().equals(""))&#123; return 0; &#125; int sum = 0; int flag = 1; if(str.charAt(0) =='+'||str.charAt(0)=='-')&#123; if(str.charAt(0)=='-') &#123; flag = -1; &#125; sum = cal(str,1,str.length(),flag); &#125;else&#123; sum = cal(str,0,str.length(),flag); &#125; return sum*flag; &#125; //计算结果 private int cal(String str, int start, int end,int flag) &#123; int sum = 0; for(int i = start;i&lt;end;i++)&#123; if(str.charAt(i)&gt;='0' &amp;&amp;str.charAt(i)&lt;='9')&#123; if(flag == 1 &amp;&amp; sum&gt;Integer.MAX_VALUE) throw new RuntimeException("上溢出"); if(flag == -1 &amp;&amp; sum&lt;Integer.MIN_VALUE) throw new RuntimeException("下溢出"); sum = sum*10+str.charAt(i)-'0'; &#125;else&#123; return 0; &#125; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【48】不用加减乘除做加法]]></title>
    <url>%2F2019%2F05%2F48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 2.解题思路利用&amp;、|、^等运算 (1)定义一个sum和一个进位位carry，sum用来记录二进制的两位数无进位相加得到的值（num1^num2）,进位位carry用来记录需要向哪个位进位（num&amp;num2&lt;&lt;1） (2)将得到的sum和carry重新赋值给num1和num2.循环的结束条件是进位位为0时终止。 3.代码12345678910111213141516171819public class Solution &#123; public int Add(int num1,int num2) &#123; int carry = 0; int sum = 0; do&#123; //异或，相同为0不同为1 ,得到的结果相当于二进制的两个数无进位相加， //相加为2的结果是0.如6和12相异或，即（0110^1100） = 1010 sum = num1 ^ num2; //num1&amp;num2得到该位数需要进位，即向前进位&lt;&lt;1 carry = (num1&amp;num2)&lt;&lt;1; num1 = sum; num2 = carry; &#125;while(num2!=0); //直到无进位结束 return num1; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【47】求1+2+...+n]]></title>
    <url>%2F2019%2F05%2F47-%E6%B1%821-2-n%2F</url>
    <content type="text"><![CDATA[1.题目描述 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 2.解题思路 1.需利用逻辑与的短路特性实现递归终止。 2.当n==0时，(n&gt;0)&amp;&amp;((ans+=Sum_Solution(n-1))&gt;0)只执行前面的判断，不执行后面的递归了，使这条语句为false，并且不往上回溯，可以执行下面return的语句了。然后直接返回ans； 3.当n&gt;0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。 3.代码12345678public class Solution &#123; public int Sum_Solution(int n) &#123; int ans = n; boolean flag = (ans &gt; 0) &amp;&amp; (ans += Sum_Solution(n - 1))&gt;0; return ans; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【46】孩子们的游戏(圆圈中最后剩下的数)]]></title>
    <url>%2F2019%2F05%2F46-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[1.题目描述 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 2.解题思路 模拟游戏过程 i一直记录的是小朋友自己最初的的位置[0,n-1] step记录的是报数，报到m-1时array[i]这个小朋友出局，记-1，step重头计数。人数这时减1. 3.代码123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if(n&lt;1||m&lt;1) return -1; int array[] = new int[n]; int i = -1 ; //初始状态 int step = -1; int count = n; //人数 while (count&gt;0)&#123; //游戏开始 //报数，其实报的一直都是自己的位置数，不是[0,m-1],而是[0,n-1] i++; //假如有8人，报数范围是[0,7],轮询一圈后那么第一个人不报8而是报0 if(i&gt;=n) i=0; if(array[i]==-1) continue; //标记为-1即出局，不遍历下边的了 step++; //step用来记录报数报到哪了 if(step==m-1)&#123; //找到喊m-1的小朋友 array[i] = -1; //出局 step = -1; //重头开始记录报数 count--; //人数减1 &#125; &#125; return i; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【45】扑克牌顺子]]></title>
    <url>%2F2019%2F05%2F45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[1.题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 2.解题思路 组成顺子的条件是： (1) 数组长度为5 (2)数组中数不重复 (3)最大值Max减最小值Min&lt;5,其中Max和Min不能为0,即不包括大小王的最大值最小值 3.代码12345678910111213141516171819202122232425262728293031public class Solution &#123; public static boolean isContinuous(int [] numbers) &#123; if(numbers.length&lt;5) return false; int Max = Integer.MIN_VALUE; int Min = Integer.MAX_VALUE; int count[] = new int[14]; //除0以外没有重复的数 for(int i = 0;i&lt;numbers.length;i++)&#123; count[numbers[i]]++; //如果是大小王的话，可以允许多个，直接continue不执行count[numbers[i]&gt;=2的判断,而且最大值最小值的判断也会跳过0 if(numbers[i] == 0)&#123; continue; &#125; if(count[numbers[i]]&gt;=2)&#123; return false; &#125; // if(Max&lt;numbers[i]) &#123; Max = numbers[i]; &#125; if(Min &gt;numbers[i])&#123; Min = numbers[i]; &#125; &#125; if ( Max - Min &lt; 5) &#123; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【44】翻转单词顺序列]]></title>
    <url>%2F2019%2F05%2F44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 2.解题思路 用str.split(“ ”) 去切分子字符串变成str[],然后再拼接。 3.代码123456789101112131415161718192021public class Solution &#123; public String ReverseSentence(String str) &#123; if(str == null)&#123; return null;&#125; //去掉前后空格，避免输入字符串全是空格情况，保证后面的split切分正确 if(str.trim().equals(""))&#123; return str; &#125; String res[] = str.split(" "); StringBuilder ss = new StringBuilder(); //第二个到最后一个数组值后面要加“ ” for(int i = res.length-1;i&gt;0;i--)&#123; ss.append(res[i]+" "); &#125; //第一个就是数组末尾了不需要加“ ”，保持反转后的数组长度跟原来一样 ss.append(res[0]); return ss.toString(); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【43】左旋转字符串]]></title>
    <url>%2F2019%2F05%2F43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1.题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 2.解题思路两个子字符串 拼接就行了。 3.代码1234567public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(n&gt;str.length()) return ""; return str.substring(n,str.length())+str.substring(0,n); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【42】和为s的两个数字]]></title>
    <url>%2F2019%2F05%2F42-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述:对应每个测试案例，输出两个数，小的先输出。 2.解题思路 将数组的数值依次放入list里面，每次放入之前查询list里面是否有（sum-array[i]），如果有,再判断两数乘积是否比之前存的两数乘积小，如果判断成功，则将这两个数放到index1和index2中。最后将这两个index放到list里面返回。 3.代码1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array, int sum) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; ss = new ArrayList&lt;&gt;(); int Min_ = Integer.MAX_VALUE; //index1用于存放比较小的那个数 int index1 = 0; //index2用于存放比较大的数 int index2 = 0; for(int i = 0;i&lt;array.length;i++)&#123; if(res.contains(sum-array[i]))&#123; if(Min_&gt;(sum-array[i])*array[i])&#123; Min_ = (sum-array[i])*array[i]; index1 = array[i]&lt;(sum-array[i])? array[i]:(sum-array[i]); index2 = sum-index1; &#125; &#125;else&#123; res.add(array[i]); &#125; &#125; if(index1!=0||index2!=0)&#123; ss.add(index1); ss.add(index2); &#125; return ss; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【41】和为S的连续正数序列]]></title>
    <url>%2F2019%2F05%2F41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 2.解题思路 滑动窗口移动方法 (1) 求出滑动窗口的累加和，公式为等差数列求和公式 (2)如果累加和等于sum,则将该滑动窗口内的数存到一个list里面，并右移动左指针 (3)如果累加和小于sum,则右移动右指针，加数进来 (4)如果累加和大约sum，则左指针右移动，减数出去 3.代码1234567891011121314151617181920212223242526272829import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; //存放结果 ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = new ArrayList&lt;&gt;(); //两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小 int plow = 1,phigh = 2; while(phigh &gt; plow)&#123; //由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2 int cur = (phigh + plow) * (phigh - plow + 1) / 2; //相等，那么就将窗口范围的所有数添加进结果集 if(cur == sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=plow;i&lt;=phigh;i++)&#123; list.add(i); &#125; result.add(list); plow++; //如果当前窗口内的值之和小于sum，那么右边窗口右移一下 &#125;else if(cur &lt; sum)&#123; phigh++; &#125;else&#123; //如果当前窗口内的值之和大于sum，那么左边窗口右移一下 plow++; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【40】数组中只出现一次的数字]]></title>
    <url>%2F2019%2F05%2F40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 2.解题思路 将数组依次放到list里面，如果list里面含有准备要进去的数值，则remove掉，剩下的两个数组即为该数组中只出现过一次的数字 list.remove要用(Object object)方法而不是list.remove(int index); 3.代码1234567891011121314151617181920212223//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果import java.util.*;public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; if(array.length&lt;2)&#123; return ; &#125; ArrayList&lt;Integer&gt; res = new ArrayList(); for(int i = 0;i&lt;array.length;i++)&#123; if(res.contains(array[i]))&#123; //这里remove掉的是里面的数array[i]，而不是array[i]索引对应的数 res.remove(Integer.valueOf(array[i])); &#125;else&#123; res.add(array[i]); &#125; &#125; num1[0] = res.get(0); num2[0] = res.get(1); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【39】平衡二叉树]]></title>
    <url>%2F2019%2F05%2F39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 2.解题思路预备知识：平衡二叉树是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 思想：从根节点开始，先判断左右子树的高度差是否超过1，然后接着判断左右子树是否是平衡二叉树。这边用到了递归思想。 代码如下： 3.代码1234567891011121314151617181920212223public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if( root == null) &#123; //一棵空树就是平衡二叉树 return true; &#125; if( Math.abs(getDepth(root.left) - getDepth(root.right)) &lt;= 1 ) &#123; //满足左右子树高度差小于等于1,那就接着判断左右子树是不是二叉树 return (IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right)); &#125; else &#123; //不满足左右子树高度差小于等于1,那这棵树肯定不是平衡二叉树啦 return false; &#125; &#125; //递归求二叉树深度 public int getDepth(TreeNode root) &#123; if( root == null ) return 0; int left = getDepth(root.left); int right = getDepth(root.right); return ( left &gt; right ? left : right ) + 1; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【38】二叉树的深度]]></title>
    <url>%2F2019%2F05%2F38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 2.解题思路 ①如果一棵树只有一个结点，它的深度为1。 ②如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。 ③如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。 3.代码12345678910111213141516171819202122232425/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125;*/public class Solution &#123; public int TreeDepth(TreeNode root) &#123; //----递归求二叉树深度---- if(root == null)&#123; return 0; &#125; int left = TreeDepth(root.left); int right = TreeDepth(root.right); return (left&gt;right)?(left+1):(right+1); &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【37】数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F05%2F37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述统计一个数字在排序数组中出现的次数。 2.解题思路排序数组嘛，找到数组里面第一个等于k的，一直res++直到数组值不等于k。 3.代码123456789101112131415public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; int res = 0; if (array == null || array.length == 0) return res; for(int i = 0;i&lt;array.length;i++)&#123; if(array[i] == k)&#123; res++; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【36】两个链表的第一个公共结点]]></title>
    <url>%2F2019%2F05%2F36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述输入两个链表，找出它们的第一个公共结点。 2.解题思路两个链表有公共点，考虑Y型的两链表相连，先计算出两个链表的长度，然后长的链表先走差值步，之后同步走，当遇到cur1==cur2时说明两链表相遇。直接返回即可。 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindFirstCommonNode(ListNode head1, ListNode head2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; ListNode cur1 = head1; ListNode cur2 = head2; int n = 0; //得到差值步（head1.length-head2.length） while (cur1.next != null) &#123; n++; cur1 = cur1.next; &#125; while (cur2.next != null) &#123; n--; cur2 = cur2.next; &#125; //相交为Y型则最后一个结点应该相同 if (cur1 != cur2) &#123; return null; &#125; cur1 = n &gt; 0 ? head1 : head2; cur2 = cur1 == head1 ? head2 : head1; n = Math.abs(n);//差值步 //走差值步 while (n != 0) &#123; n--; cur1 = cur1.next; &#125; //相等时则为相交点 while (cur1 != cur2) &#123; cur1 = cur1.next; cur2 = cur2.next; &#125; return cur1; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[争吵问题.md]]></title>
    <url>%2F2019%2F05%2F%E4%BA%89%E5%90%B5%E9%97%AE%E9%A2%98-md%2F</url>
    <content type="text"><![CDATA[1. 题目描述有一个队列，每个人要么朝左边（L表示）,要么朝右边(R表示)，因为每个人都讨厌其他任何人，只要两人面对面就会发生争吵。争吵结果是胜者留在队列中，败的人移除队中。如果序列中有多对争吵，可以任选一对，胜者留在队中，败者出局，求最后队列最少人数是多少。 例子： LRRLRL 输出：2 Hint 一种可能的变化情况是：LRRLRL -&gt; LRLRL -&gt; LRRL -&gt; LRL -&gt; LR 2.解题思路由题意可知，如果真的吵架就只有RL（两人面对面）情况，像LL,RR,LR就不会争吵。 如果吵架前面是R，则吵架结果应该是L胜利. 如果吵架前面是L，则吵架结果为R胜利 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.List;public class test &#123; public static void main(String[] args) &#123; String arr ="LRRLRL"; String res = solut(arr); System.out.println(res.length()); System.out.println(res); &#125; public static String solut(String arr) &#123; //获取第一次争吵得到的结果 String str = solution(arr); //如果还存在第二次争吵，则继续，否则得到结果 while (str.contains("RL"))&#123; str = solution(str); &#125; return str; &#125; public static String solution(String arr)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;arr.length()-1;i++)&#123; //争吵 if(arr.charAt(i)=='R'&amp;&amp;arr.charAt(i+1)=='L')&#123; if(i==0) &#123; list.add('R'); i++; &#125; else&#123; if(list.get(list.size()-1)=='L') &#123; &#123; list.add('R'); i++; &#125; &#125;else&#123; &#123; list.add('L'); i++; &#125; &#125; &#125; &#125;else &#123; //没有争吵，下一次争吵中还有该人 list.add(arr.charAt(i)); &#125; &#125; //将list转换成String String str = ""; for(int i = 0;i&lt;list.size();i++)&#123; str = str+list.get(i); &#125; return str; &#125;&#125;]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>讯飞科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【34】第一个只出现一次的字符位置]]></title>
    <url>%2F2019%2F05%2F34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.题目描述 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 2.解题思路 1.用两个list,一个list用来存放只出现一次的字符，一个用来存放出现多次的字符 2.依次遍历str里面的字符，如果list1和list2里面都没有，则说明这个字符是第一次出现，将其添加到list1，否则说明之前出现过该字符，将其移除list1并添加到list2里面 3.最后判断list里面是否有值，有则返回list里面的第一个值在str出现的第一次的位置，即为第一次出现的字符位置。 3.代码1234567891011121314151617181920212223242526public static int FirstNotRepeatingChar(String str) &#123; if (str.length() == 0 || str == null) return -1; //list1存放str中出现1次的字符 ArrayList&lt;Character&gt; list1 = new ArrayList&lt;Character&gt;(); //list2用来存放多次出现的字符 ArrayList&lt;Character&gt; list2 = new ArrayList&lt;Character&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); //两个list里面都没有这个字符 if (!list1.contains(ch) &amp;&amp; !list2.contains(ch)) &#123; //将字符放到list1中 list1.add(Character.valueOf(ch)); &#125; else &#123; //将list1之前加入的删掉（此时出现了相同字符，删掉相同字符） list1.remove(Character.valueOf(ch)); //将str中含有的相同字符存入list2 list2.add(Character.valueOf(ch)); &#125; &#125; if (list1.size() &lt; 0) &#123; return -1; &#125; return str.indexOf(list1.get(0)); &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【35】数组中的逆序对]]></title>
    <url>%2F2019%2F05%2F35.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 题目保证输入的数组中没有的相同的数字 数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 例子数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}； 2.解题思路方法1：暴力破解:时间超时 考察每一位，判断从这一位往后有多少小于该位的，结果累加，得到最后结果。 方法2：归并算法 3.代码方法1(超时)： 1234567891011121314151617181920212223public class Solution &#123; public static void main(String[]args) &#123; int []array=&#123;7,5,6,4&#125;; int num=InversePairs(array); System.out.println(num); &#125; public static int InversePairs(int [] array) &#123; int count=0; for(int i=0;i&lt;array.length-1;i++) &#123; for(int j=i+1;j&lt;array.length;j++) &#123; if(array[i]&gt;array[j]) &#123; count++; continue; &#125; &#125; &#125; return count%1000000007; &#125;&#125; 方法2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;public class Solution &#123; public int InversePairs(int [] array) &#123; if(array==null||array.length==0) &#123; return 0; &#125; int[] copy = new int[array.length]; for(int i=0;i&lt;array.length;i++) &#123; copy[i] = array[i]; &#125; int count = InversePairsCore(array,copy,0,array.length-1);//数值过大求余 return count; &#125; private int InversePairsCore(int[] array,int[] copy,int low,int high) &#123; if(low==high) &#123; return 0; &#125; int mid = (low+high)&gt;&gt;1; int leftCount= InversePairsCore(array,copy,low,mid)%1000000007; int rightCount = InversePairsCore(array,copy,mid+1,high)%1000000007; int count = 0; int i=mid; int j=high; int locCopy = high; while(i&gt;=low&amp;&amp;j&gt;mid) &#123; if(array[i]&gt;array[j]) &#123; count += j-mid; copy[locCopy--] = array[i--]; if(count&gt;=1000000007)//数值过大求余 &#123; count%=1000000007; &#125; &#125; else &#123; copy[locCopy--] = array[j--]; &#125; &#125; for(;i&gt;=low;i--) &#123; copy[locCopy--]=array[i]; &#125; for(;j&gt;mid;j--) &#123; copy[locCopy--]=array[j]; &#125; for(int s=low;s&lt;=high;s++) &#123; array[s] = copy[s]; &#125; return (leftCount+rightCount+count)%1000000007; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【33】丑数]]></title>
    <url>%2F2019%2F05%2F33-%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 2.解题思路 丑数的定义是1或者因子只有2 3 5,可推出丑数=丑数*丑数,假定丑数有序序列为:a1,a2,a3…….an 所以可以将以上序列(a1除外)可以分成3类,必定满足: 包含2的有序丑数序列:2a1, 2a2, 2*a3 ….. 包含3的有序丑数序列:3a1, 3a2, 3a3 ….. 包含5的有序丑数序列:5a1, 5a2, 5a3 ….. 以上3个序列的个数总数和为n个,而且已知a1 = 1了,将以上三个序列合并成一个有序序列即可 3.代码123456789101112131415161718192021222324252627import java.util.*;public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; int []arr=new int[index]; if(index==0) return 0; arr[0]=1; //第一个丑数为1，放入数组的第一个元素 int t2=0; int t3=0; int t5=0; for(int i=1;i&lt;index;i++) &#123; //寻找3个序列中最小的那个数 arr[i]=Math.min(arr[t2]*2,Math.min(arr[t3]*3,arr[t5]*5)); //最小的那个数的序列值加1 if(arr[t2]*2==arr[i]) t2++; if(arr[t3]*3==arr[i]) t3++; if(arr[t5]*5==arr[i]) t5++; &#125; return arr[index-1]; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【32】把数组排成最小的数]]></title>
    <url>%2F2019%2F05%2F32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 2.解题思路 方法1： (1) 求出数组里面最大的数的位数，然后其他的数位数不够的进行补位 (2) 补位原则：如数组{3,32,321},最大位数为3，所以3进行补位变成333，补的两位为str[i]数组里面的最后一个charAt[str[i].length()-1];所以32补位变成322 (3) 对数组{333，322，321}进行从小到大排序，然后根据索引把字符串拼接即可得到答案。即从小到大排序为{321，322，333}，这三个数对应原数组的{321，32，3}，最后答案即为321323. 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.*;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; if(numbers.length&lt;=0||numbers == null) return ""; //排序，可得到最大的数为numbers[len-1] Arrays.sort(numbers); //求位数 int count = 0; int Max_ = numbers[numbers.length-1]; //得到最大的数的位数 while(Max_&gt;0) &#123; count++; Max_ = Max_/10; &#125; //将数组变成字符串数组 String str[] = new String[numbers.length]; for(int i = 0;i&lt;numbers.length;i++)&#123; str[i] = ""+numbers[i]; &#125; //补位 for(int i = 0;i&lt;numbers.length;i++)&#123; //得到补位要填充的数 String tmp ="" +str[i].charAt(str[i].length()-1); //原数组的位数 int len =str[i].length(); //补足到相同的位数 for(int j = 0;j&lt;count-len;j++) &#123; str[i] = str[i]+tmp; &#125; &#125; //排序 ArrayList&lt;Integer&gt; ss= new ArrayList&lt;&gt;(); //该数组的索引对应着numbers的索引 String strcopy[] = str.clone(); //将其进行从小到大的排序 Arrays.sort(str); //得到从小到大排序后原数组所在的索引 for(int i = 0;i&lt;numbers.length;i++)&#123; for(int j = 0;j&lt;numbers.length;j++)&#123; if(str[i].equals(strcopy[j]))&#123; ss.add(j); &#125; &#125; &#125; //将索引进行拼接得到结果 String res = ""; for(int i = 0;i&lt;numbers.length;i++)&#123; res = res +numbers[ss.get(i)]; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【31】整数中1出现的次数]]></title>
    <url>%2F2019%2F05%2F31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 2.解题思路 方法1： 将每个数变成string,然后将string里面的1替换成”“,长度的减少就是这个string里面1的个数，但是这个方法中String是不可变字符串，故占用内存过多。 方法2： 依次计算出每个数中包含1的个数 3.代码123456789101112public static int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; String s = ""; for(int i = 1;i&lt;=n;i++)&#123; s = i+""; count += s.length()-s.replaceAll("1", "").length(); &#125; return count; &#125; 方法2: 1234567891011121314151617181920212223242526272829public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; if(n&lt;1) return 0; else &#123; int sum=0; for(int i=1;i&lt;=n;i++) sum+=NumberOf1(i); return sum; &#125; &#125; public int NumberOf1(int n) &#123; int count=0; while(n!=0) &#123; if(n%10==1)//求余 &#123; count++; &#125; n=n/10; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【30】连续子数组的最大和]]></title>
    <url>%2F2019%2F05%2F30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1.题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 2.解题思路用变量记录cur记录每一步的累加和，遍历到正数cur增加，遍历到负数cur减少。 当cur&lt;0时，说明累加到当前数出现了小于0的结果，那么累加的这一部分肯定不能作为产生最大累加和的子数组的左边部分，此时令cur = 0.表示从下一个数开始累加。 当cur&gt;=0，每一次累加都可能是最大的累加和。用max跟踪记录cur出现的最大值。cur累加成为负数就清零重新累加，max记录cur的最大值即可。 3.代码123456789101112131415import java.util.*;public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; if(array == null || array.length == 0) return 0; int res = Integer.MIN_VALUE; int cur = 0; for(int i = 0;i&lt;array.length;i++)&#123; cur += array[i]; res = Math.max(res,cur); cur = cur &lt; 0 ? 0 : cur; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【29】最小的K个数]]></title>
    <url>%2F2019%2F05%2F29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 2.解题思路 排序问题，本次使用快排，快排思想即： “挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j–由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(input.length&lt;k) return res; quicksort(input, 0, input.length - 1); for (int i = 0; i &lt; k; i++) &#123; res.add(input[i]); &#125; return res; &#125; public void quicksort(int arr[], int low, int high) &#123; if(low &lt; high) &#123; int position = partition(arr, low, high); quicksort(arr, low, position - 1); quicksort(arr, position + 1, high); &#125; &#125; public int partition(int arr[], int low, int high) &#123; //设置基准值 int key = arr[low]; while(low &lt; high)&#123; //从右到左，直到找到一个小于key的值 while(low &lt; high &amp;&amp; arr[high] &gt;= key) --high; //将该值填入前的坑 arr[low] = arr[high]; //从左到右，直到找到一个大于key的值 while(low &lt; high &amp;&amp; arr[low] &lt;= key) ++low; //将该值填入前一个坑 arr[high] = arr[low]; &#125; //将基准值填入最后一个坑 arr[low] = key; //最后一个坑划分了左边小于该值，右边大于该值 return low; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【28】数组中出现次数超过一半的数字]]></title>
    <url>%2F2019%2F05%2F28-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 2.解题思路利用一个hashmap用来存储数组里面每个数出现的次数，然后遍历map，比较每个数的value是否超过数组的一半 3.代码12345678910111213141516171819import java.util.*;public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int res = 0; for(int i = 0;i&lt;array.length;i++)&#123; if(map.containsKey(array[i]))&#123; map.put(array[i],map.get(array[i])+1); &#125;else&#123; map.put(array[i],1); &#125; &#125; for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123; if(entry.getValue()&gt;array.length/2) res = entry.getKey(); &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【27】字符串的排列]]></title>
    <url>%2F2019%2F05%2F27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 2.解题思路 算法思路：（递归实现）(1)n个元素的全排列=（n-1个元素的全排列）+（另一个元素作为前缀）；(2)出口：如果只有一个元素的全排列，则说明已经排完，则输出数组； (3)不断将每个元素放作第一个元素，然后将这个元素作为前缀，并将其余元素继续全排列，等到出口，出口出去后还需要还原数组； 以字符串abc为例： a 作为开头 -&gt; 求 bc 全排列 -&gt; 得到 bc 和 cb -&gt; 与 a 合并 -&gt; 得到 abc 和 acb b 作为开头 -&gt; 求 ac 全排列 -&gt; 得到 ac 和 ca -&gt; 与 b 合并 -&gt; 得到 bac 和 bca c 作为开头 -&gt; 求 ab 全排列 -&gt; 得到 ab 和 ba -&gt; 与 c 合并 -&gt; 得到 cab 和 cba 3.代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; //用于排序输出 ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); if(str==null||str.length()==0)&#123; return res; &#125; //将字符串转化成字符数组 char[] chars = str.toCharArray(); //从第0个字符开始全排列 res=Permu(chars,0,res); return res ; &#125; public ArrayList&lt;String&gt; Permu(char[] str, int start, ArrayList&lt;String&gt; list) &#123; if (str == null) &#123; return null; &#125; //设置递归的出口,即当需要全排列的范围只有一个元素，则全排结束 if (start == str.length - 1) &#123; //去除重复的字符串 if (list.contains(String.valueOf(str))) &#123; return null; &#125; else&#123; list.add(String.valueOf(str)); &#125; &#125; else &#123; //for循环将start~len-1每一个数放到start位置中去，并实现全排列 //str[start]-----str[len-1]的全排列 for (int j = start; j &lt; str.length; j++) &#123; //取出第j个字符作为第一个字符 swap(str,j,start); //求出str[start+1]----str[len-1]的全排列 Permu(str, start+ 1, list); //恢复原数组 swap(str,j,start); &#125; &#125; //生成字典序 Collections.sort(list); return list; &#125; public void swap(char[] chars,int a,int b)&#123; if(a==b)&#123;//因为会出现原位置与原位置交换，直接空即可 &#125;else&#123; char temp = chars[a]; chars[a]=chars[b]; chars[b]=temp; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【26】二叉搜索树与双向链表]]></title>
    <url>%2F2019%2F05%2F26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1. 题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 二叉树如 10 / \ 6 14 / \ / \ 4 8 12 16 转化成双向链表 4 6 8 10 12 1416 2.解题思路 (1)二叉搜索树中，每个结点都有两个分别指向其左、右子树的指针，左子树结点的值总是小于父结点的值，右子树结点的值总是大于父结点的值。 (2)双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。所以这两种数据结构的结点是一致 为了减少指针的变换次数，并让操作更加简单，在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。 链表是有序的，可以借助二叉树中序遍历，因为中序遍历算法的特点就是从小到大访问结点。当遍历访问到根结点时，假设根结点的左侧已经处理好，只需将根结点与上次访问的最近结点（左子树中最大值结点）的指针连接好即可。进而更新当前链表的最后一个结点指针。同时中序遍历过程正好是转换成链表的过程，可采用递归方法处理 思想：把左子树、右子树都转换成排序的双向链表之后在和根结点链接起来，整个二叉树也变成了排序的双向链表。 3. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeNode Convert(TreeNode root) &#123; if(root==null)&#123;//假如根节点为空，返回空 return null; &#125; if(root.left==null&amp;&amp;root.right==null)&#123;//假如只有一个根节点，则返回根节点 return root; &#125; //1、将左子树构造成双链表，并返回该链表头结点left TreeNode left=Convert(root.left); //2、定位到左子树链表的最后一个节点（左子树最右边的节点） //创建一个临时节点P,用来遍历找到左链表的最后一个节点(左子树最右边的节点)，p初始化指向做左子树的根节点， TreeNode p=left; while(p!=null&amp;&amp;p.right!=null)&#123; //最终p为左子树最右边的节点 p=p.right; &#125; //3、如果左子树链表不为空，将当前root追加到左子树链表后 if(left!=null)&#123;//左子树链表不为空 //左子树链表的最后一个节点p（左子树最右边节点）的右指针指向当前root节点 p.right=root; //当前root节点的左指针指向左子树链表的最后一个节点p（左子树最右边节点） root.left=p; &#125; //4、将右子树构造成双链表，并返回该链表的头结点right TreeNode right=Convert(root.right); //5、如果右子树链表不为空，将右子树链表追加到当前root后 if(right!=null)&#123;//右子树链表不为空 right.left=root;//右子树链表的头结点right的左指针指向当前root root.right=right;//当前root的右指针指向右子树链表的头结点right &#125; return left!=null?left:root;//根据左子树链表是否为空返回整个双向链表的头指针。 &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【25】复杂链表的复制]]></title>
    <url>%2F2019%2F05%2F25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 2.解题思路3.代码123456789101112131415161718192021222324252627282930313233/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if (pHead == null) return null; RandomListNode head = new RandomListNode(pHead.label); RandomListNode ans = head; if (pHead.random != null) &#123; head.random = new RandomListNode(pHead.random.label); &#125; while (pHead.next != null) &#123; pHead = pHead.next; head.next = new RandomListNode(pHead.label); if (pHead.random != null) &#123; head.next.random = new RandomListNode(pHead.random.label); &#125; head = head.next; &#125; return ans; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null) &#123; return null; &#125; RandomListNode currentNode = pHead; //1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面； while(currentNode != null)&#123; RandomListNode cloneNode = new RandomListNode(currentNode.label); RandomListNode nextNode = currentNode.next; currentNode.next = cloneNode; cloneNode.next = nextNode; currentNode = nextNode; &#125; currentNode = pHead; //2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next; while(currentNode != null) &#123; currentNode.next.random = currentNode.random==null?null:currentNode.random.next; currentNode = currentNode.next.next; &#125; //3、拆分链表，将链表拆分为原链表和复制后的链表 currentNode = pHead; RandomListNode pCloneHead = pHead.next; while(currentNode != null) &#123; RandomListNode cloneNode = currentNode.next; currentNode.next = cloneNode.next; cloneNode.next = cloneNode.next==null?null:cloneNode.next.next; currentNode = currentNode.next; &#125; return pCloneHead; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【24】二叉树中和为某值的路径]]></title>
    <url>%2F2019%2F05%2F24-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一棵二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 2.解题思路整个过程可以采用先序遍历方式的DFS，即根节点—–&gt;左子树—–&gt;右子树。 随后考虑一次遍历完成后的处理， (1)当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点； (2)如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。 (3)考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; //创建一个类型为ArrayList&lt;Integer&gt;的list ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathlist=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); //创建一个list,用于存放遍历的值 ArrayList&lt;Integer&gt; path=new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; //如果树为空，则返回空的pathlist if(root==null) return pathlist; //将root值放入list path.add(root.val); //如果根的左子树、右子树、目标值=根值，则返回path if(root.left==null&amp;&amp;root.right==null&amp;&amp;target==root.val) &#123; pathlist.add(new ArrayList&lt;Integer&gt;(path)); &#125; //如果此时根值小于目标值并且含有左子树 if(root.val&lt;=target&amp;&amp;root.left!=null) &#123; //将遍历左子树，将根设为左子树并且此时的target=target-遍历过的root值 FindPath(root.left,target-root.val); &#125; //如果此时根值小于目标值并且含有右子树 if(root.val&lt;=target&amp;&amp;root.right!=null) &#123; //将遍历右子树，将根设为右子树并且此时的target=target-遍历过的root值 FindPath(root.right,target-root.val); &#125; //不论路径的值是否等于输入整数值，都要回退， //即使用remove函数移除路径上的最后一个节点。 path.remove(path.size()-1); return pathlist; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【23】二叉搜索树的后序遍历序列]]></title>
    <url>%2F2019%2F05%2F23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 2.解题思路二叉搜索树后序遍历为：左子树—-&gt;右子树—-&gt;根，且左子树值&lt;根值&lt;右子树值 如二叉搜索树： 10 / \ 6 12 / \ / \ 3 7 11 20 后序遍历结果为：3 7 6 11 20 12 10 对于一个数组sequence，最后一个元素是sequence[len-1] （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于sequence[len-1] ，后一段（右子树）大于sequence[len-1] ，且这两段（子树）都是合法的后序序列 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.*;public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence==null||sequence.length&lt;=0) &#123; return false; &#125; int len=sequence.length; //数组长度 int root=sequence[len-1]; //数组的最后一个数为根 int i=0; for(;i&lt;len-1;i++) &#123; if(root&lt;=sequence[i]) //左子树的数值都小于根 break; &#125; //此时的j即为划分出来的左子树部分和右子树部分的分界 int j=i; for(;j&lt;=len-1;j++) &#123; //j到len-1都都为右子树，数值都大于root,如果root大于他们，则返回false if(root&gt;sequence[j]) &#123; return false; &#125; &#125; //递归判断左子树 boolean leftflag=true; if(i&gt;0) &#123; leftflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,0,i)); &#125; //递归判断右子树 boolean rightflag=true; if (i&lt;len-1) &#123; rightflag=VerifySquenceOfBST(Arrays.copyOfRange(sequence,i,sequence.length-1)); &#125; return leftflag &amp;&amp; rightflag; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【22】从上到下打印二叉树]]></title>
    <url>%2F2019%2F05%2F22-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 2.解题思路使用两个队列一个存放节点treelist，一个存放值intlist。 先将根节点root加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来,并将root值存入intlist,遍历结束条件是i值到达treelist.size-1 3.代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; //创建一个列表用来存储节点 ArrayList&lt;TreeNode&gt; treelist=new ArrayList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; intlist=new ArrayList&lt;Integer&gt;(); if(root==null) //没有节点 return intlist; //1.先存入根节点 treelist.add(root); //2.循环遍历列表，一开始列表里存了root for(int i=0;i&lt;treelist.size();i++) &#123; TreeNode node=treelist.get(i); //3.如果左子节点不为空，则将节点加入列表 if(node.left!=null) treelist.add(node.left); //3、如果右子节点不为空，则将右子节点加入到列表中，这时列表的size加1 if(node.right!=null) treelist.add(node.right); intlist.add(node.val); //4、因为执行上面操作后会增加列表的size //因此可以继续循环下一个节点，直到循环完所有节点 &#125; return intlist; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【21】栈的压入、弹出]]></title>
    <url>%2F2019%2F05%2F21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 2.解题思路 依次入栈pushA数组中的数,直到pushA[i] =popA[index],此时将栈顶这个相等的值弹出。 判断栈中是否还有值，如果没有返回true,如果有并且index！=popA.length,依次弹出栈中数值，并与popA[index++]比较,两个不相等返回false,到栈为空时没执行false则返回true 3.代码12345678910111213141516171819202122public boolean IsPopOrder(int [] pushA,int [] popA) &#123; //用于pushA入栈 Stack&lt;Integer&gt; a = new Stack(); int index = 0; for(int i = 0;i&lt;pushA.length;i++)&#123; a.push(pushA[i]); //当遇到与popA[index]相等的数时，弹出该数 if(pushA[i] == popA[index])&#123; if(index++ == popA.length-1)&#123; return true; &#125; a.pop(); &#125; &#125; //栈中还有值，index还没到达popA尾部，依次弹出与popA比较 while (!a.isEmpty())&#123; if(a.pop()!=popA[index++])&#123; return false; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【20】包含min函数的栈]]></title>
    <url>%2F2019%2F05%2F20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[1.题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 2.解题思路 解题思路：利用辅助栈来存储现有栈的最小值。在入栈和出栈的时候将现有栈和最小值栈进行比较。(1)入栈时，若新值比最小值栈的栈顶还小，则将该值同时push到最小值栈； (2)出栈时，若现有栈的栈顶和最小值栈栈顶一致，则同时出栈，(3)否则，仅仅现有栈pop；通过这一操作，最小值栈的栈顶将永远是现有栈元素中的最小值。 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; // 用于存储所有的数据，压入push,弹出pop Stack&lt;Integer&gt; data_stack =new Stack&lt;&gt;(); //用于存储栈最小的值 Stack&lt;Integer&gt; min_stack = new Stack&lt;&gt;(); public void push(int node) &#123; //如果最小值栈为空或者栈顶值比新入的node值大 if(min_stack.isEmpty()||min_stack.peek()&gt;=node)&#123; //压入node，保持栈顶为栈的最小值 min_stack.push(node); &#125;else &#123; //否则再次压入栈顶值 min_stack.push(min_stack.peek()); &#125; //数据都压入data_stack data_stack.push(node); &#125; //出栈 public void pop() &#123; if(data_stack.empty()||min_stack.empty()) &#123; return; &#125; //弹出数据 data_stack.pop(); //弹出min栈顶，此时min_stack的栈顶为弹出某数剩下数的最小值 min_stack.pop(); &#125; //查看栈的栈顶元素 public int top() &#123; if(!data_stack.isEmpty()) &#123; return data_stack.peek(); &#125; return 0; &#125; //查看最小的元素，即min_stack的栈顶 public int min() &#123; if(!min_stack.empty()) &#123; return min_stack.peek(); &#125; return 0; &#125; &#125; 补充stack.peek:获取栈顶元素，返回栈顶元素但是不移除它 stack.add:向栈中添加元素，成功返回true stack.push:向栈中添加元素，返回结果是当前添加的元素 stack.pop:移除并返回栈顶元素 stack.isEmpty:检查是否为空栈 stack.search(“value”):查看某元素再栈中的位置，计算从1开始]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【19】顺时针打印矩阵]]></title>
    <url>%2F2019%2F04%2F19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 2.解题思路 打印分为四步：循环的次数即打印的圈速，即 rows&gt;start*2&amp;&amp;column&gt;start*2 (1) 从左到右打印一行: 开始于[start,start]，结束于[start,col-start-1] (2) 从上到下打印一行, 开始于[start+1,col-start-1],结束于[col-start-1,col-start-1] (3) 从右到左打印一行 开始于[col-start-1,col-start-2],结束于[col-start-1,start] (4) 从下到上打印一行 开始于[col-start-2,start],结束于[start+1,start] 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; // 矩阵行数 int rows = matrix.length; // 矩阵列数 int columns = matrix[0].length; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 让循环继续的条件是当前行数大于该圈循环开始的行数的两倍以及当前列数大于 //该圈循环开始的列数的两倍（每圈循环开始的行数、列数相同） int start = 0; // 从(0,0)开始循环,圈数：start=0第一圈，start=1第二圈...以此类推 while (rows &gt; start * 2 &amp;&amp; columns &gt; start * 2)&#123; // 每一圈最后一行下标 int endRow = rows - 1 - start; // 每一圈最后一列下标 int endColumn = columns - 1 - start; // 开始一圈圈打印，每打印一圈分为四步，从左到右、从上到下、从右到左、从下到上 // 从左到右，第一步一定会走 for (int i = start; i &lt;= endColumn; i++) list.add(matrix[start][i]); // 从上到下，最后一行大于开始行 if (endRow &gt; start)&#123; for (int i = start + 1; i &lt;= endRow; i++) list.add(matrix[i][endColumn]); &#125; // 从右到左，最后一行大于开始行，最后一列大于开始列 if (endRow &gt; start &amp;&amp; endColumn &gt; start)&#123; for (int i = endColumn - 1; i &gt;= start; i--) list.add(matrix[endRow][i]); &#125; // 从下到上,至少是三行两列，也就是最后一行大于开始行加2，最后一列大于开始列 if (endRow &gt;= start + 2 &amp;&amp; endColumn &gt; start)&#123; for (int i = endRow - 1; i &gt; start; i--) list.add(matrix[i][start]); &#125; // 继续打印下一圈 start++; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【18】二叉树的镜像]]></title>
    <url>%2F2019%2F04%2F18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[1.题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 二叉树的镜像定义： 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 2.解题思路(1)镜像即左右子树交换位置，故交换左子树右子树位置 (2)交换后的左右子树的节点保持原来的顺序，故要交换左右子树自己的左右子树 (3)终止条件为root==null || root.left==null ||root.right == null 3.代码123456789101112131415161718192021222324252627282930313233/* public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125; */ public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root!=null&amp;&amp;(root.left!=null||root.right!=null))&#123; //这三句是左子树跟右子树交换 TreeNode tem=root.left; root.left=root.right; root.right=tem; //然后将根节点换成root.left Mirror(root.left); //然后将根节点换成root.right Mirror(root.right); &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【17】树的子结构]]></title>
    <url>%2F2019%2F04%2F17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 2.解题思路 大体思路是首先判断B的根节点和A的根节点是否相同（这里的相同是指节点的值相同并且左右子节点相同），如果相同比较他们的左右子节点，这一步骤是相同的，可以用递归完成，直到B遍历到每个尾节点，如果这一过程比较的所有节点是相同的，则证明B是A的子结构。如果B的根节点和A的根节点不同，则A向他的左右子节点滑动，然后继续跟B的子节点比较，步骤同上。 (1) 如果root1.val==root2.val,那个就以这个为起点判断是否A包含B (2) 如果没找到，就以root1.left作为起点继续判断A是否包含B (3) 如果没找到，再以root1.right作为起点判断A是否包含B 3.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; //当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false if (root2 != null &amp;&amp; root1 != null) &#123; //如果找到了对应Tree2的根节点的点 if(root1.val == root2.val)&#123; //以这个根节点为为起点判断是否包含Tree2 result = doesTree1HaveTree(root1,root2); &#125; //如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.left,root2); &#125; //如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.right,root2); &#125; &#125; //返回结果 return result; &#125;public boolean doesTree1HaveTree(TreeNode node1, TreeNode node2) &#123; //如果Tree2已经遍历完了都能对应的上，返回true if (node2 == null) &#123; return true; &#125; //如果Tree2还没有遍历完，Tree1却遍历完了。返回false if (node1 == null) &#123; return false; &#125; //如果其中有一个点没有对应上，返回false if (node1.val != node2.val) &#123; return false; &#125; //如果根节点对应的上，那么就分别去子节点里面匹配 return doesTree1HaveTree(node1.left,node2.left) &amp;&amp; doesTree1HaveTree(node1.right,node2.right); &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【16】合并两个排序的链表]]></title>
    <url>%2F2019%2F04%2F16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 例： 链表1： 1 ----&gt; 3 ----&gt; 5 ----&gt; 8 链表2： 2 ----&gt; 4 ----&gt; 6 ----&gt; 7 合并结果： 1 ----&gt; 2 ----&gt; 3 ----&gt; 4 ----&gt; 5 ----&gt; 6 ----&gt; 7 ----&gt; 8 2.解题思路 判断有没有ListNode是空的，如果有则返回另一个 递归实现，如果List1.val&lt;list2.val,pMergeHead = list1,否则pMergeHead = list2，递归直到两个ListNode都为空 3.代码123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1==null)&#123; return list2; &#125;else if(list2==null)&#123; return list1; &#125; ListNode pMergeHead = null; if(list1.val&lt;list2.val)&#123; pMergeHead = list1; pMergeHead.next = Merge(list1.next,list2); &#125;else&#123; pMergeHead = list2; pMergeHead.next = Merge(list1,list2.next); &#125; return pMergeHead; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【15】反转链表]]></title>
    <url>%2F2019%2F04%2F15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，反转链表后，输出新链表的表头。 2.解题思路 用一个栈stack依次存储ListNode里面的值，因为stack的特点是先进后出，故依次弹出即为反转链表 用一个链表temp依次存储弹出的值，依次next存入下一个链表值，链表res指向这个temp的头节点 反转链表的结果为res.next,因为我们之前设temp的头节点为-1（自己设的）。 3.代码123456789101112131415161718192021222324252627 /* public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; */import java.util.*; public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (head!=null)&#123; stack.push(head.val); head = head.next; &#125; ListNode temp = new ListNode(-1); ListNode res = temp; while(stack.size()!=0)&#123; temp.next = new ListNode(stack.pop()); temp = temp.next; &#125; return res.next; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【14】链表中倒数第K个结点]]></title>
    <url>%2F2019%2F04%2F14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，输出该链表中倒数第k个结点。 2.解题思路 先用一个count计算出链表的长度，如果count&lt;k，返回null 链表的倒数第K个即为链表的正数（count-k+1）个,一个for循环，将指针轮询到那个点，然后再将起后面截断（head.next = null）即可。 3.代码123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode root = head; int count = 0; while(root!=null)&#123; count ++; root = root.next; &#125; if(count&lt;k)&#123; return null; &#125; //倒数第K个即正数第（count-k+1）个 for(int i = 1;i&lt;(count-k+1);i++)&#123; head = head.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【13】调整数值顺序使奇数位于偶数前面]]></title>
    <url>%2F2019%2F04%2F13-%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 2.解题思路依次遍历array数组，遇到奇数存到原来的array数组前面，遇到偶数放到res数组，然后将两个数组拼接即可。 3.代码1234567891011121314151617181920public class Solution &#123; public void reOrderArray(int [] array) &#123; int []res = new int[array.length]; int count = 0; int count2 = 0; for(int i = 0;i&lt;array.length;i++)&#123; //如果是奇数，则放在数组前面 if(array[i]%2 != 0)&#123; array[count++] = array[i]; &#125;else&#123; //偶数放在另一个数组里 res[count2++] = array[i]; &#125; &#125; int j = 0; for(int i = count;i&lt;array.length;i++)&#123; array[i] = res[j++]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【12】数值的整数次方]]></title>
    <url>%2F2019%2F04%2F12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[1.题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方 2.解题思路 （1）exponent &gt; 0,如2^3,则可以直接运算得出结果 （2）exponent &lt; 0,如2^-3,则结果为（1/2）^3 （3）exponent = 0,如2^0,则结果为1 3.代码123456789101112131415161718192021public class Solution &#123; public double Power(double base, int exponent) &#123; if(exponent&lt;0)&#123; return powCal(1.0/base,-1*exponent); &#125;else if(exponent&gt;0)&#123; return powCal(base,exponent); &#125;else&#123; return 1; &#125; &#125; //计算base的exponent次方 public double powCal(double base, int exponent) &#123; double res = 1; for(int i = 0;i&lt;exponent;i++)&#123; res = res*base; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【11】二进制中1的个数]]></title>
    <url>%2F2019%2F04%2F11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 2.解题思路 方法1：直接将其转成二进制数组 方法2：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。 3.代码方法1： 1234567891011121314public class Solution &#123; public int NumberOf1(int n) &#123; int count=0; char []a=Integer.toBinaryString(n).toCharArray(); for(int i=0;i&lt;a.length;i++) &#123; if(a[i]=='1') &#123; count++; &#125; &#125; return count; &#125;&#125; 方法2： 123456789101112131415public class Solution &#123; public static int NumberOf(int n) &#123; int count = 0; while (n &gt; 0) &#123; count++; n = (n - 1) &amp; n; &#125; return count; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【10】矩形覆盖]]></title>
    <url>%2F2019%2F04%2F10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[1.题目描述 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 2.解题思路类似于青蛙跳台阶 当 n = 1时，只有一种横向排列的方式 当 n = 2时，有两种选择，横向或者竖向 当 n = 3时，如果选择竖向，则还剩下2*2的排列，如果选择横向，只有一种选择方案(剩下的一个横向一个竖向) 递推可得F(2 * n) = F(2 * (n-1))+F(2 * (n-2) ) , n&gt;=3 3.代码1234567891011public class Solution &#123; public int RectCover(inttarget) &#123; if(target &lt;=0)&#123; return0; &#125; elseif(target ==1|| target == 2)&#123; returntarget; &#125; return(RectCover(target-1)+RectCover(target-2)); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【9】变态跳台阶]]></title>
    <url>%2F2019%2F04%2F9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[1.题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 2.解题思路123456789101112131415161718//f(0) = 0//f(1) = 1//f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。//f(3) = f(3-1) + f(3-2) + f(3-3) ...//f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)/*说明：1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。2）n = 1时，只有1种跳法，f(1) = 13) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论： f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... + f(n-1)6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： f(n-1) =f(0)+f(1)+f(2)+f(3)+...+f((n-1)-1) =f(0)+f(1)+f(2)+f(3)+...+f(n-2) f(n) =f(0)+f(1)+f(2)+f(3)+...+f(n-2)+f(n-1)=f(n-1)+f(n-1)可以得出：f(n) = 2*f(n-1)*/ 3.代码1234567891011public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;=0)&#123; return 0; &#125;else if(target==1)&#123; return 1; &#125;else&#123; return 2*JumpFloorII(target-1); &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【8】跳台阶]]></title>
    <url>%2F2019%2F04%2F8-%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[1.题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 2.解题思路 把n级台阶的跳的次数看成是n的函数,即为f(n),当n&gt;2时,第一次跳有两种跳法, 第一次跳1级,则该次跳法数目为后面剩下的n-1级台阶的跳法数目f(n-1)。 第一次跳2级,则该次跳法数目为后面剩下的n-2级台阶的跳法数目f(n-2)。 所以f(n)=f(n-1)+f(n-2),即相当于斐波那契数列。` 即该题跟斐波那契数列是相似的，青蛙跳台阶的公式为 F(n) = F(n-1)+F(n-2),n&gt;=3 3.代码1234567891011121314151617181920public class Solution &#123; public int JumpFloor(int target) &#123; if(target&lt;=2) &#123; return target; &#125; int one_=1; //第一次跳台阶的方法数 int two_=2; //第二次跳台阶的方法数 int finN=0; for(int i=3;i&lt;=target;i++) &#123; finN=one_+two_; one_=two_; two_=finN; &#125; return finN; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【7】斐波那契数组]]></title>
    <url>%2F2019%2F04%2F7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1.题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 斐波那契数列：1 1 2 3 5 8 13 21 34 …. 2.解题思路 斐波那契数列：从第三项开始，每一项都等于前两项之和。通项公式为 F(n) = F(n-1)+F(n-2),n&gt;=3 方法1：通过递归实现，但是时间复杂度和空间复杂度都会很大 方法2：依次F(n-1)和F(n-2)值，求F(n)就很简单啦 3.代码方法一： 1234567891011public class Solution &#123; public int Fibonacci(int n) &#123; if(n==0) return 0; else if(n==1 || n==2) return 1; else return (Fibonacci(n-1)+Fibonacci(n-2)); &#125;&#125; 方法2： 1234567891011121314151617181920212223public class Solution &#123; public int Fibonacci(int n) &#123; if (n==0) return 0; if(n==1||n==2) return 1; int one_ = 1; //用于存储f(n-2) int two_ =1; //用于存储f(n-1) int fin = 0; for(int i = 3;i&lt;=n;i++)&#123; fin = one_+two_; //向前递推 one_ = two_; //下一次的f(n-2)为 上一次结果的f(n-1) two_ = fin; //下一次的f(n-1)为 上一次结果的fin &#125; return fin; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【6】旋转数组的最小数字]]></title>
    <url>%2F2019%2F04%2F6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[1. 题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 2.解题思路 方法1：重头到尾遍历，找到数组的最小值，时间复杂度为O(N) 方法2：二分遍历查找 mid = low +(high-low)/2; 需要考虑三种情况： arr[mid] &gt; arr[high],如[3,4,5,1,2]说明最小数字在mid的右边，缩小范围，low = mid+1; arr[mid]&lt;arr[high],如[1,2,3,4,5]说明最小数字在mid的左边，high = mid-1; arr[mid] = arr[high],如[0,1,1,1,1]或者[1,1,1,0,1],一步步缩小范围，high = high-1; 3.代码123456789101112131415161718192021222324252627import java.util.ArrayList;public class Solution &#123; public static int minNumberInRotateArray(int[] arr)&#123; int low = 0; int high = arr.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(arr[mid] &gt; arr[high])&#123; low = mid + 1; &#125;else if(arr[mid] == arr[high])&#123; high = high - 1; &#125;else&#123; high = mid; &#125; &#125; return arr[low]; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【5】两个栈实现队列]]></title>
    <url>%2F2019%2F04%2F5.%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1. 题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 2. 解题思路 栈的规则是先进后出，队列的规则是先进先出 stack1一直维持着栈底–栈顶是队列的入队顺序 stack2一直维持着栈顶–栈尾为队列的入队顺序 当执行队列的入队（push）时，如果stack2为空，则直接插入到stack1,stack1从栈底到栈顶的顺序为入队顺序，如果stack2不为空，则将stack2的元素倒入（栈顶—栈尾）stack1,然后再插入数据 4- 当执行队列的出队(pop)操作时，应该出的是stack1的栈底元素，故将stack1依次倒入stack2,这时stack2的栈顶就是要出队的数值，此时stack1为空，stack2从（栈顶–栈尾）为入队顺序 3. 代码12345678910111213141516171819202122232425262728public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); //队列的入队 public void push(int node) &#123; //将stack2倒入stack1 while (!stack2.empty()) &#123; stack1.push(stack2.pop()); &#125; //将元素插入stack1 stack1.push(node); &#125; //队列的出队 public int pop() &#123; //将stack1倒入stack2 while (!stack1.empty()) &#123; stack2.push(stack1.pop()); &#125; //stack2的栈顶就是出队数值 return stack2.pop(); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【4】重建二叉树]]></title>
    <url>%2F2019%2F04%2F4.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 2.解题思路 先序遍历为：根-&gt;左子树-&gt;右子树，中序遍历为左子树-&gt;根-&gt;右子树 先找到根结点，为先序遍历的第一个数值 根据这个数值，可以划分中序中的左子树和右子树范围 递归构建左子树和右子树 3.代码12345678910111213141516171819202122232425262728import java.util.Arrays;//** * Definition for binary tree public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length==0 || in.length==0) return null; TreeNode node = new TreeNode(pre[0]); //根结点 for(int i=0;i&lt;pre.length;i++)&#123; //找到根节点在中序遍历的点，左边为根的左节点，右边为根的右节点 if(pre[0] == in[i])&#123; //递归构建左子树，此时前序的范围缩小为[1,i+1),中序缩小为[0,i) node.left =reConstructBinaryTree(Arrays.copyOfRange (pre,1,i+1),Arrays.copyOfRange(in,0,i)); //递归构建右子树,此时前序的范围缩小为[i+1,len),中序缩小为[i+1,len) node.right = reConstructBinaryTree(Arrays.copyOfRange (pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length)); break; &#125; &#125; return node; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>二叉树题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【3】从尾到头打印链表]]></title>
    <url>%2F2019%2F04%2F3.%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.题目描述 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 2.解题思路 先用一个栈stack存储从头到尾的链表数值 再依次弹出，因为栈是先进后出的，故弹出的结果为从尾到头 将弹出的结果放入list返回 3.代码12345678910111213141516171819202122232425262728public class Main_3 &#123; public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; public static class Solution &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); public static ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) &#123; list.add(stack.pop()); &#125; return list; &#125; &#125; &#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【1】二维数组的查找]]></title>
    <url>%2F2019%2F04%2F1.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[1.题目描述： 在一个二维数组中（每个一维数组的长度相同），如数组 1 2 3 4 5 6 7 8 9 每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 2.解题思路 选择右上角的数字作为开始点 如果array[row][col]&gt;target,则向左查找，col–； 如果array[row][col]&lt;target,则向下查找，row++； 3.代码123456789101112131415161718public class Solution &#123; public boolean Find(int target, int [][] array) &#123; boolean res = false; int row = 0; int col = array[0].length-1; while(row&lt;=array.length-1&amp;&amp;col&gt;=0)&#123; if(array[row][col]&gt;target)&#123; col--; &#125;else if(array[row][col]&lt;target)&#123; row++; &#125;else&#123; res = true; break; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组类型题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_【2】空格替换]]></title>
    <url>%2F2019%2F04%2F2.%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1. 题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 2. 解题思路 方法1：利用函数replaceAll完成 方法2： **先计算需要多少的空间 **从后向前依次插入 3.代码方法1： 12345public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replaceAll(" ", "%20"); &#125;&#125; 方法2： 12345678910111213141516171819202122232425262728public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int spacenum = 0;//spacenum为计算空格数 for(int i=0;i&lt;str.length();i++)&#123; if(str.charAt(i)==' ') spacenum++; &#125; //indexold为为替换前的str下标 int indexold = str.length()-1; //计算空格转换成%20之后的str长度 int newlength = str.length() + spacenum*2; //indexold为为把空格替换为%20后的str下标 int indexnew = newlength-1; //使str的长度扩大到转换成%20之后的长度,防止下标越界 str.setLength(newlength); for(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; if(str.charAt(indexold) == ' ')&#123; str.setCharAt(indexnew--, '0'); str.setCharAt(indexnew--, '2'); str.setCharAt(indexnew--, '%'); &#125;else&#123; str.setCharAt(indexnew--, str.charAt(indexold)); &#125; &#125; return str.toString(); &#125;&#125; 补充1：String和StringBuffer的转换String转换成StringBuffer 12String str = "abc";StringBuffer b=new StringBuffer(str); StringBuffer转换成String 12StringBuffer a=new StringBuffer();String b=a.toString(） 补充2：String、StringBuffer、StringBuilder 1）运行速度StringBuilder&gt;StringBuffer&gt;String 2）String是字符串常量，String对象一旦创建就不能更改。StringBuffer为 字符串变量，可更改 3） String适用于少量的字符串操作，StringBuffer适用于多线程下字符缓冲区进行大量操作的情况。 4） StringBuffer 与 StringBuilder 中的方法和功能完全是等价的， 5） 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 6） 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而StringBuffer则每次都需要判断锁，效率相对更低。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_线程TLAB局部缓存区域]]></title>
    <url>%2F2019%2F04%2Fjvm-%E7%BA%BF%E7%A8%8BTLAB%E5%B1%80%E9%83%A8%E7%BC%93%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[1.对象内存分配的两种方法Ø 指针碰撞 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞” Ø 空闲列表 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表” 问题： 多线程执行时，一个线程正在给A对象分配内存，指针还没有来的及修改，其它为B对象分配内存的线程，而且还是引用这之前的指针指向。就出现问题了 2.TLAB线程本地分配缓存区概念：线程本地分配缓存区,这是一个线程专用的内存分配区域。 由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步（虚拟机采用CAS配上失败重试的方式保证更新操作的原子性），而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。 划重点：1.堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的 2.Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer）， 其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配 3.JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB。默认设定为占用Eden Space的1%。TLAB上的分配由于是线程私有所以没有锁开销。 4.TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。 5.所有新创建的Object 都将会存储在新生代Yong Generation中。 如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_内存分配和回收策略]]></title>
    <url>%2F2019%2F04%2FJVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[1.内存分配1.对象优先在eden分配 对象先在新生代Eden区分配，当Eden区没有足够空间进行分配，虚拟机将发起 Minor GC 2.大对象直接进入老年代 大对象指的是需要大量的连续内存空间的java对象。如很长的字符串或者数组 -XX:PretenureSizeThreshold:大于该值直接在老年代分配 3.长期存活的对象直接进入老年代 12设置对象年龄计数器，GC一遍没死年龄加1,默认老年阈值为15-XX:MaxTenuringThreshold:老年代年龄设置 动态对象年龄判定survivor空间中相同年龄的对象大小总和&gt;survivor的一半，该年龄进入老年代，无需等到MaxTenuringThreshold设定的年龄。 2.回收策略空间分配担保：老年代最大可用空间&gt;新生代所有对象总空间，Minor GC 确保安全。 如果允许，继续比较 老年代最大可用空间&gt;晋升到老年代对象的平均大小，如果大于进行Minor GC,否则进行Full GC. Full GC 和Minor GC 对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，与Minor GC对应的是Major GC、Full GC。 (1)Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。 (2)Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。 (3)Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。 Minor GC 触发条件当Eden区满时，触发Minor GC。 Full GC 触发条件(1) 调用System.gc (2) 老年代空间不足 新生代对象转入及创建为大对象、大数组时出现不足的现象 (3) 永久代空间不足 永久代中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。 (4) gc担保失败 老年代最大可用空间&lt;新生代所有对象总空间,继续比较老年代最大可用空间&lt;晋升到老年代对象的平均大小 (5) CMS清理阶段，发现有新的垃圾，而老年代没有足够空间]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_对象已死]]></title>
    <url>%2F2019%2F04%2FJVM-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%2F</url>
    <content type="text"><![CDATA[垃圾收集器再对堆进行回收前，第一个要做的事就是确定对象是否还存活，判断方法有2种 1)引用计数法 2)可达性分析 1.引用计数法 给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。 缺点：很难解决对象之间的相互循环引用问题，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器收集它们。 2.可达性分析 通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。 GC Roots对象:(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。 (2). 方法区中的类静态属性引用的对象。static对象 (3). 方法区中常量引用的对象。final对象 (4). 本地方法栈中JNI(Native方法)引用的对象。 扩展：引用 (1) 强引用 ：只要强引用还存在，【垃圾收集器就永远不会回收该对象】 Object obj = new Object(); (2) 软引用 :软引用关联的对象，在系统发生内存溢出异常前，会将这些对象进行第二次回收。如果第二次回收还没有足够内存才抛出内存溢出异常。【内存空间足够，回收器就不会回收它，内存不足就会回收】 (3) 弱引用：描述非必需对象。关联的对象只能生存到下一次垃圾回收前，当垃圾收集器工作时，【无论当前内存是否足够，都会回收掉它们】。 (4) 虚引用 ：无法通过虚引用来取得一个对象实例。唯一目的是能在这个对象被收集器回收时收到一个系统通知。【任何时候都可能被回收】 死亡过程 可达性分析没有发现与GCRoots的引用链 1.如果不可达，则标记筛选（条件是对象是否有必要执行finalize） 1)没必要，对象没有覆盖finalize方法或者finalize已经被虚拟机调用 2)有必要。放置在F-Queue队列中。这时候二次标记。如果重新与对象建立连接则不会被回收。 方法区的回收 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类 1.废弃常量 没有在其他地方引用则回收2.无用的类 (1) 类的实例已被回收 (2) 加载该类的classloader已被回收 (3) 该类对应的class没有被引用，也无反射访问。]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_垃圾收集器]]></title>
    <url>%2F2019%2F04%2FJVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[垃圾收集器一共有7种，如果说收集算法是内存回收的方法，那个垃圾收集器就是垃圾回收的具体实现。 以中间绿线为界，上边三个用于年轻代，下边三个用在年老代，而G1则老少通吃，**黑线**线表示两个回收器可搭配使用，**红线**则表示两者可以在同一区域交替使用。由于G1在JDK1.7才达到商用级别，而且目前线上环境也很少使用。 名称 区域 算法 适用情况 Serial 串行 年轻代 复制 单CPU（或CPU较少）、小型客户端应用 Parallel Scavenge 并行 年轻代 复制 多CPU、吞吐量优先（后台处理、科学计算） ParNew 并行 年轻代 复制 多CPU、响应优先（web服务器等） CMS 并发 年老代 标记-清除 响应优先（web服务器等） Serial Old 串行 年老代 标记-整理 单CPU、小型客户端应用 Parallel Old 并行 年老代 标记-整理 多CPU、吞吐量优先（后台处理、科学计算） 1.Serial收集器 从名字就能看出是串行的意思，该回收器是最早实现的，基于单线程， 优点： 实现简单且效率高， 缺点： 进行垃圾回收是会造成“Stop-the-World”(STW)，当回收内存区域较大时，就会造成程序响应时间变长。 STW：在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。 2.ParNew收集器 全名Parallel New Generation，也就是并行新生代垃圾收集器，该回收器实现与Serial基本上一样，只是采用多线程执行回收。是运行在服务端模式下首选的新生代收集器。 3.Parallel Scavenge收集器 Parallel Scavenge则侧重于吞吐量的控制，又名”吞吐量优先”回收器 (吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）； 停顿时间：适合需要与用户交互的程序，良好的响应速度能提升用户体验 高吞吐量：高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多的交互任务。 自适应调节策略：虚拟机会根据当前系统的运行监控信息，动态调整参数以提供最合适的停顿时间或者最大吞吐量。 该回收器与ParNew的最大区别在于ParNew通常与CMS搭配。 4.CMS收集器 Concurrent Mark Sweep，是一个并发回收器，旨在减少垃圾回收的停顿时间。集中应用于B/S系统的服务端，尤其注重服务的响应速度 CMS运作操作流程 (1)初始标记：标记GCRoots能直接关联到的对象 (2)并发标记：GCRoot开始对堆中对象进行可达性分析 (3)重新标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录 (4)并发清除：回收标记的垃圾 CMS缺点： （1）对CPU资源非常敏感 （2）无法处理浮动垃圾：CMS在并发清除阶段用户线程还在运行，会产生新的垃圾。这部分垃圾出现在标记之后，要等待下次GC才能清理掉 （3）基于标记-清除算法，会产生大量的内存碎片。 5.Serial Old收集器 标记-整理算法实现的，相当于Serial的年老代版。 （1）可以与Parallel Scavenge收集器搭配使用 （2）作为CMS收集器的后备预案 6.Paraller Old收集器 标记-整理算法实现，相当于Parallel Scavenge的年老代版。 在注重吞吐量以及CPU资源敏感的场合：Parallel Old + Parallel Scavengr 7.G1收集器 G1是一款面向服务端应用的垃圾收集器。具备以下特点： (1)并行与并发 并行即使用多个CPU来缩端STW停顿的时间，还可以通过并发方式让java程序继续执行。 (2)分代收集 可以不需要其他收集器配合就能独立管理整个GC堆 (3)空间整合 标记整理算法实现，在运行期间不会产生内存空间碎片，收集后可以提供规整的可用内存。 (4)可预测停顿 除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上时间不超过N秒。 G1收集器运作流程： (1)初始标记：标记GCRoots能直接关联到的对象 (2)并发标记：GCRoot开始对堆中对象进行可达性分析 (3)最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那部分标记记录 (4)筛选回收：回收标记的垃圾]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM_垃圾回收算法]]></title>
    <url>%2F2019%2F04%2FJVM-%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[垃圾回收算法有4种 标记-清除算法 复制算法 标记-整理算法 分代收集算法 1.复制算法可用的内存空间分为大小相等的两块，每次只是用其中的一块，当这一块被用完的时候，就将还存活的对象复制到另一块中，然后把原已使用过的那一块内存空间一次回收掉。这个算法常用于新生代的垃圾回收。 优点 复制算法解决了标记-清除算法的效率问题，以空间换时间。 缺点 但是当存活对象非常多的时候，复制操作效率将会变低，而且每次只能使用一半的内存空间，利用率不高。 应用场景 应用于新生代 Serial、ParNew、Parallel Scavenge 垃圾收集器应用的算法 2. 标记-清除算法先标记出所有需要被回收的对象，然后在标记完成后统一回收掉所有被标记的对象。 缺点效率问题：标记与清除两个过程的效率都不高 空间问题：产生大量不连续的内存碎片，碎片太多会导致再程序运行过程中需要分配较大对象时，找不到足够的连续内存尔不得不提前触发垃圾回收动作。 应用场景应用于老年代的垃圾回收 CMS垃圾收集器应用的算法 3.标记-整理算法这个算法分为三部分： 标记出所有需要被回收的对象； 把所有存活的对象都向一端移动； 把所有存活对象边界以外的内存空间都回收掉。 优点 标记-整理算法解决了复制算法多复制效率低、空间利用率低的问题， 解决了内存碎片的问题。 应用场景 Serial Old、Parallel Old 垃圾收集器应用的算法 主要应用于老年代 4.分代收集算法 根据对象生存周期的不同将内存空间划分为不同的块，然后对不同的块使用不同的回收算法。一般把Java堆分为新生代和老年代，新生代中对象的存活周期短，只有少量存活的对象，所以可以使用复制算法，而老年代中对象存活时间长，而且对象比较多，所以可以采用标记-清除和标记-整理算法。]]></content>
      <categories>
        <category>JAVA虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL_锁问题]]></title>
    <url>%2F2019%2F03%2FSQL-%E9%94%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[锁分类 （1）表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 [MYISAM、Memory、Innodb] 表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用 （2）行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发 度也最高。[Innodb] 行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用 （3）页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁 之间，并发度一般。[BDB] MYISAM表级锁锁争用12345678mysql&gt; show status like 'table%';+-----------------------+-------+| Variable_name | Value |+-----------------------+-------+| Table_locks_immediate | 2979 || Table_locks_waited | 0 |+-----------------------+-------+####Table_locks_waits值高则代表严重的表级锁争用 锁模式（1）表共享读锁：可以多个用户共同读 （2）表独占写锁：写操作独占 一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止 如何加表锁MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁 在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁 并发插入MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。  当concurrent_insert设置为0时，不允许并发插入。  当concurrent_insert设置为1时，如果MyISAM表中没有空洞(即表的中间没有被删除的行),MyISAM允许在一个进程读表的同时, 另一个进程从表尾插入记录。这也是MySQL 的默认设置。  当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。 锁调度一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，写进程先获得锁。 1234一些设置来调节 MyISAM 的调度行为。  通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。  通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。  通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。 InnoDB行锁锁争用123456789101112mysql&gt; show status like 'innodb_row_lock%';+-------------------------------+-------+| Variable_name | Value |+-------------------------------+-------+| InnoDB_row_lock_current_waits | 0 || InnoDB_row_lock_time | 0 || InnoDB_row_lock_time_avg | 0 || InnoDB_row_lock_time_max | 0 || InnoDB_row_lock_waits | 0 |+-------------------------------+-------+###InnoDB_row_lock_waits 和 InnoDB_row_lock_time_avg 的值比较高，代表严重的锁争用 锁模式共享锁：允许一个事务去读一行，阻止其他事务获得该行的排他锁 select … lock in share mode; 排他锁：允许获得排他锁的事务更新数据，阻止其他事务获得该行的共享读锁和排他写锁 select … for update; X(排他锁) IX(意向排他锁) S(共享锁) IS(意向共享锁) X(排他锁) 冲突 冲突 冲突 冲突 IX(意向排他锁) 冲突 兼容 冲突 兼容 S(共享锁) 冲突 冲突 兼容 兼容 IS(意向共享锁) 冲突 兼容 兼容 兼容 12345 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁.另外，为了允许行锁和表锁共存， 实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁 锁实现方式只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！ 1234（1）在不通过索引条件查询的时候，InnoDB 确实使用的是表锁，而不是行锁。（2）由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行.另外，不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁（4）如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。 表锁使用场景12(1)事务需要更新大部分或全部数据 (2)事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的 开销 避免死锁方法 （1）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表 （2）在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。 （3）隔离级别 在 REPEATABLE-READ 隔离级别下，如果两个线程同时对相同条件记录用 SELECT...FOR UPDATE 加排他锁， 在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录， 如果两个线程都这么做，就会出现死锁.这种情况下，将隔离级别改成 READ COMMITTED，就可避免问题，]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL_触发器]]></title>
    <url>%2F2019%2F03%2FSQL-%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[概念触发器（trigger）是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。 相关操作 语句 意义 CREATE TRIGGER trigger_name trigger_time[BEFORE&#124;AFTER] trigger_event[INSERT&#124;UPDATE&#124;DELETE]ON tbl_name FOR EACH ROW trigger_stmt 创建触发器 DROP TRIGGER [schema_name.]trigger_name 删除触发器 show triggers \G 查看触发器 desc triggers 查看触发器 触发器的使用触发器执行的语句有以下两个限制。 （1）触发程序不能调用将数据返回客户端的存储程序，也不能使用采用 CALL 语句的动态 SQL 语句 但是允许存储程序通过参数将数据返回触发程序。也就是存储过程或者函数通过 OUT 或者 INOUT 类型的参数将数据返回触发器 是可以的，但是不能调用直接返回数据的过程。 （2）不能在触发器中使用以显式或隐式方式开始或结束事务的语句，如 STARTTRANSACTION、 COMMIT 或 ROLLBACK]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL_存储过程和函数]]></title>
    <url>%2F2019%2F03%2FSQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[概念存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合。 与函数的区别 （1）函数必须有返回值，而存储过程没有 （2）存储过程的参数可以使用 IN、OUT、INOUT 类型，而函数的参数只能是 IN 类型的。 相关操作 语句 定义 CREATE PROCEDURE sp_name ([proc_parameter[,…]]) [characteristic …] routine_body 创建存储过程 CREATE FUNCTION sp_name ([func_parameter[,…]] RETURNS type [characteristic …] routine_body 创建函数 ALTER {PROCEDURE &#124; FUNCTION} sp_name [characteristic …] 修改 存储过程/函数 CALL sp_name([parameter[,…]]) 调用过程 DROP PROCEDURE name 删除存储过程 SHOW {PROCEDURE&#124;FUNCTION} STATUS [LIKE ‘pattern’] 查看存储过程或者函数的状态 SHOW CREATE {PROCEDURE &#124;FUNCTION} sp_name 查看存储过程或者函数的定义 select * from routines where ROUTINE_NAME = ‘film_in_stock’ \G 获取存储过程和函数的包括名称、类型、语法、创建人 等信息。 DECLARE var_name[,…] type [DEFAULT value] 变量的定义{用于begin…end块中} SET var_name = expr [, var_name = expr] 变量的赋值 DECLARE condition_name CONDITION FOR condition_value 条件的定义 DECLARE handler_type HANDLER FOR condition_value[,…] sp_statement 条件的处理 DECLARE cursor_name CURSOR FOR select_statement 声明光标 OPEN cursor_name 打开光标 FETCH cursor_name INTO var_name [, var_name] … fetch光标 CLOSE cursor_name 关闭光标 IF search_condition THEN statement_list[ELSEIF search_condition THEN statement_list] …[ELSE statement_list]END IF IF语句 CASE case_valueWHEN when_value THEN statement_list[WHEN when_value THEN statement_list] …[ELSE statement_list]END CASE CASE语句 [begin_label:] LOOPstatement_listEND LOOP [end_label] LOOP语句 [begin_label:] REPEATstatement_listUNTIL search_conditionEND REPEAT [end_label] REPEAT语句 [begin_label:] WHILE search_condition DOstatement_listEND WHILE [end_label] WHILE语句 参数说明： 创建存储过程的proc_parameter: [ IN | OUT | INOUT ] param_name type 创建函数的func_parameter: param_name type 创建函数的type: Any valid MySQL data type 创建存储过程/函数的characteristic: LANGUAGE SQL //说明下面过程的BODY是使用SQL语言 | [NOT] DETERMINISTIC //DEDETERMINISTIC 确定的，即每次输入一样输出也一样的程序，NOT DETERMINISTIC 非确定的，默认是非确定的。 | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } //CONTAINS SQL 表示子程序不包含读或写数据的语句。NO SQL 表示子程序不包含 SQL 语句。READS SQL DATA 表示子程序包含读数据的语句，但不包含写数据的语句。MODIFIES SQL DATA 表示子程序包含写数据的语句。 | SQL SECURITY { DEFINER | INVOKER } //可以用来指定子程序该用创建子程序者的许可来执行，还是使用调用者的许可来执行。默认值是 DEFINER | COMMENT ‘string’ //存储过程或者函数的注释信息。 创建存储过程/函数的 routine_body: Valid SQL procedure statement or statements 修改存储过程/函数中的characteristic: { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } | SQL SECURITY { DEFINER | INVOKER } | COMMENT ‘string 条件的定义condition_value: SQLSTATE [VALUE] sqlstate_value &lt; |mysql_error_code 条件的处理参数handler_type: CONTINUE | EXIT | UNDO condition_value: SQLSTATE [VALUE] sqlstate_value | condition_name | SQLWARNING //对所有以 01 开头的 SQLSTATE 代码的速记 | NOT FOUND //对所有以 02 开头的 SQLSTATE 代码的速记 | SQLEXCEPTION //对所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的速记。 | mysql_error_code 例子1234567891011121314151617181920212223242526272829mysql&gt; DELIMITER $$ //delimiter将sql的结束标志设为$$mysql&gt;mysql&gt; CREATE PROCEDURE film_in_stock(IN p_film_id INT, IN p_store_id INT, OUT p_film_countINT) -&gt; READS SQL DATA -&gt; BEGIN -&gt; SELECT inventory_id -&gt; FROM inventory -&gt; WHERE film_id = p_film_id -&gt; AND store_id = p_store_id -&gt; AND inventory_in_stock(inventory_id); ////调用了函数inventory_in_stock() -&gt; -&gt; SELECT FOUND_ROWS() INTO p_film_count; -&gt; END $$Query OK, 0 rows affected (0.00 sec)mysql&gt;mysql&gt; DELIMITER ; //delimiter将sql的结束标志设为;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL_视图]]></title>
    <url>%2F2019%2F03%2FSQL-%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[视图概念视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。 视图中的数据并不属于视图本身，而是属于基本的表，对视图可以像表一样进行insert,update,delete操作。 视图不能被修改，表修改或者删除后应该删除视图再重建。 视图的数量没有限制，但是命名不能和视图以及表重复，具有唯一性。 视图可以被嵌套，一个视图中可以嵌套另一个视图。 视图不能索引，不能有相关联的触发器和默认值，sql server不能在视图后使用order by排序。 视图的操作 语句 意义 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED &#124; MERGE&#124;TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED &#124; LOCAL] CHECK OPTION] 创建视图&gt; LOCAL 是只要满足本视图的条件就可以更新&gt; CASCADED 则是必须满足所有针对该视图的所有视图的条件才可以更新 ALTER [ALGORITHM = {UNDEFINED &#124;MERGE &#124;TEMPTABLE}]VIEW view_name [(column_list)]AS select_statement[WITH [CASCADED &#124; LOCAL] CHECK OPTION] 修改视图 DROP VIEW [IF EXISTS] view_name [, view_name] …[RESTRICT &#124; CASCADE] 删除视图 SHOW TABLES 查看视图 SHOW TABLE STATUS [FROM db_name] [LIKE ‘pattern’] 查看视图的信息 show create view view_name \G 查看视图定义 视图不可更新情况：（1）包含以下关键字的 SQL 语句： 聚合函数（SUM、MIN、MAX、COUNT 等）、DISTINCT、GROUP BY、HAVING、UNION 或者 UNION ALL。 &gt; create or replace view payment_sum as select staff_id,sum(amount) from payment **group by** staff_id; （2） 常量视图。 &gt; create or replace view pi as select 3.1415926 as pi; （3）SELECT 中包含子查询。 &gt;create view city_view as select (select city from city where city_id = 1) ; （4） JION。 （5） FROM 一个不能更新的视图。 （6）WHERE 字句的子查询引用了 FROM 字句中的表]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL_索引]]></title>
    <url>%2F2019%2F03%2FSQL-%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[1.索引概述使用索引是提高 SELECT 操作性能的最佳途径。 MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引 MySQL 目前还不支持函数索引，但是支持前缀索引。 MySQL 中还支持全文本（FULLTEXT）索引，用于全文搜索，默认情况下，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。 语句 意义 CREATE[UNIQUE&#124;FULLTEXT&#124;SPATIAL] INDEX index_name[USING index_type]ON tbl_name (index_col_name,…) 创建索引index_col_name:col_name [(length)] [ASC&#124;DESC] DROP INDEX index_name ON tbl_name 删除索引 2.设计索引原则（1）搜索的索引列，不一定是所要选择的列。换句话说，最适合索引的列是出现在 WHERE子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。 （2） 使用唯一索引。考虑某列中值的分布。索引的列的基数越大，索引的效果越好。 （3） 使用短索引。如果对字符串列进行索引，应该指定一个前缀长度。 （4）利用最左前缀 （5）不要过度索引 3.索引失效 （1）如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引. （2）如果使用 MEMORY/HEAP 表并且 where 条件中不使用“=”进行索引列，那么不会用到索引。heap 表只有在“=”的条件下才会使用索引。 （3）用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到 （4）不符合最左前缀:有复合索引，但是搜索的那个列不是索引第一列 （5）like以%开始 （6）如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的 4.查看索引使用情况 show status like ‘Handler_read%’; handler_read_key:索引值被读次数 越高越好 handler_read_rnd_next:查询效率，该值越低越好]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL_存储引擎]]></title>
    <url>%2F2019%2F03%2FSQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[四种存储引擎 (1) MYISAM MyISAM 是 MySQL 的默认存储引擎。MyISAM 不支持事务、也不支持外键，其优势是访问的速度快， 对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表.(不支持外键) (2) Innodb InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。 但是对比 MyISAM的存储引擎，InnoDB 写的处理效率差一些并且会占用 更多的磁盘空间以保留数据和索引。（支持外键） (3) Memory MEMORY 存储引擎使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文件，格式是.frm。 MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的,并且默认使用 HASH 索引，但是一旦服务关闭，表中的数据就会丢失掉。 MEMORY 类型的存储引擎主要用在那些内容变化不频繁的代码表， 或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果。 (4) Merge MERGE 存储引擎是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，MERGE表本身并没有数据. 对 MERGE 类型的表可以进行查询、更新、删除的操作，这些操作实际 上是对内部的实际的 MyISAM 表进行的。 使用MERGE 表来透明地对多个表进行查询和更新操作，而对这种按照时间记录的操作日志表则可以透明地进行插入操作。 1.MYISAM 每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，但扩展名分别是：  .frm（存储表定义）；  .MYD（MYData，存储数据）；  .MYI （MYIndex，存储索引）。 数据文件和索引文件可以放置在不同的目录，平均分布 IO，获得更快的速度。 MyISAM 的表又支持 3 种不同的存储格式，分别是：  静态（固定长度）表：存储迅速，容易缓存，出现故障容易恢复，但占用空间多。  动态表：占用空间少， 但频繁更新删除记录会产生碎片，故障恢复较难  压缩表： 记录被单独压缩，访问开支小。 2.InnoDB(1)自动增长列 （1）ALTER TABLE *** AUTO_INCREMENT = n: 语句强制设置自动增长列的初识值 （2）LAST_INSERT_ID()：查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是第一条记录使用的自动增长值。 对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于 MyISAM 表，自动增长列可以是组合索引的其他列. (2)外键约束 CONSTRAINT fk_city_country FOREIGN KEY (子表的外键名称)REFERENCES 父表(父表的名称)ON DELETE RESTRICT ON UPDATE CASCADE RESTRICT/NO ACTION： 限制在子表有关联记录的情况下父表不能更新 CASCADE： 表示父表在更新或者删除时，更新或者删除子表对应记录 SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL (3) 存储方式 @ 使用共享表空间存储 @ 使用多表空间存储 存储引擎的选用 MyISAM：默认的 MySQL 插件式存储引擎。如果应用是以读操作和插入操作为主， 只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。  InnoDB：用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的 要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、 删除操作，那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低 由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback）,对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。  MEMORY：将所有数据保存在 RAM 中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY 的缺陷是对表的大小有限制，太大的表无法 CACHE 在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY 表通常用于更新不太频繁的小表，用以快速得到访问结果。  MERGE：用于将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象 引用它们。MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制，并且通过将不同 的表分布在多个磁盘上，可以有效地改善 MERGE 表的访问效率。这对于诸如数据仓储等 VLDB 环境十分适合]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL_常用函数]]></title>
    <url>%2F2019%2F03%2FSQL-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.常用函数分为以下几种 (1) 字符串 (2) 数值函数 (3) 日期和时间函数 (4) 流程函数 (5) 其他 1.字符串 函数 功能 CANCAT(S1,S2,…Sn) 连接 S1,S2,…Sn 为一个字符串 INSERT(str,x,y,instr) 将字符串 str 从第 x 位置开始，y 个字符长的子串替换为字符串 instr LOWER(str) 将字符串 str 中所有字符变为小写 UPPER(str) 将字符串 str 中所有字符变为大写 LEFT(str ,x) 返回字符串 str 最左边的 x 个字符 RIGHT(str,x) 返回字符串 str 最右边的 x 个字符 LPAD(str,n ,pad) 用字符串 pad 对 str 最左边进行填充，直到长度为 n 个字符长度 RPAD(str,n ,pad) 用字符串 pad 对 str 最右边进行填充，直到长度为 n 个字符长度 LTRIM(str) 去掉字符串 str 左侧的空格 RTRIM(str) 去掉字符串 str 行尾的空格 REPEAT(str,x) 返回 str 重复 x 次的结果 REPLACE(str,a,b) 用字符串 b 替换字符串 str 中所有出现的字符串 a STRCMP(s1,s2) 比较字符串 s1 和 s2 TRIM(str) 去掉字符串行尾和行头的空格 SUBSTRING(str,x,y) 返回从字符串 str x 位置起 y 个字符长度的字串 2.数值函数 函数 功能 ABS(x) 返回 x 的绝对值 CEIL(x) 返回大于 x 的最大整数值 FLOOR(x) 返回小于 x 的最大整数值 MOD(x，y) 返回 x/y 的模 RAND() 返回 0 到 1 内的随机值 ROUND(x,y) 返回参数 x 的四舍五入的有 y 位小数的值 TRUNCATE(x,y) 返回数字 x 截断为 y 位小数的结果 3.日期和时间函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前的日期和时间 UNIX_TIMESTAMP(date) 返回日期 date 的 UNIX 时间戳 FROM_UNIXTIME 返回 UNIX 时间戳的日期值 WEEK(date) 返回日期 date 为一年中的第几周 YEAR(date) 返回日期 date 的年份 HOUR(time) 返回 time 的小时值 MINUTE(time) 返回 time 的分钟值 MONTHNAME(date) 返回 date 的月份名 DATE_FORMAT(date,fmt) 返回按字符串 fmt 格式化日期 date 值 DATE_ADD(date,INTERVAL expr type) 返回一个日期或时间值加上一个时间间隔的时间值，INTERVAL 是间隔类型关键字expr 是一个表达式，这个表达式对应后面的类型type 是间隔类型 DATEDIFF(expr,expr2) 返回起始时间 expr 和结束时间 expr2 之间的天数 表： MySQL 中的日期时间格式 格式符 格式说明 %S,%s 两位数字形式的秒（00,01,…,59） %i 两位数字形式的分（00,01,…,59） %H 两位数字形式的小时，24 小时（00,01,…,23） %h,%I 两位数字形式的小时，12 小时（01,02,…,12） %k 数字形式的小时，24 小时（0,1,…,23） %l 数字形式的小时，12 小时（1,2,…,12） %T 24 小时的时间形式（hh:mm:ss） %r 12 小时的时间形式（hh:mm:ssAM 或 hh:mm:ssPM） %p AM 或 PM %W 一周中每一天的名称（Sunday,Monday,…,Saturday） %a 一周中每一天名称的缩写（Sun,Mon,…,Sat） %d 两位数字表示月中的天数（00,01,…,31） %e 数字形式表示月中的天数（1,2，…,31） %D 英文后缀表示月中的天数（1st,2nd,3rd,…） %w 以数字形式表示周中的天数（0=Sunday,1=Monday,…,6=Saturday） %j 以 3 位数字表示年中的天数（001,002,…,366） %U 周（0,1,52），其中 Sunday 为周中的第一天 %u 周（0,1,52），其中 Monday 为周中的第一天 %M 月名（January,February,…,December） 1表：MYSQL中的时间间隔类型 表达式类型 描述 格式 HOUR 小时 hh MINUTE 分 mm SECOND 秒 ss YEAR 年 YY MONTH 月 MM DAY 日 DD YEAR_MONTH 年和月 YY-MM DAY_HOUR 日和小时 DD hh DAY_MINUTE 日和分钟 DD hh:mm DAY_ SECOND 日和秒 DD hh:mm:ss HOUR_MINUTE 小时和分 hh:mm HOUR_SECOND 小时和秒 hh:ss MINUTE_SECOND 分钟和秒 mm:ss 4.流程函数 函数 功能 IF(value,t f) 如果 value 是真，返回 t；否则返回 f IFNULL(value1,value2) 如果 value1 不为空返回 value1，否则返回 value2 CASE WHEN [value1] THEN[result1]…ELSE[default]END 如果 value1 是真，返回 result1，否则返回 default CASE [expr] WHEN [value1]THEN[result1]…ELSE[default]END 如果 expr 等于 value1，返回 result1，否则返回 default 5.其他函数 函数 功能 DATABASE() 返回当前数据库名 VERSION() 返回当前数据库版本 USER() 返回当前登录用户名 INET_ATON(IP) 返回 IP 地址的数字表示 INET_NTOA(num) 返回数字代表的 IP 地址 PASSWORD(str) 返回字符串 str 的加密版本 MD5() 返回字符串 str 的 MD5 值]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL_基础]]></title>
    <url>%2F2019%2F03%2FSQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[SQL分类(1) DDL(Data Definition Languages):数据定义语言：不同的数据段、数据库、表、列、索引等数据库对象的定义（create、drop、alter） (2) DML (Data Manipulation Language)：数据操纵语句：增删改查(inset、delete、select) (3) DCL(Data Control Language) :数据控制语句：数据库、表、字段、用户的访问权限和安全级别。 1.DDL数据定义语句对数据库内部的对象进行创建、删除、修改的操作语言。涉及表的定义，结构的修改。 语句 意义 CREATE DATABASE dbname 创建数据库 SHOW databases/tables 查看系统存在哪些数据库/数据表 USE dbname 选择数据库 DROP DATABASE dbname 删除数据库 DROP TABLE tablename 删除表 CREATE TABLE tablename ( column_name_1 column_type_1 constraints， column_name_2 column_type_2 constraints ， …… column_name_n column_type_n constraints ) 创建数据库 DESC tablename 查看表定义 SHOW CREATE TABLE tablename \G 查看更详细的表定义,\G表示使字段按照顺序竖着排列 ALTER TABLE tablename MODIFY [COLUMN] column_definition [FIRST &#124; AFTER col_name] 修改表类型 ALTER TABLE tablename ADD [COLUMN] column_definition [FIRST &#124; AFTER col_name] 增加表字段 ALTER TABLE tablename DROP [COLUMN] col_name 删除表字段 ALTER TABLE tablename CHANGE [COLUMN] old_col_name column_definition [FIRST&#124;AFTER col_name] 字段改名 ALTER TABLE tablename RENAME [TO] new_tablename 表改名 2.DML数据操纵语句DML 操作是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select） 语句 意义 INSERT INTO tablename (field1,field2,……fieldn) VALUES(value1,value2,……valuesn); 插入记录 UPDATE tablename SET field1=value1，field2.=value2，……fieldn=valuen [WHERE CONDITION] 更新记录 DELETE FROM tablename [WHERE CONDITION] 删除记录 SELECT * FROM tablename [WHERE CONDITION] 查询记录 SELECT DISTINCT column_name FROM tablename [WHERE CONDITION] 查询不重复的记录 SELECT * FROM tablename [WHERE CONDITION] [ORDER BY field1 [DESC &#124; ASC], field2[DESC &#124; ASC], ……fieldn [DESC&#124;ASC] [LIMIT offset_start,row_count] 排序限制 SELECT [field1,field2,……fieldn] fun_nameFROM tablename[WHERE where_contition][GROUP BY field1,field2,……fieldn[WITH ROLLUP]][HAVING where_contition] 聚合操作group by /having SELECT ename,deptname FROM deptRIGHT JOIN[LEFT JOIN] emp ON dept.deptno=emp.deptno; 右连接right join 左连接left join in、not in、=、!=、exists、not exists 子查询 SELECT * FROM t1UNION&#124;UNION ALLSELECT * FROM t2……UNION&#124;UNION ALLSELECT * FROM tn; 记录联合 3.DCL数据控制语句DCL 语句主要是 DBA 用来管理系统中的对象权限时所使用 语句 意义 grant select,insert on sakila.* to ‘z1‘@’localhost’ identified by ‘123’ 创建一个数据库用户 z1，具有对 sakila 数据库中所有表的 SELECT/INSERT 权限 revoke insert on sakila.* from ‘z1‘@’localhost’; 将z1 的权限变更，收回 INSERT，只能对数据进行 SELECT 操作 4.帮助的使用 语句 意义 ？contents 显示所有可供查询的的分类 ？ data types Mysql支持的数据类型 ？ show … … … 5.MYSQL支持的数据类型 (1)数值型 整数：tinyint smallint mediumint int/integer bigint 浮点数：float double 定点数：dec(m,d) decimal(m,d):m表示长度，d表示小数位数 位：bit (2)字符串类型 date datetime timestamp time year (3)日期和时间类型 整数：char varchar 字节：tinyblob blob mediumblob longblob tinytext text mediumtext longtext varbinary binary]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sprintboot中的数据库注解]]></title>
    <url>%2F2019%2F03%2Fsprintboot%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@Results —-表字段与数据库字段映射 @Entity —- 生成表 @Transient —-后台与数据库不映射 @Id —-主键 @Transactional —-事务 @GeneratedValuestrategy=GenerationType.IDENTITY —–自增值 @Table - 映射表名 —– 映射表名 @Column(name = “dict_name”,columnDefinition=”varchar(100) COMMENT ‘字典名’”) —– 字段名、类型、注释 @Select @Update @Delete @Insert @UpdateTimestamp —— 更新时自动更新时间 @CreationTimestamp ——创建时自动更新时间 @Version —– 版本号，更新时自动加1 1.@Entity@Entity说明这个class是实体类，并且使用默认的orm规则，即class名即数据库表中表名，class字段名即表中的字段名 12345678910111213141516@Entity@DynamicUpdate@Datapublic class OrderDetail &#123; @Id private String detailId; private String orderId; private String productId; private String productName; private BigDecimal productPrice; private Integer productQuantity; private String productIcon; private Date createTime; private Date updateTime;&#125; 运行将对应生成数据库表名为OrderDetail的表，里面字段对应上面的字段。 2.@DynamicUpdate动态更新表。 如果我们在更新表时,只想更新某个字段,就不要加 @DynamicUpdate,通常为了更新表时的效率,都是不加的.反之,如果我们更新某个字段时,更新所有的字段,就可以加上 @DynamicUpdate. @DynamicUpdate属性:设置为true,设置为true,表示update对象的时候,生成动态的update语句,如果这个字段的值是null就不会被加入到update语句中,默认false。比如只想更新某个属性，但是却把整个对象的属性都更新了，这并不是我们希望的结果，我们希望的结果是：我更改了哪些字段，只要更新我修改的字段就够了。 3.@Table@Table注解用来标识实体类与数据表的对应关系，默认和类名一致。 123456789101112131415161718192021222324252627282930@Entity@Table(name="c_user")public class User &#123; @Id @GeneratedValue private Long id; @NotNull @Column(length = 50) private String userName; @NotNull @Column(length = 20 , unique = true, nullable = false) private Long mobile; @Column(length = 20 , unique = true) private String email; @NotNull @Column(columnDefinition="tinyint") private Integer status; private String password; private String nickname; private Integer companyId; private Integer departmentId; private Date regTime; private String regIp; private Integer loginNum;&#125; 4. @Column@Column注解来标识实体类中属性与数据表中字段的对应关系。共有10个属性，这10个属性均为可选属性： name属性定义了被标注字段在数据库表中所对应字段的名称； unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。 nullable属性表示该字段是否可以为null值，默认为true。如果属性里使用了验证类里的@NotNull注释，这个属性可以不写。 insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。 updatable属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。 columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。若不指定该属性，通常使用默认的类型建表，若此时需要自定义建表的类型时，可在该属性中设置。（也就是说，如果DB中表已经建好，该属性没有必要使用。） table属性定义了包含当前字段的表名。 length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。 precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。 5.@Transactional 事务@Transactional 注解的属性信息 属性名 说明 name 当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。 propagation 事务的传播行为，默认值为 REQUIRED。 isolation 事务的隔离度，默认值采用 DEFAULT。 timeout 事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。 read-only 指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。 rollback-for 用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。 no-rollback- for 抛出 no-rollback-for 指定的异常类型，不回滚事务。 6.@Transient@Transient是希望该属性不会在数据表中产生字段，但又可以在程序中使用它。 7.@Results(1)当数据库字段名与实体类对应的属性名不一致时，可以使用@Results映射来将其对应起来。column为数据库字段名，porperty为实体类属性名，jdbcType为数据库字段数据类型，id为是否为主键。 12345678@Select(&#123;"select id, name, class_id from my_student"&#125;)@Results(&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="name", property="name", jdbcType=JdbcType.VARCHAR), @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER)&#125;)List&lt;Student&gt; selectAll(); (2)@ResultMap的用法。当这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码。 123456789101112@Select(&#123;"select id, name, class_id from my_student"&#125;)@Results(id="studentMap", value=&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER)&#125;)List&lt;Student&gt; selectAll();@Select(&#123;"select id, name, class_id from my_student where id = #&#123;id&#125;"&#125;)@ResultMap(value="studentMap")Student selectById(integer id); (3)@One的用法。当我们需要通过查询到的一个字段值作为参数，去执行另外一个方法来查询关联的内容，而且两者是一对一关系时，可以使用@One注解来便捷的实现。比如当我们需要查询学生信息以及其所属班级信息时，需要以查询到的class_id为参数，来执行ClassesMapper中的selectById方法，从而获得学生所属的班级信息。可以使用如下代码。 1234567Select(&#123;"select id, name, class_id from my_student"&#125;)@Results(id="studentMap", value=&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="class_id", property="myClass", javaType=MyClass.class, one=@One(select="com.mapper.MyClassMapper.selectById"))&#125;)List&lt;Student&gt; selectAllAndClassMsg(); （4）@Many的用法。与@One类似，只不过如果使用@One查询到的结果是多行，会抛出TooManyResultException异常，这种时候应该使用的是@Many注解，实现一对多的查询。比如在需要查询学生信息和每次考试的成绩信息时。 12345678@Select(&#123;"select id, name, class_id from my_student"&#125;)@Results(id="studentMap", value=&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER), @Result(column="id", property="gradeList", javaType=List.class, many=@Many(select="com.example.demo.mapper.GradeMapper.selectByStudentId"))&#125;)List&lt;Student&gt; selectAllAndGrade(); （5）传递多个参数。首先我们给这张表增加age（年龄）和gender（性别）两个参数。当我们需要根据age和gender查询学生的午餐，这时需要改写column属性的格式。等号左侧的age和gender对应java接口的参数，右侧的对应数据库字段名。即将查到的my_student表中age和gender字段的值，分别赋给getLunchByAgeAndGender方法中的age和gender参数，去查询对应的name（午餐名）。 1234567891011@Select("select id, name, age, gender from my_student")@Results(&#123; @Result(column="id", property="id", jdbcType=JdbcType.INTEGER, id=true), @Result(column="class_id", property="classId", jdbcType=JdbcType.INTEGER), @Result(column="&#123;age=age,gender=gender&#125;", property="lunch", one=@One(select="com.example.demo.mapper.StudentMapper.getLunchByAgeAndGender")), &#125;)List&lt;Student&gt; selectAllAndLunch();@Select("select name from lunch where student_age = #&#123;age&#125; and student_gender = #&#123;gender&#125;")String getLunchByAgeAndGender(@Param("age") int age, @Param("gender") int gender);]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis_数据的持久化]]></title>
    <url>%2F2019%2F03%2Fredis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[持久化Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 1.RDB 持久化RDB是redis默认的持久化机制。RDB相当于快照，保存的是一种状态。默认文件名是dump.rdb。 将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量很大，保存快照的时间会很长。 2.AOF 持久化由于快照方式是在一定时间间隔内做一次，所以如果redis意外down掉，就会丢失最后一次快照所有的修改，如果应用要求不能丢失任何修改的话，可以采用AOF。 将写命令添加到 AOF 文件（Append Only File）的末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项： 选项 同步频率 always 每个写命令都同步 everysec 每秒同步一次 no 让操作系统来决定何时同步 always 选项会严重减低服务器的性能； everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响； no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis.数据的淘汰机制]]></title>
    <url>%2F2019%2F03%2Fredis-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。 Redis 具体有 6 种淘汰策略： 策略 描述 volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random 从已设置过期时间的数据集中任意选择数据淘汰 allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰 allkeys-random 从所有数据集中任意选择数据进行淘汰 noeviction 禁止驱逐数据 作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。 使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。 Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis与memcached]]></title>
    <url>%2F2019%2F03%2Fredis%E4%B8%8Ememcached%2F</url>
    <content type="text"><![CDATA[Memcached介绍Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。 memcached作为高速运行的分布式缓存服务器，具有以下的特点。 协议简单 基于libevent的事件处理 内置内存存储方式 memcached不互相通信的分布式 与数据库协同合作的过程： 1.检查用户请求的数据是缓存中是否有存在，如果有存在的话，只需要直接把请求的数据返回，无需查询数据库. 2.如果请求的数据在缓存中找不到，这时候再去查询数据库。返回请求数据的同时，把数据存储到缓存中一份。 3.保持缓存的“新鲜性”，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据. Redis介绍redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。 区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。 Redis作为一个高性能的key-value数据库具有以下特征： 多样的数据模型 持久化 基于内存存储方式 主从同步 综合结论 应该说Memcached和Redis都能很好的满足解决我们的问题，它们性能都很高，总的来说，可以把Redis理解为是对Memcached的拓展，是更加重量级的实现，提供了更多更强大的功能。 两者都是非关系型内存键值数据库，主要有以下不同： Memcached与redis区别1.数据类型 Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。 2.数据持久化 Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 3.分布式 Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis则在服务器端构建分布式存储。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，各个节点地位一致，具有线性可伸缩的功能。其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个 key的数值域分成16384个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是16384。 4.内存管理机制 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，这样能保证数据的持久性。而 Memcached 的数据则会一直在内存中(断电会挂掉，数据不能超过内存)。 5.应用场景 Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息) Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis数据类型]]></title>
    <url>%2F2019%2F03%2Fredis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 LIST 列表 从两端压入或者弹出元素 对单个或者多个元素，进行修剪，只保留一个范围内的元素 SET 无序集合 添加、获取、移除单个元素 检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对 获取所有键值对；检查某个键是否存在 ZSET 有序集合 添加、获取、删除元素 根据分值范围或者成员来获取元素；计算一个键的排名 1.1Redis的键Key1234567891011&gt; DEL key 删除键&gt; EXISTS key 判断key是否存在&gt; DUMP key 序列化key&gt; EXPIRE key seconds 给key设置过期时间&gt; TTL key key的生存剩余时间（秒为单位）&gt; PTTL key key的生存剩余时间(毫秒单位)&gt; PERSIST key 移除key的过期时间，将持久保留&gt; KEYS pattern 查找所有符合给定模式的key(* 所有 ？一个字符)&gt; RANDOM key 从当前数据库随机返回一个key&gt; RENAME key newkey 修改key名称&gt; MOVE key db 当前数据库移动到给定数据库中 key的应用场景 (1)限时的活动信息 (2)网站的数据缓存(对于一些要定时更新的数据如积分排行榜) (3)手机验证码 (4)限制网站的访问频率 1.2 Redis的值value1.2.1 String类型123456789101112&gt; SET key_name value 设置给定key的值(key存在则覆盖，不存在则新建)&gt; SETNX key_name value 设置给定key的值(key不存在时)&gt; GET key_name 取值&gt; GETRANGE key start end 字符串截取&gt; GETBIT key offset 对key所存储的字符串值，获取指定偏移量上的位&gt; MGET key1 [key2..] 获取一个或多个key的值&gt; GETSET key_name value 设置key值，并返回key的旧值&gt; STRLEN key 获取长度&gt; DEL key_name 删除&gt; INCR key_name 自增&gt; DECR key_name 自减 &gt; APPEND key_name value 字符串拼接 string应用场景 1.String通常用于保存单个字符串或JSON字符串数据 2.因string是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储 3.计数器(常规key-value缓存应用。(常规计数:微博数,粉丝数) INCR等指令本身就具有原子操作的特性,所以我们完全可以利用redis的INCR.INCRBY.DECR，DECRBY等指令来实现原子计数的效果。不少网站都利用redis的这个特性来实现业务上的统计计数需求。 1.2.2 List类型1234567891011&gt; LPUSH key value1[value2] 将一个或多个值插入列表头部&gt; RPUSH key value1[value2] 将一个或多个值插入列表尾部&gt; LPUSHX key value 将一个或多个值插入列表头部，列表不存在则操作无效 &gt; RPUSHX key value 将一个或多个值插入列表尾部，列表不存在则操作无效&gt; LLEN key 获取列表长度&gt; LINDEX key index 通过索引获取列表元素&gt; LRANGE key start stop 获取列表指定范围内的元素&gt; LPOP key 左移除&gt; RPOP key 右移除&gt; BLPOP key1[key2] timeout 移除并获取列表的第一个元素，没有元素就会阻塞队列 直到等待超时或发现可弹出元素 list应用场景 1、对数据量大的集合数据删减 列表数据显示关注列表、粉丝列表、留言评价等. .分页、热点新闻(Top5)等 利用LRANGE还可以很方便的实现分页的功能,在博客系统中，每片博文的评论也可以用到。 2、任务队列 (list通常用来实现一个消息队列,而且可以确保先后顺序,不必像MySQL那样还需要通过ORDERBY来进行排序) 任务队列介绍(生产者和消费者模式): 在处理Web客户端发送的命令请求时,某些操作的执行时间可能会比我们预期的更长一些，通过将待执行任务的相关信息放入队列里面，并在之后对队列进行处理,用户可以推迟执行那些需要一段时间才能能完成的操作,这种将工作交给任务处理器来执行的做法被称为任务队列(task queue)。 RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回示例描述: 常用案例:订单系统的下单流程、用户系统登录注册短信等 1.2.3 Hash类型123456789101112&gt; HSET key field value 为指定的key,设定field/value&gt; HMSET key field value[field1,value] 同时将多个field-value 设到key中&gt; HGET key field 根据field等待value &gt; HMGET key field[field1] 获取key所有给定字段的值&gt; HGETALL key 返回hash表所有字段和值&gt; HKEYS key 获取哈希表中的字段&gt; HLEN key 获取哈希表中字段的数量&gt; HDEL key field[field2] 删除一个或多个hash表字段&gt; HSETNX key field value 只有在字段不存在时，设置字段值&gt; HINCRBY key field increment key中指定字段的整数值加增量&gt; HINCRBYFLOAT key field increment 指定字段的浮点数加增量&gt; HEXISTS key field 指定字段是否存在 hash应用场景 Hash的应用场景:(存储个用户信息对象数据) 1、 常用于存储一个对象 2、 为什么不用string存储一个对象? hash是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。 用户ID为查找的key,存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式: (1)用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时, 需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。 (2)这个用户信息对象有多少成员就存成多少个key-value对,用用户ID+对应属性的名称作为唯一标识来取得对应属性的值,虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是不可观的。 总结:Redis提供的Hash很好的解决了这个问题，Redis 的Hash实际是内部存储的Value为一个Hashmap,并提供了直接存取这个Map成员的接口 1.2.4 Set类型1234567891011121314151617181920赋值语句&gt; SADD key member1[member2] 添加一个或多个成员取值语句&gt; SCARD key 获取成员数&gt; SMEMBERS key 返回集合中的所有成员&gt; SISMEMBER key member 判断是否存在&gt; SRANDMEMBER key [count] 返回集合中一个或多个随机数删除语句&gt; SREM key member 移除一个或多个&gt; SPOP key[count] 移除并返回集合中的一个随机元素&gt; SMOVE source destination member 将member从source移到destination差集语句&gt; SDIFF key1[key2] 返回给定集合的差集(左侧)&gt; SDIFFSTORE destination key1[key2] 返回差集并存到destina.交集语句&gt; SINTER key1 [key2] 返回给定集合的交集&gt; SINTERSTORE destination key1[key2] 返回交集并存到destination并集&gt; SUNION key1[key2] 返回并集&gt; SUNIONSTORE destination key1[key2] 返回并集并存储在destination set应用场景 常应用于:对两个集合间的数据[计算]进行交集、并集、差集运算 1、以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作,你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。 2、利用唯一性，可以统计访问网站的所有独立IP 1.2.5 Zset类型12345678910赋值语句&gt; ZADD key score1 member1[score member2] 添加一个或多个成员取值语句&gt; ZCARD key 获取成员数&gt; ZCOUNT key min max 计算集合中指定区间分数的成员数&gt; ZRANK key member 返回有序集合中指定成员索引&gt; ZRANGE key start stop[WITHSCORES] 返回指定区间内成员[低到高]&gt; ZREVRANGE key start stop[WITHSCORES] 返回指定区间内成员[高到低]删除语句&gt; ZREM key member[member...] 移除有序集合中的一个或多个成员 Zset应用场景 常应用于:排行榜 1)比如twitter的public timeline可以以发表时间作为score来存储,这样获取时就是自动按时间排好序的。 2)比如一个存储全班同学成绩的Sorted Set, 其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。 3还可以用Sorted Set来做带权重的队列，比如普通消息的score为1,重要消息的score为2,然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。 字符 重新定义的ASCII码 字符 重新定义的ASCII码 字符 重新定义的ASCII码 A 32 L 54 v 75 a 33 l 55 W 76 B 34 M 56 w 77 b 35 m 57 X 78 C 36 N 58 x 79 c 37 n 59 Y 80 D 38 O 60 y 81 d 39 o 61 Z 82 E 40 P 62 z 83 e 41 p 63 0 84 F 42 Q 64 1 85 f 43 q 65 2 86 G 44 R 66 3 87 g 45 r 67 4 88 H 46 S 68 5 89 h 47 s 69 6 90 I 48 T 70 7 91 i 49 t 71 8 92 J 50 U 72 9 93 j 51 u 73 K 52 V 74 k 53]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis应用场景]]></title>
    <url>%2F2019%2F03%2Fredis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[1.概述 Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键(key)的类型只能为字符串(String)，值(value)支持五种数据类型：字符串(String)、列表(list)、集合(set)、有序集合(zset)、哈希(hash)。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 Redis的使用场景 （1）缓存：Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效； （2）排行榜：利用Redis的SortSet数据结构能够非常方便搞定； （3）计算器/限速器：利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力； 注：限速器也是对请求限流的一种实现方式。 （4）好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能； （5）简单消息队列：除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；不过最好用kafka、RabbitMQ等消息中间件。 （6）Session共享：默认Session是保存在服务器的文件中，即当前服务器，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。 Redis优点： 速度快，完全基于内存； 使用C语言实现，网络层使用epoll解决高并发问题； 单线程模型避免了不必要的上下文切换及竞争条件； Redis的缺点： 滥用可能导致系统的不稳定、成本增高等问题。 比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。 简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用Redis。数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。如果不担心浪费资源，那请忽略。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
